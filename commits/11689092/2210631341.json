[{"filename": "include/triton/codegen/selection/generator.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -4,6 +4,7 @@\n #define _TRITON_SELECTION_GENERATOR_H_\n \n #include \"triton/ir/visitor.h\"\n+#include \"triton/ir/instructions.h\"\n #include \"triton/codegen/analysis/layout.h\"\n #include <functional>\n \n@@ -261,6 +262,9 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n \n   /// Record prefetch instrs that needs to be moved\n   std::map<ir::value*, std::vector<Value*>> prefetch_latch_to_bb_;\n+\n+  // Eviction policies\n+  std::map<ir::load_inst::EVICTION_POLICY, Value*> policies_;\n };\n \n }"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "file_content_changes": "@@ -91,6 +91,7 @@ Value* geper::operator()(Value *ptr, Value* off, const std::string& name){\n #define i8_ty                builder_->getInt8Ty()\n #define i16_ty               builder_->getInt16Ty()\n #define i32_ty               builder_->getInt32Ty()\n+#define i64_ty               builder_->getInt64Ty()\n #define vec_ty(type, num_el) VectorType::get(type, num_el, false)\n #define ptr_ty(...)          PointerType::get(__VA_ARGS__)\n // constants\n@@ -778,6 +779,7 @@ void generator::visit_load_inst(ir::load_inst* x){\n     int tot_width = nbits*vec;\n     int width = std::min(tot_width, max_word_width);\n     int n_words = std::max(1, tot_width / width);\n+    bool has_evict_policy = x->get_eviction_policy() != ir::load_inst::NORMAL;\n     // -----\n     // create inline asm string\n     // -----\n@@ -789,8 +791,9 @@ void generator::visit_load_inst(ir::load_inst* x){\n     asm_oss << \".global\";\n     if (x->get_cache_modifier() == ir::load_inst::CA) asm_oss << \".ca\";\n     if (x->get_cache_modifier() == ir::load_inst::CG) asm_oss << \".cg\";\n-    if (x->get_eviction_policy() == ir::load_inst::EVICT_LAST) asm_oss << \".L1::evict_last\";\n     if (x->get_eviction_policy() == ir::load_inst::EVICT_FIRST) asm_oss << \".L1::evict_first\";\n+    if (x->get_eviction_policy() == ir::load_inst::EVICT_LAST) asm_oss << \".L1::evict_last\";\n+    if (has_evict_policy) asm_oss << \".L2::cache_hint\";\n     if(n_words > 1)\n       asm_oss << \".v\" << n_words; // vector width\n     asm_oss << \".b\" << width; // word size\n@@ -801,7 +804,9 @@ void generator::visit_load_inst(ir::load_inst* x){\n     }\n     asm_oss << \"}\";\n     asm_oss << \", [ $\" << n_words + 1; // load\n-    asm_oss << \" + \" << in_off << \"];\"; // constant offset\n+    asm_oss << \" + \" << in_off << \"]\"; // constant offset\n+    if (has_evict_policy) asm_oss << \", $\" << n_words + 2;\n+    asm_oss << \";\";\n     bool has_other = other && (other != UndefValue::get(other->getType()));\n     std::vector<Value *> others;\n     // handle `other` values for indices where the mask\n@@ -822,7 +827,7 @@ void generator::visit_load_inst(ir::load_inst* x){\n       if(ConstantInt* cst = dyn_cast<ConstantInt>(v))\n         asm_oss << \"0x\" << std::hex << cst->getSExtValue();\n       else{\n-        asm_oss << \"$\" << n_words + 2 + ii;\n+        asm_oss << \"$\" << n_words + has_evict_policy +  2 + ii;\n         others.push_back(v);\n       }\n       asm_oss.flags(flags);\n@@ -837,6 +842,8 @@ void generator::visit_load_inst(ir::load_inst* x){\n     std::vector<Type*> arg_tys = {pred->getType(), ptr->getType()};\n     for(Value *v: others)\n         arg_tys.push_back(v->getType());\n+    if (has_evict_policy) \n+      arg_tys.push_back(i64_ty);\n     FunctionType *asm_ty = FunctionType::get(ret_ty, arg_tys, false);\n     // ---\n     // create inline ASM constraints\n@@ -851,13 +858,19 @@ void generator::visit_load_inst(ir::load_inst* x){\n       asm_cstrt += \",\";\n       asm_cstrt += (width == 64) ? \"l\" : ((width == 32) ? \"r\" : \"c\");\n     }\n+    if (has_evict_policy) \n+      asm_cstrt += \",l\";\n     // ---\n     // finally call inline ASM\n     // ---\n     InlineAsm *inlineAsm = InlineAsm::get(asm_ty, asm_oss.str(), asm_cstrt, true);\n     std::vector<Value*> args = {pred, ptr};\n     for(Value *v: others)\n         args.push_back(v);\n+    if (has_evict_policy)\n+      args.push_back(policies_.at(x->get_eviction_policy()));\n+  \n+    \n     Value *_ret = call(inlineAsm, args);\n     // ---\n     // extract and store return values\n@@ -2880,6 +2893,13 @@ void generator::visit_function(ir::function* fn) {\n     bbs_[block] = dst_block;\n   }\n   builder_->SetInsertPoint(bbs_[fn->blocks()[0]]);\n+  // create policies\n+  for(ir::load_inst::EVICTION_POLICY evict: {ir::load_inst::EVICT_FIRST, ir::load_inst::EVICT_LAST}){\n+    std::string policy = (evict == ir::load_inst::EVICT_FIRST) ? \"evict_first\" : \"evict_last\";\n+    std::string asm_str = \"createpolicy.fractional.L2::\" + policy + \".b64 $0;\";\n+    InlineAsm* iasm = InlineAsm::get(FunctionType::get(i64_ty, {}), asm_str, \"=l\", false);\n+    policies_[evict] = call(iasm);\n+  }\n   // initialize layouts\n   for(auto x: layouts_->get_all()){\n     visit_layout(x.second);"}]