[{"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "file_content_changes": "@@ -18,6 +18,7 @@\n #include \"llvm/IRReader/IRReader.h\"\n #include \"llvm/Linker/Linker.h\"\n #include \"llvm/Support/SourceMgr.h\"\n+#include <dlfcn.h>\n #include <filesystem>\n \n namespace mlir {\n@@ -116,22 +117,44 @@ static std::map<std::string, std::string> getExternLibs(mlir::ModuleOp module) {\n   }\n \n   if (!funcs.empty()) {\n-    // When using the Math Dialect, it is possible that some ops (e.g., log) are\n-    // lowered to a function call. In this case, we need to link libdevice\n-    // using its default path:\n-    // [triton root dir]/python/triton/language/libdevice.10.bc\n-    // TODO(Keren): handle external linkage other than libdevice?\n-    namespace fs = std::filesystem;\n     static const std::string libdevice = \"libdevice\";\n-    static const std::filesystem::path path = std::filesystem::path(__FILE__)\n-                                                  .parent_path()\n-                                                  .parent_path()\n-                                                  .parent_path()\n-                                                  .parent_path() /\n-                                              \"python\" / \"triton\" /\n-                                              \"third_party\" / \"cuda\" / \"lib\" /\n-                                              \"libdevice.10.bc\";\n-    externLibs.try_emplace(libdevice, path.string());\n+    namespace fs = std::filesystem;\n+    // Search for libdevice relative to its library path if used from Python\n+    // Then native code is in `triton/_C/libtriton.so` and libdevice in\n+    // `triton/third_party/cuda/lib/libdevice.10.bc`\n+    static const auto this_library_path = [] {\n+      Dl_info fileinfo;\n+      if (dladdr(reinterpret_cast<void *>(&getExternLibs), &fileinfo) == 0) {\n+        return std::filesystem::path();\n+      }\n+      return std::filesystem::path(fileinfo.dli_fname);\n+    }();\n+    static const auto runtime_path =\n+        this_library_path.parent_path().parent_path() / \"third_party\" / \"cuda\" /\n+        \"lib\" / \"libdevice.10.bc\";\n+    if (fs::exists(runtime_path)) {\n+      externLibs.try_emplace(libdevice, runtime_path.string());\n+    } else {\n+      // When using the Math Dialect, it is possible that some ops (e.g., log)\n+      // are lowered to a function call. In this case, we need to link libdevice\n+      // using its default path:\n+      // [triton root dir]/python/triton/language/libdevice.10.bc\n+      // TODO(Keren): handle external linkage other than libdevice?\n+      static const auto this_file_path = std::filesystem::path(__FILE__);\n+      static const auto compiletime_path = this_file_path.parent_path()\n+                                               .parent_path()\n+                                               .parent_path()\n+                                               .parent_path() /\n+                                           \"python\" / \"triton\" / \"third_party\" /\n+                                           \"cuda\" / \"lib\" / \"libdevice.10.bc\";\n+      if (!fs::exists(compiletime_path)) {\n+        std::string error_msg = \"Can't find libdevice at neither \" +\n+                                runtime_path.string() + \" nor \" +\n+                                compiletime_path.string();\n+        llvm::report_fatal_error(error_msg.c_str());\n+      }\n+      externLibs.try_emplace(libdevice, compiletime_path.string());\n+    }\n   }\n \n   return externLibs;"}]