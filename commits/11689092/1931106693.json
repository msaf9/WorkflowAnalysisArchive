[{"filename": "include/triton/ir/context.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -9,7 +9,6 @@\n namespace triton{\n namespace ir{\n \n-class builder;\n class type;\n class context_impl;\n \n@@ -21,7 +20,6 @@ class context {\n   context& operator=(const context&) = delete;\n \n public:\n-  ir::builder* builder = nullptr;\n   std::shared_ptr<context_impl> p_impl;\n };\n "}, {"filename": "include/triton/ir/context_impl.h", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "file_content_changes": "@@ -3,17 +3,15 @@\n #ifndef _TRITON_IR_CONTEXT_IMPL_H_\n #define _TRITON_IR_CONTEXT_IMPL_H_\n \n-#include <map>\n #include \"triton/ir/type.h\"\n+#include \"triton/ir/constant.h\"\n+#include <map>\n+#include <memory>\n \n namespace triton{\n namespace ir{\n \n class context;\n-class constant;\n-class constant_int;\n-class constant_fp;\n-class undef_value;\n \n /* Context impl */\n class context_impl {\n@@ -30,16 +28,16 @@ class context_impl {\n   integer_type int1_ty, int8_ty, int16_ty, int32_ty, int64_ty, int128_ty;\n   integer_type uint8_ty, uint16_ty, uint32_ty, uint64_ty;\n   // Pointer types\n-  std::map<std::pair<type*, unsigned>, pointer_type*> ptr_tys;\n+  std::map<std::pair<type*, unsigned>, std::unique_ptr<pointer_type>> ptr_tys;\n   // Block types\n-  std::map<std::pair<type*, type::block_shapes_t>, block_type*> block_tys;\n+  std::map<std::pair<type*, type::block_shapes_t>, std::unique_ptr<block_type>> block_tys;\n \n   // Int constants\n-  std::map<std::pair<type*, uint64_t>, constant_int*> int_constants_;\n+  std::map<std::pair<type*, uint64_t>, std::unique_ptr<constant_int>> int_constants_;\n   // Float constants\n-  std::map<std::pair<type*, double>, constant_fp*> fp_constants_;\n+  std::map<std::pair<type*, double>, std::unique_ptr<constant_fp>> fp_constants_;\n   // undef values\n-  std::map<type*, undef_value*> uv_constants_;\n+  std::map<type*, std::unique_ptr<undef_value>> uv_constants_;\n \n };\n "}, {"filename": "lib/ir/constant.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "file_content_changes": "@@ -47,10 +47,10 @@ constant_int *constant_int::get(type *ty, uint64_t value) {\n   if (!ty->is_integer_ty())\n     throw std::runtime_error(\"Cannot create constant_int with non integer ty\");\n   context_impl *impl = ty->get_context().p_impl.get();\n-  constant_int *& cst = impl->int_constants_[std::make_pair(ty, value)];\n-  if(cst == nullptr)\n-    cst = new constant_int(ty, value);\n-  return cst;\n+  std::unique_ptr<constant_int> &cst = impl->int_constants_[std::make_pair(ty, value)];\n+  if(!cst)\n+    cst.reset(new constant_int(ty, value));\n+  return cst.get();\n }\n \n \n@@ -73,10 +73,10 @@ constant *constant_fp::get_zero_value_for_negation(type *ty) {\n \n constant *constant_fp::get(type *ty, double v){\n   context_impl *impl = ty->get_context().p_impl.get();\n-  constant_fp *&result = impl->fp_constants_[std::make_pair(ty, v)];\n+  std::unique_ptr<constant_fp> &result = impl->fp_constants_[std::make_pair(ty, v)];\n   if(!result)\n-    result = new constant_fp(ty, v);\n-  return result;\n+    result.reset(new constant_fp(ty, v));\n+  return result.get();\n }\n \n \n@@ -86,10 +86,10 @@ undef_value::undef_value(type *ty)\n \n undef_value *undef_value::get(type *ty) {\n   context_impl *impl = ty->get_context().p_impl.get();\n-  undef_value *&result = impl->uv_constants_[ty];\n+  std::unique_ptr<undef_value> &result = impl->uv_constants_[ty];\n   if(!result)\n-    result = new undef_value(ty);\n-  return result;\n+    result.reset(new undef_value(ty));\n+  return result.get();\n }\n \n /* global value */"}, {"filename": "lib/ir/type.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -167,10 +167,10 @@ pointer_type* pointer_type::get(type *elt_ty, unsigned address_space){\n   assert(is_valid_elt_ty(elt_ty) && \"Invalid type for pointer element!\");\n   // look-up\n   context_impl *impl = elt_ty->get_context().p_impl.get();\n-  pointer_type *&entry = impl->ptr_tys[std::make_pair(elt_ty, address_space)];\n+  std::unique_ptr<pointer_type> &entry = impl->ptr_tys[std::make_pair(elt_ty, address_space)];\n   if(!entry)\n-    entry = new pointer_type(elt_ty, address_space);\n-  return entry;\n+    entry.reset(new pointer_type(elt_ty, address_space));\n+  return entry.get();\n }\n \n //===----------------------------------------------------------------------===//\n@@ -217,10 +217,10 @@ block_type* block_type::get(type *elt_ty, const block_shapes_t &shapes) {\n   assert(is_valid_elt_ty(elt_ty) && \"Invalid type for tile element!\");\n   // look-up\n   context_impl *impl = elt_ty->get_context().p_impl.get();\n-  block_type *&entry = impl->block_tys[std::make_pair(elt_ty, shapes)];\n+  std::unique_ptr<block_type> &entry = impl->block_tys[std::make_pair(elt_ty, shapes)];\n   if(!entry)\n-    entry = new block_type(elt_ty, shapes);\n-  return entry;\n+    entry.reset(new block_type(elt_ty, shapes));\n+  return entry.get();\n }\n \n block_type* block_type::get_same_shapes(type *ty, type *ref){"}]