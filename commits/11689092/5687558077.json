[{"filename": "python/test/unit/tools/test_aot.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -107,7 +107,7 @@ def kernel(C, A, B,\n   // launch kernel\n   int gX = 1, gY = 1, gZ = 1;\n   cuStreamSynchronize(stream);\n-  matmul_fp16xfp16_16x16x16(stream, M/BM, N/BN, 1, C, A, B, N, K, N);\n+  matmul_fp16xfp16_16x16x16(stream, M/BM, N/BN, 1, C, A, B, N, 1, K, 1, N, 1);\n   cuStreamSynchronize(stream);\n \n   // read data\n@@ -150,7 +150,7 @@ def test_compile_link_matmul():\n         hints = [\":16\", \"\"]\n         for ha in hints:\n             for hb in hints:\n-                sig = f'*fp32:16, *{dtype}:16, *{dtype}:16, i32{ha}, 1, i32{hb}, 1, i32:16, 1, {BM}, {BN}, {BK}'\n+                sig = f'*fp32:16, *{dtype}:16, *{dtype}:16, i32{ha}, i32:1, i32{hb}, i32:1, i32:16, i32:1, {BM}, {BN}, {BK}'\n                 name = f\"matmul_{dtype}x{dtype}_{BM}x{BN}x{BK}\"\n                 subprocess.run([sys.executable, compiler_path, \"-n\", \"kernel\", \"--signature\", sig, \"--out-name\", name, \"-o\", name, \"-w\", \"1\", kernel_path], check=True, cwd=tmp_dir)\n "}, {"filename": "python/triton/third_party/cuda/bin/ptxas", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "file_content_changes": "N/A"}, {"filename": "python/triton/tools/compile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -10,7 +10,7 @@\n \n void unload_{kernel_name}(void);\n void load_{kernel_name}(void);\n-// tt-linker: {kernel_name}:{signature}\n+// tt-linker: {kernel_name}:{full_signature}\n CUresult{_placeholder} {kernel_name}(CUstream stream, unsigned int gX,\n                                      unsigned int gY, unsigned int gZ,\n                                      {signature});"}, {"filename": "python/triton/tools/compile.py", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "file_content_changes": "@@ -94,8 +94,15 @@ def constexpr(s):\n     divisible_by_16 = [i for i, h in hints.items() if h == 16]\n     equal_to_1 = [i for i, h in hints.items() if h == 1]\n     config = triton.compiler.instance_descriptor(divisible_by_16=divisible_by_16, equal_to_1=equal_to_1)\n+    for i in equal_to_1:\n+        constexprs.update({i: 1})\n     ccinfo = triton.compile(kernel, signature=signature, constants=constexprs, configs=[config], num_warps=args.num_warps)\n-    arg_names = [kernel.arg_names[i] for i in signature.keys()]\n+    arg_names = []\n+    arg_types = []\n+    for i in signature.keys():\n+        if i not in equal_to_1:\n+            arg_names += [kernel.arg_names[i]]\n+            arg_types += [signature[i]]\n \n     # dump C stub code\n     suffix = kernel_suffix(signature.values(), config)\n@@ -107,7 +114,8 @@ def constexpr(s):\n         \"triton_kernel_name\": triton_kernel_name,\n         \"bin_size\": len(hex_),\n         \"bin_data\": \", \".join([f\"0x{x}{y}\" for x, y in zip(hex_[::2], hex_[1::2])]),\n-        \"signature\": \", \".join([f\"{ty_to_cpp(ty)} {name}\" for name, ty in zip(arg_names, signature.values())]),\n+        \"signature\": \", \".join([f\"{ty_to_cpp(ty)} {name}\" for name, ty in zip(arg_names, arg_types)]),\n+        \"full_signature\": \", \".join([f\"{ty_to_cpp(signature[i])} {kernel.arg_names[i]}\" for i in signature.keys()]),\n         \"arg_pointers\": \", \".join([f\"&{arg}\" for arg in arg_names]),\n         \"num_args\": len(arg_names),\n         \"kernel_docstring\": \"\","}, {"filename": "python/triton/tools/link.py", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "file_content_changes": "@@ -32,10 +32,10 @@ def __init__(self) -> None:\n         self.linker_directives = re.compile(\"//[\\\\s]*tt-linker:[\\\\s]*([\\\\w]+):(.+)\")\n         # [name, suffix]\n         self.kernel_name = re.compile(\"^([\\\\w]+)_([\\\\w]+)_([\\\\w]+)$\")\n-        # [(argnum, d|c)]\n-        self.kernel_suffix = re.compile(\"([0-9]+)([c,d])\")\n         # [(type, name)]\n         self.c_sig = re.compile(\"[\\\\s]*(\\\\w+)\\\\s(\\\\w+)[,]?\")\n+        # [d|c]\n+        self.arg_suffix = re.compile(\"[c,d]\")\n \n         self.kernels = defaultdict(list)\n \n@@ -48,7 +48,7 @@ def extract_linker_meta(self, header: str):\n                     ker_name, c_sig = m.group(1), m.group(2)\n                     name, sig_hash, suffix = self._match_name(ker_name)\n                     c_types, arg_names = self._match_c_sig(c_sig)\n-                    num_specs, sizes = self._match_suffix(suffix)\n+                    num_specs, sizes = self._match_suffix(suffix, c_sig)\n                     self._add_kernel(\n                         name,\n                         KernelLinkerMeta(\n@@ -79,18 +79,27 @@ def _match_c_sig(self, c_sig: str):\n \n         raise LinkerError(f\"{c_sig} is not a valid argument signature\")\n \n-    def _match_suffix(self, suffix: str):\n-        m = self.kernel_suffix.findall(suffix)\n-        if not len(m):\n-            raise LinkerError(f\"{suffix} is not a valid kernel suffix\")\n-        sizes = []\n-        num_specs = len(m)\n+    def _match_suffix(self, suffix: str, c_sig: str):\n+        args = c_sig.split(',')\n         s2i = {\"c\": 1, \"d\": 16}\n-        for (argnum, arg_size_ann) in m:\n-            while len(sizes) < int(argnum):\n-                sizes.append(None)\n-\n-            sizes.append(s2i[arg_size_ann])\n+        num_specs = 0\n+        sizes = []\n+        # scan through suffix, first find the index,\n+        # then see if it is followed by d or c\n+        for i in range(len(args)):\n+            pos = suffix.find(str(i))\n+            if pos == -1:\n+                raise LinkerError(f\"{suffix} is not a valid kernel suffix\")\n+            pos += len(str(i))\n+            if self.arg_suffix.match(suffix, pos):\n+                num_specs += 1\n+                sizes.extend([None] * (i - len(sizes)))\n+                sizes.append(s2i[suffix[pos]])\n+                pos += 1\n+            if i < len(args) - 1:\n+                suffix = suffix[pos:]\n+            else:\n+                sizes.extend([None] * (len(args) - len(sizes)))\n         return num_specs, sizes\n \n     def _add_kernel(self, name: str, ker: KernelLinkerMeta):\n@@ -106,13 +115,20 @@ def _add_kernel(self, name: str, ker: KernelLinkerMeta):\n         self.kernels[name].append(ker)\n \n \n-def gen_signature(m):\n+def gen_signature_with_full_args(m):\n     return \", \".join([f\"{ty} {arg}\" for ty, arg in zip(m.arg_ctypes, m.arg_names)])\n \n \n+def gen_signature(m):\n+    arg_types = [ty for ty, hint in zip(m.arg_ctypes, m.sizes) if hint != 1]\n+    arg_names = [arg for arg, hint in zip(m.arg_names, m.sizes) if hint != 1]\n+    sig = \", \".join([f\"{ty} {arg}\" for ty, arg in zip(arg_types, arg_names)])\n+    return sig\n+\n+\n def make_decls(name: str, metas: Sequence[KernelLinkerMeta]) -> str:\n     return f\"\"\"\n-CUresult {name}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, {gen_signature(metas[-1])});\n+CUresult {name}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, {gen_signature_with_full_args(metas[-1])});\n void load_{name}();\n void unload_{name}();\n     \"\"\"\n@@ -124,13 +140,14 @@ def make_kernel_dispatcher(name: str, metas: Sequence[KernelLinkerMeta]) -> str:\n         src += f\"CUresult {name}_{meta.sig_hash}_{meta.suffix}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, {gen_signature(meta)});\\n\"\n     src += \"\\n\"\n \n-    src += f\"CUresult {name}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, {gen_signature(metas[-1])}){{\"\n+    src += f\"CUresult {name}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, {gen_signature_with_full_args(metas[-1])}){{\"\n     src += \"\\n\"\n     for meta in sorted(metas, key=lambda m: -m.num_specs):\n         cond_fn = lambda val, hint: f\"({val} % {hint} == 0)\" if hint == 16 else f\"({val} == {hint})\" if hint == 1 else None\n         conds = \" && \".join([cond_fn(val, hint) for val, hint in zip(meta.arg_names, meta.sizes) if hint is not None])\n         src += f\"  if ({conds})\\n\"\n-        src += f\"    return {name}_{meta.sig_hash}_{meta.suffix}(stream, gX, gY, gZ, {', '.join(meta.arg_names)});\\n\"\n+        arg_names = [arg for arg, hint in zip(meta.arg_names, meta.sizes) if hint != 1]\n+        src += f\"    return {name}_{meta.sig_hash}_{meta.suffix}(stream, gX, gY, gZ, {', '.join(arg_names)});\\n\"\n     src += \"}\\n\"\n \n     for mode in [\"load\", \"unload\"]:"}]