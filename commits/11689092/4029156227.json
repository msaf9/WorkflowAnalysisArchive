[{"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "file_content_changes": "@@ -1123,8 +1123,23 @@ class MMA16816SmemLoader {\n     Value ptr = getPtr(ptrIdx);\n \n     // The struct should have exactly the same element types.\n+    auto resTy = matTy.cast<LLVM::LLVMStructType>();\n     Type elemTy = matTy.cast<LLVM::LLVMStructType>().getBody()[0];\n \n+    // For some reasons, LLVM's NVPTX backend inserts unnecessary (?) integer\n+    // instructions to pack & unpack sub-word integers. A workaround is to\n+    // store the results of ldmatrix in i32\n+    if (auto vecElemTy = elemTy.dyn_cast<VectorType>()) {\n+      Type elemElemTy = vecElemTy.getElementType();\n+      if (auto intTy = elemElemTy.dyn_cast<IntegerType>()) {\n+        if (intTy.getWidth() <= 16) {\n+          elemTy = rewriter.getI32Type();\n+          resTy = LLVM::LLVMStructType::getLiteral(\n+              ctx, SmallVector<Type>(4, elemTy));\n+        }\n+      }\n+    }\n+\n     if (canUseLdmatrix) {\n       Value sOffset =\n           mul(i32_val(matIdx[order[1]] * sMatStride * sMatShape), sStride);\n@@ -1143,7 +1158,7 @@ class MMA16816SmemLoader {\n \n       // The result type is 4xi32, each i32 is composed of 2xf16\n       // elements (adjacent two columns in a row) or a single f32 element.\n-      Value resV4 = builder.launch(rewriter, loc, matTy);\n+      Value resV4 = builder.launch(rewriter, loc, resTy);\n       return {extract_val(elemTy, resV4, i32_arr_attr(0)),\n               extract_val(elemTy, resV4, i32_arr_attr(1)),\n               extract_val(elemTy, resV4, i32_arr_attr(2)),\n@@ -1177,6 +1192,8 @@ class MMA16816SmemLoader {\n       }\n       return {retElems[0], retElems[1], retElems[2], retElems[3]};\n     } else if (elemBytes == 1 && needTrans) { // work with int8\n+      // Can't use i32 here. Use LLVM's VectorType\n+      elemTy = matTy.cast<LLVM::LLVMStructType>().getBody()[0];\n       std::array<std::array<Value, 4>, 2> ptrs;\n       ptrs[0] = {\n           getPtr(ptrIdx),\n@@ -1235,7 +1252,8 @@ class MMA16816SmemLoader {\n         }\n       }\n \n-      return {i8v4Elems[0], i8v4Elems[1], i8v4Elems[2], i8v4Elems[3]};\n+      return {bitcast(i8v4Elems[0], i32_ty), bitcast(i8v4Elems[1], i32_ty),\n+              bitcast(i8v4Elems[2], i32_ty), bitcast(i8v4Elems[3], i32_ty)};\n     }\n \n     assert(false && \"Invalid smem load\");"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TypeConverter.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "file_content_changes": "@@ -97,6 +97,15 @@ class TritonGPUToLLVMTypeConverter : public LLVMTypeConverter {\n           Type targetTy;\n           if (targetTyMap.count(elemTy.getIntOrFloatBitWidth())) {\n             targetTy = targetTyMap.lookup(elemTy.getIntOrFloatBitWidth());\n+            // <2xi16>/<4xi8> => i32\n+            // We are doing this because NVPTX inserts extra integer instrs to\n+            // pack & unpack vectors of sub-word integers\n+            // Note: this needs to be synced with\n+            //       DotOpMmaV2ConversionHelper::loadX4\n+            if (elemTy.isa<IntegerType>() &&\n+                (elemTy.getIntOrFloatBitWidth() == 8 ||\n+                 elemTy.getIntOrFloatBitWidth() == 16))\n+              targetTy = IntegerType::get(ctx, 32);\n           } else {\n             assert(false && \"Unsupported element type\");\n           }"}]