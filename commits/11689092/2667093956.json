[{"filename": "include/triton/codegen/extern_lib.h", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "file_content_changes": "@@ -0,0 +1,89 @@\n+#ifndef _TRITON_CODE_GEN_EXTERN_LIB_H_\n+#define _TRITON_CODE_GEN_EXTERN_LIB_H_\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"llvm/IR/LLVMContext.h\"\n+#include \"llvm/IR/Module.h\"\n+#include \"llvm/IRReader/IRReader.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n+\n+namespace triton {\n+namespace codegen {\n+\n+///\n+/// \\brief ExternLib is a class that represents a library of external functions.\n+///\n+class ExternLib {\n+ public:\n+  ExternLib(const std::string &name, const std::string &path)\n+      : name_(name), path_(path) {}\n+\n+  virtual ~ExternLib() = default;\n+\n+  virtual const std::string &name() const { return name_; }\n+\n+  virtual const std::string &path() const { return path_; }\n+\n+  ///\n+  /// \\brief Load the library and return the module.\n+  ///\n+  std::unique_ptr<llvm::Module> load(llvm::LLVMContext &ctx);\n+\n+  ///\n+  /// \\brief Link the module into the given module.\n+  ///\n+  void link(std::unique_ptr<llvm::Module> &llvm,\n+            std::unique_ptr<llvm::Module> &mod);\n+\n+  ///\n+  /// \\brief Run load, link, and opt on the module.\n+  ///\n+  virtual void install(llvm::LLVMContext &ctx,\n+                       std::unique_ptr<llvm::Module> &llvm) {\n+    auto mod = load(ctx);\n+    link(llvm, mod);\n+    opt(ctx, llvm);\n+  }\n+\n+  ///\n+  /// \\brief Run opt on the module.\n+  ///\n+  virtual void opt(llvm::LLVMContext &ctx,\n+                   std::unique_ptr<llvm::Module> &llvm) = 0;\n+\n+ private:\n+  std::string name_;\n+  std::string path_;\n+};\n+\n+///\n+/// \\brief ExternLibMap is a map of ExternLibs from their names to their paths.\n+///\n+typedef std::map<std::string, std::unique_ptr<ExternLib>> ExternLibMap;\n+\n+///\n+/// \\brief Concrete class for NVIDIA's libdevice library.\n+///\n+class LibDevice final : public ExternLib {\n+ public:\n+  LibDevice(const std::string &name, const std::string &path)\n+      : ExternLib(name, path) {}\n+\n+  virtual ~LibDevice() = default;\n+\n+  virtual void opt(llvm::LLVMContext &ctx,\n+                   std::unique_ptr<llvm::Module> &llvm) override;\n+};\n+\n+///\n+/// \\brief Create an ExternLib instance based on the name and path.\n+///\n+std::unique_ptr<ExternLib> create_extern_lib(const std::string &lib_name,\n+                                             const std::string &lib_path);\n+\n+}  // namespace codegen\n+}  // namespace triton\n+\n+#endif"}, {"filename": "include/triton/codegen/pass.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "file_content_changes": "@@ -3,6 +3,7 @@\n \n \n #include <memory>\n+#include \"extern_lib.h\"\n \n namespace llvm{\n   class Module;\n@@ -30,12 +31,10 @@ namespace codegen{\n \n // TODO:\n // There should be a proper pass manager there!\n-std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMContext& ctx,\n-                                                     codegen::target* target,\n-                                                     int sm, int num_warps,\n-                                                     int num_stages, int &shared_static);\n-\n-\n+std::unique_ptr<llvm::Module> add_passes_to_emit_bin(\n+    ir::module &ir, llvm::LLVMContext &ctx, codegen::target *target,\n+    int num_warps, int num_stages, int &shared_static,\n+    const ExternLibMap &extern_libs);\n }\n }\n "}, {"filename": "include/triton/codegen/selection/generator.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "file_content_changes": "@@ -6,6 +6,7 @@\n #include \"triton/ir/visitor.h\"\n #include \"triton/ir/instructions.h\"\n #include \"triton/codegen/analysis/layout.h\"\n+#include \"triton/codegen/extern_lib.h\"\n #include <functional>\n \n // forward\n@@ -199,6 +200,7 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   void visit_make_range(ir::make_range*);\n   void visit_clock_inst(ir::clock_inst*);\n   void visit_globaltimer_inst(ir::globaltimer_inst*);\n+  void visit_extern_elementwise_inst(ir::extern_elementwise_inst*);\n //  void visit_make_range_sta(ir::make_range_sta*);\n   void visit_undef_value(ir::undef_value*);\n   void visit_constant_int(ir::constant_int*);\n@@ -209,18 +211,26 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   void visit_argument(ir::argument*);\n   void visit(ir::module &, llvm::Module &);\n \n-\n   // layouts\n   void visit_layout_mma(analysis::mma_layout*);\n   void visit_layout_scanline(analysis::scanline_layout*);\n   void visit_layout_shared(analysis::shared_layout*);\n \n+  // Add a new external library based on given name and path if it doesn't exist\n+  void add_extern_lib(const std::string &lib_name, const std::string &lib_path);\n \n-private:\n+  // Get all external libraries\n+  const ExternLibMap &get_extern_lib_map() {\n+    return extern_lib_map_;\n+  }\n+\n+ private:\n   LLVMContext *ctx_;\n   Builder* builder_;\n   Module *mod_;\n \n+  std::map<std::string, std::unique_ptr<ExternLib>> extern_lib_map_;\n+\n   analysis::axes *a_axes_;\n   analysis::swizzle *swizzle_;\n   std::map<unsigned, distributed_axis> axes_;"}, {"filename": "include/triton/ir/builder.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "file_content_changes": "@@ -169,6 +169,12 @@ class builder{\n   // Utilities\n   value *create_clock();\n   value *create_globaltimer();\n+  // Extern instruction\n+  value *create_extern_elementwise(const std::string &lib_name,\n+                                   const std::string &lib_path,\n+                                   const std::string &symbol_name,\n+                                   const std::vector<value *> &args,\n+                                   type *ret_ty);\n   // Built-in instruction\n   value *create_get_program_id(unsigned axis);\n   value *create_get_num_programs(unsigned axis);"}, {"filename": "include/triton/ir/enums.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -154,6 +154,8 @@ enum value_id_t: unsigned {\n   INST_COS,\n   INST_SIN,\n   INST_LOG,\n+  // extern\n+  INST_EXTERN_ELEMENTWISE,\n   // array arithmetic\n   INST_TRANS,\n   INST_REDUCE,"}, {"filename": "include/triton/ir/instructions.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "file_content_changes": "@@ -1097,7 +1097,28 @@ class globaltimer_inst: public instruction{\n   static globaltimer_inst* create(context &ctx, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n-\n+class extern_elementwise_inst : public instruction {\n+  extern_elementwise_inst(context &ctx, const std::vector<value *> &args,\n+                          type *dst_ty, const std::string &lib_name,\n+                          const std::string &extern_lib_path,\n+                          const std::string &symbol_name, instruction *next);\n+  std::string repr_impl() const { return \"extern_elementwise\"; }\n+  _TRITON_DEFINE_CLONE(extern_elementwise_inst)\n+  _TRITON_DEFINE_ACCEPT(extern_elementwise_inst)\n+\n+ public:\n+  static extern_elementwise_inst *create(\n+      context &ctx, const std::vector<value *> &args, type *dst_ty,\n+      const std::string &lib_name = \"\", const std::string &lib_path = \"\",\n+      const std::string &symbol_name = \"\", instruction *next = nullptr);\n+\n+  const std::string &get_lib_name() const { return lib_name_; }\n+  const std::string &get_lib_path() const { return lib_path_; }\n+\n+ private:\n+  std::string lib_name_ = \"\";\n+  std::string lib_path_ = \"\";\n+};\n }\n }\n "}, {"filename": "include/triton/ir/visitor.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -84,6 +84,8 @@ class prefetch_s_inst;\n class clock_inst;\n class globaltimer_inst;\n \n+class extern_elementwise_inst;\n+\n class make_range_sta;\n class undef_value;\n class constant_int;\n@@ -177,6 +179,8 @@ class visitor {\n   virtual void visit_constant_int(constant_int*) = 0;\n   virtual void visit_constant_fp(constant_fp*) = 0;\n   virtual void visit_alloc_const(alloc_const*) = 0;\n+\n+  virtual void visit_extern_elementwise_inst(extern_elementwise_inst*) = 0;\n };\n \n }"}, {"filename": "lib/codegen/extern_lib.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "file_content_changes": "@@ -0,0 +1,63 @@\n+#include \"triton/codegen/extern_lib.h\"\n+\n+#include \"llvm/IR/Constants.h\"\n+#include \"llvm/IR/LegacyPassManager.h\"\n+#include \"llvm/IR/Metadata.h\"\n+#include \"llvm/IR/Type.h\"\n+#include \"llvm/Linker/Linker.h\"\n+#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n+#include \"triton/codegen/pass.h\"\n+\n+namespace triton {\n+\n+namespace codegen {\n+\n+std::unique_ptr<llvm::Module> ExternLib::load(llvm::LLVMContext& ctx) {\n+  llvm::SMDiagnostic err;\n+  auto mod = llvm::parseIRFile(this->path_, err, ctx);\n+  if (!mod) {\n+    throw std::runtime_error(\"Failed to load extern lib \" + this->name_ +\n+                             \" at \" + this->path_);\n+  }\n+  return mod;\n+}\n+\n+void ExternLib::link(std::unique_ptr<llvm::Module>& llvm,\n+                     std::unique_ptr<llvm::Module>& mod) {\n+  // Set triple and data layout to match the target module\n+  mod->setTargetTriple(llvm->getTargetTriple());\n+  mod->setDataLayout(llvm->getDataLayout());\n+  if (llvm::Linker::linkModules(*llvm, std::move(mod))) {\n+    throw std::runtime_error(\"Failed to link extern lib \" + this->name_ +\n+                             \" at \" + this->path_);\n+  }\n+}\n+\n+void LibDevice::opt(llvm::LLVMContext& ctx, std::unique_ptr<llvm::Module>& llvm) {\n+  // Add nvvm reflect flags to llvm module\n+  // https://llvm.org/docs/LangRef.html#module-flags-metadata\n+  // i32 4: Override the other module.\n+  // i32 1: Emit an error\n+  // If both modules specify Override, but the values differ, an error\n+  // will be emitted.\n+  llvm::Type* I32 = llvm::Type::getInt32Ty(ctx);\n+  llvm::Metadata* md_four =\n+      llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 4));\n+  llvm::Metadata* md_name = llvm::MDString::get(ctx, \"nvvm-reflect-ftz\");\n+  llvm::Metadata* md_one =\n+      llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 1));\n+  llvm::MDNode* reflect = llvm::MDNode::get(ctx, {md_four, md_name, md_one});\n+  llvm->addModuleFlag(reflect);\n+}\n+\n+std::unique_ptr<ExternLib> create_extern_lib(const std::string& lib_name,\n+                                             const std::string& lib_path) {\n+  if (lib_name == \"libdevice\") {\n+    return std::make_unique<LibDevice>(lib_name, lib_path);\n+  } else {\n+    throw std::runtime_error(\"Unknown external library: \" + lib_name);\n+  }\n+}\n+\n+}  // namespace codegen\n+}  // namespace triton"}, {"filename": "lib/codegen/pass.cc", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "file_content_changes": "@@ -1,4 +1,14 @@\n #include \"triton/codegen/pass.h\"\n+\n+#include \"llvm/IR/Constants.h\"\n+#include \"llvm/IR/LegacyPassManager.h\"\n+#include \"llvm/IR/Module.h\"\n+#include \"llvm/IR/Verifier.h\"\n+#include \"llvm/IRReader/IRReader.h\"\n+#include \"llvm/Linker/Linker.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n+#include \"llvm/Transforms/IPO.h\"\n+#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n #include \"triton/codegen/analysis/align.h\"\n #include \"triton/codegen/analysis/allocation.h\"\n #include \"triton/codegen/analysis/axes.h\"\n@@ -9,24 +19,66 @@\n #include \"triton/codegen/transform/cts.h\"\n #include \"triton/codegen/transform/dce.h\"\n #include \"triton/codegen/transform/disassociate.h\"\n+#include \"triton/codegen/transform/inline.h\"\n #include \"triton/codegen/transform/membar.h\"\n #include \"triton/codegen/transform/peephole.h\"\n #include \"triton/codegen/transform/pipeline.h\"\n #include \"triton/codegen/transform/prefetch.h\"\n-#include \"triton/codegen/transform/inline.h\"\n #include \"triton/ir/function.h\"\n #include \"triton/ir/module.h\"\n #include \"triton/ir/print.h\"\n-#include \"llvm/IR/Module.h\"\n-#include \"llvm/IR/LegacyPassManager.h\"\n-#include \"llvm/IR/Verifier.h\"\n+\n namespace triton {\n namespace codegen {\n \n+static void link_extern_libs(const ExternLibMap& user_extern_lib_map,\n+                             const ExternLibMap& target_extern_lib_map,\n+                             ir::module& ir, llvm::LLVMContext& ctx,\n+                             std::unique_ptr<llvm::Module>& llvm) {\n+  for (const auto& iter : target_extern_lib_map) {\n+    auto &lib_name = iter.first;\n+    if (user_extern_lib_map.count(lib_name) != 0 &&\n+        user_extern_lib_map.at(lib_name)->path() != \"\") {\n+      // If the user specified a path for this library, use it.\n+      user_extern_lib_map.at(lib_name)->install(ctx, llvm);\n+    } else {\n+      // Otherwise, use the default path.\n+      iter.second->install(ctx, llvm);\n+    }\n+  }\n+\n+  std::set<llvm::StringRef> function_names;\n+  for (auto& func : ir.get_function_list()) {\n+    function_names.insert(func->get_name());\n+  }\n+  llvm::legacy::PassManager pass;\n+  pass.add(llvm::createInternalizePass([&](const llvm::GlobalValue& v) -> bool {\n+    if (function_names.count(v.getName()) != 0) {\n+      // Preserve global functions\n+      return true;\n+    }\n+    // Internalize all device functions\n+    return false;\n+  }));\n+\n+  llvm::legacy::PassManager pm;\n+  pm.add(llvm::createVerifierPass());\n+  pm.run(*llvm);\n+\n+  llvm::PassManagerBuilder builder;\n+  builder.OptLevel = 3;\n+  builder.SizeLevel = 0;\n+  builder.populateModulePassManager(pass);\n+\n+  pass.run(*llvm);\n+}\n+\n // TODO:\n // There should be a proper pass manager there!\n-std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMContext& ctx, codegen::target* target,\n-                                                     int cc, int num_warps, int num_stages, int& shared_static) {\n+std::unique_ptr<llvm::Module> add_passes_to_emit_bin(\n+    ir::module& ir, llvm::LLVMContext& ctx, codegen::target* target,\n+    int num_warps, int num_stages, int& shared_static,\n+    const ExternLibMap& extern_lib_map) {\n   // generate llvm code\n   std::string name = ir.get_function_list()[0]->get_name();\n   std::unique_ptr<llvm::Module> llvm(new llvm::Module(name, ctx));\n@@ -47,34 +99,34 @@ std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMC\n   codegen::transform::peephole peephole(target, &layouts);\n   codegen::transform::coalesce coalesce(&align, &layouts, has_sm80);\n   codegen::transform::prefetch prefetch_s(target);\n-  codegen::transform::membar barriers(&liveness, &layouts, &allocation, &prefetch_s, target);\n-  codegen::generator isel(&axes, &layouts, &align, &allocation, &swizzle, target, num_warps);\n+  codegen::transform::membar barriers(&liveness, &layouts, &allocation,\n+                                      &prefetch_s, target);\n+  codegen::generator isel(&axes, &layouts, &align, &allocation, &swizzle,\n+                          target, num_warps);\n   // run passes\n   inliner.run(ir);\n   dce.run(ir);\n   // ir.print(std::cout);\n   peephole.run(ir);\n   dce.run(ir);\n   pipeline.run(ir);\n-  dce.run(ir);  \n+  dce.run(ir);\n   disassociate.run(ir);\n   dce.run(ir);\n   align.run(ir);\n   axes.run(ir);\n   layouts.run(ir);\n   peephole.run(ir);\n   dce.run(ir);\n-  if (target->is_gpu())\n-    cts.run(ir);\n+  if (target->is_gpu()) cts.run(ir);\n   align.run(ir);\n   axes.run(ir);\n   layouts.run(ir);\n   coalesce.run(ir);\n   dce.run(ir);\n   align.run(ir);\n   dce.run(ir);\n-  if (target->is_gpu())\n-    cts.run(ir);\n+  if (target->is_gpu()) cts.run(ir);\n   dce.run(ir);\n   align.run(ir);\n   axes.run(ir);\n@@ -97,8 +149,15 @@ std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMC\n   // ir.print(std::cout);\n   isel.visit(ir, *llvm);\n   shared_static = allocation.allocated_size();\n+\n+  if (isel.get_extern_lib_map().size() > 0) {\n+    // If there's any extern lib calls,\n+    // we need to link them in.\n+    link_extern_libs(extern_lib_map, isel.get_extern_lib_map(), ir, ctx, llvm);\n+  }\n+\n   return llvm;\n }\n \n-} // namespace codegen\n-} // namespace triton\n+}  // namespace codegen\n+}  // namespace triton"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "file_content_changes": "@@ -1195,7 +1195,7 @@ void generator::visit_cos_inst(ir::cos_inst* x){\n   for(auto idx: idxs_.at(x)){\n     vals_[x][idx] = call(cos, std::vector<llvm::Value*>{vals_[x->get_operand(0)][idx]});\n   }\n- }\n+}\n \n /**\n  * \\brief Code Generation for `umulhi`\n@@ -3154,6 +3154,30 @@ void generator::visit_async_wait_inst(ir::async_wait_inst* i) {\n   call(iasm);\n }\n \n+/**\n+ * \\brief Code Generation for `extern_elementwise`\n+ */\n+void generator::visit_extern_elementwise_inst(ir::extern_elementwise_inst *i) {\n+  std::vector<Type *> operand_types;\n+  for (size_t j = 0; j < i->get_num_operands(); j++) {\n+    operand_types.push_back(\n+        cvt(i->get_operand(j)->get_type()->get_scalar_ty()));\n+  }\n+  Type *ret_type = cvt(i->get_type()->get_scalar_ty());\n+  FunctionType *FT =\n+      FunctionType::get(ret_type, std::move(operand_types), false);\n+  Function *F = llvm::cast<llvm::Function>(\n+      mod_->getOrInsertFunction(i->get_name(), FT).getCallee());\n+  for (auto idx : idxs_.at(i)) {\n+    std::vector<llvm::Value *> args;\n+    for (size_t j = 0; j < i->get_num_operands(); j++) {\n+      args.emplace_back(vals_[i->get_operand(j)][idx]);\n+    }\n+    vals_[i][idx] = call(F, std::move(args));\n+  }\n+  add_extern_lib(i->get_lib_name(), i->get_lib_path());\n+}\n+\n //void generator::visit_make_range_dyn(ir::make_range_dyn* x) {\n //  for(indices_t idx: idxs_.at(x)){\n //    assert(idx.size() == 1);\n@@ -3741,6 +3765,15 @@ void generator::visit(ir::module &src, llvm::Module &dst) {\n     visit_function(fn);\n }\n \n-\n-}\n+void generator::add_extern_lib(const std::string &lib_name,\n+                               const std::string &lib_path) {\n+  if (extern_lib_map_.count(lib_name) == 0) {\n+    extern_lib_map_[lib_name] = create_extern_lib(lib_name, lib_path);\n+  } else if (extern_lib_map_.at(lib_name)->path() != lib_path) {\n+    throw std::runtime_error(\"A library has multiple paths (1) \" + lib_path +\n+                             \" (2) \" + extern_lib_map_.at(lib_name)->path());\n+  }\n }\n+\n+}  // namespace codegen\n+}  // namespace triton"}, {"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "file_content_changes": "@@ -358,8 +358,5 @@ hipModule_t amdgpu_to_hipmodule(const std::string& path) {\n   return ret;\n }\n \n-\n-\n-}\n-}\n-\n+}  // namespace driver\n+}  // namespace triton"}, {"filename": "lib/ir/builder.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "file_content_changes": "@@ -379,6 +379,19 @@ value *builder::create_globaltimer() {\n   return insert(globaltimer_inst::create(ctx_));\n }\n \n+//===----------------------------------------------------------------------===//\n+//                               externs\n+//===----------------------------------------------------------------------===//\n+\n+value *builder::create_extern_elementwise(const std::string &lib_name,\n+                                          const std::string &lib_path,\n+                                          const std::string &symbol_name,\n+                                          const std::vector<value *> &args,\n+                                          type *ret_ty) {\n+  return insert(extern_elementwise_inst::create(ctx_, args, ret_ty, lib_name,\n+                                                lib_path, symbol_name));\n+}\n+\n //===----------------------------------------------------------------------===//\n //                               built-in instructions\n //===----------------------------------------------------------------------===//"}, {"filename": "lib/ir/instructions.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "file_content_changes": "@@ -988,6 +988,28 @@ globaltimer_inst* globaltimer_inst::create(context &ctx, const std::string &name\n   return new globaltimer_inst(ctx, name, next);\n }\n \n+// extern elementwise\n+extern_elementwise_inst::extern_elementwise_inst(\n+    context &ctx, const std::vector<value *> &args, type *ret_ty,\n+    const std::string &lib_name, const std::string &lib_path,\n+    const std::string &symbol_name, instruction *next)\n+    : instruction(ret_ty, INST_EXTERN_ELEMENTWISE, args.size(), symbol_name,\n+                  next),\n+      lib_name_(lib_name),\n+      lib_path_(lib_path) {\n+  for (size_t i = 0; i < args.size(); i++) {\n+    set_operand(i, args[i]);\n+  }\n+}\n+\n+extern_elementwise_inst *extern_elementwise_inst::create(\n+    context &ctx, const std::vector<value *> &args, type *ret_ty,\n+    const std::string &lib_name, const std::string &lib_path,\n+    const std::string &symbol_name, instruction *next) {\n+  return new extern_elementwise_inst(ctx, args, ret_ty, lib_name, lib_path,\n+                                     symbol_name, next);\n+}\n+\n // clock\n clock_inst::clock_inst(context &ctx, const std::string &name, instruction *next)\n   : instruction(type::get_int64_ty(ctx), INST_CLOCK, 0, name, next) { }"}, {"filename": "python/setup.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -98,7 +98,7 @@ def build_extension(self, ext):\n         if not os.path.exists(self.build_temp):\n             os.makedirs(self.build_temp)\n         # python directories\n-        python_include_dirs = [distutils.sysconfig.get_python_inc()] + ['/usr/local/cuda/include']\n+        python_include_dirs = [distutils.sysconfig.get_python_inc()]\n         cmake_args = [\n             \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=\" + extdir,\n             \"-DBUILD_TUTORIALS=OFF\","}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "file_content_changes": "@@ -1,5 +1,6 @@\n \ufeff#include \"triton/codegen/pass.h\"\n #include \"triton/codegen/target.h\"\n+#include \"triton/codegen/extern_lib.h\"\n #include \"triton/driver/error.h\"\n #include \"triton/driver/llvm.h\"\n #include \"triton/ir/builder.h\"\n@@ -19,7 +20,6 @@\n #include <stdexcept>\n #include <string>\n #include \"llvm/IR/Module.h\"\n-#include \"llvm/IR/LegacyPassManager.h\"\n #include \"llvm/IR/Verifier.h\"\n \n namespace py = pybind11;\n@@ -140,7 +140,7 @@ size_t get_pointer_range_size(uint64_t addr){\n // Launch\n void parse_args(py::list& args, py::list do_not_specialize, const std::string& func_key, py::list& arg_names,\n                 std::string& cache_key, std::string& params, size_t& params_size, py::dict constants,\n-                int num_warps, int num_stages) {\n+                int num_warps, int num_stages, py::dict& extern_libs) {\n     size_t len = PyList_Size(args.ptr());\n     params.reserve(8*len); // 8 max bytes by argument\n     char* params_ptr = &params[0];\n@@ -256,6 +256,11 @@ void parse_args(py::list& args, py::list do_not_specialize, const std::string& f\n       throw std::runtime_error(err_msg);\n     }\n   params_size = (std::ptrdiff_t)(params_ptr - &params[0]);\n+\n+  for (auto item : extern_libs) {\n+    cache_key += \"-\" + item.first.cast<std::string>();\n+    cache_key += \"_\" + item.second.cast<std::string>();\n+  }\n }\n \n //\n@@ -288,21 +293,22 @@ void init_triton_runtime(py::module &&m) {\n   // cache key\n   m.def(\"launch\", [](py::list args, py::list do_not_specialize, const std::string& func_key, py::list& arg_names, \n                      py::object device, py::int_ stream, py::dict bin_cache, py::int_ num_warps, py::int_ num_stages, \n-                     py::function add_to_cache, py::object grid){\n+                     py::dict extern_libs, py::function add_to_cache, py::object grid){\n     // parse arguments to compute cache key, compile-time constants and packed kernel arguments\n     long _num_warps = PyLong_AsLong(num_warps.ptr());\n     long _num_stages = PyLong_AsLong(num_stages.ptr());\n     std::string cache_key;\n     std::string params;\n     size_t params_size;\n     py::dict constants;\n-    parse_args(args, do_not_specialize, func_key, arg_names, cache_key, params, params_size, constants, _num_warps, _num_stages);\n+    parse_args(args, do_not_specialize, func_key, arg_names, cache_key, params,\n+               params_size, constants, _num_warps, _num_stages, extern_libs);\n \n     // get cached binary\n     py::str key(cache_key);\n     py::bool_ noop = false;\n     if(!bin_cache.contains(key)) {\n-      noop = add_to_cache(key, args, device, num_warps, num_stages);\n+      noop = add_to_cache(key, args, device, num_warps, num_stages, extern_libs);\n     }\n     if (noop)\n       return (py::object)py::none();\n@@ -467,11 +473,10 @@ std::tuple<uint64_t, uint64_t, uint64_t, uint64_t> hip_load_binary(const std::st\n // --------------------------------------- \n \n // CUDA\n-std::tuple<std::string, asm_map_t, int> cu_compile_ttir(const std::string& name, ir::module &ir, \n-                                                               uint64_t device, int num_warps, int num_stages,\n-                                                               asm_map_t &asm_map){\n-\n-  int n_shared_bytes;\n+std::tuple<std::string, asm_map_t, int> cu_compile_ttir(\n+    const std::string &name, ir::module &ir, uint64_t device, int num_warps,\n+    int num_stages, asm_map_t &asm_map,\n+    const triton::codegen::ExternLibMap &extern_lib_map) {\n   py::gil_scoped_release allow_threads;\n   llvm::LLVMContext ctx;\n   // device properties\n@@ -483,7 +488,9 @@ std::tuple<std::string, asm_map_t, int> cu_compile_ttir(const std::string& name,\n   std::string ptxas_path = drv::path_to_ptxas(version);\n   // Triton-IR -> NVPTX LLVM-IR\n   triton::codegen::nvidia_cu_target target(cc);\n-  auto llvm = triton::codegen::add_passes_to_emit_bin(ir, ctx, &target, cc, num_warps, num_stages, n_shared_bytes);\n+  int n_shared_bytes;\n+  auto llvm = triton::codegen::add_passes_to_emit_bin(\n+      ir, ctx, &target, num_warps, num_stages, n_shared_bytes, extern_lib_map);\n   std::string tmp;\n   llvm::raw_string_ostream llir(tmp);\n   llir << *llvm;\n@@ -502,14 +509,16 @@ std::tuple<std::string, asm_map_t, int> cu_compile_ttir(const std::string& name,\n }\n \n // HIP\n-std::tuple<std::string, asm_map_t, int> hip_compile_ttir(const std::string& name, ir::module &ir, \n-                                                                uint64_t device, int num_warps, int num_stages, \n-                                                                asm_map_t &asm_map){\n+std::tuple<std::string, asm_map_t, int> hip_compile_ttir(\n+    const std::string &name, ir::module &ir, uint64_t device, int num_warps,\n+    int num_stages, asm_map_t &asm_map,\n+    const triton::codegen::ExternLibMap &extern_lib_map) {\n   llvm::LLVMContext ctx;\n   // Triton-IR -> NVPTX LLVM-IR\n   triton::codegen::amd_cl_target target;\n   int n_shared_bytes;\n-  auto llvm = triton::codegen::add_passes_to_emit_bin(ir, ctx, &target, 70, num_warps, num_stages, n_shared_bytes);\n+  auto llvm = triton::codegen::add_passes_to_emit_bin(\n+      ir, ctx, &target, num_warps, num_stages, n_shared_bytes, extern_lib_map);\n   std::string tmp;\n   llvm::raw_string_ostream llir(tmp);\n   llir << *llvm;\n@@ -523,19 +532,30 @@ std::tuple<std::string, asm_map_t, int> hip_compile_ttir(const std::string& name\n \n void init_triton_codegen(py::module &&m) {\n   m.def(\n-      \"compile_ttir\", [](backend_t backend, ir::module &ir, uint64_t device, int num_warps, int num_stages) {\n+      \"compile_ttir\",\n+      [](backend_t backend, ir::module &ir, uint64_t device, int num_warps,\n+         int num_stages, py::dict& extern_libs) {\n         std::string name = ir.get_function_list()[0]->get_name();\n         // record asm as we generate\n         asm_map_t asm_map;\n         std::ostringstream ttir;\n         ir.print(ttir);\n         asm_map[\"ttir\"] = py::cast(ttir.str());\n         llvm::LLVMContext ctx;\n+        // construct extern lib map\n+        triton::codegen::ExternLibMap extern_lib_map;\n+        for (auto item : extern_libs) {\n+          auto name = item.first.cast<std::string>();\n+          auto path = item.second.cast<std::string>();\n+          extern_lib_map.emplace(\n+              name, triton::codegen::create_extern_lib(name, path));\n+        }\n         if(backend == CUDA)\n-          return cu_compile_ttir(name, ir, device, num_warps, num_stages, asm_map);\n+          return cu_compile_ttir(name, ir, device, num_warps, num_stages, asm_map, extern_lib_map);\n         if(backend == ROCM)\n-          return hip_compile_ttir(name, ir, device, num_warps, num_stages, asm_map);\n-      }, py::return_value_policy::take_ownership);\n+          return hip_compile_ttir(name, ir, device, num_warps, num_stages, asm_map, extern_lib_map);\n+      },\n+      py::return_value_policy::take_ownership);\n   m.def(\"load_binary\", [](backend_t backend, const std::string& name, asm_map_t &asm_map, size_t n_shared_bytes, uint64_t dev){\n \tpy::gil_scoped_release allow_threads;\n         if(backend == CUDA)\n@@ -931,7 +951,8 @@ void init_triton_ir(py::module &&m) {\n       // Utilities\n       .def(\"create_clock\", &ir::builder::create_clock, ret::reference)\n       .def(\"create_globaltimer\", &ir::builder::create_globaltimer, ret::reference)\n-\n+      // Extern instruction\n+      .def(\"create_extern_elementwise\", &ir::builder::create_extern_elementwise, ret::reference)\n       // Built-in instruction\n       .def(\"create_get_program_id\", &ir::builder::create_get_program_id, ret::reference)\n       .def(\"create_get_num_programs\", &ir::builder::create_get_num_programs, ret::reference)"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "file_content_changes": "@@ -1300,3 +1300,49 @@ def _kernel(dst):\n     _kernel[(1,)](dst=dst, num_warps=1)\n     _kernel[(1,)](dst=dst, num_warps=2)\n     _kernel[(1,)](dst=dst, num_warps=4)\n+\n+# -------------\n+# test extern\n+# -------------\n+\n+\n+@pytest.mark.parametrize(\"dtype_str, expr, lib_path\",\n+                         [('int32', 'libdevice.ffs', ''),\n+                          ('float32', 'libdevice.pow', '/usr/local/cuda/nvvm/libdevice/libdevice.10.bc'),\n+                          ('float64', 'libdevice.norm4d', '')])\n+def test_libdevice(dtype_str, expr, lib_path):\n+\n+    @triton.jit\n+    def kernel(X, Y, BLOCK: tl.constexpr):\n+        x = tl.load(X + tl.arange(0, BLOCK))\n+        y = GENERATE_TEST_HERE\n+        tl.store(Y + tl.arange(0, BLOCK), y)\n+\n+    shape = (128, )\n+    rs = RandomState(17)\n+    # limit the range of integers so that the sum does not overflow\n+    x = numpy_random(shape, dtype_str=dtype_str, rs=rs)\n+\n+    if expr == 'libdevice.ffs':\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.libdevice.ffs(x)'})\n+        y_ref = np.zeros(shape, dtype=x.dtype)\n+        for i in range(shape[0]):\n+            y_ref[i] = (int(x[i]) & int(-x[i])).bit_length()\n+    elif expr == 'libdevice.pow':\n+        # numpy does not allow negative factors in power, so we use abs()\n+        x = np.abs(x)\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.libdevice.pow(x, x)'})\n+        y_ref = np.power(x, x)\n+    elif expr == 'libdevice.norm4d':\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.libdevice.norm4d(x, x, x, x)'})\n+        y_ref = np.sqrt(4 * np.power(x, 2))\n+\n+    x_tri = to_triton(x)\n+    # triton result\n+    y_tri = to_triton(numpy_random((shape[0],), dtype_str=dtype_str, rs=rs), device='cuda')\n+    kernel[(1,)](x_tri, y_tri, BLOCK=shape[0], extern_libs={'libdevice': lib_path})\n+    # compare\n+    if expr == 'libdevice.ffs':\n+        np.testing.assert_equal(y_ref, to_numpy(y_tri))\n+    else:\n+        np.testing.assert_allclose(y_ref, to_numpy(y_tri), rtol=0.01)"}, {"filename": "python/triton/code_gen.py", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "file_content_changes": "@@ -689,7 +689,7 @@ def visit_Call(self, node):\n                 ret = triton.language.tensor(ret, self.prototypes[fn_name].ret_type)\n             return ret\n         # built-in function\n-        if sys.modules[fn.__module__] is triton.language.core:\n+        if sys.modules[fn.__module__] is triton.language.core or isinstance(fn, triton.language.extern.ExternalFunction):\n             ret = fn(*args, _builder=self.builder, **kws)\n         if fn in self.value_constructor.builtins.values():\n             args = [arg.value if isinstance(arg, triton.language.constexpr) else arg\n@@ -933,7 +933,7 @@ def __init__(self, fn):\n         self.fn = fn\n         self.cache_key = {}\n \n-    def add_to_cache(self, key, wargs, device_idx, num_warps, num_stages):\n+    def add_to_cache(self, key, wargs, device_idx, num_warps, num_stages, extern_libs):\n         tensor_idxs = [i for i, arg in enumerate(wargs) if hasattr(arg, 'data_ptr')]\n \n         # attributes\n@@ -953,9 +953,10 @@ def add_to_cache(self, key, wargs, device_idx, num_warps, num_stages):\n         constants.update({i: arg.value for i, arg in enumerate(wargs) if isinstance(arg, triton.language.constexpr)})\n         constants.update({i: None for i, arg in enumerate(wargs) if arg is None})\n         arg_types = [Kernel._to_python_ir(arg) for i, arg in enumerate(wargs) if i not in constants]\n-        return self.fn._warmup(key, arg_types=arg_types, device=device_idx, attributes=attributes, constants=constants, num_warps=num_warps, num_stages=num_stages, is_manual_warmup=False)\n+        return self.fn._warmup(key, arg_types=arg_types, device=device_idx, attributes=attributes, constants=constants, num_warps=num_warps, num_stages=num_stages,\n+                               extern_libs=extern_libs, is_manual_warmup=False)\n \n-    def __call__(self, *wargs, grid, num_warps=4, num_stages=2, **kwargs):\n+    def __call__(self, *wargs, grid, num_warps=4, num_stages=2, extern_libs={}, **kwargs):\n         assert num_warps != 0 and (num_warps & (num_warps - 1)) == 0, f\"num_warps={num_warps} must be a power of 2.\"\n         # handle arguments passed by name\n         kwargs = {self.fn.arg_names.index(name): value for name, value in kwargs.items()}\n@@ -985,7 +986,7 @@ def __call__(self, *wargs, grid, num_warps=4, num_stages=2, **kwargs):\n         cache_key = self.cache_key[device]\n         stream = current_cuda_stream(device)\n         return _triton.runtime.launch(wargs, self.fn.do_not_specialize, cache_key, self.fn.arg_names,\n-                                      device, stream, self.fn.bin_cache, num_warps, num_stages, self.add_to_cache,\n+                                      device, stream, self.fn.bin_cache, num_warps, num_stages, extern_libs, self.add_to_cache,\n                                       grid)\n \n \n@@ -1242,7 +1243,7 @@ def _init_kernel(self):\n     def warmup(self, compile):\n         return self._warmup(**compile, is_manual_warmup=True)\n \n-    def _warmup(self, key, arg_types, device, attributes, constants, num_warps, num_stages, is_manual_warmup):\n+    def _warmup(self, key, arg_types, device, attributes, constants, num_warps, num_stages, extern_libs, is_manual_warmup):\n         hashed_key = hashlib.md5(key.encode(\"utf-8\")).hexdigest()\n \n         # create cache directory\n@@ -1264,7 +1265,7 @@ def _warmup(self, key, arg_types, device, attributes, constants, num_warps, num_\n                 with open(bin_cache_path, 'rb') as f:\n                     binary = pickle.load(f)[\"binary\"]\n \n-        compile = dict(arg_types=arg_types, device=device, attributes=attributes, constants=constants, num_warps=num_warps, num_stages=num_stages)\n+        compile = dict(arg_types=arg_types, device=device, attributes=attributes, constants=constants, num_warps=num_warps, num_stages=num_stages, extern_libs=extern_libs)\n         if JITFunction.cache_hook is not None:\n             name = self.__name__\n             info = key.split('-')[-3:]\n@@ -1293,7 +1294,7 @@ def _warmup(self, key, arg_types, device, attributes, constants, num_warps, num_\n         self.bin_cache[key] = LoadedBinary(device, binary)\n         return False\n \n-    def _compile(self, arg_types, device, attributes, constants, num_warps, num_stages):\n+    def _compile(self, arg_types, device, attributes, constants, num_warps, num_stages, extern_libs):\n         # create IR module\n         context = _triton.ir.context()\n         # get just-in-time proto-type of kernel\n@@ -1316,7 +1317,7 @@ def _compile(self, arg_types, device, attributes, constants, num_warps, num_stag\n             backend = _triton.runtime.backend.CUDA\n         else:\n             backend = _triton.runtime.backend.ROCM\n-        name, asm, shared_mem = _triton.code_gen.compile_ttir(backend, generator.module, device, num_warps, num_stages)\n+        name, asm, shared_mem = _triton.code_gen.compile_ttir(backend, generator.module, device, num_warps, num_stages, extern_libs)\n         max_shared_memory = _triton.runtime.max_shared_memory(backend, device)\n         if shared_mem > max_shared_memory:\n             raise OutOfResources(shared_mem, max_shared_memory, \"shared memory\")"}, {"filename": "python/triton/language/__init__.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,4 +1,4 @@\n # flake8: noqa: F401\n-from . import core, random\n+from . import core, extern, libdevice, random\n from .core import *\n from .random import *"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "file_content_changes": "@@ -248,8 +248,10 @@ def __init__(self, element_ty: dtype, shape: List[int]):\n         # while tensor's shape is a list of constexpr\n         self.shape = shape\n         self.numel = 1\n-        for s in self.shape:\n-            self.numel *= s\n+        for i, s in enumerate(self.shape):\n+            if isinstance(s, constexpr):\n+                self.shape[i] = s.value\n+            self.numel *= self.shape[i]\n \n         self.name = self.__str__()\n "}, {"filename": "python/triton/language/extern.py", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "file_content_changes": "@@ -0,0 +1,107 @@\n+from __future__ import annotations  # remove after python 3.11\n+\n+from . import core, semantic\n+\n+\n+def dispatch(func, lib_name: str, lib_path: str, args: list, arg_type_symbol_dict: dict, ret_shape: tuple, _builder=None):\n+    '''\n+        Dispatch a function to a library\n+\n+        :param func: the function to dispatch\n+        :param lib_name: the name of the library\n+        :param lib_path: the path of the library\n+        :param args: the arguments of the function\n+        :param arg_type_symbol_dict: the type of the arguments\n+        :param ret_shape: the shape of the return value\n+        :param _builder: the builder\n+\n+        :return: the return value of the function\n+    '''\n+    if len(arg_type_symbol_dict) == 0:\n+        raise ValueError(\"arg_type_symbol_dict is empty\")\n+\n+    num_args = len(list(arg_type_symbol_dict.keys())[0])\n+    if len(args) != num_args:\n+        raise ValueError(f\"length of input args does not match.\"\n+                         f\"Expect {len(args)}, got {num_args}\")\n+\n+    arg_types = []\n+    arg_list = []\n+    for arg in args:\n+        if isinstance(arg, core.tensor):\n+            arg_types.append(arg.dtype)\n+            arg_list.append(arg.handle)\n+        else:\n+            arg_types.append(type(arg))\n+            arg_list.append(arg)\n+    arg_types = tuple(arg_types)\n+\n+    if arg_types not in arg_type_symbol_dict:\n+        raise ValueError(f\"input arg type does not match.\"\n+                         f\"Expect one of {arg_type_symbol_dict.keys()}, got {arg_types}\")\n+    else:\n+        symbol = arg_type_symbol_dict[arg_types][0]\n+        ret_type = arg_type_symbol_dict[arg_types][1]\n+        ret_type = core.block_type(ret_type, ret_shape) if ret_shape is not None else ret_type\n+        return core.tensor(func(lib_name, lib_path, symbol, arg_list, ret_type.to_ir(_builder)), ret_type)\n+\n+\n+def elementwise(lib_name: str, lib_path: str, args: list, arg_type_symbol_dict: dict, _builder=None):\n+    '''\n+        Dispatch an elementwise function to a library\n+\n+        :param lib_name: the name of the library\n+        :param lib_path: the path of the library\n+        :param args: the arguments of the function\n+        :param arg_type_symbol_dict: the type of the arguments\n+        :param _builder: the builder\n+\n+        :return: the return value of the function\n+    '''\n+    dispatch_args = args.copy()\n+    if len(args) == 1:\n+        dispatch_args[0] = core._to_tensor(dispatch_args[0], _builder)\n+        ret_shape = dispatch_args[0].shape\n+    elif len(args) == 2:\n+        dispatch_args[0] = core._to_tensor(dispatch_args[0], _builder)\n+        dispatch_args[1] = core._to_tensor(dispatch_args[1], _builder)\n+        dispatch_args[0], dispatch_args[1] = semantic.binary_op_type_checking_impl(\n+            dispatch_args[0], dispatch_args[1], _builder)\n+        ret_shape = dispatch_args[0].shape\n+    else:\n+        for i in range(len(dispatch_args)):\n+            dispatch_args[i] = core._to_tensor(dispatch_args[i], _builder)\n+        broadcast_arg = dispatch_args[0]\n+        # Get the broadcast shape over all the arguments\n+        for i in range(len(dispatch_args)):\n+            _, broadcast_arg = semantic.binary_op_type_checking_impl(\n+                dispatch_args[i], broadcast_arg, _builder)\n+        # Change the shape of each argument based on the broadcast shape\n+        for i in range(len(dispatch_args)):\n+            dispatch_args[i], _ = semantic.binary_op_type_checking_impl(\n+                dispatch_args[i], broadcast_arg, _builder)\n+        ret_shape = broadcast_arg.shape\n+    func = getattr(_builder, \"create_extern_elementwise\")\n+    return dispatch(func, lib_name, lib_path, dispatch_args, arg_type_symbol_dict, ret_shape, _builder)\n+\n+\n+class ExternalFunction:\n+    '''\n+        A wrapper for external functions\n+    '''\n+\n+    def __init__(self, fn):\n+        self.fn = fn\n+\n+    def __call__(self, *args, **kwargs):\n+        if '_builder' not in kwargs or \\\n+           kwargs['_builder'] is None:\n+            raise ValueError(\"Did you forget to add @triton.jit ? (`_builder` argument must be provided outside of JIT functions.)\")\n+        return self.fn(*args, **kwargs)\n+\n+\n+def extern(fn):\n+    '''\n+        A decorator for external functions\n+    '''\n+    return ExternalFunction(fn)"}, {"filename": "python/triton/language/libdevice.10.bc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "file_content_changes": "N/A"}, {"filename": "python/triton/language/libdevice.py", "status": "added", "additions": 1661, "deletions": 0, "changes": 1661, "file_content_changes": "@@ -0,0 +1,1661 @@\n+import os\n+\n+from . import core, extern\n+\n+LIBDEVICE_PATH = os.path.dirname(\n+    os.path.abspath(__file__)) + \"/libdevice.10.bc\"\n+\n+\n+@extern.extern\n+def clz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_clz\", core.dtype(\"int32\")),\n+                               (core.dtype(\"int64\"),): (\"__nv_clzll\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def popc(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_popc\", core.dtype(\"int32\")),\n+                               (core.dtype(\"int64\"),): (\"__nv_popcll\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def byte_perm(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_byte_perm\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def min(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_min\", core.dtype(\"int32\")),\n+                               (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_umin\", core.dtype(\"uint32\")),\n+                               (core.dtype(\"int64\"), core.dtype(\"int64\"),): (\"__nv_llmin\", core.dtype(\"int64\")),\n+                               (core.dtype(\"uint64\"), core.dtype(\"uint64\"),): (\"__nv_ullmin\", core.dtype(\"uint64\")),\n+                               (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fminf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fmin\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def max(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_max\", core.dtype(\"int32\")),\n+                               (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_umax\", core.dtype(\"uint32\")),\n+                               (core.dtype(\"int64\"), core.dtype(\"int64\"),): (\"__nv_llmax\", core.dtype(\"int64\")),\n+                               (core.dtype(\"uint64\"), core.dtype(\"uint64\"),): (\"__nv_ullmax\", core.dtype(\"uint64\")),\n+                               (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaxf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fmax\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def mulhi(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_mulhi\", core.dtype(\"int32\")),\n+                               (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_umulhi\", core.dtype(\"uint32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def mul64hi(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int64\"), core.dtype(\"int64\"),): (\"__nv_mul64hi\", core.dtype(\"int64\")),\n+                               (core.dtype(\"uint64\"), core.dtype(\"uint64\"),): (\"__nv_umul64hi\", core.dtype(\"uint64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def mul24(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_mul24\", core.dtype(\"int32\")),\n+                               (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_umul24\", core.dtype(\"uint32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def brev(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_brev\", core.dtype(\"int32\")),\n+                               (core.dtype(\"int64\"),): (\"__nv_brevll\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def sad(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"), core.dtype(\"uint32\"),): (\"__nv_sad\", core.dtype(\"int32\")),\n+                               (core.dtype(\"uint32\"), core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_usad\", core.dtype(\"uint32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def abs(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_abs\", core.dtype(\"int32\")),\n+                               (core.dtype(\"int64\"),): (\"__nv_llabs\", core.dtype(\"int64\")),\n+                               (core.dtype(\"fp32\"),): (\"__nv_fabsf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_fabs\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def floor(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_floorf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_floor\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def rcp64h(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_rcp64h\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def rsqrt(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_rsqrtf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_rsqrt\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ceil(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_ceil\", core.dtype(\"fp64\")),\n+                               (core.dtype(\"fp32\"),): (\"__nv_ceilf\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def trunc(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_trunc\", core.dtype(\"fp64\")),\n+                               (core.dtype(\"fp32\"),): (\"__nv_truncf\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def exp2(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_exp2f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_exp2\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def saturatef(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_saturatef\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmaf_rn(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmaf_rz(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmaf_rd(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmaf_ru(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmaf_ieee_rn(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_ieee_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmaf_ieee_rz(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_ieee_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmaf_ieee_rd(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_ieee_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmaf_ieee_ru(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_ieee_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fma_rn(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fma_rz(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rz\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fma_rd(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rd\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fma_ru(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_ru\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_fdividef(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fast_fdividef\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fdiv_rn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fdiv_rz(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fdiv_rd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fdiv_ru(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def frcp_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_frcp_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def frcp_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_frcp_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def frcp_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_frcp_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def frcp_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_frcp_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fsqrt_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fsqrt_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fsqrt_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fsqrt_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ddiv_rn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ddiv_rz(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rz\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ddiv_rd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rd\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ddiv_ru(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_ru\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def drcp_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_drcp_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def drcp_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_drcp_rz\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def drcp_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_drcp_rd\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def drcp_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_drcp_ru\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dsqrt_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_dsqrt_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dsqrt_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_dsqrt_rz\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dsqrt_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_dsqrt_rd\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dsqrt_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_dsqrt_ru\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def sqrt(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_sqrtf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_sqrt\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dadd_rn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dadd_rz(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rz\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dadd_rd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rd\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dadd_ru(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_ru\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dmul_rn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dmul_rz(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rz\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dmul_rd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rd\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dmul_ru(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_ru\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fadd_rd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fadd_ru(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmul_rd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmul_ru(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fadd_rn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fadd_rz(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmul_rn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmul_rz(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2float_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2float_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2float_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2float_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2float_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2float_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2float_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2float_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2int_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2int_rn\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2int_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2int_rz\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2int_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2int_rd\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2int_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2int_ru\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2uint_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rn\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2uint_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rz\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2uint_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rd\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2uint_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2uint_ru\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def int2double_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_int2double_rn\", core.dtype(\"fp64\")),\n+                               (core.dtype(\"uint32\"),): (\"__nv_uint2double_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2int_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2int_rn\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2int_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2int_rz\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2int_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2int_rd\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2int_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2int_ru\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2uint_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rn\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2uint_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rz\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2uint_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rd\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2uint_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2uint_ru\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def int2float_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_int2float_rn\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint32\"),): (\"__nv_uint2float_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def int2float_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_int2float_rz\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint32\"),): (\"__nv_uint2float_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def int2float_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_int2float_rd\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint32\"),): (\"__nv_uint2float_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def int2float_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_int2float_ru\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint32\"),): (\"__nv_uint2float_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def hiloint2double(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_hiloint2double\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2loint(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2loint\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2hiint(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2hiint\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2ll_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rn\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2ll_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rz\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2ll_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rd\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2ll_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2ll_ru\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2ull_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rn\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2ull_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rz\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2ull_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rd\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float2ull_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float2ull_ru\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2ll_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rn\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2ll_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rz\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2ll_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rd\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2ll_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2ll_ru\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2ull_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rn\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2ull_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rz\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2ull_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rd\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double2ull_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double2ull_ru\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ll2float_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_ll2float_rn\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint64\"),): (\"__nv_ull2float_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ll2float_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_ll2float_rz\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint64\"),): (\"__nv_ull2float_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ll2float_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_ll2float_rd\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint64\"),): (\"__nv_ull2float_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ll2float_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_ll2float_ru\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint64\"),): (\"__nv_ull2float_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ll2double_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_ll2double_rn\", core.dtype(\"fp64\")),\n+                               (core.dtype(\"uint64\"),): (\"__nv_ull2double_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ll2double_rz(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_ll2double_rz\", core.dtype(\"fp64\")),\n+                               (core.dtype(\"uint64\"),): (\"__nv_ull2double_rz\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ll2double_rd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_ll2double_rd\", core.dtype(\"fp64\")),\n+                               (core.dtype(\"uint64\"),): (\"__nv_ull2double_rd\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ll2double_ru(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_ll2double_ru\", core.dtype(\"fp64\")),\n+                               (core.dtype(\"uint64\"),): (\"__nv_ull2double_ru\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def int_as_float(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_int_as_float\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"uint32\"),): (\"__nv_uint_as_float\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float_as_int(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float_as_int\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def float_as_uint(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_float_as_uint\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def longlong_as_double(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int64\"),): (\"__nv_longlong_as_double\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def double_as_longlong(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_double_as_longlong\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_sinf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fast_sinf\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_cosf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fast_cosf\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_log2f(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fast_log2f\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_logf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fast_logf\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_expf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fast_expf\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_tanf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fast_tanf\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_exp10f(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fast_exp10f\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fast_log10f(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_fast_log10f\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def pow(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fast_powf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_powf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_pow\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def hadd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_hadd\", core.dtype(\"int32\")),\n+                               (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_uhadd\", core.dtype(\"uint32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def rhadd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_rhadd\", core.dtype(\"int32\")),\n+                               (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_urhadd\", core.dtype(\"uint32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fsub_rn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fsub_rz(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rz\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fsub_rd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rd\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fsub_ru(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_ru\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def frsqrt_rn(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_frsqrt_rn\", core.dtype(\"fp32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ffs(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"int32\"),): (\"__nv_ffs\", core.dtype(\"int32\")),\n+                               (core.dtype(\"int64\"),): (\"__nv_ffsll\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def rint(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_rintf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_rint\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def llrint(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_llrintf\", core.dtype(\"int64\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_llrint\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def nearbyint(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_nearbyintf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_nearbyint\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def isnanf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_isnanf\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def signbitf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_signbitf\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def copysign(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_copysignf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_copysign\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def finitef(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_finitef\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def isinff(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_isinff\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def nextafter(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_nextafterf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_nextafter\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def sin(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_sinf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_sin\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def cos(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_cosf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_cos\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def sinpi(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_sinpif\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_sinpi\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def cospi(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_cospif\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_cospi\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def tan(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_tanf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_tan\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def log2(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_log2f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_log2\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def exp(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_expf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_exp\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def exp10(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_exp10f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_exp10\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def cosh(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_coshf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_cosh\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def sinh(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_sinhf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_sinh\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def tanh(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_tanhf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_tanh\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def atan2(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_atan2f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_atan2\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def atan(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_atanf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_atan\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def asin(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_asinf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_asin\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def acos(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_acosf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_acos\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def log(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_logf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_log\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def log10(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_log10f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_log10\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def log1p(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_log1pf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_log1p\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def acosh(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_acoshf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_acosh\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def asinh(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_asinhf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_asinh\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def atanh(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_atanhf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_atanh\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def expm1(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_expm1f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_expm1\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def hypot(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_hypotf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_hypot\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def rhypot(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rhypotf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rhypot\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def norm3d(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_norm3df\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_norm3d\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def rnorm3d(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rnorm3df\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rnorm3d\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def norm4d(arg0, arg1, arg2, arg3, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, arg3, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_norm4df\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_norm4d\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def rnorm4d(arg0, arg1, arg2, arg3, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, arg3, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rnorm4df\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rnorm4d\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def cbrt(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_cbrtf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_cbrt\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def rcbrt(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_rcbrtf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_rcbrt\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def j0(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_j0f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_j0\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def j1(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_j1f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_j1\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def y0(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_y0f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_y0\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def y1(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_y1f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_y1\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def yn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"fp32\"),): (\"__nv_ynf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"int32\"), core.dtype(\"fp64\"),): (\"__nv_yn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def jn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"int32\"), core.dtype(\"fp32\"),): (\"__nv_jnf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"int32\"), core.dtype(\"fp64\"),): (\"__nv_jn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def cyl_bessel_i0(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_cyl_bessel_i0f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_cyl_bessel_i0\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def cyl_bessel_i1(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_cyl_bessel_i1f\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_cyl_bessel_i1\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def erf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_erff\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_erf\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def erfinv(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_erfinvf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_erfinv\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def erfc(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_erfcf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_erfc\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def erfcx(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_erfcxf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_erfcx\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def erfcinv(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_erfcinvf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_erfcinv\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def normcdfinv(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_normcdfinvf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_normcdfinv\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def normcdf(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_normcdff\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_normcdf\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def lgamma(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_lgammaf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_lgamma\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ldexp(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_ldexpf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"int32\"),): (\"__nv_ldexp\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def scalbn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_scalbnf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"int32\"),): (\"__nv_scalbn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fmod(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmodf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fmod\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def remainder(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_remainderf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_remainder\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fma(arg0, arg1, arg2, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def powi(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_powif\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"int32\"),): (\"__nv_powi\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def tgamma(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_tgammaf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_tgamma\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def round(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_roundf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_round\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def llround(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_llroundf\", core.dtype(\"int64\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_llround\", core.dtype(\"int64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def fdim(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdimf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fdim\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def ilogb(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_ilogbf\", core.dtype(\"int32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_ilogb\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def logb(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp32\"),): (\"__nv_logbf\", core.dtype(\"fp32\")),\n+                               (core.dtype(\"fp64\"),): (\"__nv_logb\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def signbitd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_signbitd\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def isfinited(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_isfinited\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def isinfd(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_isinfd\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def isnand(arg0, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n+                              {(core.dtype(\"fp64\"),): (\"__nv_isnand\", core.dtype(\"int32\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dsub_rn(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rn\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dsub_rz(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rz\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dsub_ru(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_ru\", core.dtype(\"fp64\")),\n+                               }, _builder)\n+\n+\n+@extern.extern\n+def dsub_rd(arg0, arg1, _builder=None):\n+    return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n+                              {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rd\", core.dtype(\"fp64\")),\n+                               }, _builder)"}, {"filename": "python/triton/tools/build_extern.py", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "file_content_changes": "@@ -0,0 +1,340 @@\n+import argparse\n+import subprocess\n+from abc import ABC, abstractmethod\n+\n+\n+class Symbol:\n+    def __init__(self, name: str, op_name: str, ret_type: str, arg_names: list, arg_types: list) -> None:\n+        '''\n+        A symbol is a function declaration.\n+\n+        :param name: name of the symbol\n+        :param op_name: name of the operation\n+        :param ret_type: return type of the operation\n+        :param arg_names: names of the arguments\n+        :param arg_types: types of the arguments\n+        '''\n+        self._name = name\n+        self._op_name = op_name\n+        self._ret_type = ret_type\n+        self._arg_names = arg_names\n+        self._arg_types = arg_types\n+\n+    @property\n+    def name(self):\n+        return self._name\n+\n+    @property\n+    def op_name(self):\n+        return self._op_name\n+\n+    @property\n+    def ret_type(self):\n+        return self._ret_type\n+\n+    @property\n+    def arg_names(self):\n+        return self._arg_names\n+\n+    @property\n+    def arg_types(self):\n+        return self._arg_types\n+\n+\n+def convert_type(type_str):\n+    if type_str == \"i32\":\n+        return \"int32\"\n+    elif type_str == \"u32\":\n+        return \"uint32\"\n+    elif type_str == \"i64\":\n+        return \"int64\"\n+    elif type_str == \"u64\":\n+        return \"uint64\"\n+    elif type_str == \"float\":\n+        return \"fp32\"\n+    elif type_str == \"double\":\n+        return \"fp64\"\n+    else:\n+        # ignore other types, such as pointer types\n+        return None\n+\n+\n+def to_unsigned(type_str):\n+    if type_str == \"int32\":\n+        return \"uint32\"\n+    elif type_str == \"int64\":\n+        return \"uint64\"\n+    else:\n+        return type_str\n+\n+\n+class ExternLibrary(ABC):\n+    def __init__(self, name: str, path: str, format: bool = True, grouping: bool = True) -> None:\n+        '''\n+        Abstract class for extern library.\n+\n+        :param name: name of the library\n+        :param path: path of the library\n+        :param format: whether to format the generated stub file\n+        '''\n+        self._name = name\n+        self._path = path\n+        self._symbols = {}\n+        self._format = True\n+        self._grouping = grouping\n+\n+    @property\n+    def name(self):\n+        return self._name\n+\n+    @property\n+    def path(self):\n+        return self._path\n+\n+    @property\n+    def symbols(self):\n+        return self._symbols\n+\n+    @property\n+    def grouping(self):\n+        return self._grouping\n+\n+    @abstractmethod\n+    def parse_symbols(self, input_file):\n+        pass\n+\n+    @abstractmethod\n+    def _output_stubs(self) -> str:\n+        pass\n+\n+    def generate_stub_file(self, output_dir):\n+        file_str = self._output_stubs()\n+        if file_str is None or len(file_str) == 0:\n+            raise Exception(\"file_str is empty\")\n+\n+        output_file = f\"{output_dir}/{self._name}.py\"\n+        with open(output_file, \"w\") as f:\n+            f.write(file_str)\n+            f.close()\n+            if self._format:\n+                subprocess.Popen([\"autopep8\", \"-a\", \"-r\", \"-i\", output_file],\n+                                 stdout=subprocess.PIPE).communicate()\n+                subprocess.Popen([\"isort\", output_file], stdout=subprocess.PIPE).communicate()\n+\n+\n+class Libdevice(ExternLibrary):\n+    def __init__(self, path) -> None:\n+        '''\n+        Constructor for Libdevice.\n+\n+        :param path: path of the libdevice library\n+        '''\n+        super().__init__(\"libdevice\", path)\n+        self._symbol_groups = {}\n+\n+    def _extract_symbol(self, line):\n+        # Extract symbols from line in the following format:\n+        # \"define [internal] <ret_type> @<name>(<arg_types>,)\"\n+        entries = line.split(\"@\")\n+        ret_str = entries[0]\n+        func_str = entries[1]\n+        # Get ret_type, skip internal symbols\n+        ret_strs = ret_str.split()\n+        if ret_strs[1] == \"internal\":\n+            return None\n+        ret_type = convert_type(ret_strs[1])\n+        if ret_type is None:\n+            return None\n+        # Get function name\n+        func_strs = func_str.split(\"(\")\n+        func_name = func_strs[0].replace(\"@\", \"\")\n+        op_name = func_name.replace(\"__nv_\", \"\")\n+        # Get arg_types\n+        arg_strs = func_strs[1].split(\",\")\n+        arg_types = []\n+        arg_names = []\n+        for i, arg_str in enumerate(arg_strs):\n+            arg_type = convert_type(arg_str.split()[0])\n+            if arg_type is None:\n+                return None\n+            arg_name = 'arg' + str(i)\n+            arg_types.append(arg_type)\n+            arg_names.append(arg_name)\n+        if op_name == \"sad\":\n+            # Special case for sad, where the last argument is an unsigned int\n+            arg_types[-1] = to_unsigned(arg_types[-1])\n+        elif op_name.startswith(\"u\"):\n+            # LLVM does not differentiate between signed and unsigned integer type.\n+            # We have to convert the types to unsigned\n+            ret_type = to_unsigned(ret_type)\n+            for i, arg_type in enumerate(arg_types):\n+                arg_types[i] = to_unsigned(arg_type)\n+        return Symbol(func_name, op_name, ret_type, arg_names, arg_types)\n+\n+    def _group_symbols(self):\n+        symbol_set = {}\n+        for symbol in self._symbols.values():\n+            op_name = symbol.op_name\n+            symbol_set[op_name] = symbol\n+        # The following cases are grouped together:\n+        # op_name, <u/ull/ll>op_name<ll/f/i>\n+        for symbol in self._symbols.values():\n+            op_name = symbol.op_name\n+            if \"max\" in op_name:\n+                op_name = \"max\"\n+            elif \"min\" in op_name:\n+                op_name = \"min\"\n+            elif \"abs\" in op_name:\n+                op_name = \"abs\"\n+            elif \"pow\" in op_name and \"fast\" in op_name:\n+                op_name = \"pow\"\n+            elif \"round\" in op_name:\n+                if \"llround\" in op_name:\n+                    op_name = \"llround\"\n+                else:\n+                    op_name = \"round\"\n+            elif \"rint\" in op_name:\n+                if \"llrint\" in op_name:\n+                    op_name = \"llrint\"\n+                else:\n+                    op_name = \"rint\"\n+            elif op_name.startswith(\"ull\"):\n+                if \"2\" not in op_name:\n+                    # e.g., ullmax->max\n+                    op_name = op_name[3:]\n+                else:\n+                    # e.g., ull2double->ll2double\n+                    op_name = op_name[1:]\n+            elif op_name.startswith(\"u\"):\n+                if \"2\" not in op_name:\n+                    # e.g., uhadd->hadd\n+                    op_name = op_name[1:]\n+                else:\n+                    # e.g., uint2double_rn->int2double_rn\n+                    op_name = op_name[1:]\n+            elif op_name.startswith(\"ll\"):\n+                if \"2\" not in op_name:\n+                    # e.g., llmax->max\n+                    op_name = op_name[2:]\n+            elif op_name.endswith(\"ll\"):\n+                op_name = op_name[:-2]\n+            elif op_name.endswith(\"f\"):\n+                op_name = op_name[:-1]\n+            if op_name in symbol_set:\n+                # Update op_name only if there's an existing symbol\n+                symbol._op_name = op_name\n+            else:\n+                op_name = symbol._op_name\n+            if op_name in self._symbol_groups:\n+                self._symbol_groups[op_name].append(symbol)\n+            else:\n+                self._symbol_groups[op_name] = [symbol]\n+\n+    def parse_symbols(self, input_file):\n+        if len(self.symbols) > 0:\n+            return\n+        output = subprocess.check_output([\"grep\", \"define\", input_file]).decode().splitlines()\n+        for line in output:\n+            symbol = self._extract_symbol(line)\n+            if symbol is None:\n+                continue\n+            self._symbols[symbol.name] = symbol\n+\n+        self._group_symbols()\n+\n+    def _output_stubs(self):\n+        # Generate python functions in the following format:\n+        # @extern.extern\n+        # def <op_name>(<args>, _builder=None):\n+        #   arg_type_symbol_dict = {[arg_type]: {(symbol, ret_type)}}\n+        #   return extern.dispatch(\"libdevice\", <path>, <args>, <arg_type_symbol_dict>, _builder)\n+        import_str = \"from . import core, extern\\n\"\n+        import_str += \"import os\\n\"\n+        header_str = \"LIBDEVICE_PATH = os.path.dirname(os.path.abspath(__file__)) + \\\"/libdevice.10.bc\\\"\\n\"\n+        func_str = \"\"\n+        for symbols in self._symbol_groups.values():\n+            func_str += \"@extern.extern\\n\"\n+            func_name_str = f\"def {symbols[0].op_name}(\"\n+            for arg_name in symbols[0].arg_names:\n+                func_name_str += f\"{arg_name}, \"\n+            func_name_str += \"_builder=None):\\n\"\n+\n+            return_str = f\"\\treturn extern.elementwise(\\\"{self._name}\\\", LIBDEVICE_PATH, [\"\n+            for arg_name in symbols[0].arg_names:\n+                return_str += f\"{arg_name}, \"\n+            return_str += \"], \\n\"\n+\n+            arg_type_symbol_dict_str = \"{\"\n+            for symbol in symbols:\n+                arg_type_symbol_dict_str += \"(\"\n+                for arg_type in symbol.arg_types:\n+                    arg_type_symbol_dict_str += f\"core.dtype(\\\"{arg_type}\\\"),\"\n+                ret_type = f\"core.dtype(\\\"{symbol.ret_type}\\\")\"\n+                arg_type_symbol_dict_str += \"): (\\\"\" + symbol.name + \"\\\", \" + ret_type + \"),\\n\"\n+            arg_type_symbol_dict_str += \"}\"\n+\n+            return_str += arg_type_symbol_dict_str\n+            return_str += \", _builder)\\n\"\n+\n+            func_str += func_name_str + return_str + \"\\n\"\n+        file_str = import_str + header_str + func_str\n+\n+        return file_str\n+\n+\n+class LLVMDisassembler:\n+    def __init__(self, path):\n+        '''\n+        Invoke llvm-dis to disassemble the given file.\n+\n+        :param path: path to llvm-dis\n+        '''\n+        self._path = path\n+        self._ll_file = \"/tmp/extern_lib.ll\"\n+\n+    def disasm(self, lib_path):\n+        subprocess.Popen([self._path, lib_path, \"-o\", self.ll_file],\n+                         stdout=subprocess.PIPE).communicate()\n+\n+    @property\n+    def ll_file(self):\n+        return self._ll_file\n+\n+    @property\n+    def path(self):\n+        return self._path\n+\n+\n+extern_libs = [\"libdevice\"]\n+\n+\n+def build(llvm_dis_path, lib_path, lib_name, output_dir):\n+    '''\n+      Interface function to build the library file.\n+\n+      :param llvm_dis_path: path to the llvm-dis binary\n+      :param lib_path: path to the external library file\n+      :param lib_name: name of the library\n+      :param output_dir: path to the output directory\n+    '''\n+    if lib_name == \"libdevice\":\n+        extern_lib = Libdevice(lib_path)\n+    else:\n+        raise Exception(f\"Unknown extern library: {lib_name}\")\n+\n+    llvm_disassembler = LLVMDisassembler(llvm_dis_path)\n+    llvm_disassembler.disasm(lib_path)\n+\n+    extern_lib.parse_symbols(llvm_disassembler.ll_file)\n+    extern_lib.generate_stub_file(output_dir)\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"-llvm\", dest=\"llvm_dis_path\", help=\"path to llvm-dis\", default=\"llvm-dis\")\n+    parser.add_argument(\"--lib-path\", dest=\"lib_path\", help=\"path to the extern library\")\n+    parser.add_argument(\"--lib-name\", dest=\"lib_name\", help=\"name of the extern library\")\n+    parser.add_argument(\"-o\", dest=\"output_dir\", help=\"output file path\", default=\"/tmp/\")\n+    args = parser.parse_args()\n+\n+    build(args.llvm_dis_path, args.lib_path, args.lib_name, args.output_dir)"}, {"filename": "python/tutorials/07-libdevice-function.py", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "file_content_changes": "@@ -0,0 +1,74 @@\n+\"\"\"\n+Libdevice function\n+===============\n+Triton can invoke a custom function from an external library.\n+In this example, we will use the `libdevice` library to apply `asin` on a tensor.\n+Please refer to https://docs.nvidia.com/cuda/libdevice-users-guide/index.html regarding the semantics of all available libdevice functions.\n+\n+In `trition/language/libdevice.py`, we try to aggregate functions with the same computation but different data types together.\n+For example, both `__nv_asin` and `__nvasinf` calculate the principal value of the arc sine of the input, but `__nv_asin` operates on `double` and `__nv_asinf` operates on `float`.\n+Using triton, you can simply call `tl.libdevice.asinf`.\n+triton automatically selects the correct underlying device function to invoke based on input and output types.\n+\"\"\"\n+\n+# %%\n+#  asin Kernel\n+# --------------------------\n+\n+import torch\n+\n+import triton\n+import triton.language as tl\n+\n+\n+@triton.jit\n+def asin_kernel(\n+    x_ptr,\n+    y_ptr,\n+    n_elements,\n+    BLOCK_SIZE: tl.constexpr,\n+):\n+    pid = tl.program_id(axis=0)\n+    block_start = pid * BLOCK_SIZE\n+    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n+    mask = offsets < n_elements\n+    x = tl.load(x_ptr + offsets, mask=mask)\n+    x = tl.libdevice.asin(x)\n+    tl.store(y_ptr + offsets, x, mask=mask)\n+\n+# %%\n+#  Using the default libdevice library path\n+# --------------------------\n+# We can use the default libdevice library path encoded in `triton/language/libdevice.py`\n+\n+\n+torch.manual_seed(0)\n+size = 98432\n+x = torch.rand(size, device='cuda')\n+output_triton = torch.zeros(size, device='cuda')\n+output_torch = torch.asin(x)\n+assert x.is_cuda and output_triton.is_cuda\n+n_elements = output_torch.numel()\n+grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n+asin_kernel[grid](x, output_triton, n_elements, BLOCK_SIZE=1024)\n+print(output_torch)\n+print(output_triton)\n+print(\n+    f'The maximum difference between torch and triton is '\n+    f'{torch.max(torch.abs(output_torch - output_triton))}'\n+)\n+\n+# %%\n+#  Customize the libdevice library path\n+# --------------------------\n+# We can also customize the libdevice library path by passing the path to the `libdevice` library to the `asin` kernel.\n+\n+output_triton = torch.empty_like(x)\n+asin_kernel[grid](x, output_triton, n_elements, BLOCK_SIZE=1024,\n+                  extern_libs={'libdevice': '/usr/local/cuda/nvvm/libdevice/libdevice.10.bc'})\n+print(output_torch)\n+print(output_triton)\n+print(\n+    f'The maximum difference between torch and triton is '\n+    f'{torch.max(torch.abs(output_torch - output_triton))}'\n+)"}]