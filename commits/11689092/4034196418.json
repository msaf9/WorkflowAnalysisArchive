[{"filename": "include/triton/Conversion/MLIRTypes.h", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "file_content_changes": "@@ -1,5 +1,5 @@\n-#ifndef TRITON_CONVERSION_MLIR_TYPES_H_\n-#define TRITON_CONVERSION_MLIR_TYPES_H_\n+#ifndef TRITON_CONVERSION_MLIR_TYPES_H\n+#define TRITON_CONVERSION_MLIR_TYPES_H\n \n #include \"mlir/Transforms/DialectConversion.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n@@ -10,31 +10,30 @@ namespace triton {\n namespace type {\n \n // Integer types\n-// TODO(Superjomn): may change `static` into better implementations\n-static Type i32Ty(MLIRContext *ctx) { return IntegerType::get(ctx, 32); }\n-static Type i16Ty(MLIRContext *ctx) { return IntegerType::get(ctx, 16); }\n-static Type i8Ty(MLIRContext *ctx) { return IntegerType::get(ctx, 8); }\n-static Type u32Ty(MLIRContext *ctx) {\n+inline Type i32Ty(MLIRContext *ctx) { return IntegerType::get(ctx, 32); }\n+inline Type i16Ty(MLIRContext *ctx) { return IntegerType::get(ctx, 16); }\n+inline Type i8Ty(MLIRContext *ctx) { return IntegerType::get(ctx, 8); }\n+inline Type u32Ty(MLIRContext *ctx) {\n   return IntegerType::get(ctx, 32, IntegerType::Unsigned);\n }\n-static Type u1Ty(MLIRContext *ctx) {\n+inline Type u1Ty(MLIRContext *ctx) {\n   return IntegerType::get(ctx, 1, IntegerType::Unsigned);\n }\n \n // Float types\n-static Type f16Ty(MLIRContext *ctx) { return FloatType::getF16(ctx); }\n-static Type f32Ty(MLIRContext *ctx) { return FloatType::getF32(ctx); }\n-static Type f64Ty(MLIRContext *ctx) { return FloatType::getF64(ctx); }\n-static Type bf16Ty(MLIRContext *ctx) { return FloatType::getBF16(ctx); }\n+inline Type f16Ty(MLIRContext *ctx) { return FloatType::getF16(ctx); }\n+inline Type f32Ty(MLIRContext *ctx) { return FloatType::getF32(ctx); }\n+inline Type f64Ty(MLIRContext *ctx) { return FloatType::getF64(ctx); }\n+inline Type bf16Ty(MLIRContext *ctx) { return FloatType::getBF16(ctx); }\n \n-static bool isFloat(Type type) {\n+inline bool isFloat(Type type) {\n   return type.isF32() || type.isF64() || type.isF16() || type.isF128();\n }\n \n-static bool isInt(Type type) { return type.isIntOrFloat() && !isFloat(type); }\n+inline bool isInt(Type type) { return type.isIntOrFloat() && !isFloat(type); }\n \n } // namespace type\n } // namespace triton\n } // namespace mlir\n \n-#endif // TRITON_CONVERSION_MLIR_TYPES_H_\n+#endif // TRITON_CONVERSION_MLIR_TYPES_H"}, {"filename": "lib/Conversion/TritonGPUToLLVM/CMakeLists.txt", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "file_content_changes": "@@ -1,13 +1,14 @@\n add_mlir_conversion_library(TritonGPUToLLVM\n-    TritonGPUToLLVM.cpp\n-    TritonGPUToLLVMPass.cpp\n-    PTXAsmFormat.cpp\n     ConvertLayoutOpToLLVM.cpp\n+    DotOpToLLVM.cpp\n     ElementwiseOpToLLVM.cpp\n-    ViewOpToLLVM.cpp\n     LoadStoreOpToLLVM.cpp\n-    DotOpToLLVM.cpp\n+    TritonGPUToLLVM.cpp\n+    TritonGPUToLLVMPass.cpp\n+    PTXAsmFormat.cpp\n     ReduceOpToLLVM.cpp\n+    Utility.cpp\n+    ViewOpToLLVM.cpp\n \n     ADDITIONAL_HEADER_DIRS\n     ${PROJECT_SOURCE_DIR}/include/triton/Conversion/TritonGPUToLLVM"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -70,7 +70,6 @@ struct BroadcastOpConversion\n     auto resultOffsets = emitOffsetForLayout(resultLayout, resultShape);\n     SmallVector<Value> srcVals = getElementsFromStruct(loc, src, rewriter);\n     if (auto srcMma = srcLayout.dyn_cast<MmaEncodingAttr>()) {\n-\n       // NOTE: This is just an naive fix, but for MMA layout, and 2-d fix should\n       // be all right.\n       // TODO[Superjomn]: Replace this with a generic implementation."}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.cpp", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "file_content_changes": "@@ -0,0 +1,140 @@\n+#include \"Utility.h\"\n+\n+namespace mlir {\n+\n+namespace LLVM {\n+using namespace mlir::triton;\n+\n+Value getStructFromElements(Location loc, ValueRange resultVals,\n+                            ConversionPatternRewriter &rewriter,\n+                            Type structType) {\n+  if (!structType.isa<LLVM::LLVMStructType>()) {\n+    return *resultVals.begin();\n+  }\n+\n+  Value llvmStruct = rewriter.create<LLVM::UndefOp>(loc, structType);\n+  for (const auto &v : llvm::enumerate(resultVals)) {\n+    assert(v.value() && \"can not insert null values\");\n+    llvmStruct = insert_val(structType, llvmStruct, v.value(),\n+                            rewriter.getI64ArrayAttr(v.index()));\n+  }\n+  return llvmStruct;\n+}\n+\n+SmallVector<Value> getElementsFromStruct(Location loc, Value llvmStruct,\n+                                         ConversionPatternRewriter &rewriter) {\n+  if (llvmStruct.getType().isIntOrIndexOrFloat() ||\n+      llvmStruct.getType().isa<triton::PointerType>() ||\n+      llvmStruct.getType().isa<LLVM::LLVMPointerType>())\n+    return {llvmStruct};\n+  ArrayRef<Type> types =\n+      llvmStruct.getType().cast<LLVM::LLVMStructType>().getBody();\n+  SmallVector<Value> results(types.size());\n+  for (unsigned i = 0; i < types.size(); ++i) {\n+    Type type = types[i];\n+    results[i] = extract_val(type, llvmStruct, i64_arr_attr(i));\n+  }\n+  return results;\n+}\n+\n+Value createConstantI32(Location loc, PatternRewriter &rewriter, int32_t v) {\n+  auto i32ty = rewriter.getIntegerType(32);\n+  return rewriter.create<LLVM::ConstantOp>(loc, i32ty,\n+                                           IntegerAttr::get(i32ty, v));\n+}\n+\n+Value createConstantF32(Location loc, PatternRewriter &rewriter, float v) {\n+  auto type = type::f32Ty(rewriter.getContext());\n+  return rewriter.create<LLVM::ConstantOp>(loc, type,\n+                                           rewriter.getF32FloatAttr(v));\n+}\n+\n+Value createConstantF64(Location loc, PatternRewriter &rewriter, float v) {\n+  auto type = type::f64Ty(rewriter.getContext());\n+  return rewriter.create<LLVM::ConstantOp>(loc, type,\n+                                           rewriter.getF64FloatAttr(v));\n+}\n+\n+// Create an index type constant.\n+Value createIndexConstant(OpBuilder &builder, Location loc,\n+                          TypeConverter *converter, int64_t value) {\n+  Type ty = converter->convertType(builder.getIndexType());\n+  return builder.create<LLVM::ConstantOp>(loc, ty,\n+                                          builder.getIntegerAttr(ty, value));\n+}\n+\n+// Create an integer constant of \\param width bits.\n+Value createLLVMIntegerConstant(OpBuilder &builder, Location loc, short width,\n+                                int64_t value) {\n+  Type ty = builder.getIntegerType(width);\n+  return builder.create<LLVM::ConstantOp>(loc, ty,\n+                                          builder.getIntegerAttr(ty, value));\n+}\n+\n+SharedMemoryObject\n+getSharedMemoryObjectFromStruct(Location loc, Value llvmStruct,\n+                                ConversionPatternRewriter &rewriter) {\n+  auto elems = getElementsFromStruct(loc, llvmStruct, rewriter);\n+  auto rank = (elems.size() - 1) / 2;\n+  return {/*base=*/elems[0],\n+          /*strides=*/{elems.begin() + 1, elems.begin() + 1 + rank},\n+          /*offsets=*/{elems.begin() + 1 + rank, elems.end()}};\n+}\n+\n+SmallVector<Value>\n+getStridesFromShapeAndOrder(ArrayRef<int64_t> shape, ArrayRef<unsigned> order,\n+                            Location loc, ConversionPatternRewriter &rewriter) {\n+  auto rank = shape.size();\n+  SmallVector<Value> strides(rank);\n+  int64_t stride = 1;\n+  for (auto idx : order) {\n+    strides[idx] = i32_val(stride);\n+    stride *= shape[idx];\n+  }\n+  return strides;\n+}\n+\n+Value storeShared(ConversionPatternRewriter &rewriter, Location loc, Value ptr,\n+                  Value val, Value pred) {\n+  MLIRContext *ctx = rewriter.getContext();\n+  unsigned bits = val.getType().getIntOrFloatBitWidth();\n+  const char *c = bits == 64 ? \"l\" : (bits == 16 ? \"h\" : \"r\");\n+\n+  PTXBuilder builder;\n+  auto *ptrOpr = builder.newAddrOperand(ptr, \"r\");\n+  auto *valOpr = builder.newOperand(val, c);\n+  auto &st = builder.create<>(\"st\")->shared().b(bits);\n+  st(ptrOpr, valOpr).predicate(pred, \"b\");\n+  return builder.launch(rewriter, loc, void_ty(ctx));\n+}\n+\n+Value shflSync(Location loc, ConversionPatternRewriter &rewriter, Value val,\n+               int i) {\n+  unsigned bits = val.getType().getIntOrFloatBitWidth();\n+\n+  if (bits == 64) {\n+    Type vecTy = vec_ty(f32_ty, 2);\n+    Value vec = bitcast(val, vecTy);\n+    Value val0 = extract_element(f32_ty, vec, i32_val(0));\n+    Value val1 = extract_element(f32_ty, vec, i32_val(1));\n+    val0 = shflSync(loc, rewriter, val0, i);\n+    val1 = shflSync(loc, rewriter, val1, i);\n+    vec = undef(vecTy);\n+    vec = insert_element(vecTy, vec, val0, i32_val(0));\n+    vec = insert_element(vecTy, vec, val1, i32_val(1));\n+    return bitcast(vec, val.getType());\n+  }\n+\n+  PTXBuilder builder;\n+  auto &shfl = builder.create(\"shfl.sync\")->o(\"bfly\").o(\"b32\");\n+  auto *dOpr = builder.newOperand(\"=r\");\n+  auto *aOpr = builder.newOperand(val, \"r\");\n+  auto *bOpr = builder.newConstantOperand(i);\n+  auto *cOpr = builder.newConstantOperand(\"0x1f\");\n+  auto *maskOpr = builder.newConstantOperand(\"0xffffffff\");\n+  shfl(dOpr, aOpr, bOpr, cOpr, maskOpr);\n+  return builder.launch(rewriter, loc, val.getType(), false);\n+}\n+\n+} // namespace LLVM\n+} // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.h", "status": "modified", "additions": 28, "deletions": 129, "changes": 157, "file_content_changes": "@@ -137,8 +137,7 @@ llvm::SmallVector<T> getMultiDimIndex(T linearIndex, llvm::ArrayRef<T> shape,\n \n // Linearize supposing order is [0, 1, .. , n]\n template <typename T>\n-static T getLinearIndexImpl(llvm::ArrayRef<T> multiDimIndex,\n-                            llvm::ArrayRef<T> shape) {\n+T getLinearIndexImpl(llvm::ArrayRef<T> multiDimIndex, llvm::ArrayRef<T> shape) {\n   assert(multiDimIndex.size() == shape.size());\n   // shape: {a, b, c, d}  ->  accMul: {1, a, a*b, a*b*c}\n   size_t rank = shape.size();\n@@ -154,9 +153,8 @@ static T getLinearIndexImpl(llvm::ArrayRef<T> multiDimIndex,\n }\n \n template <typename T>\n-static T getLinearIndex(llvm::ArrayRef<T> multiDimIndex,\n-                        llvm::ArrayRef<T> shape,\n-                        llvm::ArrayRef<unsigned> order) {\n+T getLinearIndex(llvm::ArrayRef<T> multiDimIndex, llvm::ArrayRef<T> shape,\n+                 llvm::ArrayRef<unsigned> order) {\n   assert(shape.size() == order.size());\n   return getLinearIndexImpl<T>(reorder(multiDimIndex, order),\n                                reorder(shape, order));\n@@ -167,91 +165,34 @@ static T getLinearIndex(llvm::ArrayRef<T> multiDimIndex,\n namespace LLVM {\n using namespace mlir::triton;\n \n-static Value getStructFromElements(Location loc, ValueRange resultVals,\n-                                   ConversionPatternRewriter &rewriter,\n-                                   Type structType) {\n-  if (!structType.isa<LLVM::LLVMStructType>()) {\n-    return *resultVals.begin();\n-  }\n+Value getStructFromElements(Location loc, ValueRange resultVals,\n+                            ConversionPatternRewriter &rewriter,\n+                            Type structType);\n \n-  Value llvmStruct = rewriter.create<LLVM::UndefOp>(loc, structType);\n-  for (const auto &v : llvm::enumerate(resultVals)) {\n-    assert(v.value() && \"can not insert null values\");\n-    llvmStruct = insert_val(structType, llvmStruct, v.value(),\n-                            rewriter.getI64ArrayAttr(v.index()));\n-  }\n-  return llvmStruct;\n-}\n+SmallVector<Value> getElementsFromStruct(Location loc, Value llvmStruct,\n+                                         ConversionPatternRewriter &rewriter);\n \n-static SmallVector<Value>\n-getElementsFromStruct(Location loc, Value llvmStruct,\n-                      ConversionPatternRewriter &rewriter) {\n-  if (llvmStruct.getType().isIntOrIndexOrFloat() ||\n-      llvmStruct.getType().isa<triton::PointerType>() ||\n-      llvmStruct.getType().isa<LLVM::LLVMPointerType>())\n-    return {llvmStruct};\n-  ArrayRef<Type> types =\n-      llvmStruct.getType().cast<LLVM::LLVMStructType>().getBody();\n-  SmallVector<Value> results(types.size());\n-  for (unsigned i = 0; i < types.size(); ++i) {\n-    Type type = types[i];\n-    results[i] = extract_val(type, llvmStruct, i64_arr_attr(i));\n-  }\n-  return results;\n-}\n+/// Create a 32-bit integer constant.\n+Value createConstantI32(Location loc, PatternRewriter &rewriter, int32_t v);\n \n-// Create a 32-bit integer constant.\n-static Value createConstantI32(Location loc, PatternRewriter &rewriter,\n-                               int32_t v) {\n-  auto i32ty = rewriter.getIntegerType(32);\n-  return rewriter.create<LLVM::ConstantOp>(loc, i32ty,\n-                                           IntegerAttr::get(i32ty, v));\n-}\n+/// Create a 32-bit float constant.\n+Value createConstantF32(Location loc, PatternRewriter &rewriter, float v);\n \n-static Value createConstantF32(Location loc, PatternRewriter &rewriter,\n-                               float v) {\n-  auto type = type::f32Ty(rewriter.getContext());\n-  return rewriter.create<LLVM::ConstantOp>(loc, type,\n-                                           rewriter.getF32FloatAttr(v));\n-}\n+/// Create a 64-bit float constant.\n+Value createConstantF64(Location loc, PatternRewriter &rewriter, float v);\n \n-static Value createConstantF64(Location loc, PatternRewriter &rewriter,\n-                               float v) {\n-  auto type = type::f64Ty(rewriter.getContext());\n-  return rewriter.create<LLVM::ConstantOp>(loc, type,\n-                                           rewriter.getF64FloatAttr(v));\n-}\n+/// Create an index type constant.\n+Value createIndexConstant(OpBuilder &builder, Location loc,\n+                          TypeConverter *converter, int64_t value);\n \n-// Create an index type constant.\n-static Value createIndexConstant(OpBuilder &builder, Location loc,\n-                                 TypeConverter *converter, int64_t value) {\n-  Type ty = converter->convertType(builder.getIndexType());\n-  return builder.create<LLVM::ConstantOp>(loc, ty,\n-                                          builder.getIntegerAttr(ty, value));\n-}\n-\n-// Create an integer constant of \\param width bits.\n-static Value createLLVMIntegerConstant(OpBuilder &builder, Location loc,\n-                                       short width, int64_t value) {\n-  Type ty = builder.getIntegerType(width);\n-  return builder.create<LLVM::ConstantOp>(loc, ty,\n-                                          builder.getIntegerAttr(ty, value));\n-}\n+/// Create an integer constant of \\param width bits.\n+Value createLLVMIntegerConstant(OpBuilder &builder, Location loc, short width,\n+                                int64_t value);\n \n /// Helper function to get strides from a given shape and its order\n-static SmallVector<Value>\n+SmallVector<Value>\n getStridesFromShapeAndOrder(ArrayRef<int64_t> shape, ArrayRef<unsigned> order,\n-                            Location loc, ConversionPatternRewriter &rewriter) {\n-  auto rank = shape.size();\n-  SmallVector<Value> strides(rank);\n-  int64_t stride = 1;\n-  for (auto idx : order) {\n-    strides[idx] = i32_val(stride);\n-    stride *= shape[idx];\n-  }\n-  return strides;\n-}\n-\n+                            Location loc, ConversionPatternRewriter &rewriter);\n struct SharedMemoryObject {\n   Value base; // i32 ptr. The start address of the shared memory object.\n   // We need to store strides as Values but not integers because the\n@@ -315,57 +256,15 @@ struct SharedMemoryObject {\n   }\n };\n \n-static SharedMemoryObject\n+SharedMemoryObject\n getSharedMemoryObjectFromStruct(Location loc, Value llvmStruct,\n-                                ConversionPatternRewriter &rewriter) {\n-  auto elems = getElementsFromStruct(loc, llvmStruct, rewriter);\n-  auto rank = (elems.size() - 1) / 2;\n-  return {/*base=*/elems[0],\n-          /*strides=*/{elems.begin() + 1, elems.begin() + 1 + rank},\n-          /*offsets=*/{elems.begin() + 1 + rank, elems.end()}};\n-}\n+                                ConversionPatternRewriter &rewriter);\n \n-static Value storeShared(ConversionPatternRewriter &rewriter, Location loc,\n-                         Value ptr, Value val, Value pred) {\n-  MLIRContext *ctx = rewriter.getContext();\n-  unsigned bits = val.getType().getIntOrFloatBitWidth();\n-  const char *c = bits == 64 ? \"l\" : (bits == 16 ? \"h\" : \"r\");\n-\n-  PTXBuilder builder;\n-  auto *ptrOpr = builder.newAddrOperand(ptr, \"r\");\n-  auto *valOpr = builder.newOperand(val, c);\n-  auto &st = builder.create<>(\"st\")->shared().b(bits);\n-  st(ptrOpr, valOpr).predicate(pred, \"b\");\n-  return builder.launch(rewriter, loc, void_ty(ctx));\n-}\n-\n-static Value shflSync(Location loc, ConversionPatternRewriter &rewriter,\n-                      Value val, int i) {\n-  unsigned bits = val.getType().getIntOrFloatBitWidth();\n-\n-  if (bits == 64) {\n-    Type vecTy = vec_ty(f32_ty, 2);\n-    Value vec = bitcast(val, vecTy);\n-    Value val0 = extract_element(f32_ty, vec, i32_val(0));\n-    Value val1 = extract_element(f32_ty, vec, i32_val(1));\n-    val0 = shflSync(loc, rewriter, val0, i);\n-    val1 = shflSync(loc, rewriter, val1, i);\n-    vec = undef(vecTy);\n-    vec = insert_element(vecTy, vec, val0, i32_val(0));\n-    vec = insert_element(vecTy, vec, val1, i32_val(1));\n-    return bitcast(vec, val.getType());\n-  }\n+Value storeShared(ConversionPatternRewriter &rewriter, Location loc, Value ptr,\n+                  Value val, Value pred);\n \n-  PTXBuilder builder;\n-  auto &shfl = builder.create(\"shfl.sync\")->o(\"bfly\").o(\"b32\");\n-  auto *dOpr = builder.newOperand(\"=r\");\n-  auto *aOpr = builder.newOperand(val, \"r\");\n-  auto *bOpr = builder.newConstantOperand(i);\n-  auto *cOpr = builder.newConstantOperand(\"0x1f\");\n-  auto *maskOpr = builder.newConstantOperand(\"0xffffffff\");\n-  shfl(dOpr, aOpr, bOpr, cOpr, maskOpr);\n-  return builder.launch(rewriter, loc, val.getType(), false);\n-}\n+Value shflSync(Location loc, ConversionPatternRewriter &rewriter, Value val,\n+               int i);\n \n } // namespace LLVM\n } // namespace mlir"}]