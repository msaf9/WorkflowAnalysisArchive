[{"filename": "include/triton/codegen/analysis/layout.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -224,6 +224,7 @@ struct scanline_layout: public distributed_layout {\n   int nts(size_t k) { return nts_.at(k); }\n   int contig_per_thread(size_t k) { return nts_.at(k); }\n \n+  int per_thread(size_t k) { return nts(k) * shape_[k] / shape_per_cta(k);}\n public:\n   // micro tile size. The size of a tile held by a thread block.\n   std::vector<int> mts_;"}, {"filename": "include/triton/codegen/selection/generator.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "file_content_changes": "@@ -24,6 +24,7 @@ namespace llvm{\n   class IRBuilder;\n   class ArrayType;\n   class Function;\n+  class StructType;\n }\n \n namespace triton{\n@@ -114,6 +115,8 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n private:\n   Type *cvt(ir::type *ty);\n   llvm::Attribute cvt(ir::attribute attr);\n+  llvm::StructType* packed_type(ir::value* i);\n+  void forward_declare(ir::function* fn);\n \n public:\n   generator(analysis::axes *a_axes,\n@@ -125,6 +128,8 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n             unsigned num_warps);\n \n   void visit_value(ir::value* v);\n+  void visit_call_inst(ir::call_inst*);\n+  void visit_launch_inst(ir::launch_inst *);\n   void visit_phi_node(ir::phi_node*);\n   void visit_binary_operator(ir::binary_operator*);\n   void visit_getelementptr_inst(ir::getelementptr_inst*);\n@@ -148,6 +153,8 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   void visit_unmasked_store_inst(ir::unmasked_store_inst*);\n   void visit_masked_store_inst(ir::masked_store_inst*);\n   void visit_cat_inst(ir::cat_inst*);\n+  void visit_extract_value_inst(ir::extract_value_inst *);\n+  void visit_insert_value_inst(ir::insert_value_inst *);\n   void visit_reshape_inst(ir::reshape_inst*);\n   void visit_splat_inst(ir::splat_inst*);\n   void visit_broadcast_inst(ir::broadcast_inst*);\n@@ -242,6 +249,7 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   /// triton bb -> llvm bb\n   std::map<ir::value*, BasicBlock *> bbs_;\n   std::map<ir::value*, std::vector<int>> ords_;\n+  std::map<ir::value*, Function*> fns_;\n \n   // helper for creating llvm values\n   adder add;"}, {"filename": "include/triton/codegen/transform/inline.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "file_content_changes": "@@ -0,0 +1,31 @@\n+#pragma once\n+\n+#include <list>\n+\n+namespace triton {\n+\n+namespace ir {\n+  class module;\n+  class function;\n+  class call_inst;\n+  class builder;\n+}\n+\n+namespace codegen{\n+namespace transform{\n+\n+struct fncmp {\n+  bool operator()(ir::function* x, ir::function* y) const;\n+};\n+\n+class inliner {\n+public:\n+  inliner() {}\n+  void do_inline(ir::function* fn, ir::call_inst* callsite, ir::builder& builder, std::list<ir::call_inst*>& callsites);\n+  void run(ir::module &mod);\n+};\n+\n+\n+}\n+}\n+}"}, {"filename": "include/triton/codegen/transform/peephole.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -30,6 +30,9 @@ class peephole {\n   bool rewrite_dot_hmma(ir::dot_inst *dot, ir::builder& builder, bool trans_a, bool trans_b, ir::value *A, ir::value *B, ir::value *D);\n   bool rewrite_dot(ir::instruction *value, ir::builder& builder);\n   bool rewrite_mult(ir::instruction *value, ir::builder& builder);\n+  bool rewrite_insert_extract(ir::instruction *value, ir::builder& builder);\n+\n+\n   bool rewrite_unit_red(ir::instruction *value, ir::builder& builder);\n   bool rewrite_gep_ptr_min_off_plus_off(ir::instruction *value, ir::builder& builder);\n   bool rewrite_select_masked_load(ir::instruction *value, ir::builder& builder);"}, {"filename": "include/triton/driver/dispatch.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -89,6 +89,7 @@ class dispatch\n   static CUresult cuDeviceGetAttribute(int *pi, CUdevice_attribute attrib, CUdevice dev);\n   static CUresult cuDeviceGetCount(int *count);\n   // link management\n+  static CUresult cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char *path, unsigned int numOptions, CUjit_option *options, void **optionValues);\n   static CUresult cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void* data, size_t size, const char* name, unsigned int numOptions, CUjit_option* options, void** optionValues);\n   static CUresult cuLinkCreate_v2(unsigned int  numOptions, CUjit_option* options, void** optionValues, CUlinkState* stateOut);\n   static CUresult cuLinkComplete(CUlinkState state, void** cubinOut, size_t* sizeOut);\n@@ -214,6 +215,7 @@ class dispatch\n   static void* cuDeviceGetAttribute_;\n   static void* cuDeviceGetCount_;\n   // link management\n+  static void* cuLinkAddFile_v2_;\n   static void* cuLinkAddData_v2_;\n   static void* cuLinkCreate_v2_;\n   static void* cuLinkDestroy_;"}, {"filename": "include/triton/external/CUDA/cuda.h", "status": "modified", "additions": 99, "deletions": 145, "changes": 244, "file_content_changes": "@@ -224,7 +224,7 @@ typedef uint64_t cuuint64_t;\n /**\n  * CUDA API version number\n  */\n-#define CUDA_VERSION 11050\n+#define CUDA_VERSION 11040\n \n #ifdef __cplusplus\n extern \"C\" {\n@@ -496,33 +496,7 @@ typedef enum CUarray_format_enum {\n     CU_AD_FORMAT_SIGNED_INT32   = 0x0a, /**< Signed 32-bit integers */\n     CU_AD_FORMAT_HALF           = 0x10, /**< 16-bit floating point */\n     CU_AD_FORMAT_FLOAT          = 0x20, /**< 32-bit floating point */\n-    CU_AD_FORMAT_NV12           = 0xb0, /**< 8-bit YUV planar format, with 4:2:0 sampling */\n-    CU_AD_FORMAT_UNORM_INT8X1   = 0xc0, /**< 1 channel unsigned 8-bit normalized integer */\n-    CU_AD_FORMAT_UNORM_INT8X2   = 0xc1, /**< 2 channel unsigned 8-bit normalized integer */\n-    CU_AD_FORMAT_UNORM_INT8X4   = 0xc2, /**< 4 channel unsigned 8-bit normalized integer */\n-    CU_AD_FORMAT_UNORM_INT16X1  = 0xc3, /**< 1 channel unsigned 16-bit normalized integer */\n-    CU_AD_FORMAT_UNORM_INT16X2  = 0xc4, /**< 2 channel unsigned 16-bit normalized integer */\n-    CU_AD_FORMAT_UNORM_INT16X4  = 0xc5, /**< 4 channel unsigned 16-bit normalized integer */\n-    CU_AD_FORMAT_SNORM_INT8X1   = 0xc6, /**< 1 channel signed 8-bit normalized integer */\n-    CU_AD_FORMAT_SNORM_INT8X2   = 0xc7, /**< 2 channel signed 8-bit normalized integer */\n-    CU_AD_FORMAT_SNORM_INT8X4   = 0xc8, /**< 4 channel signed 8-bit normalized integer */\n-    CU_AD_FORMAT_SNORM_INT16X1  = 0xc9, /**< 1 channel signed 16-bit normalized integer */\n-    CU_AD_FORMAT_SNORM_INT16X2  = 0xca, /**< 2 channel signed 16-bit normalized integer */\n-    CU_AD_FORMAT_SNORM_INT16X4  = 0xcb, /**< 4 channel signed 16-bit normalized integer */\n-    CU_AD_FORMAT_BC1_UNORM      = 0x91, /**< 4 channel unsigned normalized block-compressed (BC1 compression) format */\n-    CU_AD_FORMAT_BC1_UNORM_SRGB = 0x92, /**< 4 channel unsigned normalized block-compressed (BC1 compression) format with sRGB encoding*/\n-    CU_AD_FORMAT_BC2_UNORM      = 0x93, /**< 4 channel unsigned normalized block-compressed (BC2 compression) format */\n-    CU_AD_FORMAT_BC2_UNORM_SRGB = 0x94, /**< 4 channel unsigned normalized block-compressed (BC2 compression) format with sRGB encoding*/\n-    CU_AD_FORMAT_BC3_UNORM      = 0x95, /**< 4 channel unsigned normalized block-compressed (BC3 compression) format */\n-    CU_AD_FORMAT_BC3_UNORM_SRGB = 0x96, /**< 4 channel unsigned normalized block-compressed (BC3 compression) format with sRGB encoding*/\n-    CU_AD_FORMAT_BC4_UNORM      = 0x97, /**< 1 channel unsigned normalized block-compressed (BC4 compression) format */\n-    CU_AD_FORMAT_BC4_SNORM      = 0x98, /**< 1 channel signed normalized block-compressed (BC4 compression) format */\n-    CU_AD_FORMAT_BC5_UNORM      = 0x99, /**< 2 channel unsigned normalized block-compressed (BC5 compression) format */\n-    CU_AD_FORMAT_BC5_SNORM      = 0x9a, /**< 2 channel signed normalized block-compressed (BC5 compression) format */\n-    CU_AD_FORMAT_BC6H_UF16      = 0x9b, /**< 3 channel unsigned half-float block-compressed (BC6H compression) format */\n-    CU_AD_FORMAT_BC6H_SF16      = 0x9c, /**< 3 channel signed half-float block-compressed (BC6H compression) format */\n-    CU_AD_FORMAT_BC7_UNORM      = 0x9d, /**< 4 channel unsigned normalized block-compressed (BC7 compression) format */\n-    CU_AD_FORMAT_BC7_UNORM_SRGB = 0x9e  /**< 4 channel unsigned normalized block-compressed (BC7 compression) format with sRGB encoding */\n+    CU_AD_FORMAT_NV12           = 0xb0\n } CUarray_format;\n \n /**\n@@ -657,15 +631,15 @@ typedef enum CUdevice_attribute_enum {\n     CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = 102,         /**< Device supports virtual memory management APIs like ::cuMemAddressReserve, ::cuMemCreate, ::cuMemMap and related APIs */\n     CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = 103,  /**< Device supports exporting memory to a posix file descriptor with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate */\n     CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = 104,           /**< Device supports exporting memory to a Win32 NT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate */\n-    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = 105,       /**< Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate */\n+    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = 105,       /**< Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested ::cuMemCreate */\n     CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = 106,                /**< Maximum number of blocks per multiprocessor */\n     CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = 107,                /**< Device supports compression of memory */\n     CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = 108,                 /**< Maximum L2 persisting lines capacity setting in bytes. */\n     CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = 109,                /**< Maximum value of CUaccessPolicyWindow::num_bytes. */\n     CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = 110,      /**< Device supports specifying the GPUDirect RDMA flag with ::cuMemCreate */\n     CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = 111,             /**< Shared memory reserved by CUDA driver per block in bytes */\n     CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = 112,                  /**< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays */\n-    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = 113,            /**< Device supports using the ::cuMemHostRegister flag ::CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU */\n+    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = 113,            /**< Device supports using the ::cuMemHostRegister flag CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU */\n     CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = 114,         /**< External timeline semaphore interop is supported on the device */\n     CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = 115,                       /**< Device supports using the ::cuMemAllocAsync and ::cuMemPool family of APIs */\n     CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = 116,                    /**< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information) */\n@@ -1650,8 +1624,7 @@ typedef enum cudaError_enum {\n     CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY      = 224,\n \n     /**\n-     * This indicates that the device kernel source is invalid. This includes\n-     * compilation/linker errors encountered in device code or user error.\n+     * This indicates that the device kernel source is invalid.\n      */\n     CUDA_ERROR_INVALID_SOURCE                 = 300,\n \n@@ -2068,9 +2041,9 @@ typedef size_t (CUDA_CB *CUoccupancyB2DSize)(int blockSize);\n  * On Windows the flag is a no-op.\n  * On Linux that memory is marked as non cache-coherent for the GPU and\n  * is expected to be physically contiguous. It may return\n- * ::CUDA_ERROR_NOT_PERMITTED if run as an unprivileged user,\n- * ::CUDA_ERROR_NOT_SUPPORTED on older Linux kernel versions.\n- * On all other platforms, it is not supported and ::CUDA_ERROR_NOT_SUPPORTED\n+ * CUDA_ERROR_NOT_PERMITTED if run as an unprivileged user,\n+ * CUDA_ERROR_NOT_SUPPORTED on older Linux kernel versions.\n+ * On all other platforms, it is not supported and CUDA_ERROR_NOT_SUPPORTED\n  * is returned.\n  * Flag for ::cuMemHostRegister()\n  */\n@@ -2079,12 +2052,12 @@ typedef size_t (CUDA_CB *CUoccupancyB2DSize)(int blockSize);\n /**\n * If set, the passed memory pointer is treated as pointing to memory that is\n * considered read-only by the device.  On platforms without\n-* ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES, this flag is\n+* CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES, this flag is\n * required in order to register memory mapped to the CPU as read-only.  Support\n * for the use of this flag can be queried from the device attribute\n-* ::CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED.  Using this flag with\n+* CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED.  Using this flag with\n * a current context associated with a device that does not have this attribute\n-* set will cause ::cuMemHostRegister to error with ::CUDA_ERROR_NOT_SUPPORTED.\n+* set will cause ::cuMemHostRegister to error with CUDA_ERROR_NOT_SUPPORTED.\n */\n #define CU_MEMHOSTREGISTER_READ_ONLY    0x08\n \n@@ -3735,117 +3708,117 @@ CUresult CUDAAPI cuDeviceGetTexture1DLinearMaxWidth(size_t *maxWidthInElements,\n  * \\p dev. The supported attributes are:\n  * - ::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: Maximum number of threads per\n  *   block;\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: Maximum x-dimension of a block\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: Maximum y-dimension of a block\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: Maximum z-dimension of a block\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: Maximum x-dimension of a grid\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: Maximum y-dimension of a grid\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: Maximum z-dimension of a grid\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: Maximum x-dimension of a block;\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: Maximum y-dimension of a block;\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: Maximum z-dimension of a block;\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: Maximum x-dimension of a grid;\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: Maximum y-dimension of a grid;\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: Maximum z-dimension of a grid;\n  * - ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK: Maximum amount of\n- *   shared memory available to a thread block in bytes\n+ *   shared memory available to a thread block in bytes;\n  * - ::CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY: Memory available on device for\n- *   __constant__ variables in a CUDA C kernel in bytes\n- * - ::CU_DEVICE_ATTRIBUTE_WARP_SIZE: Warp size in threads\n+ *   __constant__ variables in a CUDA C kernel in bytes;\n+ * - ::CU_DEVICE_ATTRIBUTE_WARP_SIZE: Warp size in threads;\n  * - ::CU_DEVICE_ATTRIBUTE_MAX_PITCH: Maximum pitch in bytes allowed by the\n  *   memory copy functions that involve memory regions allocated through\n- *   ::cuMemAllocPitch()\n+ *   ::cuMemAllocPitch();\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH: Maximum 1D\n- *  texture width\n+ *  texture width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH: Maximum width\n- *  for a 1D texture bound to linear memory\n+ *  for a 1D texture bound to linear memory;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH: Maximum\n- *  mipmapped 1D texture width\n+ *  mipmapped 1D texture width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH: Maximum 2D\n- *  texture width\n+ *  texture width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT: Maximum 2D\n- *  texture height\n+ *  texture height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH: Maximum width\n- *  for a 2D texture bound to linear memory\n+ *  for a 2D texture bound to linear memory;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT: Maximum height\n- *  for a 2D texture bound to linear memory\n+ *  for a 2D texture bound to linear memory;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH: Maximum pitch\n- *  in bytes for a 2D texture bound to linear memory\n+ *  in bytes for a 2D texture bound to linear memory;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH: Maximum\n- *  mipmapped 2D texture width\n+ *  mipmapped 2D texture width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT: Maximum\n- *  mipmapped 2D texture height\n+ *  mipmapped 2D texture height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH: Maximum 3D\n- *  texture width\n+ *  texture width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT: Maximum 3D\n- *  texture height\n+ *  texture height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH: Maximum 3D\n- *  texture depth\n+ *  texture depth;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE:\n  *  Alternate maximum 3D texture width, 0 if no alternate\n- *  maximum 3D texture size is supported\n+ *  maximum 3D texture size is supported;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE:\n  *  Alternate maximum 3D texture height, 0 if no alternate\n- *  maximum 3D texture size is supported\n+ *  maximum 3D texture size is supported;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE:\n  *  Alternate maximum 3D texture depth, 0 if no alternate\n- *  maximum 3D texture size is supported\n+ *  maximum 3D texture size is supported;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH:\n- *  Maximum cubemap texture width or height\n+ *  Maximum cubemap texture width or height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH:\n- *  Maximum 1D layered texture width\n+ *  Maximum 1D layered texture width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS:\n- *   Maximum layers in a 1D layered texture\n+ *   Maximum layers in a 1D layered texture;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH:\n- *  Maximum 2D layered texture width\n+ *  Maximum 2D layered texture width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT:\n- *   Maximum 2D layered texture height\n+ *   Maximum 2D layered texture height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS:\n- *   Maximum layers in a 2D layered texture\n+ *   Maximum layers in a 2D layered texture;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH:\n- *   Maximum cubemap layered texture width or height\n+ *   Maximum cubemap layered texture width or height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS:\n- *   Maximum layers in a cubemap layered texture\n+ *   Maximum layers in a cubemap layered texture;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH:\n- *   Maximum 1D surface width\n+ *   Maximum 1D surface width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH:\n- *   Maximum 2D surface width\n+ *   Maximum 2D surface width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT:\n- *   Maximum 2D surface height\n+ *   Maximum 2D surface height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH:\n- *   Maximum 3D surface width\n+ *   Maximum 3D surface width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT:\n- *   Maximum 3D surface height\n+ *   Maximum 3D surface height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH:\n- *   Maximum 3D surface depth\n+ *   Maximum 3D surface depth;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH:\n- *   Maximum 1D layered surface width\n+ *   Maximum 1D layered surface width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS:\n- *   Maximum layers in a 1D layered surface\n+ *   Maximum layers in a 1D layered surface;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH:\n- *   Maximum 2D layered surface width\n+ *   Maximum 2D layered surface width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT:\n- *   Maximum 2D layered surface height\n+ *   Maximum 2D layered surface height;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS:\n- *   Maximum layers in a 2D layered surface\n+ *   Maximum layers in a 2D layered surface;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH:\n- *   Maximum cubemap surface width\n+ *   Maximum cubemap surface width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH:\n- *   Maximum cubemap layered surface width\n+ *   Maximum cubemap layered surface width;\n  * - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS:\n- *   Maximum layers in a cubemap layered surface\n+ *   Maximum layers in a cubemap layered surface;\n  * - ::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK: Maximum number of 32-bit\n- *   registers available to a thread block\n- * - ::CU_DEVICE_ATTRIBUTE_CLOCK_RATE: The typical clock frequency in kilohertz\n+ *   registers available to a thread block;\n+ * - ::CU_DEVICE_ATTRIBUTE_CLOCK_RATE: The typical clock frequency in kilohertz;\n  * - ::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: Alignment requirement; texture\n  *   base addresses aligned to ::textureAlign bytes do not need an offset\n- *   applied to texture fetches\n+ *   applied to texture fetches;\n  * - ::CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT: Pitch alignment requirement\n- *   for 2D texture references bound to pitched memory\n+ *   for 2D texture references bound to pitched memory;\n  * - ::CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: 1 if the device can concurrently copy\n- *   memory between host and device while executing a kernel, or 0 if not\n+ *   memory between host and device while executing a kernel, or 0 if not;\n  * - ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: Number of multiprocessors on\n- *   the device\n+ *   the device;\n  * - ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: 1 if there is a run time limit\n- *   for kernels executed on the device, or 0 if not\n+ *   for kernels executed on the device, or 0 if not;\n  * - ::CU_DEVICE_ATTRIBUTE_INTEGRATED: 1 if the device is integrated with the\n- *   memory subsystem, or 0 if not\n+ *   memory subsystem, or 0 if not;\n  * - ::CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: 1 if the device can map host\n- *   memory into the CUDA address space, or 0 if not\n+ *   memory into the CUDA address space, or 0 if not;\n  * - ::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: Compute mode that device is currently\n  *   in. Available modes are as follows:\n  *   - ::CU_COMPUTEMODE_DEFAULT: Default mode - Device is not restricted and\n@@ -3858,33 +3831,33 @@ CUresult CUDAAPI cuDeviceGetTexture1DLinearMaxWidth(size_t *maxWidthInElements,\n  *   executing multiple kernels within the same context simultaneously, or 0 if\n  *   not. It is not guaranteed that multiple kernels will be resident\n  *   on the device concurrently so this feature should not be relied upon for\n- *   correctness.\n+ *   correctness;\n  * - ::CU_DEVICE_ATTRIBUTE_ECC_ENABLED: 1 if error correction is enabled on the\n- *    device, 0 if error correction is disabled or not supported by the device\n- * - ::CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: PCI bus identifier of the device\n+ *    device, 0 if error correction is disabled or not supported by the device;\n+ * - ::CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: PCI bus identifier of the device;\n  * - ::CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: PCI device (also known as slot) identifier\n- *   of the device\n+ *   of the device;\n  * - ::CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: PCI domain identifier of the device\n  * - ::CU_DEVICE_ATTRIBUTE_TCC_DRIVER: 1 if the device is using a TCC driver. TCC\n- *    is only available on Tesla hardware running Windows Vista or later\n- * - ::CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: Peak memory clock frequency in kilohertz\n- * - ::CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH: Global memory bus width in bits\n- * - ::CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: Size of L2 cache in bytes. 0 if the device doesn't have L2 cache\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR: Maximum resident threads per multiprocessor\n+ *    is only available on Tesla hardware running Windows Vista or later;\n+ * - ::CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: Peak memory clock frequency in kilohertz;\n+ * - ::CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH: Global memory bus width in bits;\n+ * - ::CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: Size of L2 cache in bytes. 0 if the device doesn't have L2 cache;\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR: Maximum resident threads per multiprocessor;\n  * - ::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: 1 if the device shares a unified address space with\n- *   the host, or 0 if not\n- * - ::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR: Major compute capability version number\n- * - ::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR: Minor compute capability version number\n+ *   the host, or 0 if not;\n+ * - ::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR: Major compute capability version number;\n+ * - ::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR: Minor compute capability version number;\n  * - ::CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED: 1 if device supports caching globals\n- *    in L1 cache, 0 if caching globals in L1 cache is not supported by the device\n+ *    in L1 cache, 0 if caching globals in L1 cache is not supported by the device;\n  * - ::CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED: 1 if device supports caching locals\n- *    in L1 cache, 0 if caching locals in L1 cache is not supported by the device\n+ *    in L1 cache, 0 if caching locals in L1 cache is not supported by the device;\n  * - ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR: Maximum amount of\n  *   shared memory available to a multiprocessor in bytes; this amount is shared\n- *   by all thread blocks simultaneously resident on a multiprocessor\n+ *   by all thread blocks simultaneously resident on a multiprocessor;\n  * - ::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR: Maximum number of 32-bit\n  *   registers available to a multiprocessor; this number is shared by all thread\n- *   blocks simultaneously resident on a multiprocessor\n+ *   blocks simultaneously resident on a multiprocessor;\n  * - ::CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: 1 if device supports allocating managed memory\n  *   on this system, 0 if allocating managed memory is not supported by the device on this system.\n  * - ::CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: 1 if device is on a multi-GPU board, 0 if not.\n@@ -3910,20 +3883,14 @@ CUresult CUDAAPI cuDeviceGetTexture1DLinearMaxWidth(size_t *maxWidthInElements,\n  * - ::CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED:  Device supports virtual memory management APIs like ::cuMemAddressReserve, ::cuMemCreate, ::cuMemMap and related APIs\n  * - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED: Device supports exporting memory to a posix file descriptor with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate\n  * - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED:  Device supports exporting memory to a Win32 NT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate\n- * - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED: Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR: Maximum number of thread blocks that can reside on a multiprocessor\n+ * - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED: Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested ::cuMemCreate\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE: Maximum L2 persisting lines capacity setting in bytes.\n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE: Maximum value of CUaccessPolicyWindow::num_bytes. \n+ * - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR: Maximum number of thread blocks that can reside on a multiprocessor.\n  * - ::CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED: Device supports compressible memory allocation via ::cuMemCreate\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE: Maximum L2 persisting lines capacity setting in bytes\n- * - ::CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE: Maximum value of CUaccessPolicyWindow::num_bytes \n- * - ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED: Device supports specifying the GPUDirect RDMA flag with ::cuMemCreate.\n- * - ::CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK: Amount of shared memory per block reserved by CUDA driver in bytes\n- * - ::CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED: Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays. \n- * - ::CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED: Device supports using the ::cuMemHostRegister flag ::CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU\n+ * - ::CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK: Amount of shared memory per block reserved by CUDA driver in bytes.\n+ * - ::CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED: Device supports using the ::cuMemHostRegister flag CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU\n  * - ::CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED: Device supports using the ::cuMemAllocAsync and ::cuMemPool family of APIs\n- * - ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED: Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)\n- * - ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS: The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the ::CUflushGPUDirectRDMAWritesOptions enum\n- * - ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING: GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::CUGPUDirectRDMAWritesOrdering for the numerical values returned here.\n- * - ::CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES: Bitmask of handle types supported with mempool based IPC\n  *\n  * \\param pi     - Returned device attribute value\n  * \\param attrib - Device attribute to query\n@@ -4690,13 +4657,6 @@ CUresult CUDAAPI cuCtxCreate_v3(CUcontext *pctx, CUexecAffinityParam *paramsArra\n  * It is the responsibility of the calling function to ensure that no API\n  * call issues using \\p ctx while ::cuCtxDestroy() is executing.\n  *\n- * Destroys and cleans up all resources associated with the context.\n- * It is the caller's responsibility to ensure that the context or its resources\n- * are not accessed or passed in subsequent API calls and doing so will result in undefined behavior.\n- * These resources include CUDA types such as ::CUmodule, ::CUfunction, ::CUstream, ::CUevent,\n- * ::CUarray, ::CUmipmappedArray, ::CUtexObject, ::CUsurfObject, ::CUtexref, ::CUsurfref,\n- * ::CUgraphicsResource, ::CUlinkState, ::CUexternalMemory and ::CUexternalSemaphore.\n- *\n  * If \\p ctx is current to the calling thread then \\p ctx will also be\n  * popped from the current thread's context stack (as though ::cuCtxPopCurrent()\n  * were called).  If \\p ctx is current to other threads, then \\p ctx will\n@@ -5672,7 +5632,6 @@ CUresult CUDAAPI cuModuleLoadFatBinary(CUmodule *module, const void *fatCubin);\n  * ::CUDA_ERROR_INVALID_CONTEXT,\n  * ::CUDA_ERROR_INVALID_VALUE\n  * \\notefnerr\n- * \\note_destroy_ub\n  *\n  * \\sa ::cuModuleGetFunction,\n  * ::cuModuleGetGlobal,\n@@ -5993,9 +5952,8 @@ cuLinkDestroy(CUlinkState state);\n /**\n  * \\brief Gets free and total memory\n  *\n- * Returns in \\p *total the total amount of memory available to the the current context.\n- * Returns in \\p *free the amount of memory on the device that is free according to the OS.\n- * CUDA is not guaranteed to be able to allocate all of the memory that the OS reports as free.\n+ * Returns in \\p *free and \\p *total respectively, the free and total amount of\n+ * memory available for allocation by the CUDA context, in bytes.\n  *\n  * \\param free  - Returned free memory in bytes\n  * \\param total - Returned total memory in bytes\n@@ -6839,10 +6797,10 @@ CUresult CUDAAPI cuIpcCloseMemHandle(CUdeviceptr dptr);\n  *\n  * - ::CU_MEMHOSTREGISTER_READ_ONLY: The pointer is treated as pointing to memory\n  *   that is considered read-only by the device.  On platforms without\n- *   ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES, this flag is\n+ *   CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES, this flag is\n  *   required in order to register memory mapped to the CPU as read-only.  Support\n  *   for the use of this flag can be queried from the device attribute\n- *   ::CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED.  Using this flag with\n+ *   CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED.  Using this flag with\n  *   a current context associated with a device that does not have this attribute\n  *   set will cause ::cuMemHostRegister to error with CUDA_ERROR_NOT_SUPPORTED.\n  *\n@@ -8987,7 +8945,7 @@ CUresult CUDAAPI cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsi\n  * float16's:\n  * \\code\n     CUDA_ARRAY_DESCRIPTOR desc;\n-    desc.Format = CU_AD_FORMAT_HALF;\n+    desc.FormatFlags = CU_AD_FORMAT_HALF;\n     desc.NumChannels = 4;\n     desc.Width = width;\n     desc.Height = height;\n@@ -8997,7 +8955,7 @@ CUresult CUDAAPI cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsi\n  * of which is two 8-bit unsigned chars:\n  * \\code\n     CUDA_ARRAY_DESCRIPTOR arrayDesc;\n-    desc.Format = CU_AD_FORMAT_UNSIGNED_INT8;\n+    desc.FormatFlags = CU_AD_FORMAT_UNSIGNED_INT8;\n     desc.NumChannels = 2;\n     desc.Width = width;\n     desc.Height = height;\n@@ -9323,7 +9281,7 @@ CUresult CUDAAPI cuArrayDestroy(CUarray hArray);\n  * 4x16-bit float16's:\n  * \\code\n     CUDA_ARRAY3D_DESCRIPTOR desc;\n-    desc.Format = CU_AD_FORMAT_HALF;\n+    desc.FormatFlags = CU_AD_FORMAT_HALF;\n     desc.NumChannels = 4;\n     desc.Width = width;\n     desc.Height = height;\n@@ -15180,7 +15138,7 @@ CUresult CUDAAPI cuGraphExternalSemaphoresWaitNodeSetParams(CUgraphNode hNode, c\n  * \\param nodeParams      - Parameters for the node\n  *\n  * When ::cuGraphAddMemAllocNode creates an allocation node, it returns the address of the allocation in\n- * \\p nodeParams.dptr.  The allocation's address remains fixed across instantiations and launches.\n+ * \\param nodeParams.dptr.  The allocation's address remains fixed across instantiations and launches.\n  *\n  * If the allocation is freed in the same graph, by creating a free node using ::cuGraphAddMemFreeNode,\n  * the allocation can be accessed by nodes ordered after the allocation node but before the free node.\n@@ -15356,9 +15314,7 @@ CUresult CUDAAPI cuGraphMemFreeNodeGetParams(CUgraphNode hNode, CUdeviceptr *dpt\n  *\n  * \\sa\n  * ::cuGraphAddMemAllocNode,\n- * ::cuGraphAddMemFreeNode,\n- * ::cuDeviceSetGraphMemAttribute,\n- * ::cuDeviceGetGraphMemAttribute\n+ * ::cuGraphAddMemFreeNode\n  */\n CUresult CUDAAPI cuDeviceGraphMemTrim(CUdevice device);\n \n@@ -15384,7 +15340,6 @@ CUresult CUDAAPI cuDeviceGraphMemTrim(CUdevice device);\n  * ::CUDA_ERROR_INVALID_DEVICE\n  *\n  * \\sa\n- * ::cuDeviceSetGraphMemAttribute,\n  * ::cuGraphAddMemAllocNode,\n  * ::cuGraphAddMemFreeNode\n  */\n@@ -15409,7 +15364,6 @@ CUresult CUDAAPI cuDeviceGetGraphMemAttribute(CUdevice device, CUgraphMem_attrib\n  * ::CUDA_ERROR_INVALID_DEVICE\n  *\n  * \\sa\n- * ::cuDeviceGetGraphMemAttribute,\n  * ::cuGraphAddMemAllocNode,\n  * ::cuGraphAddMemFreeNode\n  */"}, {"filename": "include/triton/ir/basic_block.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "file_content_changes": "@@ -1,4 +1,4 @@\n-#pragma once\n+\ufeff#pragma once\n \n #ifndef _TRITON_IR_BASIC_BLOCK_H_\n #define _TRITON_IR_BASIC_BLOCK_H_\n@@ -27,14 +27,15 @@ class basic_block: public value{\n \n private:\n   // constructors\n-  basic_block(context &ctx, const std::string &name, function *parent);\n+  basic_block(context &ctx, const std::string &name, function *parent, basic_block *next);\n \n public:\n   // accessors\n   function* get_parent() { return parent_; }\n   context& get_context() { return ctx_; }\n \n   // get iterator to first instruction that is not a phi\n+  void replace_phi_uses_with(basic_block* before, basic_block* after);\n   iterator get_first_non_phi();\n \n   // get instruction list\n@@ -60,13 +61,16 @@ class basic_block: public value{\n   inline const instruction       &back() const { return *inst_list_.back();  }\n   inline       instruction       &back()       { return *inst_list_.back();  }\n \n+  void append_instruction(ir::instruction* i);\n+  // split\n+  basic_block* split_before(ir::instruction* loc, const std::string& name);\n+\n   // predecessors\n-  const std::vector<basic_block*>& get_predecessors() const { return preds_; }\n-  const std::vector<basic_block*>& get_successors() const { return succs_; }\n-  void add_predecessor(basic_block* pred);\n+  std::vector<basic_block*> get_predecessors() const;\n+  std::vector<basic_block*> get_successors() const;\n \n   // factory functions\n-  static basic_block* create(context &ctx, const std::string &name, function *parent);\n+  static basic_block* create(context &ctx, const std::string &name, function *parent, basic_block *next = nullptr);\n \n   void print(std::ostream &os);\n "}, {"filename": "include/triton/ir/builder.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "file_content_changes": "@@ -22,6 +22,7 @@ class phi_node;\n \n /* Builder */\n class builder{\n+public:\n   typedef basic_block::iterator iterator;\n \n public:\n@@ -75,6 +76,7 @@ class builder{\n   value* create_br(basic_block *dest);\n   value* create_cond_br(value *cond, basic_block* if_dest, basic_block* else_dest);\n   value* create_ret_void();\n+  value* create_ret(value *ret);\n   // Cast instructions\n   value *create_cast(cast_op_t op, value *v, type *dst_ty);\n   value* create_ptr_to_int(value *src, type *dst_ty);\n@@ -86,6 +88,9 @@ class builder{\n   value* create_fp_trunc(value *src, type *dst_ty);\n   value* create_int_cast(value *src, type *dst_ty, bool is_signed);\n   value *create_downcast(value *arg);\n+  // Call instruction\n+  value* create_call(function* fn, const std::vector<value*>& args);\n+  value* create_launch(function* fn, const std::vector<value*>& args, const std::vector<value*>& grid, value* num_warps);\n   // Phi instruction\n   phi_node* create_phi(type *ty, unsigned num_reserved);\n   // Binary instructions\n@@ -142,6 +147,9 @@ class builder{\n   value *create_store(value *ptr, value *val);\n   value *create_masked_load(value *arg, value *mask, value *false_value, load_inst::CACHE_MODIFIER cache, load_inst::EVICTION_POLICY eviction, bool is_volatile);\n   value *create_masked_store(value *ptr, value *val, value *mask);\n+  // Struct instructions\n+  value *create_insert_value(value* val, value *elt, size_t idx);\n+  value *create_extract_value(value* val, size_t idx);\n   // Block instruction\n   value *create_splat(value *arg, const type::block_shapes_t &shapes);\n   value *create_reshape(value *arg, const type::block_shapes_t &shapes);"}, {"filename": "include/triton/ir/context_impl.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -31,7 +31,8 @@ class context_impl {\n   std::map<std::pair<type*, unsigned>, std::unique_ptr<pointer_type>> ptr_tys;\n   // Block types\n   std::map<std::pair<type*, type::block_shapes_t>, std::unique_ptr<block_type>> block_tys;\n-\n+  // Struct types\n+  std::map<type::contained_tys_vec_t, struct_type*> struct_tys;\n   // Int constants\n   std::map<std::pair<type*, uint64_t>, std::unique_ptr<constant_int>> int_constants_;\n   // Float constants"}, {"filename": "include/triton/ir/enums.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "file_content_changes": "@@ -95,6 +95,9 @@ enum value_id_t: unsigned {\n     INSTRUCTIONS\n    * ------------ */\n   INST_BEGIN,\n+  // call\n+  INST_CALL,\n+  INST_LAUNCH,\n   // phi\n   INST_PHI,\n   // arithmetic\n@@ -129,6 +132,9 @@ enum value_id_t: unsigned {\n   INST_MASKED_LOAD_ASYNC,\n   INST_UNMASKED_STORE,\n   INST_MASKED_STORE,\n+  // struct\n+  INST_EXTRACT_VALUE,\n+  INST_INSERT_VALUE,\n   // retile\n   INST_RESHAPE,\n   INST_SPLAT,"}, {"filename": "include/triton/ir/function.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "file_content_changes": "@@ -24,7 +24,7 @@ class argument: public value{\n   static argument* create(type *ty, const std::string &name,\n                           function *parent = nullptr, unsigned arg_no = 0);\n   function* get_parent() const;\n-  unsigned get_arg_no() const;\n+  unsigned  get_arg_no() const;\n \n   void accept(visitor *v);\n \n@@ -121,6 +121,8 @@ class function: public global_object{\n   const attr_map_t &attrs() { return attrs_; }\n   bool has_attr(unsigned arg_id) const { return  attrs_.find(arg_id) != attrs_.end(); }\n   std::set<attribute> get_attributes(const argument* arg) { return attrs_[arg->get_arg_no() + 1]; }\n+  void set_is_kernel(bool new_val) { is_kernel_ = new_val; }\n+  bool get_is_kernel() { return is_kernel_; }\n \n   void print(std::ostream &os);\n \n@@ -134,6 +136,7 @@ class function: public global_object{\n   args_t args_;\n   blocks_t blocks_;\n   attr_map_t attrs_;\n+  bool is_kernel_;\n };\n \n }"}, {"filename": "include/triton/ir/instructions.h", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "file_content_changes": "@@ -81,6 +81,51 @@ class instruction: public user{\n   value_id_t id_;\n };\n \n+//===----------------------------------------------------------------------===//\n+//                               call_inst classes\n+//===----------------------------------------------------------------------===//\n+\n+class call_inst: public instruction {\n+private:\n+  std::string repr_impl() const;\n+  call_inst(ir::function* fn, const std::vector<ir::value*>& values, const std::string& name, instruction* next);\n+\n+public:\n+  static call_inst* create(ir::function* fn, const std::vector<ir::value*>& values, const std::string &name = \"\", instruction *next = nullptr);\n+  ir::function* get_fn() { return fn_; }\n+\n+  _TRITON_DEFINE_CLONE(call_inst)\n+  _TRITON_DEFINE_ACCEPT(call_inst)\n+\n+private:\n+  ir::function* fn_;\n+};\n+\n+class launch_inst: public instruction {\n+private:\n+  std::string repr_impl() const { return \"launch\"; }\n+  launch_inst(ir::function* fn, const std::vector<ir::value*>& values, const std::vector<ir::value*>& grid, ir::value* num_warps,\n+              const std::string &name = \"\", instruction *next = nullptr);\n+\n+public:\n+  static launch_inst* create(ir::function* fn, const std::vector<ir::value*>& values, const std::vector<ir::value*>& grid, ir::value* num_warps,\n+                             const std::string& name = \"\", instruction* next = nullptr);\n+\n+  ir::function* get_fn();\n+  std::vector<ir::value*> get_values();\n+  std::vector<ir::value*> get_grid();\n+  ir::value* get_num_warps();\n+\n+\n+  _TRITON_DEFINE_CLONE(launch_inst)\n+  _TRITON_DEFINE_ACCEPT(launch_inst)\n+\n+private:\n+  unsigned val_begin;\n+  unsigned val_end;\n+  unsigned grid_begin;\n+  unsigned grid_end;\n+};\n \n //===----------------------------------------------------------------------===//\n //                               phi_node classes\n@@ -546,6 +591,44 @@ class masked_store_inst: public store_inst{\n   _TRITON_DEFINE_ACCEPT(masked_store_inst)\n };\n \n+//===----------------------------------------------------------------------===//\n+//                               struct classes\n+//===----------------------------------------------------------------------===//\n+\n+// insert_value\n+\n+class insert_value_inst: public instruction {\n+private:\n+  std::string repr_impl() const { return \"insertvalue\"; }\n+  insert_value_inst(value *val, value *elt, size_t idx, const std::string &name, instruction *next);\n+\n+public:\n+  static insert_value_inst* create(value *val, value* elt, size_t idx, const std::string &name = \"\", instruction *next = nullptr);\n+  size_t get_idx() { return idx_; }\n+  _TRITON_DEFINE_CLONE(insert_value_inst)\n+  _TRITON_DEFINE_ACCEPT(insert_value_inst)\n+\n+private:\n+  size_t idx_;\n+};\n+\n+// extract_value\n+\n+class extract_value_inst: public instruction {\n+private:\n+  std::string repr_impl() const { return \"extractvalue\"; }\n+  extract_value_inst(value *val, size_t idx, const std::string &name, instruction *next);\n+\n+public:\n+  static extract_value_inst* create(value *val, size_t idx, const std::string &name = \"\", instruction *next = nullptr);\n+  size_t get_idx() { return idx_; }\n+  _TRITON_DEFINE_CLONE(extract_value_inst)\n+  _TRITON_DEFINE_ACCEPT(extract_value_inst)\n+\n+private:\n+  size_t idx_;\n+};\n+\n //===----------------------------------------------------------------------===//\n //                               retile_inst classes\n //===----------------------------------------------------------------------===//"}, {"filename": "include/triton/ir/module.h", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "file_content_changes": "@@ -34,79 +34,97 @@ class constant;\n class global_value;\n class alloc_const;\n \n+class value_constructor {\n+  typedef std::pair<std::string, basic_block*> val_key_t;\n+  typedef std::pair<ir::metadata::kind_t, unsigned> md_pair_t;\n+\n+private:\n+  phi_node *make_phi(type *ty, unsigned num_values, basic_block *block);\n+  value *try_remove_trivial_phis(ir::phi_node *&phi);\n+  value *add_phi_operands(const std::string& name, phi_node *&phi);\n+  value *get_value_recursive(const std::string& name, basic_block *block);\n+\n+public:\n+  value_constructor(builder &builder);\n+\n+  void set_value(const std::string& name, basic_block* block, value *x);\n+  void set_value(const std::string& name, value* x);\n+  const std::map<val_key_t, value*>& get_values() { return values_; }\n+  void set_values(const std::map<val_key_t, value*>& values) { values_ = values; }\n+  value *get_value(const std::string& name, basic_block* block);\n+  value *get_value(const std::string& name);\n+  void set_type(const std::string& name, ir::type* ty) { types_[name] = ty; }\n+  // Seal block -- no more predecessors will be added\n+  void seal_block(basic_block *block);\n+  // Metadata\n+  void add_metadata(const std::string &name, md_pair_t x)     { metadatas_[name] = x; }\n+\n+private:\n+  ir::builder& builder_;\n+  std::map<val_key_t, value*> values_;\n+  std::map<std::string, type*> types_;\n+  std::set<basic_block*> sealed_blocks_;\n+  std::map<basic_block*, std::map<std::string, phi_node*>> incomplete_phis_;\n+  std::map<value*, value**> current_phi_;\n+  std::map<std::string, md_pair_t> metadatas_;\n+};\n+\n /* Module */\n \n class module {\n   typedef std::pair<std::string, basic_block*> val_key_t;\n   friend class function;\n-  typedef std::pair<ir::metadata::kind_t, unsigned> md_pair_t;\n \n public:\n   typedef std::map<std::string, global_value*> symbols_map_t;\n   typedef std::vector<function*> functions_list_t;\n-  struct current_iteration_info_t{\n-    lang::iteration_statement *statement;\n-    basic_block *block;\n-  };\n \n private:\n-  phi_node *make_phi(type *ty, unsigned num_values, basic_block *block);\n-  value *try_remove_trivial_phis(ir::phi_node *&phi);\n-  value *add_phi_operands(const std::string& name, phi_node *&phi);\n-  value *get_value_recursive(const std::string& name, basic_block *block);\n   void push_function(function *fn) { functions_.push_back(fn); }\n \n public:\n   module(const std::string &name, builder& builder);\n   builder& get_builder();\n   // Setters\n-  void set_value(const std::string& name, basic_block* block, value *x);\n-  void set_value(const std::string& name, value* x);\n-  void set_const(const std::string& name);\n   void set_continue_fn(std::function<ir::value*()> fn);\n   // Getters\n-  const std::map<val_key_t, value*>& get_values() { return values_; }\n-  const std::map<std::string, type*>& get_types() { return types_; }\n-  void set_values(const std::map<val_key_t, value*>& values) { values_ = values; }\n-  void set_types(const std::map<std::string, type*>& types) { types_ = types; }\n-\n-  value *get_value(const std::string& name, basic_block* block);\n-  value *get_value(const std::string& name);\n-  void set_type(const std::string& name, ir::type* ty) { types_[name] = ty; }\n   const std::string& get_name();\n   std::function<ir::value*()> get_continue_fn();\n-  // Seal block -- no more predecessors will be added\n-  void seal_block(basic_block *block);\n   // Functions\n   const functions_list_t &get_function_list() const { return functions_; }\n   functions_list_t &get_function_list()             { return functions_; }\n+  function *get_function(const std::string& name)   {\n+    if(symbols_.find(name) == symbols_.end())\n+      throw std::runtime_error(\"function \" + name + \" is not declared\");\n+    return (function*)symbols_.at(name);\n+  }\n   function *get_or_insert_function(const std::string &name, function_type *ty);\n+  bool has_function(const std::string& name){\n+    return symbols_.find(name) != symbols_.end();\n+  }\n+  void remove_function(ir::function* fn){\n+    functions_.erase(std::remove(functions_.begin(), functions_.end(), fn), functions_.end());\n+  }\n+\n+  void reset_ret_ty(const std::string& name, type* ty);\n+\n   // Const allocation\n   void add_alloc(ir::alloc_const* x)                          { allocs_.push_back(x); }\n   const std::vector<ir::alloc_const*>& allocs()               { return allocs_; }\n   // Register global\n   void register_global(const std::string& name, ir::value *x) { globals_[name] = x; }\n   const std::map<std::string, ir::value*>& globals() const    { return globals_; }\n-  // Metadata\n-  void add_metadata(const std::string &name, md_pair_t x)     { metadatas_[name] = x; }\n-\n+  //\n   void print(std::ostream &os);\n \n private:\n   std::string name_;\n   builder& builder_;\n-  std::map<val_key_t, value*> values_;\n-  std::map<std::string, type*> types_;\n-  std::set<std::string> const_;\n-  std::set<basic_block*> sealed_blocks_;\n-  std::map<basic_block*, std::map<std::string, phi_node*>> incomplete_phis_;\n   functions_list_t functions_;\n   symbols_map_t symbols_;\n   std::function<ir::value*()> continue_fn_;\n-  std::map<value*, value**> current_phi_;\n   std::vector<ir::alloc_const*> allocs_;\n   std::map<std::string, ir::value*> globals_;\n-  std::map<std::string, md_pair_t> metadatas_;\n };\n \n }"}, {"filename": "include/triton/ir/type.h", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "file_content_changes": "@@ -1,4 +1,4 @@\n-#pragma once\n+\ufeff#pragma once\n \n #ifndef _TRITON_IR_TYPE_H_\n #define _TRITON_IR_TYPE_H_\n@@ -73,6 +73,8 @@ class type {\n   type *get_tile_element_ty() const;\n   unsigned get_pointer_address_space() const;\n   type *get_pointer_element_ty() const;\n+  unsigned get_struct_numel() const { return contained_tys_.size(); }\n+  type *get_struct_type(unsigned int i) const { return contained_tys_[i]; }\n \n   // primitive predicates\n   bool is_void_ty() const               { return id_ == VoidTyID; }\n@@ -91,6 +93,7 @@ class type {\n   bool is_bool_ty() const               { return is_integer_ty(1); }\n   bool is_pointer_ty() const            { return id_ == PointerTyID; }\n   bool is_block_ty() const               { return id_ == BlockTyID; }\n+  bool is_struct_ty() const             { return id_ == StructTyID; }\n \n   // Composite predicates\n   bool is_int_or_tileint_ty();\n@@ -138,10 +141,10 @@ class type {\n     switch(id_) {\n       case VoidTyID: return \"void\";\n       case FP8TyID: return \"fp8\";\n+      case BF16TyID: return \"bf16\";\n       case FP16TyID: return \"f16\";\n       case FP32TyID: return \"f32\";\n       case FP64TyID: return \"f64\";\n-      case BF16TyID: return \"bf16\";\n       case LabelTyID: return \"label\";\n       case MetadataTyID: return \"md\";\n       case TokenTyID: return \"tok\";\n@@ -194,6 +197,16 @@ class composite_type: public type{\n   type* get_type_at_index(value *idx) const;\n };\n \n+class struct_type: public composite_type {\n+public:\n+  struct_type(const contained_tys_vec_t& tys, bool is_packed);\n+  unsigned get_num_types() const { return contained_tys_.size(); }\n+  static struct_type* get(const contained_tys_vec_t& tys, bool is_packed);\n+\n+private:\n+  bool is_packed_;\n+};\n+\n class block_type: public composite_type {\n private:\n   block_type(type *ty, const block_shapes_t &shapes);\n@@ -242,6 +255,7 @@ class function_type: public type {\n   ty_iterator       params_end()         { return contained_tys_.end(); }\n   type*    get_param_ty(unsigned i) const { return contained_tys_.at(1 + i);   }\n   type*    get_return_ty()          const { return contained_tys_.at(0);       }\n+  void     reset_ret_ty(type* ty)         { contained_tys_[0] = ty;}\n   // factory methods\n   static function_type* get(type *ret_ty, const std::vector<type*>& param_tys);\n };"}, {"filename": "include/triton/ir/value.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -21,7 +21,7 @@ class visitor;\n \n class value {\n public:\n-  typedef std::set<user*> users_t;\n+  typedef std::vector<user*> users_t;\n \n public:\n   // constructor\n@@ -30,7 +30,7 @@ class value {\n   // uses\n   void add_use(user* arg);\n   users_t::iterator erase_use(user* arg);\n-  const std::set<user*> &get_users() { return users_; }\n+  const std::vector<user*> &get_users() { return users_; }\n   void replace_all_uses_with(value *target);\n   // name\n   void set_name(const std::string &name);"}, {"filename": "include/triton/ir/visitor.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "file_content_changes": "@@ -11,6 +11,9 @@ class value;\n \n class instruction;\n \n+class call_inst;\n+class launch_inst;\n+\n class phi_node;\n class binary_operator;\n class getelementptr_inst;\n@@ -42,6 +45,9 @@ class masked_load_inst;\n class unmasked_store_inst;\n class masked_store_inst;\n \n+class extract_value_inst;\n+class insert_value_inst;\n+\n class retile_inst;\n class reshape_inst;\n class splat_inst;\n@@ -105,6 +111,8 @@ class visitor {\n   virtual ~visitor() {}\n \n   virtual void visit_value(ir::value*);\n+  virtual void visit_call_inst(ir::call_inst*) = 0;\n+  virtual void visit_launch_inst(ir::launch_inst*) = 0;\n \n   virtual void visit_basic_block(basic_block*) = 0;\n   virtual void visit_argument(argument*) = 0;\n@@ -132,6 +140,9 @@ class visitor {\n   virtual void visit_sin_inst(sin_inst*) = 0;\n   virtual void visit_log_inst(log_inst*) = 0;\n \n+  virtual void visit_extract_value_inst(extract_value_inst*) = 0;\n+  virtual void visit_insert_value_inst(insert_value_inst*) = 0;\n+\n   virtual void visit_reshape_inst(reshape_inst*) = 0;\n   virtual void visit_splat_inst(splat_inst*) = 0;\n   virtual void visit_cat_inst(cat_inst*) = 0;"}, {"filename": "lib/codegen/analysis/layout.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -608,6 +608,8 @@ void layouts::run(ir::module &mod) {\n   // create temporaries\n   size_t id = values_.size();\n   ir::for_each_instruction(mod, [this, &id](ir::instruction* i) {\n+//    std::cout << \"layout: \" << std::endl;\n+//    i->print(std::cout);\n     if(auto *red = dynamic_cast<ir::reduce_inst*>(i)) {\n       id++;\n       ir::value *arg = red->get_operand(0);"}, {"filename": "lib/codegen/pass.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -13,6 +13,7 @@\n #include \"triton/codegen/transform/peephole.h\"\n #include \"triton/codegen/transform/pipeline.h\"\n #include \"triton/codegen/transform/prefetch.h\"\n+#include \"triton/codegen/transform/inline.h\"\n #include \"triton/ir/function.h\"\n #include \"triton/ir/module.h\"\n #include \"triton/ir/print.h\"\n@@ -33,6 +34,7 @@ std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMC\n   bool cts_use_async = target->as_nvidia() && target->as_nvidia()->sm() >= 80;\n   // create passes\n   codegen::analysis::align align;\n+  codegen::transform::inliner inliner;\n   codegen::analysis::axes axes;\n   codegen::transform::cts cts(cts_use_async);\n   codegen::transform::pipeline pipeline(cts_use_async, num_stages);\n@@ -48,6 +50,7 @@ std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMC\n   codegen::transform::membar barriers(&liveness, &layouts, &allocation, &prefetch_s, target);\n   codegen::generator isel(&axes, &layouts, &align, &allocation, &swizzle, target, num_warps);\n   // run passes\n+  inliner.run(ir);\n   dce.run(ir);\n   peephole.run(ir);\n   dce.run(ir);"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 148, "deletions": 7, "changes": 155, "file_content_changes": "@@ -13,6 +13,7 @@\n #include \"triton/ir/module.h\"\n #include \"triton/ir/function.h\"\n #include \"triton/ir/type.h\"\n+#include \"triton/ir/utils.h\"\n #include \"llvm/IR/Module.h\"\n #include \"llvm/IR/IRBuilder.h\"\n #include \"llvm/IR/IntrinsicsNVPTX.h\"\n@@ -139,6 +140,14 @@ Value* geper::operator()(Value *ptr, Value* off, const std::string& name){\n  * \\brief Convert Triton-IR Type to LLVM-IR Type\n  */\n Type *generator::cvt(ir::type *ty) {\n+  // struct\n+  if(ty->is_struct_ty()){\n+    std::vector<Type*> tys;\n+    for(size_t i = 0; i < ty->get_struct_numel(); i++)\n+      tys.push_back(cvt(ty->get_struct_type(i)));\n+    return StructType::get(builder_->getContext(), tys, true);\n+  }\n+\n   // function\n   if(auto* tt = dynamic_cast<ir::function_type*>(ty)){\n     Type *ret_ty = cvt(tt->get_return_ty());\n@@ -266,7 +275,8 @@ void generator::visit_value(ir::value* v) {\n     builder_->SetInsertPoint(&*current->getFirstNonPHI());\n   // visit user\n   if(auto *usr = dynamic_cast<ir::user*>(v)){\n-    usr->accept(this);\n+    if(!dynamic_cast<ir::function*>(usr))\n+      usr->accept(this);\n   }\n   // revert insert point\n   if(phi && !current->empty() && current->getFirstNonPHI())\n@@ -282,6 +292,81 @@ void generator::visit_phi_node(ir::phi_node* x) {\n     vals_[x][idx] = phi(ty, x->get_num_operands());\n }\n \n+/**\n+ * \\brief Code Generation for `call`\n+ */\n+void generator::visit_call_inst(ir::call_inst* call) {\n+  throw std::runtime_error(\"call not supported! Triton should be inlining everything.\");\n+}\n+\n+void generator::visit_launch_inst(ir::launch_inst *launch) {\n+  ir::function* fn = (ir::function*)launch->get_operand(0);\n+  // forward-declare cudaGetParameterBufferV2\n+  std::vector<Type*> get_param_arg_tys = {PointerType::get(builder_->getInt8Ty(), 0),\n+                                           ArrayType::get(builder_->getInt32Ty(), 3),\n+                                           ArrayType::get(builder_->getInt32Ty(), 3),\n+                                           builder_->getInt32Ty()};\n+  FunctionType* get_param_ty = FunctionType::get(PointerType::get(builder_->getInt8Ty(), 0), get_param_arg_tys, false);\n+  Function* get_param_buffer = Function::Create(get_param_ty, Function::ExternalLinkage, \"cudaGetParameterBufferV2\", mod_);\n+  AllocaInst* grid = builder_->CreateAlloca(get_param_arg_tys[1]);\n+  AllocaInst* block = builder_->CreateAlloca(get_param_arg_tys[2]);\n+  ConstantInt* _0 = builder_->getInt32(0);\n+  ConstantInt* _1 = builder_->getInt32(1);\n+  ConstantInt* _2 = builder_->getInt32(2);\n+  // create basic block\n+  BasicBlock* launch_done_bb = BasicBlock::Create(builder_->getContext(), \"launch_done\", builder_->GetInsertBlock()->getParent());\n+  BasicBlock* launch_bb = BasicBlock::Create(builder_->getContext(), \"launch\", launch_done_bb->getParent(), launch_done_bb);\n+  Value *tid = tgt_->get_local_id(mod_, *builder_, 0);\n+  Value *is_first_thread = builder_->CreateICmpEQ(tid, i32(0));\n+  builder_->CreateCondBr(is_first_thread, launch_bb, launch_done_bb);\n+  builder_->SetInsertPoint(launch_bb);\n+\n+  //\n+  builder_->CreateStore(vals_[launch->get_grid()[0]][{}], builder_->CreateGEP(grid, {_0, _0}));\n+  builder_->CreateStore(vals_[launch->get_grid()[1]][{}], builder_->CreateGEP(grid, {_0, _1}));\n+  builder_->CreateStore(vals_[launch->get_grid()[2]][{}], builder_->CreateGEP(grid, {_0, _2}));\n+  Value* num_warps = mul(builder_->getInt32(32), vals_[launch->get_num_warps()][{}]);\n+  builder_->CreateStore(num_warps, builder_->CreateGEP(block, {_0, _0}));\n+  builder_->CreateStore(builder_->getInt32(1), builder_->CreateGEP(block, {_0, _1}));\n+  builder_->CreateStore(builder_->getInt32(1), builder_->CreateGEP(block, {_0, _2}));\n+  Function* called_fn = fns_[fn];\n+  Value* callee = ConstantExpr::getCast(Instruction::BitCast, called_fn, get_param_arg_tys[0]);\n+  Value* arg_ptr = builder_->CreateCall(get_param_buffer, {callee, builder_->CreateLoad(grid), builder_->CreateLoad(block), builder_->getInt32(0)});\n+  // forwrd-declare cudaLaunchDeviceV2\n+  std::vector<Type*> launch_device_arg_tys = {get_param_ty->getReturnType(), builder_->getInt64Ty()};\n+  FunctionType* launch_device_ty = FunctionType::get(builder_->getInt32Ty(), launch_device_arg_tys, false);\n+  Function* launch_device = Function::Create(launch_device_ty, Function::ExternalLinkage, \"cudaLaunchDeviceV2\", mod_);\n+  // TODO: add branch\n+  Value* do_not_launch = builder_->CreateICmpEQ(builder_->CreatePtrToInt(arg_ptr, builder_->getInt64Ty()),\n+                                                builder_->getInt64(0));\n+  BasicBlock* launch2_bb = BasicBlock::Create(builder_->getContext(), \"launch2\", launch_done_bb->getParent(), launch_done_bb);\n+  builder_->CreateCondBr(do_not_launch, launch_done_bb, launch2_bb);\n+  builder_->SetInsertPoint(launch2_bb);\n+\n+  unsigned addr_space = arg_ptr->getType()->getPointerAddressSpace();\n+  unsigned off = 0;\n+  unsigned last_size = 0;\n+  for(ir::value* arg: launch->get_values()){\n+    Value* curr_arg = vals_[arg][{}];\n+    Type* curr_arg_ty = curr_arg->getType();\n+    // handle struct alignment\n+    off += last_size;\n+    unsigned size = curr_arg_ty->isPointerTy() ? 8 : curr_arg_ty->getPrimitiveSizeInBits() / 8;\n+    off = (off + size - 1) / size * size;\n+    // get pointer to current arg\n+    Value* curr_arg_ptr = builder_->CreateGEP(arg_ptr, builder_->getInt32(off));\n+    curr_arg_ptr = builder_->CreateBitCast(curr_arg_ptr, curr_arg_ty->getPointerTo(addr_space));\n+    // store arg\n+    builder_->CreateStore(curr_arg, curr_arg_ptr);\n+    last_size = size;\n+  }\n+  builder_->CreateCall(launch_device, {arg_ptr, builder_->getInt64(0)});\n+  builder_->CreateBr(launch_done_bb);\n+  // done\n+  builder_->SetInsertPoint(launch_done_bb);\n+\n+}\n+\n /**\n  * \\brief Code Generation for `binary_operator`\n  */\n@@ -311,6 +396,7 @@ void generator::visit_binary_operator(ir::binary_operator*x) {\n       default: throw std::runtime_error(\"unreachable switch\");\n     }\n   };\n+//  x->print(std::cout);\n   for(indices_t idx: idxs_.at(x)){\n     Value *lhs = vals_[x->get_operand(0)][idx];\n     Value *rhs = vals_[x->get_operand(1)][idx];\n@@ -852,6 +938,31 @@ void generator::visit_masked_store_inst(ir::masked_store_inst* x) {\n   visit_store_inst(x);\n }\n \n+// --\n+\n+void generator::visit_extract_value_inst(ir::extract_value_inst *x) {\n+  auto idxs    = idxs_.at(x);\n+  ir::value* agg = x->get_operand(0);\n+  unsigned insert_idx = x->get_idx();\n+  for(size_t i = 0; i < idxs.size(); i++){\n+    auto idx = idxs[i];\n+    vals_[x][idx] = builder_->CreateExtractValue(vals_[agg][idx], {insert_idx});\n+  }\n+}\n+\n+\n+void generator::visit_insert_value_inst(ir::insert_value_inst *x){\n+  auto idxs    = idxs_.at(x);\n+  ir::value* agg = x->get_operand(0);\n+  ir::value* val = x->get_operand(1);\n+  unsigned insert_idx = x->get_idx();\n+  for(size_t i = 0; i < idxs.size(); i++){\n+    auto idx = idxs[i];\n+    vals_[x][idx] = builder_->CreateInsertValue(vals_[agg][idx], vals_[val][idx],{insert_idx});\n+  }\n+}\n+\n+// --\n /**\n  * \\brief Code Generation for `cat`\n  */\n@@ -2686,7 +2797,8 @@ void generator::visit_make_range(ir::make_range* x) {\n }\n \n void generator::visit_undef_value(ir::undef_value *x) {\n-  Type* ty = cvt(x->get_type()->get_scalar_ty());\n+  ir::type* sca_ty = x->get_type()->get_scalar_ty();\n+  Type* ty = cvt(sca_ty);\n   for(indices_t idx: idxs_.at(x))\n     vals_[x][idx] = llvm::UndefValue::get(ty);\n }\n@@ -2713,8 +2825,7 @@ void generator::visit_alloc_const(ir::alloc_const *alloc) {\n }\n \n \n-void generator::visit_function(ir::function* fn) {\n-  LLVMContext &ctx = builder_->getContext();\n+void generator::forward_declare(ir::function* fn){\n   FunctionType *fn_ty = (FunctionType*)cvt(fn->get_fn_type());\n   if(!tgt_->is_gpu()){\n     Type *fn_ret_ty = fn_ty->getReturnType();\n@@ -2727,6 +2838,18 @@ void generator::visit_function(ir::function* fn) {\n     fn_ty = FunctionType::get(fn_ret_ty, fn_args_ty, false);\n   }\n   Function *ret = Function::Create(fn_ty, Function::ExternalLinkage, fn->get_name(), mod_);\n+  fns_[fn] = ret;\n+}\n+\n+void generator::visit_function(ir::function* fn) {\n+  idxs_.clear();\n+  vals_.clear();\n+  seen_.clear();\n+  LLVMContext &ctx = builder_->getContext();\n+\n+  Function* ret = fns_[fn];\n+\n+\n   // set attributes\n   for(auto attr_pair: fn->attrs()){\n     unsigned id = attr_pair.first;\n@@ -2751,7 +2874,8 @@ void generator::visit_function(ir::function* fn) {\n   for(unsigned i = 0; i < fn->args().size(); i++)\n     vals_[fn->args()[i]][{}] = &*(ret->arg_begin() + i);\n   // create blocks\n-  for(ir::basic_block *block: fn->blocks()) {\n+  auto blocks = ir::cfg::reverse_post_order(fn);\n+  for(ir::basic_block *block: blocks) {\n     BasicBlock *dst_block = BasicBlock::Create(ctx, block->get_name(), ret);\n     bbs_[block] = dst_block;\n   }\n@@ -2761,7 +2885,7 @@ void generator::visit_function(ir::function* fn) {\n     visit_layout(x.second);\n   }\n   // generate LLVM-IR code\n-  for(ir::basic_block *block: fn->blocks())\n+  for(ir::basic_block *block: blocks)\n     visit_basic_block(block);\n   // finalize\n   finalize_function(fn);\n@@ -2982,10 +3106,12 @@ void generator::visit_layout_shared(analysis::shared_layout* layout) {\n }\n \n void generator::visit_basic_block(ir::basic_block * block) {\n+\n   BasicBlock *parent = bbs_[block];\n   builder_->SetInsertPoint(parent);\n-  for(ir::instruction *i: block->get_inst_list())\n+  for(ir::instruction *i: block->get_inst_list()){\n     visit_value(i);\n+  }\n   // Update ir bb -> llvm bb mapping\n   bbs_[block] = builder_->GetInsertBlock();\n }\n@@ -3168,6 +3294,12 @@ void generator::finalize_phi_node(ir::phi_node *x) {\n   }\n }\n \n+StructType* generator::packed_type(ir::value* i){\n+  Type* dtype = cvt(i->get_type()->get_tile_element_ty());\n+  auto* layout = dynamic_cast<analysis::scanline_layout*>(layouts_->get(i));\n+  assert(layout);\n+}\n+\n void generator::visit(ir::module &src, llvm::Module &dst) {\n   mod_ = &dst;\n   ctx_ = &dst.getContext();\n@@ -3184,7 +3316,16 @@ void generator::visit(ir::module &src, llvm::Module &dst) {\n                          nullptr, \"__shared_ptr\", nullptr, GlobalVariable::NotThreadLocal, 3);\n     shmem_ = bit_cast(sh_mem_array, ptr_ty);\n   }\n+  // instantiate device functions\n+//  for(ir::function *fn: src.get_function_list())\n+//  for(ir::basic_block *bb: fn->blocks())\n+//  for(ir::instruction *i: bb->get_inst_list())\n+//  if(auto *call = dynamic_cast<ir::call_inst*>(i)){\n+//    std::cout << \"call??\" << std::endl;\n+//  }\n   // visit functions\n+  for(ir::function *fn: src.get_function_list())\n+    forward_declare(fn);\n   for(ir::function *fn: src.get_function_list())\n     visit_function(fn);\n }"}, {"filename": "lib/codegen/transform/dce.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -3,6 +3,7 @@\n #include \"triton/ir/basic_block.h\"\n #include \"triton/ir/module.h\"\n #include \"triton/ir/utils.h\"\n+#include <iostream>\n \n namespace triton {\n namespace codegen{\n@@ -28,6 +29,8 @@ void dce::run(ir::module &mod) {\n         case ir::INST_ATOMIC_CAS:\n         case ir::INST_ATOMIC_RMW:\n         case ir::INST_ATOMIC_EXCH:\n+        case ir::INST_CALL:\n+        case ir::INST_LAUNCH:\n         case ir::INST_BARRIER: {\n           work_list.push_back(i);\n           marked.insert(i);\n@@ -65,6 +68,7 @@ void dce::run(ir::module &mod) {\n     }\n   }\n \n+\n   // delete\n   for(ir::instruction* i: to_delete)\n     i->erase_from_parent();"}, {"filename": "lib/codegen/transform/inline.cc", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "file_content_changes": "@@ -0,0 +1,127 @@\n+#include <iostream>\n+#include \"triton/codegen/transform/inline.h\"\n+#include \"triton/ir/module.h\"\n+#include \"triton/ir/function.h\"\n+#include \"triton/ir/utils.h\"\n+\n+namespace triton{\n+namespace codegen{\n+namespace transform{\n+\n+\n+bool fncmp::operator()(ir::function* x, ir::function* y) const {\n+  auto fn_list = x->get_parent()->get_function_list();\n+  return std::find(fn_list.begin(), fn_list.end(), x) < std::find(fn_list.begin(), fn_list.end(), y);\n+};\n+\n+void inliner::do_inline(ir::function* fn, ir::call_inst* callsite, ir::builder& builder,\n+                        std::list<ir::call_inst*>& callsites){\n+  ir::basic_block* parent_block = callsite->get_parent();\n+  ir::function* parent_fn = parent_block->get_parent();\n+   // the parent block is split into block A and block B:\n+  //   - block A (`new_blocks[0]`) is the entry block of the inlined function\n+  //   - block B (`exit`) resumes execution of the parent function\n+  ir::basic_block* entry = parent_block->split_before(callsite, fn->get_name());\n+  ir::basic_block* exit = entry->get_successors()[0];\n+  std::vector<ir::basic_block*> new_blocks = {entry};\n+  for(size_t i = 1; i < fn->blocks().size(); i++){\n+   ir::basic_block* block = fn->blocks()[i];\n+   ir::context& ctx = block->get_context();\n+   const std::string& name = block->get_parent()->get_name() + \"_\" + block->get_name();\n+   new_blocks.push_back(ir::basic_block::create(ctx, name, parent_fn));\n+  }\n+  // a phi node holds the return values of the inlined function\n+  if(exit->get_inst_list().empty())\n+    builder.set_insert_point(exit);\n+  else\n+    builder.set_insert_point(exit->get_first_non_phi());\n+  ir::phi_node* exit_val = builder.create_phi(fn->get_fn_type()->get_return_ty(), 0);\n+  callsite->replace_all_uses_with(exit_val);\n+  callsite->erase_from_parent();\n+  // get arguments `fn` is called with\n+  std::vector<ir::value*> tgt_args(callsite->op_begin(), callsite->op_end());\n+  std::vector<ir::argument*> src_args(fn->args().begin(), fn->args().end());\n+  // Actually generate the instructions:\n+  // - Remove the branch created by basic_block::split_before\n+  // - Clone all instructions\n+  // - Replace `ret` with incoming nodes to `exit_val` and branches to `exit`\n+  ir::instruction* terminator = new_blocks[0]->get_inst_list().back();\n+//  new_blocks[0]->get_inst_list().back()->erase_from_parent();\n+  terminator->erase_from_parent();\n+  std::map<ir::instruction*, ir::instruction*> inst_map;\n+  std::map<ir::argument*, ir::value*> arg_map;\n+  for(size_t k = 0; k < fn->args().size(); k++)\n+    arg_map[fn->args()[k]] = callsite->ops()[k];\n+  std::vector<ir::basic_block*> rpo = ir::cfg::reverse_post_order(fn);\n+  for(size_t i = 0; i < new_blocks.size(); i++){\n+    ir::basic_block* old_block = fn->blocks()[i];\n+    ir::basic_block* new_block = new_blocks[i];\n+    builder.set_insert_point(new_block);\n+    for(ir::instruction* old_inst: old_block->get_inst_list()){\n+      // clone instruction\n+      ir::instruction* new_inst = old_inst->clone();\n+      // replace basic block\n+      for(size_t k = 0; k < new_blocks.size(); k++)\n+        new_inst->replace_uses_of_with(fn->blocks()[k], new_blocks[k]);\n+      // replace values\n+      for(size_t k = 0; k < new_inst->get_num_operands(); k++){\n+        ir::value* op = new_inst->get_operand(k);\n+        if(auto arg_op = dynamic_cast<ir::argument*>(op))\n+          new_inst->set_operand(k, arg_map.at(arg_op));\n+        if(auto inst_op = dynamic_cast<ir::instruction*>(op))\n+          if(inst_map.find(inst_op) != inst_map.end())\n+            new_inst->set_operand(k, inst_map.at(inst_op));\n+      }\n+       // `ret` instruction is a special case:\n+      // instead of returning we need to branch to after the function call\n+      if(ir::return_inst* ret = dynamic_cast<ir::return_inst*>(new_inst)){\n+        if(ir::value* ret_val = ret->get_return_value())\n+          exit_val->add_incoming(ret_val, new_block);\n+        new_inst = ir::branch_inst::create(exit);\n+      }\n+      inst_map[old_inst] = new_inst;\n+      builder.insert(new_inst);\n+    }\n+  }\n+  if(exit_val->get_num_incoming() == 1)\n+    exit_val->replace_all_uses_with(exit_val->get_incoming_value(0));\n+  // done -- make sure insert point is properly set to exit block\n+  builder.set_insert_point(exit);\n+}\n+\n+void inliner::run(ir::module &mod) {\n+\n+  // gather all call sites\n+  while(true){\n+    std::map<ir::function*, size_t> counts;\n+    for(ir::function* fn: mod.get_function_list())\n+      counts[fn] = 0;\n+\n+    std::list<ir::call_inst*> callsites;\n+    for(ir::function* fn: mod.get_function_list()){\n+      for(ir::basic_block* block: fn->blocks())\n+      for(ir::instruction* instr: block->get_inst_list())\n+      if(ir::call_inst* call = dynamic_cast<ir::call_inst*>(instr)){\n+        callsites.push_back(call);\n+        counts[call->get_fn()] += 1;\n+      }\n+    }\n+\n+    for(auto& count: counts){\n+      if(!count.first->get_is_kernel() && count.second == 0)\n+        count.first->get_parent()->remove_function(count.first);\n+    }\n+\n+    if(callsites.empty())\n+      break;\n+\n+    for(ir::call_inst* call: callsites)\n+      do_inline(call->get_fn(), call, mod.get_builder(), callsites);\n+  }\n+\n+\n+}\n+\n+}\n+}\n+}"}, {"filename": "lib/codegen/transform/peephole.cc", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "file_content_changes": "@@ -150,32 +150,53 @@ bool peephole::rewrite_unit_red(ir::instruction *value, ir::builder& builder){\n }\n \n bool peephole::rewrite_mult(ir::instruction *value, ir::builder& builder) {\n-    auto binop = dynamic_cast<ir::binary_operator*>(value);\n-    if(binop && binop->get_op() == ir::binary_op_t::Mul) {\n-      ir::value *lhs = binop->get_operand(0);\n-      ir::value *rhs = binop->get_operand(1);\n-      ir::constant_int *_1_lhs = nullptr;\n-      if(ir::splat_inst *splat = dynamic_cast<ir::splat_inst*>(lhs)){\n-        auto *cst = dynamic_cast<ir::constant_int*>(splat->get_operand(0));\n-        if(cst && cst->get_value() == 1)\n-          _1_lhs = cst;\n-      }\n-      ir::constant_int *_1_rhs = nullptr;\n-      if(ir::splat_inst *splat = dynamic_cast<ir::splat_inst*>(rhs)){\n-        auto *cst = dynamic_cast<ir::constant_int*>(splat->get_operand(0));\n-        if(cst && cst->get_value() == 1)\n-          _1_rhs = cst;\n-      }\n-      if(_1_lhs){\n-        binop->replace_all_uses_with(rhs);\n-        return true;\n-      }\n-      else if(_1_rhs){\n-        binop->replace_all_uses_with(lhs);\n-        return true;\n-      }\n+  auto binop = dynamic_cast<ir::binary_operator*>(value);\n+  if(binop && binop->get_op() == ir::binary_op_t::Mul) {\n+    ir::value *lhs = binop->get_operand(0);\n+    ir::value *rhs = binop->get_operand(1);\n+    ir::constant_int *_1_lhs = nullptr;\n+    if(ir::splat_inst *splat = dynamic_cast<ir::splat_inst*>(lhs)){\n+      auto *cst = dynamic_cast<ir::constant_int*>(splat->get_operand(0));\n+      if(cst && cst->get_value() == 1)\n+        _1_lhs = cst;\n+    }\n+    ir::constant_int *_1_rhs = nullptr;\n+    if(ir::splat_inst *splat = dynamic_cast<ir::splat_inst*>(rhs)){\n+      auto *cst = dynamic_cast<ir::constant_int*>(splat->get_operand(0));\n+      if(cst && cst->get_value() == 1)\n+        _1_rhs = cst;\n+    }\n+    if(_1_lhs){\n+      binop->replace_all_uses_with(rhs);\n+      return true;\n+    }\n+    else if(_1_rhs){\n+      binop->replace_all_uses_with(lhs);\n+      return true;\n     }\n+  }\n+  return false;\n+}\n+\n+bool peephole::rewrite_insert_extract(ir::instruction *value, ir::builder& builder){\n+  auto extracted = dynamic_cast<ir::extract_value_inst*>(value);\n+  if(!extracted)\n     return false;\n+  size_t extract_idx = extracted->get_idx();\n+  ir::value* agg = extracted->get_operand(0);\n+  auto insert = dynamic_cast<ir::insert_value_inst*>(agg);\n+  while(insert){\n+    agg = insert->get_operand(0);\n+    ir::value* inserted = insert->get_operand(1);\n+    size_t insert_idx = insert->get_idx();\n+    insert = dynamic_cast<ir::insert_value_inst*>(agg);\n+    if(extract_idx == insert_idx){\n+      extracted->replace_all_uses_with(inserted);\n+      return true;\n+    }\n+    insert = dynamic_cast<ir::insert_value_inst*>(agg);\n+  }\n+  return false;\n }\n \n \n@@ -291,6 +312,7 @@ void peephole::run(ir::module &mod) {\n       was_modified = was_modified || rewrite_mult(i, builder);\n       // was_modified = was_modified || rewrite_cts_cfs(i, builder);\n //      was_modified = was_modified || rewrite_trans_phi(i, builder);\n+      was_modified = was_modified || rewrite_insert_extract(i, builder);\n       was_modified = was_modified || rewrite_unit_red(i, builder);\n       was_modified = was_modified || rewrite_gep_ptr_min_off_plus_off(i, builder);\n       // TODO: DOESN'T WORK FOR VECTORIZED MASKED LOAD"}, {"filename": "lib/codegen/transform/pipeline.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -134,6 +134,7 @@ void pipeline::run(ir::module &mod) {\n   ir::builder &builder = mod.get_builder();\n   const int num_stages = num_stages_;\n   std::vector<std::pair<ir::phi_node*, std::vector<ir::value*>>> preheader_loads; // Used to reorder loads\n+\n   for(auto info: to_pipeline){\n     ir::load_inst* load = info.load;\n     ir::phi_node* ptr   = info.ptr;"}, {"filename": "lib/driver/dispatch.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -138,6 +138,7 @@ CUDA_DEFINE3(CUresult, cuDeviceGetAttribute, int *, CUdevice_attribute, CUdevice\n CUDA_DEFINE1(CUresult, cuDeviceGetCount, int*)\n \n // link management\n+CUDA_DEFINE6(CUresult, cuLinkAddFile_v2, CUlinkState, CUjitInputType, const char *, unsigned int , CUjit_option *, void **);\n CUDA_DEFINE8(CUresult, cuLinkAddData_v2, CUlinkState, CUjitInputType, void*, size_t, const char*, unsigned int, CUjit_option*, void**);\n CUDA_DEFINE4(CUresult, cuLinkCreate_v2, unsigned int, CUjit_option*, void**, CUlinkState*);\n CUDA_DEFINE1(CUresult, cuLinkDestroy, CUlinkState);"}, {"filename": "lib/driver/error.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -90,7 +90,7 @@ void check(CUresult err)\n   case CUDA_ERROR_NOT_PERMITTED                  : throw not_permitted();\n   case CUDA_ERROR_NOT_SUPPORTED                  : throw not_supported();\n   case CUDA_ERROR_UNKNOWN                        : throw unknown();\n-  default                                        : throw unknown();\n+  default                                        : throw std::runtime_error(\"unimplemented code: \" + std::to_string(err));\n   }\n }\n "}, {"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -174,6 +174,7 @@ std::string llir_to_ptx(llvm::Module* module, int cc, int version){\n   init_llvm();\n   // verify and store llvm\n   llvm::legacy::PassManager pm;\n+//  pm.add(llvm::createPrintModulePass(llvm::outs()));\n   pm.add(llvm::createVerifierPass());\n   pm.run(*module);\n   // module->print(llvm::outs(), nullptr);\n@@ -213,6 +214,7 @@ std::string llir_to_ptx(llvm::Module* module, int cc, int version){\n   return result;\n }\n \n+\n std::string ptx_to_cubin(const std::string& ptx, const std::string& ptxas, int cc) {\n   // compile ptx with ptxas\n   char _fsrc[L_tmpnam];"}, {"filename": "lib/ir/basic_block.cc", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "file_content_changes": "@@ -1,3 +1,5 @@\n+#include <iostream>\n+#include <algorithm>\n #include \"triton/ir/basic_block.h\"\n #include \"triton/ir/instructions.h\"\n #include \"triton/ir/type.h\"\n@@ -9,23 +11,68 @@ namespace ir {\n class phi_node;\n \n \n-basic_block::basic_block(context &ctx, const std::string &name, function *parent):\n+basic_block::basic_block(context &ctx, const std::string &name, function *parent, basic_block* next):\n     value(type::get_label_ty(ctx), name), ctx_(ctx), parent_(parent) {\n   if(parent_)\n-    parent_->insert_block(this);\n+    parent_->insert_block(this, next);\n }\n \n-basic_block* basic_block::create(context &ctx, const std::string &name, function *parent){\n-  return new basic_block(ctx, name, parent);\n+basic_block* basic_block::create(context &ctx, const std::string &name, function *parent, basic_block* next){\n+  return new basic_block(ctx, name, parent, next);\n }\n \n-void basic_block::add_predecessor(basic_block *pred) {\n-  preds_.push_back(pred);\n-  if(pred)\n-    pred->succs_.push_back(this);\n+void basic_block::replace_phi_uses_with(basic_block* before, basic_block* after) {\n+  for(ir::instruction* i: inst_list_){\n+    auto* curr_phi = dynamic_cast<ir::phi_node*>(i);\n+    if(!curr_phi)\n+      break;\n+    curr_phi->replace_uses_of_with(before, after);\n+  }\n+}\n+\n+void basic_block::append_instruction(ir::instruction* i){\n+  i->set_parent(this);\n+  inst_list_.push_back(i);\n }\n \n+basic_block* basic_block::split_before(ir::instruction* loc, const std::string& name) {\n+  basic_block* ret = basic_block::create(ctx_, name, parent_, this);\n+  ret->set_name(get_name());\n+  set_name(\"after_\" + name);\n \n+  // splice instruction list\n+  auto loc_it = std::find(inst_list_.begin(), inst_list_.end(), loc);\n+  ret->get_inst_list().splice(ret->get_inst_list().begin(), inst_list_, inst_list_.begin(), loc_it);\n+  for(ir::instruction* i: ret->get_inst_list())\n+    i->set_parent(ret);\n+  // the predecessors of `this` becomes the predecessors of `ret`\n+  for(ir::basic_block* pred: get_predecessors()){\n+    auto* term = dynamic_cast<ir::terminator_inst*>(pred->get_inst_list().back());\n+    assert(term);\n+    term->replace_uses_of_with(this, ret);\n+    replace_phi_uses_with(pred, ret);\n+  }\n+  ir::branch_inst* br = branch_inst::create(this);\n+  ret->append_instruction(br);\n+  return ret;\n+}\n+\n+std::vector<basic_block*> basic_block::get_predecessors() const {\n+  std::vector<basic_block*> ret;\n+  for(ir::user* u: users_)\n+    if(auto term = dynamic_cast<ir::terminator_inst*>(u))\n+      ret.push_back(term->get_parent());\n+  return ret;\n+}\n+\n+std::vector<basic_block*> basic_block::get_successors() const {\n+  std::vector<basic_block*> ret;\n+  for(ir::instruction* i: inst_list_)\n+  for(ir::value* v: i->ops())\n+    if(auto block = dynamic_cast<ir::basic_block*>(v))\n+      ret.push_back(block);\n+  return ret;\n+}\n \n basic_block::iterator basic_block::get_first_non_phi(){\n   auto it = begin();"}, {"filename": "lib/ir/builder.cc", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "file_content_changes": "@@ -117,20 +117,21 @@ type *builder::get_double_ty()\n //===----------------------------------------------------------------------===//\n \n value* builder::create_br(basic_block *dest){\n-  dest->add_predecessor(block_);\n   return insert(branch_inst::create(dest));\n }\n \n value* builder::create_cond_br(value *cond, basic_block *if_dest, basic_block *else_dest){\n-  if_dest->add_predecessor(block_);\n-  else_dest->add_predecessor(block_);\n   return insert(branch_inst::create(cond, if_dest, else_dest));\n }\n \n value *builder::create_ret_void() {\n   return insert(return_inst::create(ctx_));\n }\n \n+value *builder::create_ret(value* val) {\n+  return insert(return_inst::create(ctx_, val));\n+}\n+\n //===----------------------------------------------------------------------===//\n //                               cast instructions\n //===----------------------------------------------------------------------===//\n@@ -163,6 +164,19 @@ phi_node* builder::create_phi(type *ty, unsigned num_reserved){\n   return insert(phi_node::create(ty, num_reserved));\n }\n \n+//===----------------------------------------------------------------------===//\n+//                               call instructions\n+//===----------------------------------------------------------------------===//\n+\n+value *builder::create_call(function* fn, const std::vector<value*>& args){\n+  return insert(call_inst::create(fn, args));\n+}\n+\n+value* builder::create_launch(function* fn, const std::vector<value*>& args, const std::vector<value*>& grid, value* num_warps){\n+  return insert(launch_inst::create(fn, args, grid, num_warps));\n+\n+}\n+\n //===----------------------------------------------------------------------===//\n //                               binary float instructions\n //===----------------------------------------------------------------------===//\n@@ -307,6 +321,19 @@ value *builder::create_masked_store(value *ptr, value *val, value *mask){\n   return insert(masked_store_inst::create(ptr, val, mask));\n }\n \n+//===----------------------------------------------------------------------===//\n+//                               struct instructions\n+//===----------------------------------------------------------------------===//\n+\n+\n+// Struct instructions\n+value *builder::create_insert_value(value* val, value *elt, size_t idx){\n+  return insert(insert_value_inst::create(val, elt, idx));\n+}\n+\n+value *builder::create_extract_value(value* val, size_t idx) {\n+  return insert(extract_value_inst::create(val, idx));\n+}\n //===----------------------------------------------------------------------===//\n //                               block instructions\n //===----------------------------------------------------------------------===//"}, {"filename": "lib/ir/dispatch.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -865,6 +865,9 @@ ir::value *dispatch::clock(ir::builder *builder) {\n \n }\n \n+//===----------------------------------------------------------------------===//\n+//                               Control FLow\n+//===----------------------------------------------------------------------===//\n //\n \n ir::value *dispatch::multiple_of(ir::value *x, int value, ir::builder *){"}, {"filename": "lib/ir/function.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -33,8 +33,10 @@ void argument::accept(visitor *v) {\n /* function */\n function::function(function_type *ty, linkage_types_t linkage,\n                    const std::string &name, module *parent)\n-    : global_object(ty, 0, linkage, name), parent_(parent), fn_ty_(ty) {\n+    : global_object(ty, 0, linkage, name), parent_(parent), fn_ty_(ty), is_kernel_(false) {\n   unsigned num_params = fn_ty_->get_num_params();\n+  if(parent)\n+    parent->push_function(this);\n   // skip if no parameter\n   if(num_params == 0)\n     return;\n@@ -44,8 +46,6 @@ function::function(function_type *ty, linkage_types_t linkage,\n     type *param_ty = fn_ty_->get_param_ty(i);\n     args_[i] = argument::create(param_ty, \"\", this, i);\n   }\n-  if(parent)\n-    parent->push_function(this);\n }\n \n /* basic block */"}, {"filename": "lib/ir/instructions.cc", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "file_content_changes": "@@ -5,6 +5,7 @@\n #include \"triton/ir/instructions.h\"\n #include \"triton/ir/constant.h\"\n #include \"triton/ir/type.h\"\n+#include \"triton/ir/function.h\"\n \n namespace triton{\n namespace ir{\n@@ -79,6 +80,70 @@ phi_node* phi_node::create(type *ty, unsigned num_reserved, const std::string &n\n   return new phi_node(ty, num_reserved, name, next);\n }\n \n+//===----------------------------------------------------------------------===//\n+//                               call_inst classes\n+//===----------------------------------------------------------------------===//\n+\n+std::string call_inst::repr_impl() const { return \"call \" + fn_->get_name(); }\n+\n+call_inst::call_inst(ir::function* fn, const std::vector<ir::value*>& values, const std::string& name, instruction* next)\n+  : instruction(fn->get_fn_type()->get_return_ty(), INST_CALL, values.size(), name, next), fn_(fn){\n+  for(size_t i = 0; i < values.size(); i++)\n+    set_operand(i, values.at(i));\n+}\n+\n+call_inst* call_inst::create(ir::function* fn, const std::vector<ir::value*>& values, const std::string &name, instruction *next) {\n+  return new call_inst(fn, values, name, next);\n+}\n+\n+\n+// launch\n+\n+launch_inst::launch_inst(ir::function* fn, const std::vector<ir::value*>& values, const std::vector<ir::value*>& grid, ir::value* num_warps, const std::string& name, instruction* next)\n+  : instruction(fn->get_fn_type()->get_return_ty(), INST_LAUNCH, 1 + values.size() + grid.size() + 1, name, next){\n+  int k = 0;\n+  if(grid.size() != 3)\n+    throw std::runtime_error(\"grid must have 3 elements\");\n+  set_operand(k++, fn);\n+  val_begin = k;\n+  for(ir::value* v: values)\n+    set_operand(k++, v);\n+  val_end = k;\n+  grid_begin = k;\n+  for(ir::value* g: grid)\n+    set_operand(k++, g);\n+  grid_end = k;\n+  set_operand(k++, num_warps);\n+}\n+\n+\n+ir::function* launch_inst::get_fn() {\n+  return (ir::function*)get_operand(0);\n+}\n+\n+std::vector<ir::value*> launch_inst::get_values() {\n+  std::vector<ir::value*> ret;\n+  for(int i = val_begin; i < val_end; i++)\n+    ret.push_back(get_operand(i));\n+  return ret;\n+}\n+\n+std::vector<ir::value*> launch_inst::get_grid() {\n+  std::vector<ir::value*> ret;\n+  for(int i = grid_begin; i < grid_end; i++)\n+    ret.push_back(get_operand(i));\n+  return ret;\n+}\n+\n+ir::value* launch_inst::get_num_warps() {\n+  return get_operand(grid_end);\n+}\n+\n+\n+launch_inst* launch_inst::create(ir::function *fn, const std::vector<ir::value *> &values, const std::vector<ir::value *> &grid, ir::value *num_warps, const std::string &name, instruction *next) {\n+ return new launch_inst(fn, values, grid, num_warps, name, next);\n+}\n+\n \n //===----------------------------------------------------------------------===//\n //                               binary_operator classes\n@@ -324,7 +389,7 @@ cast_inst *cast_inst::create_integer_cast(value *arg, type *ty, bool is_signed,\n \n // return_inst\n return_inst::return_inst(context &ctx, value *ret_val, instruction *next)\n-    : terminator_inst(type::get_void_ty(ctx), INST_RETURN, ret_val!=nullptr, \"\", next){\n+    : terminator_inst(ret_val?ret_val->get_type():type::get_void_ty(ctx), INST_RETURN, ret_val!=nullptr, \"\", next){\n   if(ret_val)\n     set_operand(0, ret_val);\n }\n@@ -521,6 +586,36 @@ masked_store_inst::masked_store_inst(value *ptr, value *val, value *mask,\n masked_store_inst* masked_store_inst::create(value *ptr, value *val, value *mask, const std::string &name, instruction *next)  {\n   return new masked_store_inst(ptr, val, mask, name, next);\n }\n+\n+//===----------------------------------------------------------------------===//\n+//                               struct classes\n+//===----------------------------------------------------------------------===//\n+\n+// insert value\n+\n+insert_value_inst::insert_value_inst(value *val, value *elt, size_t idx, const std::string& name, instruction *next)\n+  : instruction(val->get_type(), INST_INSERT_VALUE, 2, name, next), idx_(idx) {\n+  set_operand(0, val);\n+  set_operand(1, elt);\n+}\n+\n+insert_value_inst* insert_value_inst::create(value *val, value *elt, size_t idx, const std::string& name, instruction *next){\n+  return new insert_value_inst(val, elt, idx, name, next);\n+}\n+\n+\n+// extract value\n+\n+extract_value_inst::extract_value_inst(value *val, size_t idx, const std::string& name, instruction *next)\n+  : instruction(val->get_type()->get_struct_type(idx), INST_EXTRACT_VALUE, 1, name, next), idx_(idx) {\n+  set_operand(0, val);\n+}\n+\n+extract_value_inst* extract_value_inst::create(value *val, size_t idx, const std::string& name, instruction *next){\n+  return new extract_value_inst(val, idx, name, next);\n+}\n+\n+\n //===----------------------------------------------------------------------===//\n //                               retile_inst classes\n //===----------------------------------------------------------------------===//\n@@ -575,6 +670,9 @@ instruction* downcast_inst::create(value *arg, const std::string &name, instruct\n   return new downcast_inst(arg->get_type()->get_scalar_ty(), INST_DOWNCAST, arg, name, next);\n }\n \n+\n+\n+\n //===----------------------------------------------------------------------===//\n //                               matmul_inst classes\n //===----------------------------------------------------------------------===//"}, {"filename": "lib/ir/module.cc", "status": "modified", "additions": 47, "deletions": 38, "changes": 85, "file_content_changes": "@@ -9,17 +9,12 @@\n namespace triton{\n namespace ir{\n \n-/* Module */\n-module::module(const std::string &name, builder &builder)\n-  : name_(name), builder_(builder) {\n+/* */\n+value_constructor::value_constructor(ir::builder& builder): builder_(builder){\n   sealed_blocks_.insert(nullptr);\n }\n \n-ir::builder& module::get_builder() {\n-  return builder_;\n-}\n-\n-void module::set_value(const std::string& name, ir::basic_block *block, ir::value *value){\n+void value_constructor::set_value(const std::string& name, ir::basic_block *block, ir::value *value){\n   values_[val_key_t{name, block}] = value;\n   auto it = metadatas_.find(name);\n   if(auto *x = dynamic_cast<ir::instruction*>(value))\n@@ -29,23 +24,11 @@ void module::set_value(const std::string& name, ir::basic_block *block, ir::valu\n //  value->set_name(name);\n }\n \n-void module::set_value(const std::string& name, ir::value *value){\n+void value_constructor::set_value(const std::string& name, ir::value *value){\n   return set_value(name, builder_.get_insert_block(), value);\n }\n \n-void module::set_const(const std::string& name){\n-  const_.insert(name);\n-}\n-\n-void module::set_continue_fn(std::function<ir::value*()> fn) {\n-  continue_fn_ = fn;\n-}\n-\n-std::function<ir::value*()> module::get_continue_fn() {\n-  return continue_fn_;\n-}\n-\n-ir::phi_node* module::make_phi(ir::type *ty, unsigned num_values, ir::basic_block *block){\n+ir::phi_node* value_constructor::make_phi(ir::type *ty, unsigned num_values, ir::basic_block *block){\n   basic_block::iterator insert = block->get_first_non_phi();\n   if(insert != block->end()){\n     builder_.set_insert_point(insert);\n@@ -56,7 +39,7 @@ ir::phi_node* module::make_phi(ir::type *ty, unsigned num_values, ir::basic_bloc\n   return res;\n }\n \n-ir::value *module::try_remove_trivial_phis(ir::phi_node *&phi){\n+ir::value *value_constructor::try_remove_trivial_phis(ir::phi_node *&phi){\n   // find non-self references\n   std::set<ir::value*> non_self_ref;\n   std::copy_if(phi->ops().begin(), phi->ops().end(), std::inserter(non_self_ref, non_self_ref.begin()),\n@@ -69,7 +52,7 @@ ir::value *module::try_remove_trivial_phis(ir::phi_node *&phi){\n   assert(same != nullptr);\n   phi->replace_all_uses_with(same);\n   phi->erase_from_parent();\n-  std::set<ir::user*> users = phi->get_users();\n+  std::vector<ir::user*> users = phi->get_users();\n   for(ir::user* u: users)\n   if(auto *uphi = dynamic_cast<ir::phi_node*>(u))\n     if(uphi != phi)\n@@ -78,7 +61,7 @@ ir::value *module::try_remove_trivial_phis(ir::phi_node *&phi){\n }\n \n \n-ir::value *module::add_phi_operands(const std::string& name, ir::phi_node *&phi){\n+ir::value *value_constructor::add_phi_operands(const std::string& name, ir::phi_node *&phi){\n   // already initialized\n   if(phi->get_num_operands())\n     return phi;\n@@ -90,12 +73,11 @@ ir::value *module::add_phi_operands(const std::string& name, ir::phi_node *&phi)\n   return phi;\n }\n \n-ir::value *module::get_value_recursive(const std::string& name, ir::basic_block *block) {\n+ir::value *value_constructor::get_value_recursive(const std::string& name, ir::basic_block *block) {\n   ir::value *result;\n-  bool is_const = const_.find(name) != const_.end();\n-  auto &preds = block->get_predecessors();\n+  auto preds = block->get_predecessors();\n   ir::type *ty = types_.at(name);\n-  if(block && !is_const && sealed_blocks_.find(block) == sealed_blocks_.end()){\n+  if(block && sealed_blocks_.find(block) == sealed_blocks_.end()){\n     incomplete_phis_[block][name] = make_phi(ty, 1, block);\n     result = (ir::value*)incomplete_phis_[block][name];\n   }\n@@ -117,10 +99,12 @@ ir::value *module::get_value_recursive(const std::string& name, ir::basic_block\n   return result;\n }\n \n-ir::value *module::get_value(const std::string& name, ir::basic_block *block) {\n+ir::value *value_constructor::get_value(const std::string& name, ir::basic_block *block) {\n   ir::basic_block* save_block = builder_.get_insert_block();\n   ir::basic_block::iterator save_pt = builder_.get_insert_point();\n   val_key_t key(name, block);\n+//  std::cout << values_.size() << std::endl;\n+//  std::cout << name << \" \" << block << \" \" << values_.begin()->first.first << \" \" << values_.begin()->first.second << std::endl;\n   if(values_.find(key) != values_.end()){\n     return values_.at(key);\n   }\n@@ -131,15 +115,11 @@ ir::value *module::get_value(const std::string& name, ir::basic_block *block) {\n   return result;\n }\n \n-ir::value *module::get_value(const std::string& name) {\n+ir::value *value_constructor::get_value(const std::string& name) {\n   return get_value(name, builder_.get_insert_block());\n }\n \n-const std::string& module::get_name() {\n-  return name_;\n-}\n-\n-void module::seal_block(ir::basic_block *block){\n+void value_constructor::seal_block(ir::basic_block *block){\n   for(auto &x: incomplete_phis_[block]){\n     add_phi_operands(x.first, x.second);\n     if(get_value(x.first) == x.second)\n@@ -149,11 +129,40 @@ void module::seal_block(ir::basic_block *block){\n   incomplete_phis_[block].clear();\n }\n \n+\n+\n+/* Module */\n+\n+module::module(const std::string &name, builder &builder)\n+  : name_(name), builder_(builder) {\n+}\n+\n+void module::reset_ret_ty(const std::string& name, type* ty) {\n+  get_function(name)->get_fn_type()->reset_ret_ty(ty);\n+}\n+\n+ir::builder& module::get_builder() {\n+  return builder_;\n+}\n+\n+void module::set_continue_fn(std::function<ir::value*()> fn) {\n+  continue_fn_ = fn;\n+}\n+\n+std::function<ir::value*()> module::get_continue_fn() {\n+  return continue_fn_;\n+}\n+\n+const std::string& module::get_name() {\n+  return name_;\n+}\n+\n /* functions */\n function *module::get_or_insert_function(const std::string &name, function_type *ty) {\n   function *&fn = (function*&)symbols_[name];\n-  if(fn == nullptr)\n-    return fn = function::create(ty, global_value::external, name, this);\n+  if(fn == nullptr){\n+    fn = function::create(ty, global_value::external, name, this);\n+  }\n   return fn;\n }\n "}, {"filename": "lib/ir/type.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "file_content_changes": "@@ -188,7 +188,26 @@ bool composite_type::index_valid(value *idx) const{\n }\n \n //===----------------------------------------------------------------------===//\n-//                               tile_type class\n+//                               struct_type class\n+//===----------------------------------------------------------------------===//\n+\n+struct_type::struct_type(const contained_tys_vec_t& tys, bool is_packed)\n+  : composite_type(tys[0]->get_context(), StructTyID), is_packed_(is_packed) {\n+ contained_tys_ = tys;\n+}\n+\n+struct_type* struct_type::get(const contained_tys_vec_t& tys, bool is_packed) {\n+  assert(tys.size());\n+  context_impl* impl = tys[0]->get_context().p_impl.get();\n+  struct_type *& entry = impl->struct_tys[tys];\n+  if(!entry)\n+    entry = new struct_type(tys, is_packed);\n+  return  entry;\n+}\n+\n+\n+//===----------------------------------------------------------------------===//\n+//                               block_type class\n //===----------------------------------------------------------------------===//\n \n block_type::block_type(type *ty, const block_shapes_t &shapes)"}, {"filename": "lib/ir/value.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "file_content_changes": "@@ -1,5 +1,6 @@\n #include <cassert>\n #include <iostream>\n+#include <algorithm>\n #include \"triton/ir/value.h\"\n #include \"triton/ir/instructions.h\"\n \n@@ -17,11 +18,11 @@ value::value(type *ty, const std::string &name): ty_(ty){\n }\n \n void value::add_use(user *arg) {\n-  users_.insert(arg);\n+  users_.push_back(arg);\n }\n \n value::users_t::iterator value::erase_use(user *arg){\n-  auto it = users_.find(arg);\n+  auto it = std::find(users_.begin(), users_.end(), arg);\n   if(it == users_.end())\n     return it;\n   return users_.erase(it);"}, {"filename": "python/setup.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -79,7 +79,7 @@ def run(self):\n \n     def build_extension(self, ext):\n         llvm_include_dir, llvm_library_dir = get_llvm()\n-        self.debug = True\n+        # self.debug = True\n         extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.path)))\n         # create build directories\n         build_suffix = 'debug' if self.debug else 'release'"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "file_content_changes": "@@ -659,6 +659,8 @@ void init_triton_ir(py::module &&m) {\n   py::class_<ir::type>(m, \"type\")\n       .def(\"is_ptr\", &ir::type::is_pointer_ty)\n       .def(\"is_int\", static_cast<bool (ir::type::*)() const>(&ir::type::is_integer_ty))\n+      .def(\"get_int_width\", &ir::type::get_integer_bitwidth)\n+\n       .def(\"is_floating\", &ir::type::is_floating_point_ty)\n       .def(\"is_block\", &ir::type::is_block_ty)\n       .def(\"make_ptr\", &ir::pointer_type::get, ret::reference)\n@@ -695,6 +697,7 @@ void init_triton_ir(py::module &&m) {\n       .def(\"is_uint16\", [](ir::type *self) { return self->is_integer_ty(16, ir::signedness::UNSIGNED); })\n       .def(\"is_uint32\", [](ir::type *self) { return self->is_integer_ty(32, ir::signedness::UNSIGNED); })\n       .def(\"is_uint64\", [](ir::type *self) { return self->is_integer_ty(64, ir::signedness::UNSIGNED); })\n+      .def(\"is_struct\", &ir::type::is_struct_ty)\n \n       .def(\"repr\", &ir::type::repr)\n       .def_property_readonly(\"fp_mantissa_width\", &ir::type::get_fp_mantissa_width)\n@@ -704,23 +707,37 @@ void init_triton_ir(py::module &&m) {\n   py::class_<ir::pointer_type, ir::type>(m, \"pointer_type\")\n       .def_property_readonly(\"element\", &ir::pointer_type::get_element_ty, ret::reference);\n \n-  py::class_<ir::function_type, ir::type>(m, \"function_type\");\n+  py::class_<ir::function_type, ir::type>(m, \"function_type\")\n+      .def_property_readonly(\"ret_ty\", &ir::function_type::get_return_ty)\n+      .def_property_readonly(\"arg_tys\", [](ir::function_type* self){ \n+        return std::vector<ir::type*>(self->params_begin(), self->params_end());\n+      });\n+\n   py::class_<ir::integer_type, ir::type>(m, \"integer_type\");\n+\n   py::class_<ir::block_type, ir::type>(m, \"block_type\")\n       .def_property_readonly(\"shape\", &ir::block_type::get_shapes)\n       .def_property_readonly(\"numel\", &ir::type::get_tile_num_elements);\n+  \n+  py::class_<ir::struct_type, ir::type>(m, \"struct_type\")\n+      .def(\"get\", &ir::struct_type::get, ret::reference)\n+      .def_property_readonly(\"num_types\", &ir::struct_type::get_num_types);\n+\n+  py::class_<ir::value_constructor>(m, \"value_constructor\")\n+      .def(py::init<ir::builder&>())\n+      .def(\"seal_block\", &ir::value_constructor::seal_block)\n+      .def(\"set_value\", (void (ir::value_constructor::*)(const std::string &, ir::value *)) & ir::value_constructor::set_value)\n+      .def(\"set_type\", &ir::value_constructor::set_type)\n+      .def(\"get_value\", (ir::value * (ir::value_constructor::*)(const std::string &)) & ir::value_constructor::get_value, ret::reference)\n+      .def(\"get_values\", &ir::value_constructor::get_values, ret::reference)\n+      .def(\"set_values\", &ir::value_constructor::set_values);\n \n   py::class_<ir::module>(m, \"module\")\n       .def(py::init<std::string, ir::builder &>())\n+      .def(\"has_function\", &ir::module::has_function)\n+      .def(\"get_function\", &ir::module::get_function, ret::reference)\n       .def(\"get_or_insert_function\", &ir::module::get_or_insert_function, ret::reference)\n-      .def(\"seal_block\", &ir::module::seal_block)\n-      .def(\"set_value\", (void (ir::module::*)(const std::string &, ir::value *)) & ir::module::set_value)\n-      .def(\"set_type\", &ir::module::set_type)\n-      .def(\"get_value\", (ir::value * (ir::module::*)(const std::string &)) & ir::module::get_value, ret::reference)\n-      .def(\"get_values\", &ir::module::get_values, ret::reference)\n-      .def(\"set_values\", &ir::module::set_values)\n-      .def(\"get_types\", &ir::module::get_types, ret::reference)\n-      .def(\"set_types\", &ir::module::set_types)\n+      .def(\"reset_ret_ty\", &ir::module::reset_ret_ty)\n       .def_property_readonly(\"builder\", &ir::module::get_builder, ret::reference);\n \n   using eattr = ir::attribute_kind_t;\n@@ -734,29 +751,45 @@ void init_triton_ir(py::module &&m) {\n       .value(\"not_implemented\", eattr::not_implemented);\n \n   py::class_<ir::attribute>(m, \"attribute\")\n-      .def(py::init<eattr, int>());\n+      .def(py::init<eattr, int>())\n+      .def_property_readonly(\"value\", &ir::attribute::get_value);\n \n   py::class_<ir::function>(m, \"function\")\n       .def_property_readonly(\"args\", &ir::function::args)\n       .def_property_readonly(\"attrs\", &ir::function::attrs)\n-      .def(\"add_attr\", &ir::function::add_attr);\n+      .def(\"set_is_kernel\", &ir::function::set_is_kernel)\n+      .def(\"add_attr\", &ir::function::add_attr)\n+      .def(\"has_attr\", &ir::function::has_attr)\n+      .def(\"get_attrs\", &ir::function::get_attributes);\n \n-  py::class_<ir::argument, ir::value>(m, \"argument\");\n+  py::class_<ir::argument, ir::value>(m, \"argument\")\n+      .def_property_readonly(\"parent\", &ir::argument::get_parent, ret::reference)\n+      .def_property_readonly(\"arg_no\", &ir::argument::get_arg_no);\n \n   py::class_<ir::basic_block, ir::value>(m, \"basic_block\")\n-      .def(\"create\", &ir::basic_block::create, ret::reference)\n+      .def(\"create\", &ir::basic_block::create, ret::reference, py::arg(), py::arg(), py::arg() = nullptr)\n       .def_property_readonly(\"parent\", &ir::basic_block::get_parent, ret::reference);\n \n+  py::class_<ir::builder::iterator>(m, \"bb_iterator\");\n+\n   py::class_<ir::builder>(m, \"builder\", py::dynamic_attr())\n       .def(py::init<ir::context &>())\n       // getters\n       .def_property_readonly(\"context\", &ir::builder::get_context, ret::reference)\n       // control flow\n+      .def(\"call\", &ir::builder::create_call, ret::reference)\n+      .def(\"launch\", &ir::builder::create_launch, ret::reference)\n       .def(\"br\", &ir::builder::create_br, ret::reference)\n       .def(\"cond_br\", &ir::builder::create_cond_br, ret::reference)\n       .def(\"ret_void\", &ir::builder::create_ret_void, ret::reference)\n+      .def(\"ret\", &ir::builder::create_ret, ret::reference)\n+      .def(\"get_insert_point\", &ir::builder::get_insert_point)\n+      .def(\"set_insert_point\", (void (ir::builder::*)(ir::builder::iterator))&ir::builder::set_insert_point)\n       .def(\"get_insert_block\", &ir::builder::get_insert_block, ret::reference)\n       .def(\"set_insert_block\", (void (ir::builder::*)(ir::basic_block *)) & ir::builder::set_insert_point)\n+      // struct\n+      .def(\"insert_value\", &ir::builder::create_insert_value, ret::reference)\n+      .def(\"extract_value\", &ir::builder::create_extract_value, ret::reference)\n       // constants\n       .def(\"get_int1\", &ir::builder::get_int1, ret::reference)\n       .def(\"get_int32\", &ir::builder::get_int32, ret::reference)"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "file_content_changes": "@@ -585,7 +585,6 @@ def copy_kernel(input_ptr, output_ptr, n_elements, BLOCK_SIZE: tl.constexpr):\n \n     f8_output_tensor = torch.empty_like(f16, dtype=torch.int8)\n     f8_output = triton.reinterpret(f8_output_tensor, tl.float8)\n-    print(f16.dtype, f8_output.dtype)\n     copy_kernel[grid](f16, f8_output, n_elements, BLOCK_SIZE=1024)\n \n     assert torch.all(f8_tensor == f8_output_tensor)\n@@ -1009,8 +1008,8 @@ def kernel(VALUE, X):\n \n     # Parse out the type of the 'VALUE' parameter from the Triton IR.\n     triton_ir = pgm.asm['ttir']\n-    ir_value_match = re.match(r'\\s*def void kernel\\((\\w+) VALUE ', triton_ir)\n-    ir_value_type = None if ir_value_match is None else ir_value_match.group(1)\n+    ir_value_match = re.match(r'\\s*def void (\\w+)\\((\\w+) VALUE ', triton_ir)\n+    ir_value_type = None if ir_value_match is None else ir_value_match.group(2)\n     assert ir_value_type == value_type\n \n \n@@ -1031,3 +1030,28 @@ def kernel(VALUE, X):\n             kernel[(1, )](value, x)\n     else:\n         kernel[(1, )](value, x)\n+# -------------------------\n+# test dynamic parallelism\n+# -------------------------\n+\n+\n+@triton.jit\n+def mult(x, alpha):\n+    tl.store(x + tl.program_id(0), alpha)\n+\n+\n+@triton.jit\n+def stub(X, alpha, grid_0, grid_1, grid_2):\n+    tl.launch(mult, [X, alpha], [grid_0, grid_1, grid_2])\n+\n+\n+def test_dyn_par(cond=True, device='cuda'):\n+    n_pids = 10\n+    # pids = torch.arange(n_pids, device=device)\n+    # alpha = 2.0\n+    # x_ref = pids * alpha\n+    x_tri = torch.full((10,), fill_value=-1., device=device)\n+    # cond = torch.tensor([cond], device=device)\n+    stub[(1,)](x_tri, 3.14, n_pids, 1, 1)\n+    print(x_tri)\n+    # triton.testing.assert_almost_equal(x_ref, x_tri)"}, {"filename": "python/triton/code_gen.py", "status": "modified", "additions": 182, "deletions": 82, "changes": 264, "file_content_changes": "@@ -21,6 +21,41 @@\n from .tools.disasm import extract\n \n \n+def mangle_ty(type):\n+    if type.is_ptr():\n+        return 'P' + mangle_ty(type.element)\n+    if type.is_int():\n+        return 'i' + str(type.get_int_width())\n+    if type.is_fp8():\n+        return 'fp8'\n+    if type.is_fp16():\n+        return 'fp16'\n+    if type.is_bf16():\n+        return 'bf16'\n+    if type.is_fp32():\n+        return 'fp32'\n+    if type.is_fp64():\n+        return 'fp64'\n+    if type.is_void():\n+        return 'V'\n+    if type.is_block():\n+        elt = mangle_ty(type.scalar)\n+        shape = '_'.join(map(str, type.shape))\n+        return f'{elt}S{shape}S'\n+    assert False, \"Unsupport type\"\n+\n+\n+def mangle_fn(name, arg_tys, constants):\n+    # doesn't mangle ret type, which must be a function of arg tys\n+    mangled_arg_names = '_'.join([mangle_ty(ty) for ty in arg_tys])\n+    key = lambda x: x.__name__ if isinstance(x, JITFunction) else repr(x)\n+    mangled_constants = '_'.join([f'{i}c{key(constants[i])}' for i in sorted(constants)])\n+    mangled_constants = mangled_constants.replace('.', '_d_')\n+    mangled_constants = mangled_constants.replace(\"'\", '_sq_')\n+    ret = f'{name}__{mangled_arg_names}__{mangled_constants}'\n+    return ret\n+\n+\n class CodeGenerator(ast.NodeVisitor):\n     def get_value(self, name):\n         # search node.id in local scope\n@@ -36,16 +71,16 @@ def get_value(self, name):\n         else:\n             raise ValueError(f'{name} is not defined')\n         if isinstance(ret, triton.language.block):\n-            handle = self.module.get_value(name)\n+            handle = self.value_constructor.get_value(name)\n             return triton.language.block(handle)\n         return ret\n \n     def set_value(self, name, value):\n         if isinstance(value, _triton.ir.value):\n             value = triton.language.block(value)\n         if isinstance(value, triton.language.block):\n-            self.module.set_value(name, value.handle)\n-            self.module.set_type(name, value.handle.type)\n+            self.value_constructor.set_value(name, value.handle)\n+            self.value_constructor.set_type(name, value.handle.type)\n         self.lscope[name] = value\n \n     def is_triton_object(self, value):\n@@ -58,16 +93,17 @@ def visit_compound_statement(self, stmts):\n                 break\n         return stmts and isinstance(stmt, ast.Return)\n \n-    def __init__(self, context, prototype, gscope, attributes, constants, kwargs):\n+    def __init__(self, context, prototype, gscope, attributes, constants, module=None, is_kernel=False):\n         self.builder = _triton.ir.builder(context)\n-        self.module = _triton.ir.module('', self.builder)\n+        self.value_constructor = _triton.ir.value_constructor(self.builder)\n+        self.module = _triton.ir.module('', self.builder) if module is None else module\n         self.prototype = prototype\n         self.gscope = gscope\n         self.lscope = dict()\n         self.attributes = attributes\n         self.constants = constants\n-        self.kwargs = kwargs\n         self.last_node = None\n+        self.is_kernel = is_kernel\n         self.builtins = {\n             'range': range,\n             'min': triton.language.minimum,\n@@ -92,9 +128,17 @@ def visit_Return(self, node):\n         ret = self.visit(node.value)\n         if ret is None:\n             return self.builder.ret_void()\n-        return ret\n+        if isinstance(ret, _triton.ir.value):\n+            ret = self.builder.ret(ret)\n+            return ret\n+        if isinstance(ret, triton.language.block):\n+            ret = ret.handle\n+        if isinstance(ret, triton.language.constexpr):\n+            ret = triton.language.core._to_ir(ret, self.builder)\n+        # TODO: should return tl.block\n+        return self.builder.ret(ret)\n \n-    def visit_FunctionDef(self, node, inline=False, arg_values=None):\n+    def visit_FunctionDef(self, node):\n         arg_names, kwarg_names = self.visit(node.args)\n         # initialize defaults\n         for i, default_value in enumerate(node.args.defaults):\n@@ -107,45 +151,44 @@ def visit_FunctionDef(self, node, inline=False, arg_values=None):\n             else:\n                 init_node = ast.AnnAssign(target=st_target, value=default_value, annotation=annotation)\n             self.visit(init_node)\n-        # store keyword arguments in local scope\n-        self.lscope[kwarg_names] = self.kwargs\n         # initialize function\n-        if inline:\n-            pass\n-        else:\n-            fn = self.module.get_or_insert_function(node.name, self.prototype)\n-            arg_values = []\n-            idx = 0\n-            for i, arg_name in enumerate(arg_names):\n-                if i in self.constants:\n-                    cst = self.constants[i]\n-                    if not isinstance(cst, triton.language.constexpr):\n-                        cst = triton.language.constexpr(self.constants[i])\n-                    arg_values.append(cst)\n-                else:\n-                    if i in self.attributes:\n-                        is_ptr = fn.args[idx].type.is_ptr()\n-                        attr = 'aligned' if is_ptr else 'multiple_of'\n-                        attr = getattr(_triton.ir.attribute_kind, attr)\n-                        attr = _triton.ir.attribute(attr, self.attributes[i])\n-                        fn.add_attr(idx + 1, attr)\n-                    fn.args[idx].name = arg_name\n-                    arg_values.append(fn.args[idx])\n-                    idx += 1\n-\n+        fn_name = mangle_fn(node.name, self.prototype.arg_tys, self.constants)\n+        fn = self.module.get_or_insert_function(fn_name, self.prototype)\n+        fn.set_is_kernel(self.is_kernel)\n+        arg_values = []\n+        idx = 0\n+        for i, arg_name in enumerate(arg_names):\n+            if i in self.constants:\n+                cst = self.constants[i]\n+                if not isinstance(cst, triton.language.constexpr):\n+                    cst = triton.language.constexpr(self.constants[i])\n+                arg_values.append(cst)\n+            else:\n+                if i in self.attributes:\n+                    is_ptr = fn.args[idx].type.is_ptr()\n+                    attr = 'aligned' if is_ptr else 'multiple_of'\n+                    attr = getattr(_triton.ir.attribute_kind, attr)\n+                    attr = _triton.ir.attribute(attr, self.attributes[i])\n+                    fn.add_attr(idx + 1, attr)\n+                fn.args[idx].name = arg_name\n+                arg_values.append(fn.args[idx])\n+                idx += 1\n+\n+        insert_pt = self.builder.get_insert_block()\n+        entry = _triton.ir.basic_block.create(self.builder.context, \"entry\", fn)\n+        self.builder.set_insert_block(entry)\n+        self.value_constructor.seal_block(entry)\n         for arg_name, arg_value in zip(arg_names, arg_values):\n             self.set_value(arg_name, arg_value)\n-        if inline:\n-            self.visit_compound_statement(node.body)\n-            return self.last_ret\n-        else:\n-            entry = _triton.ir.basic_block.create(self.builder.context, \"entry\", fn)\n-            self.module.seal_block(entry)\n-            self.builder.set_insert_block(entry)\n-            # visit function body\n-            self.visit_compound_statement(node.body)\n-            # finalize function\n+        # visit function body\n+        has_ret = self.visit_compound_statement(node.body)\n+        # finalize\n+        if not has_ret:\n             self.builder.ret_void()\n+        else:\n+            self.module.reset_ret_ty(fn_name, self.last_ret.type)\n+        # self.module.reset_ret_type(node.name)\n+        self.builder.set_insert_block(insert_pt)\n \n     def visit_arguments(self, node):\n         arg_names = []\n@@ -186,6 +229,12 @@ def visit_Assign(self, node):\n             names = [names]\n         if not isinstance(values, tuple):\n             values = [values]\n+        if isinstance(values[0], _triton.ir.value):\n+            struct = values[0]\n+            ty = struct.type\n+            if ty.is_struct():\n+                values = [self.builder.extract_value(struct, i) for i in range(ty.num_types)]\n+        assert len(values) == len(names)\n         for name, value in zip(names, values):\n             # by default, constexpr are assigned into python variable\n             if isinstance(value, triton.language.constexpr):\n@@ -215,6 +264,17 @@ def visit_Load(self, node):\n \n     def visit_Tuple(self, node):\n         args = [self.visit(x) for x in node.elts]\n+        mode = type(args[0])\n+        # tuple of values -- create a struct\n+        if len(args) > 1 and mode == triton.language.block\\\n+                and all([type(arg) == mode for arg in args]):\n+            args = [arg.handle for arg in args]\n+            tys = [arg.type for arg in args]\n+            struct_ty = _triton.ir.struct_type.get(tys, True)\n+            ret = _triton.ir.undef.get(struct_ty)\n+            for i, arg in enumerate(args):\n+                ret = self.builder.insert_value(ret, arg, i)\n+            return ret\n         return tuple(args)\n \n     def visit_BinOp(self, node):\n@@ -254,9 +314,9 @@ def visit_If(self, node):\n             then_bb = _triton.ir.basic_block.create(self.builder.context, \"then\", current_bb.parent)\n             else_bb = _triton.ir.basic_block.create(self.builder.context, \"else\", current_bb.parent) if node.orelse else None\n             endif_bb = _triton.ir.basic_block.create(self.builder.context, \"endif\", current_bb.parent)\n-            self.module.seal_block(then_bb)\n+            self.value_constructor.seal_block(then_bb)\n             if else_bb:\n-                self.module.seal_block(else_bb)\n+                self.value_constructor.seal_block(else_bb)\n                 self.builder.cond_br(cond.handle, then_bb, else_bb)\n             else:\n                 self.builder.cond_br(cond.handle, then_bb, endif_bb)\n@@ -271,7 +331,7 @@ def visit_If(self, node):\n                 # TODO: last statement is a terminator?\n                 if not is_terminator:\n                     self.builder.br(endif_bb)\n-            self.module.seal_block(endif_bb)\n+            self.value_constructor.seal_block(endif_bb)\n             self.builder.set_insert_block(endif_bb)\n         else:\n             if isinstance(cond, triton.language.constexpr):\n@@ -350,9 +410,9 @@ def continue_fn():\n         self.visit_compound_statement(node.body)\n         continue_fn()\n         stop_bb = self.builder.get_insert_block()\n-        self.module.seal_block(stop_bb)\n-        self.module.seal_block(loop_bb)\n-        self.module.seal_block(next_bb)\n+        self.value_constructor.seal_block(stop_bb)\n+        self.value_constructor.seal_block(loop_bb)\n+        self.value_constructor.seal_block(next_bb)\n         self.builder.set_insert_block(next_bb)\n \n         for stmt in node.orelse:\n@@ -421,9 +481,9 @@ def continue_fn():\n         # TODO: handle case where body breaks control flow\n         continue_fn()\n         stop_bb = self.builder.get_insert_block()\n-        self.module.seal_block(stop_bb)\n-        self.module.seal_block(loop_bb)\n-        self.module.seal_block(next_bb)\n+        self.value_constructor.seal_block(stop_bb)\n+        self.value_constructor.seal_block(loop_bb)\n+        self.value_constructor.seal_block(next_bb)\n         self.builder.set_insert_block(next_bb)\n \n         for stmt in node.orelse:\n@@ -449,15 +509,62 @@ def visit_Call(self, node):\n         for keyword in node.keywords:\n             kws.update(self.visit(keyword))\n         args = [self.visit(arg) for arg in node.args]\n+\n         if isinstance(fn, JITFunction):\n-            return fn(*args, generator=self, **kws)\n+            from inspect import getcallargs\n+            args = getcallargs(fn.fn, *args, **kws)\n+            args = [args[name] for name in fn.arg_names]\n+            args = [arg if isinstance(arg, triton.language.block)\n+                    else triton.language.constexpr(arg) for arg in args]\n+            # generate function def\n+            attributes = dict()\n+            constexprs = [i for i, arg in enumerate(args) if isinstance(arg, triton.language.constexpr)]\n+            constants = {i: args[i] for i in constexprs}\n+            # generate call\n+            args = [None if i in constexprs else arg for i, arg in enumerate(args)]\n+            arg_vals = [arg.handle for arg in args if arg is not None]\n+            arg_types = [arg.type for arg in arg_vals]\n+            fn_name = mangle_fn(fn.__name__, arg_types, constants)\n+            # generate function def if necessary\n+            if not self.module.has_function(fn_name):\n+                ret_type = _triton.ir.type.get_void(self.builder.context)\n+                prototype = _triton.ir.type.make_function(ret_type, arg_types)\n+                gscope = sys.modules[fn.fn.__module__].__dict__\n+                generator = CodeGenerator(self.builder.context, prototype, gscope, attributes, constants, module=self.module)\n+                generator.visit(fn.parse())\n+            symbol = self.module.get_function(fn_name)\n+            ret = self.builder.call(symbol, arg_vals)\n+            if not ret.type.is_void() and not ret.type.is_struct():\n+                ret = triton.language.block(ret)\n+            return ret\n+        # built-in function\n         if hasattr(fn, '__self__') and self.is_triton_object(fn.__self__) or \\\n                 sys.modules[fn.__module__] is triton.language.core:\n-            return fn(*args, _builder=self.builder, **kws)\n+            ret = fn(*args, _builder=self.builder, **kws)\n         if fn in self.builtins.values():\n             args = [arg.value if isinstance(arg, triton.language.constexpr) else arg\n                     for arg in args]\n-        return fn(*args, **kws)\n+            ret = fn(*args, **kws)\n+        # special case: dynamic parallelism\n+        # in this case the core primitive returns a proxy\n+        # if isinstance(ret, triton.language.core.LaunchProxy):\n+        #     ret_type  = _triton.ir.type.get_void(self.builder.context)\n+        #     arg_tys = [x.type for x in ret.args]\n+        #     prototype = _triton.ir.type.make_function(ret_type, arg_tys)\n+        #     gscope = sys.modules[ret.fn.fn.__module__].__dict__\n+        #     constants = ret.constants\n+        #     fn_name = mangle_fn(ret.fn.__name__, arg_tys, ret.constants)\n+        #     # TODO: clean-up attributes handling in function\n+        #     if not self.module.has_function(fn_name):\n+        #         attributes = {i: list(arg.parent.get_attrs(arg))[0].value for i, arg in enumerate(ret.args) \\\n+        #                 if isinstance(arg, _triton.ir.argument) and arg.parent.has_attr(i + 1) }\n+        #         generator = CodeGenerator(self.builder.context, prototype, gscope, attributes, constants, module=self.module, is_kernel=True)\n+        #         generator.visit(ret.fn.parse())\n+        #     symbol = self.module.get_function(fn_name)\n+        #     # TODO: should ret.args not include any constants ?\n+        #     ret = self.builder.launch(symbol, ret.args, ret.grid, ret.num_warps)\n+        return ret\n+        # return fn(*args, **kws)\n \n     def visit_Constant(self, node):\n         return triton.language.constexpr(node.value)\n@@ -669,6 +776,7 @@ def __init__(self, fn):\n \n     def add_to_cache(self, key, wargs, device_idx, num_warps, num_stages):\n         tensor_idxs = [i for i, arg in enumerate(wargs) if hasattr(arg, 'data_ptr')]\n+\n         # attributes\n         attributes = dict()\n         for i, arg in enumerate(wargs):\n@@ -881,7 +989,7 @@ class JITFunction:\n \n     cache_hook = None\n \n-    def __init__(self, fn, version=None, do_not_specialize=None):\n+    def __init__(self, fn, version=None, inline=True, do_not_specialize=None):\n         # information of wrapped function\n         self.fn = fn\n         self.module = fn.__module__\n@@ -890,6 +998,7 @@ def __init__(self, fn, version=None, do_not_specialize=None):\n         self.arg_defaults = [v.default for v in signature.parameters.values()]\n \n         self.version = version\n+        self.inline = inline\n         self.src = textwrap.dedent(inspect.getsource(fn))\n         self.src = self.src[self.src.find(\"def\"):]\n         self.do_not_specialize = [] if do_not_specialize is None else do_not_specialize\n@@ -904,6 +1013,8 @@ def __init__(self, fn, version=None, do_not_specialize=None):\n         # annotations\n         self.annotations = {self.arg_names.index(name): ty for name, ty in fn.__annotations__.items()}\n         self.__annotations__ = fn.__annotations__\n+        # constexprs\n+        self.constexprs = [self.arg_names.index(ann) for ann in self.__annotations__.keys()]\n         # forward docs\n         self.__doc__ = fn.__doc__\n         self.__name__ = fn.__name__\n@@ -930,31 +1041,8 @@ def parse(self):\n         assert isinstance(tree.body[0], ast.FunctionDef)\n         return tree\n \n-    def __call__(self, *args, generator: CodeGenerator, **kwargs):\n-        try:\n-            from inspect import getcallargs\n-            arg_values = getcallargs(self.fn, *args, **kwargs)\n-            arg_values = [arg_values[name] for name in self.arg_names]\n-            arg_values = [arg if isinstance(arg, triton.language.block)\n-                          else triton.language.constexpr(arg) for arg in arg_values]\n-\n-            gscope = generator.gscope.copy()\n-            lscope = generator.lscope.copy()\n-            values = generator.module.get_values().copy()\n-            types = generator.module.get_types().copy()\n-            generator.gscope = sys.modules[self.fn.__module__].__dict__\n-            generator.lscope = dict()\n-            ret = generator.visit_FunctionDef(self.parse().body[0], inline=True, arg_values=arg_values)\n-            generator.gscope = gscope\n-            generator.lscope = lscope\n-            generator.module.set_values(values)\n-            generator.module.set_types(types)\n-            return ret\n-        except Exception as e:\n-            node = generator.last_node\n-            if node is None or isinstance(e, (NotImplementedError, CompilationError)):\n-                raise e\n-            raise CompilationError(self.src, node) from e\n+    def __call__(self, *args, **kwargs):\n+        raise RuntimeError(\"Cannot call @triton.jit'd outside of the scope of a kernel.\")\n \n     # - when `.src` attribute is set, cache path needs\n     #   to be reinitialized\n@@ -1039,7 +1127,7 @@ def _compile(self, arg_types, device, attributes, constants, num_warps, num_stag\n         # generate Triton-IR\n         # export symbols visible from self into code-generator object\n         gscope = self.__globals__\n-        generator = CodeGenerator(context, prototype, gscope=gscope, attributes=attributes, constants=constants, kwargs=dict())\n+        generator = CodeGenerator(context, prototype, gscope=gscope, attributes=attributes, constants=constants, is_kernel=True)\n         try:\n             generator.visit(self.parse())\n         except Exception as e:\n@@ -1199,9 +1287,21 @@ def decorator(fn):\n             return JITFunction(fn, **kwargs)\n         return decorator\n \n+######\n+\n+# class ForwardDeclaration:\n+\n+#     def __init__(self, name, ret_ty, arg_tys) -> None:\n+#         self.name = name\n+#         self.ret_ty = ret_ty\n+#         self.arg_tys = arg_tys\n+\n+# def forward_declare(name, ret_ty, arg_tys):\n+#     return ForwardDeclaration(name, ret_ty, arg_tys)\n \n ######\n \n+\n def cdiv(x, y):\n     return (x + y - 1) // y\n "}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "file_content_changes": "@@ -888,7 +888,7 @@ def sigmoid(x):\n \n @triton.jit\n @_add_math_1arg_docstr(\"softmax\")\n-def softmax(x, ieee_rounding=False):\n+def softmax(x, ieee_rounding: constexpr = False):\n     z = x - triton.language.max(x, 0)\n     num = triton.language.exp(z)\n     den = triton.language.sum(num, 0)\n@@ -942,3 +942,26 @@ def swizzle2d(i, j, size_i, size_j, size_g):\n @triton.jit\n def zeros_like(input):\n     return zeros(input.shape, input.dtype)\n+# -----------------------\n+# Dynamic Parallelism\n+# -----------------------\n+\n+\n+class LaunchProxy:\n+\n+    def __init__(self, fn, args, constants, grid, num_warps) -> None:\n+        self.args = args\n+        self.grid = grid\n+        self.constants = constants\n+        self.num_warps = num_warps\n+        self.fn = fn\n+\n+\n+@builtin\n+def launch(fn, args, grid, num_warps=None, _builder=None):\n+    constants = {i: x for i, x in enumerate(args) if isinstance(x, constexpr)}\n+    args = [_to_ir(x, builder=_builder) for x in args if not isinstance(x, constexpr)]\n+    grid = [_to_ir(x, builder=_builder) for x in grid]\n+    if num_warps is None:\n+        num_warps = _to_ir(4, builder=_builder)\n+    return LaunchProxy(fn, args, constants, grid, num_warps)"}]