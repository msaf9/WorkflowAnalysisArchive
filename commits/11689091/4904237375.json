[{"filename": "include/triton/Analysis/Allocation.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -245,8 +245,6 @@ class ModuleAllocation : public CallGraph<Allocation> {\n   FuncOffsetMapT sharedMemoryValue;\n };\n \n-template <typename T> Interval(T, T) -> Interval<T>;\n-\n } // namespace mlir\n \n #endif // TRITON_ANALYSIS_ALLOCATION_H"}, {"filename": "include/triton/Analysis/Membar.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -72,7 +72,7 @@ class MembarAnalysis {\n   /// in the following circumstances:\n   /// - RAW: If a shared memory write is followed by a shared memory read, and\n   /// their addresses are intersected, a barrier is inserted.\n-  /// - WAR: If a shared memory read is followed by a shared memory read, and\n+  /// - WAR: If a shared memory read is followed by a shared memory write, and\n   /// their addresses are intersected, a barrier is inserted.\n   /// The following circumstances do not require a barrier:\n   /// - WAW: not possible because overlapped memory allocation is not allowed."}, {"filename": "lib/Analysis/Membar.cpp", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "file_content_changes": "@@ -81,9 +81,8 @@ void MembarAnalysis::visitTerminator(Operation *op,\n                                      SmallVector<Block *> &successors) {\n   if (auto branchInterface = dyn_cast<BranchOpInterface>(op)) {\n     Block *parentBlock = branchInterface->getBlock();\n-    for (Block *successor : parentBlock->getSuccessors()) {\n-      successors.push_back(successor);\n-    }\n+    successors.append(std::begin(parentBlock->getSuccessors()),\n+                      std::end(parentBlock->getSuccessors()));\n     return;\n   }\n   // Otherwise, it could be a return op"}]