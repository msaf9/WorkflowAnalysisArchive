[{"filename": "include/triton/ir/instructions.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -59,8 +59,8 @@ class instruction: public user{\n   std::string repr() const                                    { return repr_impl(); }\n   // metadata\n   void set_metadata(ir::metadata::kind_t kind,\n-                    unsigned value)                           { metadatas_[kind] = value;}\n-  unsigned get_metadata(ir::metadata::kind_t kind)            { return metadatas_[kind];}\n+                    std::vector<unsigned> value)                           { metadatas_[kind] = value;}\n+  std::vector<unsigned> get_metadata(ir::metadata::kind_t kind)            { return metadatas_[kind];}\n   // cloning\n   ir::instruction* clone() {\n     ir::instruction* res = clone_impl();\n@@ -77,7 +77,7 @@ class instruction: public user{\n \n private:\n   basic_block *parent_;\n-  std::map<ir::metadata::kind_t, unsigned> metadatas_;\n+  std::map<ir::metadata::kind_t, std::vector<unsigned>> metadatas_;\n   value_id_t id_;\n };\n "}, {"filename": "include/triton/ir/metadata.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "file_content_changes": "@@ -3,6 +3,8 @@\n #ifndef _TRITON_IR_METADATA_H_\n #define _TRITON_IR_METADATA_H_\n \n+#include <vector>\n+\n namespace triton{\n namespace ir{\n \n@@ -16,14 +18,14 @@ class metadata{\n   };\n \n private:\n-  metadata(kind_t kind, unsigned value);\n+  metadata(kind_t kind, std::vector<unsigned> value);\n \n public:\n-  static metadata* get(kind_t kind, unsigned value);\n+  static metadata* get(kind_t kind, std::vector<unsigned> value);\n \n private:\n   kind_t kind_;\n-  unsigned value_;\n+  std::vector<unsigned> value_;\n };\n \n }"}, {"filename": "include/triton/ir/module.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -70,7 +70,7 @@ class value_constructor {\n \n class module {\n   typedef std::pair<std::string, basic_block*> val_key_t;\n-  typedef std::pair<ir::metadata::kind_t, unsigned> md_pair_t;\n+  typedef std::pair<ir::metadata::kind_t, std::vector<unsigned>> md_pair_t;\n   friend class function;\n \n public:"}, {"filename": "lib/codegen/analysis/align.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -366,9 +366,9 @@ std::vector<unsigned> align::populate_max_contiguous(ir::value *v){\n   if(max_contiguous_.find(v) != max_contiguous_.end())\n     return max_contiguous_.at(v);\n   if(auto *x = dynamic_cast<ir::instruction*>(v)){\n-    unsigned max_contiguous = x->get_metadata(ir::metadata::max_contiguous);\n-    if(max_contiguous > 0)\n-      return add_to_cache(x, {max_contiguous}, max_contiguous_);\n+    std::vector<unsigned> max_contiguous = x->get_metadata(ir::metadata::max_contiguous);\n+    if(!max_contiguous.empty())\n+      return add_to_cache(x, max_contiguous, max_contiguous_);\n   }\n   if(auto *x = dynamic_cast<ir::cast_inst*>(v))\n     return populate_max_contiguous_cast(x);\n@@ -521,9 +521,9 @@ std::vector<unsigned> align::populate_starting_multiple(ir::value *v){\n   if(starting_multiple_.find(v) != starting_multiple_.end())\n     return starting_multiple_.at(v);\n   if(auto *x = dynamic_cast<ir::instruction*>(v)){\n-    unsigned multiple_of = x->get_metadata(ir::metadata::multiple_of);\n-    if(multiple_of > 0)\n-      return add_to_cache(x, {multiple_of}, starting_multiple_);\n+    std::vector<unsigned> multiple_of = x->get_metadata(ir::metadata::multiple_of);\n+    if(!multiple_of.empty())\n+      return add_to_cache(x, multiple_of, starting_multiple_);\n   }\n   if(auto *x = dynamic_cast<ir::cast_inst*>(v))\n     return populate_starting_multiple_cast(x);"}, {"filename": "lib/ir/metadata.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -3,10 +3,10 @@\n namespace triton{\n namespace ir{\n \n-metadata::metadata(kind_t kind, unsigned value)\n+metadata::metadata(kind_t kind, std::vector<unsigned> value)\n   : kind_(kind), value_(value) { }\n \n-metadata* metadata::get(kind_t kind, unsigned value) {\n+metadata* metadata::get(kind_t kind, std::vector<unsigned> value) {\n   return new metadata(kind, value);\n }\n "}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -625,13 +625,13 @@ void init_triton_ir(py::module &&m) {\n       .def(py::init<>());\n \n   py::class_<ir::value>(m, \"value\")\n-      .def(\"multiple_of\", [](ir::value *self, int val) {\n+      .def(\"multiple_of\", [](ir::value *self, std::vector<unsigned> val) {\n         if (auto *instr = dynamic_cast<ir::instruction*>(self)) {\n           instr->set_metadata(ir::metadata::multiple_of, val);\n         } else\n           throw std::runtime_error(\"multiple_of\");\n       })\n-      .def(\"max_contiguous\", [](ir::value *self, int val) {\n+      .def(\"max_contiguous\", [](ir::value *self, std::vector<unsigned> val) {\n         if (auto *instr = dynamic_cast<ir::instruction*>(self)) {\n           instr->set_metadata(ir::metadata::max_contiguous, val);\n         } else"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "file_content_changes": "@@ -1088,21 +1088,35 @@ def debug_barrier(_builder=None):\n \n \n @builtin\n-def multiple_of(input, value, _builder=None):\n+def multiple_of(input, values, _builder=None):\n     \"\"\"\n     Let the compiler knows that the values in :code:`input` are all multiples of :code:`value`.\n     \"\"\"\n-    value = _constexpr_to_value(value)\n-    return semantic.multiple_of(input, value)\n+    if isinstance(values, constexpr):\n+        values = [values]\n+    for i, d in enumerate(values):\n+        if not isinstance(d, constexpr):\n+            raise TypeError(f\"values element {i} must have type `constexpr`\")\n+        if not isinstance(d.value, int):\n+            raise TypeError(f\"values element {i} must have type `constexpr[int]`, got `constexpr[{type(d.value)}]\")\n+    values = [x.value for x in values]\n+    return semantic.multiple_of(input, values)\n \n \n @builtin\n-def max_contiguous(input, value, _builder=None):\n+def max_contiguous(input, values, _builder=None):\n     \"\"\"\n     Let the compiler knows that the `value` first values in :code:`input` are contiguous.\n     \"\"\"\n-    value = _constexpr_to_value(value)\n-    return semantic.max_contiguous(input, value)\n+    if isinstance(values, constexpr):\n+        values = [values]\n+    for i, d in enumerate(values):\n+        if not isinstance(d, constexpr):\n+            raise TypeError(f\"values element {i} must have type `constexpr`\")\n+        if not isinstance(d.value, int):\n+            raise TypeError(f\"values element {i} must have type `constexpr[int]`, got `constexpr[{type(d.value)}]\")\n+    values = [x.value for x in values]\n+    return semantic.max_contiguous(input, values)\n \n \n # -----------------------"}, {"filename": "python/triton/language/semantic.py", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "file_content_changes": "@@ -1090,13 +1090,17 @@ def sqrt(x: tl.tensor, builder: ir.builder) -> tl.tensor:\n \n ##\n \n-def multiple_of(x: tl.tensor, value: int) -> tl.tensor:\n-    x.handle.multiple_of(value)\n+def multiple_of(x: tl.tensor, values: List[int]) -> tl.tensor:\n+    if len(x.shape) != len(values):\n+        raise ValueError(\"Shape of input to multiple_of does not match the length of values\")\n+    x.handle.multiple_of(values)\n     return x\n \n \n-def max_contiguous(x: tl.tensor, value: int) -> tl.tensor:\n-    x.handle.max_contiguous(value)\n+def max_contiguous(x: tl.tensor, values: List[int]) -> tl.tensor:\n+    if len(x.shape) != len(values):\n+        raise ValueError(\"Shape of input to max_contiguous does not match the length of values\")\n+    x.handle.max_contiguous(values)\n     return x\n \n "}]