[{"filename": "python/triton/tools/build_extern.py", "status": "modified", "additions": 63, "deletions": 27, "changes": 90, "file_content_changes": "@@ -1,10 +1,24 @@\n import argparse\n import subprocess\n from abc import ABC, abstractmethod\n+from typing import Dict, List, Optional\n \n \n class Symbol:\n-    def __init__(self, name: str, op_name: str, ret_type: str, arg_names: list, arg_types: list) -> None:\n+    _name: str\n+    _op_name: str\n+    _ret_type: str\n+    _arg_names: List[str]\n+    _arg_types: List[str]\n+\n+    def __init__(\n+        self,\n+        name: str,\n+        op_name: str,\n+        ret_type: str,\n+        arg_names: List[str],\n+        arg_types: List[str],\n+    ) -> None:\n         '''\n         A symbol is a function declaration.\n \n@@ -17,31 +31,31 @@ def __init__(self, name: str, op_name: str, ret_type: str, arg_names: list, arg_\n         self._name = name\n         self._op_name = op_name\n         self._ret_type = ret_type\n-        self._arg_names = arg_names\n-        self._arg_types = arg_types\n+        self._arg_names = list(arg_names)\n+        self._arg_types = list(arg_types)\n \n     @property\n-    def name(self):\n+    def name(self) -> str:\n         return self._name\n \n     @property\n-    def op_name(self):\n+    def op_name(self) -> str:\n         return self._op_name\n \n     @property\n-    def ret_type(self):\n+    def ret_type(self) -> str:\n         return self._ret_type\n \n     @property\n-    def arg_names(self):\n+    def arg_names(self) -> List[str]:\n         return self._arg_names\n \n     @property\n-    def arg_types(self):\n+    def arg_types(self) -> List[str]:\n         return self._arg_types\n \n \n-def convert_type(type_str):\n+def convert_type(type_str) -> Optional[str]:\n     if type_str == \"i32\":\n         return \"int32\"\n     elif type_str == \"u32\":\n@@ -59,7 +73,7 @@ def convert_type(type_str):\n         return None\n \n \n-def to_unsigned(type_str):\n+def to_unsigned(type_str) -> str:\n     if type_str == \"int32\":\n         return \"uint32\"\n     elif type_str == \"int64\":\n@@ -69,7 +83,19 @@ def to_unsigned(type_str):\n \n \n class ExternLibrary(ABC):\n-    def __init__(self, name: str, path: str, format: bool = True, grouping: bool = True) -> None:\n+    _name: str\n+    _path: str\n+    _symbols: Dict[str, Symbol]\n+    _format: bool\n+    _grouping: bool\n+\n+    def __init__(\n+        self,\n+        name: str,\n+        path: str,\n+        format: bool = True,\n+        grouping: bool = True,\n+    ) -> None:\n         '''\n         Abstract class for extern library.\n \n@@ -80,34 +106,34 @@ def __init__(self, name: str, path: str, format: bool = True, grouping: bool = T\n         self._name = name\n         self._path = path\n         self._symbols = {}\n-        self._format = True\n+        self._format = format\n         self._grouping = grouping\n \n     @property\n-    def name(self):\n+    def name(self) -> str:\n         return self._name\n \n     @property\n-    def path(self):\n+    def path(self) -> str:\n         return self._path\n \n     @property\n-    def symbols(self):\n+    def symbols(self) -> Dict[str, Symbol]:\n         return self._symbols\n \n     @property\n-    def grouping(self):\n+    def grouping(self) -> bool:\n         return self._grouping\n \n     @abstractmethod\n-    def parse_symbols(self, input_file):\n+    def parse_symbols(self, input_file) -> None:\n         pass\n \n     @abstractmethod\n     def _output_stubs(self) -> str:\n         pass\n \n-    def generate_stub_file(self, output_dir):\n+    def generate_stub_file(self, output_dir) -> None:\n         file_str = self._output_stubs()\n         if file_str is None or len(file_str) == 0:\n             raise Exception(\"file_str is empty\")\n@@ -123,6 +149,8 @@ def generate_stub_file(self, output_dir):\n \n \n class Libdevice(ExternLibrary):\n+    _symbol_groups: Dict[str, List[Symbol]]\n+\n     def __init__(self, path) -> None:\n         '''\n         Constructor for Libdevice.\n@@ -132,7 +160,7 @@ def __init__(self, path) -> None:\n         super().__init__(\"libdevice\", path)\n         self._symbol_groups = {}\n \n-    def _extract_symbol(self, line):\n+    def _extract_symbol(self, line) -> Optional[Symbol]:\n         # Extract symbols from line in the following format:\n         # \"define [internal] <ret_type> @<name>(<arg_types>,)\"\n         entries = line.split(\"@\")\n@@ -174,7 +202,7 @@ def _extract_symbol(self, line):\n                 arg_types[i] = to_unsigned(arg_type)\n         return Symbol(func_name, op_name, ret_type, arg_names, arg_types)\n \n-    def _group_symbols(self):\n+    def _group_symbols(self) -> None:\n         symbol_set = {}\n         for symbol in self._symbols.values():\n             op_name = symbol.op_name\n@@ -244,7 +272,7 @@ def _group_symbols(self):\n             else:\n                 self._symbol_groups[op_name] = [symbol]\n \n-    def parse_symbols(self, input_file):\n+    def parse_symbols(self, input_file) -> None:\n         if len(self.symbols) > 0:\n             return\n         output = subprocess.check_output([\"grep\", \"define\", input_file]).decode().splitlines()\n@@ -256,7 +284,7 @@ def parse_symbols(self, input_file):\n \n         self._group_symbols()\n \n-    def _output_stubs(self):\n+    def _output_stubs(self) -> str:\n         # Generate python functions in the following format:\n         # @extern.extern\n         # def <op_name>(<args>, _builder=None):\n@@ -297,7 +325,10 @@ def _output_stubs(self):\n \n \n class LLVMDisassembler:\n-    def __init__(self, path):\n+    _path: str\n+    _ll_file: str\n+\n+    def __init__(self, path) -> None:\n         '''\n         Invoke llvm-dis to disassemble the given file.\n \n@@ -306,23 +337,28 @@ def __init__(self, path):\n         self._path = path\n         self._ll_file = \"/tmp/extern_lib.ll\"\n \n-    def disasm(self, lib_path):\n+    def disasm(self, lib_path: str) -> None:\n         subprocess.Popen([self._path, lib_path, \"-o\", self.ll_file],\n                          stdout=subprocess.PIPE).communicate()\n \n     @property\n-    def ll_file(self):\n+    def ll_file(self) -> str:\n         return self._ll_file\n \n     @property\n-    def path(self):\n+    def path(self) -> str:\n         return self._path\n \n \n extern_libs = [\"libdevice\"]\n \n \n-def build(llvm_dis_path, lib_path, lib_name, output_dir):\n+def build(\n+    llvm_dis_path: str,\n+    lib_path: str,\n+    lib_name: str,\n+    output_dir: str,\n+) -> None:\n     '''\n       Interface function to build the library file.\n "}]