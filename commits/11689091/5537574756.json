[{"filename": "lib/Analysis/Allocation.cpp", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "file_content_changes": "@@ -388,10 +388,19 @@ class AllocationAnalysis {\n     DenseMap<BufferT *, size_t> bufferStart;\n     calculateStarts(buffers, bufferStart);\n \n+    // NOTE: The original paper doesn't consider interference between\n+    // the bumped ranges. Buffers that previously do not interfere with\n+    // could interfere after offset bumping if their liveness ranges overlap.\n+    // Therefore, we rerun the interference graph algorithm after bumping so\n+    // that we regroup the buffers and color them again. Since we always\n+    // increase the buffer offset and keep reducing conflicts, we will\n+    // eventually reach a fixed point.\n     GraphT interference;\n     buildInterferenceGraph(buffers, bufferStart, interference);\n-\n-    allocate(buffers, bufferStart, interference);\n+    do {\n+      allocate(buffers, interference, bufferStart);\n+      buildInterferenceGraph(buffers, bufferStart, interference);\n+    } while (!interference.empty());\n   }\n \n   /// Computes the initial shared memory offsets.\n@@ -457,6 +466,8 @@ class AllocationAnalysis {\n   void buildInterferenceGraph(const SmallVector<BufferT *> &buffers,\n                               const DenseMap<BufferT *, size_t> &bufferStart,\n                               GraphT &interference) {\n+    // Reset interference graph\n+    interference.clear();\n     for (auto x : buffers) {\n       for (auto y : buffers) {\n         if (x == y)\n@@ -479,8 +490,10 @@ class AllocationAnalysis {\n \n   /// Finalizes shared memory offsets considering interference.\n   void allocate(const SmallVector<BufferT *> &buffers,\n-                const DenseMap<BufferT *, size_t> &bufferStart,\n-                const GraphT &interference) {\n+                const GraphT &interference,\n+                DenseMap<BufferT *, size_t> &bufferStart) {\n+    // Reset shared memory size\n+    allocation->sharedMemorySize = 0;\n     // First-fit graph coloring\n     // Neighbors are nodes that interfere with each other.\n     // We color a node by finding the index of the first available\n@@ -514,6 +527,7 @@ class AllocationAnalysis {\n         adj = std::max(adj, bufferStart.lookup(y) + y->size);\n       }\n       x->offset = bufferStart.lookup(x) + colors.lookup(x) * adj;\n+      bufferStart[x] = x->offset;\n       allocation->sharedMemorySize =\n           std::max(allocation->sharedMemorySize, x->offset + x->size);\n     }"}, {"filename": "test/Analysis/test-allocation.mlir", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "file_content_changes": "@@ -202,6 +202,34 @@ tt.func @multi_color(%A : !tt.ptr<f16>) {\n   tt.return\n }\n \n+// This example triggers graph coloring with multiple rounds\n+// CHECK-LABEL: multi_color_multi_rounds\n+tt.func @multi_color_multi_rounds(%arg0: !tt.ptr<f16>) {\n+  // CHECK: offset = 0, size = 32\n+  %cst = arith.constant dense<0.000000e+00> : tensor<4x4xf16, #A_SHARED>\n+  // CHECK-NEXT: offset = 1184, size = 128\n+  %cst_0 = arith.constant dense<0.000000e+00> : tensor<16x4xf16, #A_SHARED>\n+  // CHECK-NEXT: offset = 1312, size = 8192\n+  %cst_1 = arith.constant dense<0.000000e+00> : tensor<1024x4xf16, #A_SHARED>\n+  %cst_2 = arith.constant dense<0.000000e+00> : tensor<16x32xf16, #AL>\n+  // CHECK-NEXT: scratch offset = 32, size = 1152\n+  %0 = triton_gpu.convert_layout %cst_2 : (tensor<16x32xf16, #AL>) -> tensor<16x32xf16, #AL>\n+  %1 = triton_gpu.convert_layout %cst : (tensor<4x4xf16, #A_SHARED>) -> tensor<4x4xf16, #AL>\n+  // CHECK-NEXT: offset = 11968, size = 128\n+  %cst_3 = arith.constant dense<0.000000e+00> : tensor<2x32xf16, #A_SHARED>\n+  %2 = triton_gpu.convert_layout %cst : (tensor<4x4xf16, #A_SHARED>) -> tensor<4x4xf16, #AL>\n+  // CHECK-NEXT: offset = 0, size = 512\n+  %cst_4 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n+  %3 = triton_gpu.convert_layout %cst_0 : (tensor<16x4xf16, #A_SHARED>) -> tensor<16x4xf16, #AL>\n+  %4 = triton_gpu.convert_layout %cst_1 : (tensor<1024x4xf16, #A_SHARED>) -> tensor<1024x4xf16, #AL>\n+  // CHECK-NEXT: scratch offset = 0, size = 1152\n+  %5 = triton_gpu.convert_layout %cst_2 : (tensor<16x32xf16, #AL>) -> tensor<16x32xf16, #AL>\n+  %6 = triton_gpu.convert_layout %cst_3 : (tensor<2x32xf16, #A_SHARED>) -> tensor<2x32xf16, #AL>\n+  // CHECK-NEXT: size = 12096\n+  tt.return\n+}\n+\n+\n // CHECK-LABEL: alloc\n tt.func @alloc(%A : !tt.ptr<f16>) {\n   // CHECK: offset = 0, size = 512"}]