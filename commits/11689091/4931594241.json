[{"filename": "python/src/triton.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "file_content_changes": "@@ -262,6 +262,11 @@ void init_triton_ir(py::module &&m) {\n              return !self.empty() &&\n                     self.back().hasTrait<mlir::OpTrait::IsTerminator>();\n            })\n+      .def(\"has_return\",\n+           [](mlir::Block &self) {\n+             return !self.empty() &&\n+                    self.back().hasTrait<mlir::OpTrait::ReturnLike>();\n+           })\n       .def(\"erase\", [](mlir::Block &self) { self.erase(); });\n \n   // using eattr = ir::attribute_kind_t;\n@@ -428,6 +433,25 @@ void init_triton_ir(py::module &&m) {\n             self.setArgAttr(arg_no, name, mlir::IntegerAttr::get(attrTy, val));\n           },\n           ret::reference)\n+      .def(\"finalize\",\n+           [](mlir::triton::FuncOp &self) -> void {\n+             // Remove dead code\n+             // 1. Unreachable code after return\n+             self.walk([&](mlir::Block *block) {\n+               mlir::Operation *retOp = nullptr;\n+               block->walk([&](mlir::Operation *op) {\n+                 if (mlir::isa<mlir::triton::ReturnOp>(op))\n+                   if (retOp == nullptr)\n+                     retOp = op;\n+               });\n+               if (retOp && retOp != &block->back()) {\n+                 auto pos = retOp->getIterator();\n+                 pos++;\n+                 auto *newBlock = block->splitBlock(pos);\n+                 newBlock->erase();\n+               }\n+             });\n+           })\n       .def_property_readonly(\"type\", &mlir::triton::FuncOp::getFunctionType)\n       .def(\"reset_type\", &mlir::triton::FuncOp::setType);\n "}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 64, "deletions": 10, "changes": 74, "file_content_changes": "@@ -2550,24 +2550,30 @@ def kernel(Cond, TrueVal, FalseVal, Out):\n     assert to_numpy(out)[0] == false_val[0]\n \n \n-def test_if_return():\n+@pytest.mark.parametrize(\"mode\", [\"dynamic\", \"static\"])\n+def test_if_return(mode):\n \n     @triton.jit\n-    def kernel(ExitEarly, Out):\n-        if tl.load(ExitEarly):\n-            tl.store(Out, 0)\n-            return\n+    def kernel(ExitEarly, Out, cond: tl.constexpr, mode: tl.constexpr):\n+        if mode == \"dynamic\":\n+            if tl.load(ExitEarly):\n+                tl.store(Out, 0)\n+                return\n+        else:\n+            if cond:\n+                tl.store(Out, 0)\n+                return\n         tl.store(Out, 1)\n \n     out = to_triton(np.zeros((1,), dtype=np.int32), device='cuda')\n     exit_early = to_triton(np.zeros((1,), dtype=np.int32), device='cuda')\n     # exit early path taken\n     exit_early[0] = 1\n-    kernel[(1,)](exit_early, out)\n+    kernel[(1,)](exit_early, out, True, mode)\n     assert to_numpy(out)[0] == 0\n     # exit early path not taken\n     exit_early[0] = 0\n-    kernel[(1,)](exit_early, out)\n+    kernel[(1,)](exit_early, out, False, mode)\n     assert to_numpy(out)[0] == 1\n \n \n@@ -2576,21 +2582,69 @@ def add_fn(x):\n     return x + 1\n \n \n-@pytest.mark.parametrize(\"call_type\", [\"attribute\", \"jit_function\"])\n+@triton.jit(noinline=True)\n+def add_fn_noinline(x):\n+    return x + 1\n+\n+\n+@triton.jit\n+def add_fn_return(x, pid):\n+    if pid == 0:\n+        return x + 1\n+    else:\n+        return x + 2\n+\n+\n+@triton.jit\n+def add_fn_expr(Out, x):\n+    tl.store(Out, x)\n+\n+\n+@triton.jit\n+def add_fn_static_cond(x, cond: tl.constexpr):\n+    if cond == \"\":\n+        return x\n+    else:\n+        return x + 1\n+\n+\n+@pytest.mark.parametrize(\"call_type\", [\"attribute\", \"jit_function\", \"jit_function_return\",\n+                                       \"ifexp\", \"expr\", \"jit_function_static_cond\", \"jit_function_noinline\"])\n def test_if_call(call_type):\n     @triton.jit\n     def kernel(Out, call_type: tl.constexpr):\n         pid = tl.program_id(0)\n         o = tl.load(Out)\n         if pid == 0:\n             if call_type == \"attribute\":\n+                # call attribute\n                 a = o + 1\n-                a = a.to(tl.int32)\n+                a = a.to(tl.int32).to(tl.int32)\n                 o = a\n             else:\n                 a = o\n-                a = add_fn(a)\n+                if call_type == \"jit_function\":\n+                    # regular function call\n+                    a = add_fn(a)\n+                elif call_type == \"jit_function_return\":\n+                    # function without end_if block\n+                    a = add_fn_return(a, pid)\n+                elif call_type == \"ifexp\":\n+                    # ifexp expression\n+                    a = add_fn(a) if pid == 0 else add_fn_return(a, pid)\n+                elif call_type == \"expr\":\n+                    if pid == 1:\n+                        return\n+                    a = add_fn(a)\n+                    if pid == 0:\n+                        # call without return\n+                        add_fn_expr(Out, a)\n+                elif call_type == \"jit_function_static_cond\":\n+                    a = add_fn_static_cond(a, call_type)\n+                elif call_type == \"jit_function_noinline\":\n+                    a = add_fn_noinline(a)\n                 o = a\n+\n         tl.store(Out, o)\n \n     out = to_triton(np.zeros((1,), dtype=np.int32), device='cuda')"}, {"filename": "python/triton/compiler/code_generator.py", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "file_content_changes": "@@ -104,6 +104,7 @@ def __init__(self, context, prototype, gscope, attributes, constants, function_n\n         self.debug = debug\n         self.noinline = noinline\n         self.scf_stack = []\n+        self.last_ret_type = None\n         # SSA-construction\n         # name => language.tensor\n         self.local_defs: Dict[str, tensor] = {}\n@@ -138,7 +139,7 @@ def name_lookup(name: str) -> Any:\n     def set_value(self, name: str,\n                   value: Union[tensor, constexpr]) -> None:\n         ''' This function:\n-          called by visit_Assign() & visit_FuncDef() to store left value (lvalue)\n+            called by visit_Assign() & visit_FunctionDef() to store left value (lvalue)\n         1. record local defined name (FIXME: should consider control flow)\n         2. store tensor in self.lvalue\n         '''\n@@ -150,10 +151,9 @@ def set_value(self, name: str,\n     #\n     def visit_compound_statement(self, stmts):\n         for stmt in stmts:\n-            self.last_ret_type = self.visit(stmt)\n-            if isinstance(stmt, ast.Return):\n-                break\n-        return stmts and isinstance(stmt, ast.Return)\n+            ret_type = self.visit(stmt)\n+            if ret_type is not None and isinstance(stmt, ast.Return):\n+                self.last_ret_type = ret_type\n \n     # TODO: should be its own AST visitor\n     def contains_return_op(self, node):\n@@ -168,10 +168,23 @@ def contains_return_op(self, node):\n             pred = lambda s: self.contains_return_op(s)\n             return any(pred(s) for s in node.body)\n         elif isinstance(node, ast.Call):\n-            if isinstance(node.func, ast.Attribute):\n+            def check_undefined_name(cur_node):\n+                # Check if name is an undefined local variable,\n+                # which can only be a tensor or a constexpr\n+                if isinstance(cur_node.func, ast.Attribute):\n+                    if isinstance(cur_node.func.value, ast.Name):\n+                        name = cur_node.func.value.id\n+                        if name not in self.lscope and name not in self.gscope:\n+                            return True\n+                        return False\n+                    # chain of calls\n+                    # e.g., tl.load(a).to(tl.float32)\n+                    return check_undefined_name(cur_node.func.value)\n+                return False\n+            if check_undefined_name(node):\n                 return False\n             fn = self.visit(node.func)\n-            if isinstance(fn, JITFunction):\n+            if isinstance(fn, JITFunction) and fn.noinline is False:\n                 old_gscope = self.gscope\n                 self.gscope = sys.modules[fn.fn.__module__].__dict__\n                 ret = self.contains_return_op(fn.parse())\n@@ -184,6 +197,18 @@ def contains_return_op(self, node):\n             if node.orelse:\n                 ret = ret or any(pred(s) for s in node.orelse)\n             return ret\n+        elif isinstance(node, ast.IfExp):\n+            return self.contains_return_op(node.body) or self.contains_return_op(node.orelse)\n+        elif isinstance(node, ast.Expr):\n+            ret = False\n+            for _, value in ast.iter_fields(node):\n+                if isinstance(value, list):\n+                    for item in value:\n+                        if isinstance(item, ast.AST):\n+                            ret = ret or self.contains_return_op(item)\n+                elif isinstance(value, ast.AST):\n+                    ret = ret or self.contains_return_op(value)\n+            return ret\n         else:\n             return False\n \n@@ -257,9 +282,9 @@ def visit_FunctionDef(self, node):\n             self.set_value(arg_name, arg_value)\n         self.builder.set_insertion_point_to_start(entry)\n         # visit function body\n-        has_ret = self.visit_compound_statement(node.body)\n+        self.visit_compound_statement(node.body)\n         # finalize function\n-        if not has_ret:\n+        if self.last_ret_type is None:\n             self.builder.ret([])\n         else:\n             # update return type\n@@ -271,6 +296,8 @@ def visit_FunctionDef(self, node):\n                 fn.reset_type(self.prototype.to_ir(self.builder))\n         if insert_pt:\n             self.builder.set_insertion_point_to_end(insert_pt)\n+        # Remove dead code\n+        fn.finalize()\n \n     def visit_arguments(self, node):\n         arg_names = []\n@@ -421,6 +448,7 @@ def visit_then_else_blocks(self, node, liveins, then_block, else_block):\n         return then_defs, else_defs, then_block, else_block, names, ret_types, ir_ret_types\n \n     def visit_if_top_level(self, cond, node):\n+        has_endif_block = True\n         with enter_sub_region(self) as sr:\n             liveins, ip_block = sr\n             then_block = self.builder.create_block()\n@@ -435,20 +463,25 @@ def visit_if_top_level(self, cond, node):\n                 self.visit_then_else_blocks(node, liveins, then_block, else_block)\n             # then terminator\n             self.builder.set_insertion_point_to_end(then_block)\n-            if not then_block.has_terminator():\n+            if then_block.has_return() and else_block.has_return():\n+                has_endif_block = False\n+                endif_block.erase()\n+            if not then_block.has_terminator() and has_endif_block:\n                 self.builder.create_branch(endif_block, [then_defs[n].handle for n in names])\n             # else terminator\n             self.builder.set_insertion_point_to_end(else_block)\n-            if not else_block.has_terminator():\n+            if not else_block.has_terminator() and has_endif_block:\n                 self.builder.create_branch(endif_block, [else_defs[n].handle for n in names])\n-            for ty in ir_ret_types:\n-                endif_block.add_argument(ty)\n-        # change block\n-        self.builder.set_insertion_point_to_start(endif_block)\n-        # update value\n-        for i, name in enumerate(names):\n-            new_tensor = language.core.tensor(endif_block.arg(i), ret_types[i])\n-            self.set_value(name, new_tensor)\n+            if has_endif_block:\n+                for ty in ir_ret_types:\n+                    endif_block.add_argument(ty)\n+        if has_endif_block:\n+            # change block\n+            self.builder.set_insertion_point_to_start(endif_block)\n+            # update value\n+            for i, name in enumerate(names):\n+                new_tensor = language.core.tensor(endif_block.arg(i), ret_types[i])\n+                self.set_value(name, new_tensor)\n \n     # TODO: refactor\n     def visit_if_scf(self, cond, node):"}]