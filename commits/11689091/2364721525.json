[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "file_content_changes": "@@ -514,9 +514,41 @@ def kernel(X, Z):\n         np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01)\n \n \n+def test_atomic_cas():\n+    # 1. make sure that atomic_cas changes the original value (Lock)\n+    @triton.jit\n+    def change_value(Lock):\n+        tl.atomic_cas(Lock, 0, 1)\n+\n+    Lock = torch.zeros((1,), device='cuda', dtype=torch.int32)\n+    change_value[(1,)](Lock)\n+\n+    assert(Lock[0] == 1)\n+\n+    # 2. only one block enters the critical section\n+    @triton.jit\n+    def serialized_add(data, Lock):\n+        ptrs = data + tl.arange(0, 128)\n+        while tl.atomic_cas(Lock, 0, 1) == 1:\n+            pass\n+\n+        tl.store(ptrs, tl.load(ptrs) + 1.0)\n+\n+        # release lock\n+        tl.atomic_xchg(Lock, 0)\n+\n+    Lock = torch.zeros((1,), device='cuda', dtype=torch.int32)\n+    data = torch.zeros((128,), device='cuda', dtype=torch.float32)\n+    ref = torch.full((128,), 64.0)\n+    serialized_add[(64,)](data, Lock)\n+    triton.testing.assert_almost_equal(data, ref)\n+\n+\n # ---------------\n # test cast\n # ---------------\n+\n+\n @pytest.mark.parametrize(\"dtype_x, dtype_z, bitcast\", [\n     (dtype_x, dtype_z, False)\n     for dtype_x in dtypes"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -806,7 +806,7 @@ def _decorator(func):\n @_add_atomic_docstr(\"compare-and-swap\")\n def atomic_cas(pointer, cmp, val, _builder=None):\n     cmp = _to_tensor(cmp, _builder)\n-    val = _to_tensor(cmp, _builder)\n+    val = _to_tensor(val, _builder)\n     return semantic.atomic_cas(pointer, cmp, val, _builder)\n \n "}]