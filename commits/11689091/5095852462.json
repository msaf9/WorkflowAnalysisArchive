[{"filename": "python/src/triton.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "file_content_changes": "@@ -439,11 +439,15 @@ void init_triton_ir(py::module &&m) {\n              // 1. Unreachable code after return\n              self.walk([&](mlir::Block *block) {\n                mlir::Operation *retOp = nullptr;\n-               block->walk([&](mlir::Operation *op) {\n+               // It's better to not use walk here because we only want to\n+               // check operations in the current block\n+               for (auto &op : block->getOperations()) {\n                  if (mlir::isa<mlir::triton::ReturnOp>(op))\n-                   if (retOp == nullptr)\n-                     retOp = op;\n-               });\n+                   if (retOp == nullptr) {\n+                     retOp = &op;\n+                     break;\n+                   }\n+               }\n                if (retOp && retOp != &block->back()) {\n                  auto pos = retOp->getIterator();\n                  pos++;"}, {"filename": "python/triton/compiler/code_generator.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "file_content_changes": "@@ -560,7 +560,11 @@ def visit_If(self, node):\n         cond = self.visit(node.test)\n         if _is_triton_tensor(cond):\n             cond = cond.to(language.int1, _builder=self.builder)\n-            if self.scf_stack or not ContainsReturnChecker(self.gscope).visit(node):\n+            contains_return = ContainsReturnChecker(self.gscope).visit(node)\n+            if self.scf_stack and contains_return:\n+                raise UnsupportedLanguageConstruct(None, node,\n+                                                   \"Cannot have `return` statements inside `while` or `for` statements in triton\")\n+            elif self.scf_stack or not contains_return:\n                 self.visit_if_scf(cond, node)\n             else:\n                 self.visit_if_top_level(cond, node)"}]