[{"filename": "include/triton/Analysis/AxisInfo.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -54,6 +54,10 @@ class AxisInfo {\n \n   std::optional<int64_t> getConstantValue() const { return constantValue; }\n \n+  template <class T>\n+  static void\n+  initPessimisticStateFromFunc(int argNumber, T funcOp, DimVectorT *contiguity,\n+                               DimVectorT *divisibility, DimVectorT *constancy);\n   /// Comparison\n   bool operator==(const AxisInfo &other) const {\n     return (contiguity == other.contiguity) &&"}, {"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "file_content_changes": "@@ -42,6 +42,28 @@ static constexpr int log2Int(int64_t num) {\n // AxisInfo\n //===----------------------------------------------------------------------===//\n \n+template <class T>\n+void AxisInfo::initPessimisticStateFromFunc(int argNumber, T funcOp,\n+                                            DimVectorT *contiguity,\n+                                            DimVectorT *divisibility,\n+                                            DimVectorT *constancy) {\n+  // liast of attributes that we care about\n+  SmallVector<std::pair<DimVectorT *, std::string>> retVecs;\n+  retVecs.push_back({contiguity, \"tt.contiguity\"});\n+  retVecs.push_back({divisibility, \"tt.divisibility\"});\n+  retVecs.push_back({constancy, \"tt.constancy\"});\n+  // initialize attributes one by one\n+  for (auto [vec, attrName] : retVecs) {\n+    Attribute attr = funcOp.getArgAttr(argNumber, attrName);\n+    if (auto int_attr = attr.dyn_cast_or_null<IntegerAttr>())\n+      *vec = DimVectorT(contiguity->size(), int_attr.getValue().getZExtValue());\n+    if (auto dense_attr = attr.dyn_cast_or_null<DenseElementsAttr>()) {\n+      auto vals = dense_attr.getValues<int>();\n+      *vec = DimVectorT(vals.begin(), vals.end());\n+    }\n+  }\n+}\n+\n AxisInfo AxisInfo::getPessimisticValueState(Value value) {\n   auto rank = 1;\n   if (TensorType ty = value.getType().dyn_cast<TensorType>())\n@@ -53,33 +75,21 @@ AxisInfo AxisInfo::getPessimisticValueState(Value value) {\n \n   BlockArgument blockArg = value.dyn_cast<BlockArgument>();\n \n-  auto parseFuncAttrs = [&]<class T>(T funcOp) {\n-    // liast of attributes that we care about\n-    SmallVector<std::pair<DimVectorT *, std::string>> retVecs;\n-    retVecs.push_back({&knownContiguity, \"tt.contiguity\"});\n-    retVecs.push_back({&knownDivisibility, \"tt.divisibility\"});\n-    retVecs.push_back({&knownConstancy, \"tt.constancy\"});\n-    // initialize attributes one by one\n-    for (auto [vec, attrName] : retVecs) {\n-      Attribute attr = funcOp.getArgAttr(blockArg.getArgNumber(), attrName);\n-      if (auto int_attr = attr.dyn_cast_or_null<IntegerAttr>())\n-        *vec = DimVectorT(rank, int_attr.getValue().getZExtValue());\n-      if (auto dense_attr = attr.dyn_cast_or_null<DenseElementsAttr>()) {\n-        auto vals = dense_attr.getValues<int>();\n-        *vec = DimVectorT(vals.begin(), vals.end());\n-      }\n-    }\n-  };\n+  auto parseFuncAttrs = [&]<class T>(T funcOp) {};\n \n   if (blockArg && blockArg.getOwner()->isEntryBlock()) {\n     Operation *op = blockArg.getOwner()->getParentOp();\n-    if (auto fun = dyn_cast<func::FuncOp>(op)) {\n-      parseFuncAttrs(fun);\n-    }\n+    if (auto fun = dyn_cast<func::FuncOp>(op))\n+      initPessimisticStateFromFunc(blockArg.getArgNumber(), fun,\n+                                   &knownContiguity, &knownDivisibility,\n+                                   &knownConstancy);\n     // llvm codegen check alignment to generate vector load/store\n-    if (auto fun = dyn_cast<LLVM::LLVMFuncOp>(op)) {\n-      parseFuncAttrs(fun);\n-    } else {\n+    // would be nice if this wasn't the case\n+    else if (auto fun = dyn_cast<LLVM::LLVMFuncOp>(op))\n+      initPessimisticStateFromFunc(blockArg.getArgNumber(), fun,\n+                                   &knownContiguity, &knownDivisibility,\n+                                   &knownConstancy);\n+    else {\n       // Derive the divisibility of the induction variable only when\n       // the step and the lower bound are both constants\n       if (auto forOp = dyn_cast<scf::ForOp>(op)) {"}]