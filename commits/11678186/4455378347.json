[{"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -261,7 +261,7 @@ translateLLVMToLLVMIR(llvm::LLVMContext *llvmContext, mlir::ModuleOp module) {\n   }\n \n   auto optPipeline = mlir::makeOptimizingTransformer(\n-      /*optLevel=*/0, /*sizeLevel=*/0,\n+      /*optLevel=*/3, /*sizeLevel=*/0,\n       /*targetMachine=*/nullptr);\n \n   if (auto err = optPipeline(llvmModule.get())) {"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "file_content_changes": "@@ -520,6 +520,17 @@ def test_unary_op(dtype_x, expr, device='cuda'):\n def test_math_op(expr, device='cuda'):\n     _test_unary('float32', f'tl.{expr}(x)', f'np.{expr}(x) ', device=device)\n \n+# ----------------\n+# test abs\n+# ----------------\n+\n+\n+@pytest.mark.parametrize(\"dtype_x\", [\n+    (dtype_x)\n+    for dtype_x in dtypes_with_bfloat16\n+])\n+def test_abs(dtype_x, device='cuda'):\n+    _test_unary(dtype_x, 'tl.abs(x)', 'np.abs(x) ', device=device)\n \n # ----------------\n # test indexing"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "file_content_changes": "@@ -1215,7 +1215,23 @@ def max_contiguous(input, values, _builder=None):\n \n @triton.jit\n def abs(x):\n-    return where(x >= 0, x, -x)\n+    if x.dtype.is_fp16():\n+        m = 0x7fff\n+        y = x.to(triton.language.int16, bitcast=True) & m.to(triton.language.int16, bitcast=False)\n+        z = y.to(triton.language.float16, bitcast=True)\n+    elif x.dtype.is_bf16():\n+        m = 0x7fff\n+        y = x.to(triton.language.int16, bitcast=True) & m.to(triton.language.int16, bitcast=False)\n+        z = y.to(triton.language.bfloat16, bitcast=True)\n+    elif x.dtype.is_fp32():\n+        y = x.to(triton.language.int32, bitcast=True) & 0x7fffffff\n+        z = y.to(triton.language.float32, bitcast=True)\n+    elif x.dtype.is_fp64():\n+        y = x.to(triton.language.int64, bitcast=True) & 0x7fffffffffffffff\n+        z = y.to(triton.language.float64, bitcast=True)\n+    else:\n+        z = where(x >= 0, x, -x)\n+    return z\n \n \n @triton.jit"}]