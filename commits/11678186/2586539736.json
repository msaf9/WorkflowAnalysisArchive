[{"filename": "include/triton/ir/visitor.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -84,6 +84,8 @@ class prefetch_s_inst;\n class clock_inst;\n class globaltimer_inst;\n \n+class extern_elementwise_inst;\n+\n class make_range_sta;\n class undef_value;\n class constant_int;"}, {"filename": "lib/codegen/pass.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "file_content_changes": "@@ -36,12 +36,10 @@ static std::unique_ptr<llvm::Module> link_extern_libs(\n     const std::map<std::string, std::unique_ptr<ExternLib>>& extern_libs,\n     ir::module& ir, llvm::LLVMContext& ctx,\n     std::unique_ptr<llvm::Module> llvm) {\n-  for (const auto& extern_lib : extern_libs) {\n-    extern_lib->install(ctx, llvm);\n+  for (const auto& iter : extern_libs) {\n+    iter.second->install(ctx, llvm);\n   }\n \n-  llvm::legacy::PassManager pass;\n-\n   // Internalize all device functions\n   std::set<llvm::StringRef> function_names;\n   for (auto& func : ir.get_function_list()) {"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "file_content_changes": "@@ -3455,7 +3455,11 @@ void generator::visit(ir::module &src, llvm::Module &dst) {\n \n void generator::add_extern_lib(const std::string &lib_name, const std::string &lib_path) {\n   if (extern_libs_.count(lib_name) == 0) {\n-    extern_libs_.emplace(lib_name, lib_path);\n+    if (lib_name == \"libdevice\") {\n+      extern_libs_[lib_name] = std::make_unique<LibDevice>(lib_name, lib_path);\n+    } else {\n+      throw std::runtime_error(\"Unknown external library: \" + lib_name);\n+    }\n   } else if (extern_libs_.at(lib_name)->path() != lib_path) {\n     throw std::runtime_error(\"A library has multiple paths (1) \" + lib_path +\n                              \" (2) \" + extern_libs_.at(lib_name)->path());"}, {"filename": "python/triton/language/.gitignore", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -0,0 +1 @@\n+libdevice.py"}, {"filename": "python/triton/language/extern.py", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "file_content_changes": "@@ -1,33 +1,33 @@\n from . import core\n \n \n-def dispatch(func, lib_name: str, path: str, args: list, arg_type_symbol_dict: dict, _builder=None):\n-  if len(arg_type_symbol_dict) == 0:\n-    raise ValueError(\"arg_type_symbol_dict is empty\")\n+def dispatch(func, lib_name: str, lib_path: str, args: list, arg_type_symbol_dict: dict, _builder=None):\n+    if len(arg_type_symbol_dict) == 0:\n+        raise ValueError(\"arg_type_symbol_dict is empty\")\n \n-  first_symbol = list(arg_type_symbol_dict.values())[0][0]\n-  if len(args) != len(first_symbol.arg_types):\n-    raise ValueError(f\"length of input args does not match function {first_symbol.op_name}'s declaration.\"\n-                     f\"Expect {len(args)}, got {len(first_symbol.arg_types)}\")\n+    first_symbol = list(arg_type_symbol_dict.values())[0][0]\n+    if len(args) != len(first_symbol.arg_types):\n+        raise ValueError(f\"length of input args does not match function {first_symbol.op_name}'s declaration.\"\n+                         f\"Expect {len(args)}, got {len(first_symbol.arg_types)}\")\n \n-  arg_types = []\n-  for i, arg in enumerate(args):\n-    if type(arg) is core.tensor:\n-      arg_types.append(arg.dtype)\n-      args[i] = core._to_tensor(arg, _builder)\n-    else:\n-      arg_types.append(type(arg))\n-      args[i] = core._constexpr_to_value(arg)\n+    arg_types = []\n+    for i, arg in enumerate(args):\n+        if isinstance(arg, core.tensor):\n+            arg_types.append(arg.dtype)\n+            args[i] = core._to_tensor(arg, _builder)\n+        else:\n+            arg_types.append(type(arg))\n+            args[i] = core._constexpr_to_value(arg)\n \n-  if arg_types not in arg_type_symbol_dict:\n-    raise ValueError(f\"input arg type does not match function {first_symbol.op_name}'s declaration.\"\n-                     f\"Expect one of {arg_type_symbol_dict.keys()}, got {arg_types}\")\n-  else:\n-    symbol = arg_type_symbol_dict[arg_types][0]\n-    ret_type = arg_type_symbol_dict[arg_types][1]\n-    return core.tensor(func(lib_name, path, symbol, args), ret_type)\n+    if arg_types not in arg_type_symbol_dict:\n+        raise ValueError(f\"input arg type does not match function {first_symbol.op_name}'s declaration.\"\n+                         f\"Expect one of {arg_type_symbol_dict.keys()}, got {arg_types}\")\n+    else:\n+        symbol = arg_type_symbol_dict[arg_types][0]\n+        ret_type = arg_type_symbol_dict[arg_types][1]\n+        return core.tensor(func(lib_name, lib_path, symbol, args, ret_type.to_ir(_builder)), ret_type)\n \n \n-def elementwise(lib_name: str, path: str, args: list, arg_type_symbol_dict: dict, _builder=None):\n-  func = getattr(_builder, \"create_elementwise\")\n-  dispatch(func, lib_name, path, args, arg_type_symbol_dict)\n+def elementwise(lib_name: str, lib_path: str, args: list, arg_type_symbol_dict: dict, _builder=None):\n+    func = getattr(_builder, \"create_extern_elementwise\")\n+    dispatch(func, lib_name, lib_path, args, arg_type_symbol_dict)"}, {"filename": "python/triton/tools/build_extern.py", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "file_content_changes": "@@ -0,0 +1,271 @@\n+from abc import ABC, abstractmethod\n+import argparse\n+import subprocess\n+\n+\n+class Symbol:\n+    def __init__(self, name: str, op_name: str, ret_type: str, arg_names: list, arg_types: list) -> None:\n+        '''\n+        A symbol is a function declaration.\n+\n+        :param name: name of the symbol\n+        :param op_name: name of the operation\n+        :param ret_type: return type of the operation\n+        :param arg_names: names of the arguments\n+        :param arg_types: types of the arguments\n+        '''\n+        self._name = name\n+        self._op_name = op_name\n+        self._ret_type = ret_type\n+        self._arg_names = arg_names\n+        self._arg_types = arg_types\n+\n+    @property\n+    def name(self):\n+        return self._name\n+\n+    @property\n+    def op_name(self):\n+        return self._op_name\n+\n+    @property\n+    def ret_type(self):\n+        return self._ret_type\n+\n+    @property\n+    def arg_names(self):\n+        return self._arg_names\n+\n+    @property\n+    def arg_types(self):\n+        return self._arg_types\n+\n+\n+def convert_type(type_str):\n+    if type_str == \"i32\":\n+        return \"int32\"\n+    elif type_str == \"u32\":\n+        return \"uint32\"\n+    elif type_str == \"i64\":\n+        return \"int64\"\n+    elif type_str == \"u64\":\n+        return \"uint64\"\n+    elif type_str == \"float\":\n+        return \"fp32\"\n+    elif type_str == \"double\":\n+        return \"fp64\"\n+    else:\n+        # ignore other types, such as pointer types\n+        return None\n+\n+\n+class ExternLibrary(ABC):\n+    def __init__(self, name: str, path: str, format: bool = True) -> None:\n+        '''\n+        Abstract class for extern library.\n+\n+        :param name: name of the library\n+        :param path: path of the library\n+        :param format: whether to format the generated stub file\n+        '''\n+        self._name = name\n+        self._path = path\n+        self._symbols = {}\n+        self._format = True\n+\n+    @property\n+    def name(self):\n+        return self._name\n+\n+    @property\n+    def path(self):\n+        return self._path\n+\n+    @property\n+    def symbols(self):\n+        return self._symbols\n+\n+    @abstractmethod\n+    def parse_symbols(self, input_file):\n+        pass\n+\n+    @abstractmethod\n+    def _output_stubs(self) -> str:\n+        pass\n+\n+    def generate_stub_file(self, output_dir):\n+        file_str = self._output_stubs()\n+        if file_str is None or len(file_str) == 0:\n+            raise Exception(\"file_str is empty\")\n+\n+        output_file = f\"{output_dir}/{self._name}.py\"\n+        with open(output_file, \"w\") as f:\n+            f.write(file_str)\n+            f.close()\n+            if self._format:\n+                subprocess.Popen([\"autopep8\", \"-a\", \"-r\", \"-i\", output_file],\n+                                 stdout=subprocess.PIPE).communicate()\n+\n+\n+class Libdevice(ExternLibrary):\n+    def __init__(self, path) -> None:\n+        '''\n+        Constructor for Libdevice.\n+\n+        :param path: path of the libdevice library\n+        '''\n+        super().__init__(\"libdevice\", path)\n+        self._symbol_groups = {}\n+\n+    def _extract_symbol(self, line):\n+        # Extract symbols from line in the following format:\n+        # \"define [internal] <ret_type> @<name>(<arg_types>,)\"\n+        entries = line.split(\"@\")\n+        ret_str = entries[0]\n+        func_str = entries[1]\n+        # Get ret_type, skip internal symbols\n+        ret_strs = ret_str.split()\n+        if ret_strs[1] == \"internal\":\n+            return None\n+        ret_type = convert_type(ret_strs[1])\n+        if ret_type is None:\n+            return None\n+        # Get function name\n+        func_strs = func_str.split(\"(\")\n+        func_name = func_strs[0].replace(\"@\", \"\")\n+        op_name = func_name.replace(\"__nv_\", \"\")\n+        # Get arg_types\n+        arg_strs = func_strs[1].split(\",\")\n+        arg_types = []\n+        arg_names = []\n+        for arg_str in arg_strs:\n+            arg_type = convert_type(arg_str.split()[0])\n+            if arg_type is None:\n+                return None\n+            arg_name = arg_str.split()[1].replace(\"%\", \"\").replace(\")\", \"\")\n+            arg_types.append(arg_type)\n+            arg_names.append(arg_name)\n+        return Symbol(func_name, op_name, ret_type, arg_names, arg_types)\n+\n+    def _group_symbols(self):\n+        # The following cases are grouped together:\n+        # op_name, <u>op_name<ll/f>\n+        for symbol in self._symbols.values():\n+            op_name = symbol.op_name\n+            if op_name.startswith(\"u\"):\n+                op_name = op_name[1:]\n+            elif op_name.endswith(\"ll\"):\n+                op_name = op_name[:-2]\n+            elif op_name.endswith(\"f\"):\n+                op_name = op_name[:-1]\n+            if op_name in self._symbol_groups:\n+                self._symbol_groups[op_name].append(symbol)\n+            else:\n+                self._symbol_groups[op_name] = [symbol]\n+\n+    def parse_symbols(self, input_file):\n+        if len(self.symbols) > 0:\n+            return\n+        output = subprocess.check_output([\"grep\", \"define\", input_file]).decode().splitlines()\n+        for line in output:\n+            symbol = self._extract_symbol(line)\n+            if symbol is None:\n+                continue\n+            self._symbols[symbol.name] = symbol\n+\n+        self._group_symbols()\n+\n+    def _output_stubs(self):\n+        # Generate python functions in the following format:\n+        # @core.builtin\n+        # def <op_name>(<args>, _builder=None):\n+        #   arg_type_symbol_dict = {[arg_type]: {(symbol, ret_type)}}\n+        #   return extern.dispatch(\"libdevice\", <path>, <args>, <arg_type_symbol_dict>, _builder)\n+        import_str = \"from . import core, extern\\n\"\n+        file_str = \"\"\n+        func_str = \"\"\n+        for symbols in self._symbol_groups.values():\n+            func_str += \"@core.builtin\\n\"\n+            func_name_str = f\"def {symbols[0].op_name}(\"\n+            for arg_name in symbols[0].arg_names:\n+                func_name_str += f\"{arg_name}, \"\n+            func_name_str += \"_builder=None):\\n\"\n+\n+            return_str = f\"\\treturn extern.elementwise(\\\"{self._name}\\\", \\\"{self.path}\\\", [\"\n+            for arg_name in symbols[0].arg_names:\n+                return_str += f\"{arg_name}, \"\n+            return_str += \"], \"\n+\n+            arg_type_symbol_dict_str = \"{\"\n+            for symbol in symbols:\n+                arg_type_symbol_dict_str += \"[\"\n+                for arg_type in symbol.arg_types:\n+                    arg_type_symbol_dict_str += f\"core.dtype(\\\"{arg_type}\\\"),\"\n+                ret_type = f\"core.dtype(\\\"{symbol.ret_type}\\\")\"\n+                arg_type_symbol_dict_str += \"]: {(\\\"\" + symbol.name + \"\\\", \" + ret_type + \")},\"\n+            arg_type_symbol_dict_str += \"}\"\n+\n+            return_str += arg_type_symbol_dict_str\n+            return_str += \", _builder)\\n\"\n+\n+            func_str += func_name_str + return_str + \"\\n\"\n+        file_str += import_str + func_str\n+\n+        return file_str\n+\n+\n+class LLVMDisassembler:\n+    def __init__(self, path):\n+        '''\n+        Invoke llvm-dis to disassemble the given file.\n+\n+        :param path: path to llvm-dis\n+        '''\n+        self._path = path\n+        self._ll_file = \"/tmp/extern_lib.ll\"\n+\n+    def disasm(self, lib_path):\n+        subprocess.Popen([self._path, lib_path, \"-o\", self.ll_file],\n+                         stdout=subprocess.PIPE).communicate()\n+\n+    @property\n+    def ll_file(self):\n+        return self._ll_file\n+\n+    @property\n+    def path(self):\n+        return self._path\n+\n+\n+extern_libs = [\"libdevice\"]\n+\n+\n+def build(llvm_dis_path, lib_path, lib_name, output_dir):\n+    '''\n+      Interface function to build the library file.\n+\n+      :param llvm_dis_path: path to the llvm-dis binary\n+      :param lib_path: path to the external library file\n+      :param lib_name: name of the library\n+      :param output_dir: path to the output directory\n+    '''\n+    if lib_name == \"libdevice\":\n+        extern_lib = Libdevice(lib_path)\n+    else:\n+        raise Exception(f\"Unknown extern library: {lib_name}\")\n+\n+    llvm_disassembler = LLVMDisassembler(llvm_dis_path)\n+    llvm_disassembler.disasm(lib_path)\n+\n+    extern_lib.parse_symbols(llvm_disassembler.ll_file)\n+    extern_lib.generate_stub_file(output_dir)\n+\n+\n+parser = argparse.ArgumentParser()\n+parser.add_argument(\"-llvm\", dest=\"llvm_dis_path\", help=\"path to llvm-dis\", default=\"llvm-dis\")\n+parser.add_argument(\"--lib-path\", dest=\"lib_path\", help=\"path to the extern library\")\n+parser.add_argument(\"--lib-name\", dest=\"lib_name\", help=\"name of the extern library\")\n+parser.add_argument(\"-o\", dest=\"output_dir\", help=\"output file path\", default=\"/tmp/\")\n+args = parser.parse_args()\n+\n+build(args.llvm_dis_path, args.lib_path, args.lib_name, args.output_dir)"}, {"filename": "python/triton/tools/extract_libdevice.py", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "file_content_changes": "@@ -1,178 +0,0 @@\n-import argparse\n-import subprocess\n-\n-\n-class Symbol:\n-  def __init__(self, name, ret_type, arg_names: list, arg_types: list) -> None:\n-    self._name = name\n-    self._op_name = name.split(\"nv_\")[1]\n-    self._ret_type = ret_type\n-    self._arg_names = arg_names\n-    self._arg_types = arg_types\n-\n-  @property\n-  def name(self):\n-    return self._name\n-\n-  @property\n-  def op_name(self):\n-    return self._op_name\n-\n-  @property\n-  def ret_type(self):\n-    return self._ret_type\n-\n-  @property\n-  def arg_names(self):\n-    return self._arg_names\n-\n-  @property\n-  def arg_types(self):\n-    return self._arg_types\n-\n-\n-def convert_type(type_str):\n-  if type_str == 'i32':\n-    return 'int32'\n-  elif type_str == 'u32':\n-    return 'uint32'\n-  elif type_str == 'i64':\n-    return 'int64'\n-  elif type_str == 'u64':\n-    return 'uint64'\n-  elif type_str == 'float':\n-    return 'fp32'\n-  elif type_str == 'double':\n-    return 'fp64'\n-  else:\n-    # ignore other types, such as pointer types\n-    return None\n-\n-\n-class Libdevice:\n-  def __init__(self, path) -> None:\n-    self._path = path\n-    self._symbols = {}\n-    self._symbol_groups = {}\n-\n-  def _extract_symbol(self, line):\n-    # Extract symbols from line in the following format:\n-    # \"define [internal] <ret_type> @<name>(<arg_types>,)\"\n-    entries = line.split('@')\n-    ret_str = entries[0]\n-    func_str = entries[1]\n-    # Get ret_type, skip internal symbols\n-    ret_strs = ret_str.split()\n-    if ret_strs[1] == 'internal':\n-      return None\n-    ret_type = convert_type(ret_strs[1])\n-    if ret_type is None:\n-      return None\n-    # Get function name\n-    func_strs = func_str.split('(')\n-    func_name = func_strs[0].replace('@', '')\n-    # Get arg_types\n-    arg_strs = func_strs[1].split(',')\n-    arg_types = []\n-    arg_names = []\n-    for arg_str in arg_strs:\n-      arg_type = convert_type(arg_str.split()[0])\n-      if arg_type is None:\n-        return None\n-      arg_name = arg_str.split()[1].replace('%', '')\n-      arg_types.append(arg_type)\n-      arg_names.append(arg_name)\n-    return Symbol(func_name, ret_type, arg_names, arg_types)\n-\n-  def _group_symbols(self):\n-    # The following cases are grouped together:\n-    # op_name, <u>op_name<ll/f>\n-    for symbol in self._symbols.values():\n-      op_name = symbol.op_name\n-      if op_name.startswith('u'):\n-        op_name = op_name[1:]\n-      elif op_name.endswith('ll'):\n-        op_name = op_name[:-2]\n-      elif op_name.endswith('f'):\n-        op_name = op_name[:-1]\n-      if op_name in self._symbol_groups:\n-        self._symbol_groups[op_name].append(symbol)\n-      else:\n-        self._symbol_groups[op_name] = [symbol]\n-\n-  def parse_symbols(self):\n-    if len(self.symbols) > 0:\n-      return\n-    output = subprocess.check_output(['grep', 'define', 'tmp/libdevice.ll']).decode().splitlines()\n-    for line in output:\n-      symbol = self._extract_symbol(line)\n-      if symbol is None:\n-        continue\n-      self._symbols[symbol.name] = symbol\n-\n-    self._group_symbols()\n-\n-  def generate_stubs(self, output_dir):\n-    # Generate python functions in the following format:\n-    # @core.builtin\n-    # def <op_name>(<args>, _builder=None):\n-    #   arg_type_symbol_dict = {[arg_type]: {(symbol, ret_type)}}\n-    #   return extern.dispatch(\"libdevice\", <path>, <args>, <arg_type_symbol_dict>, _builder)\n-    import_str = \"from . import core, extern\\n\"\n-    functions_str = \"core.builtin\\n\"\n-    for symbols in self._symbol_groups.values():\n-      func_name_str = f\"def {symbols[0].op_name}(\"\n-      for arg_name in symbols[0].arg_names:\n-        func_name_str += f\"{arg_name}, \"\n-      func_name_str += \"_builder=None):\\n\"\n-\n-      return_str = f\"return extern.dispatch(libdevice, {self.path}, \"\n-      for arg_name in symbol.arg_names:\n-        return_str += f\"[{arg_name}, \"\n-      return_str += \"], \"\n-\n-      arg_type_symbol_dict_str = \"{\"\n-      for symbol in symbols:\n-        arg_type_symbol_dict_str += \"[\"\n-        for arg_type in symbol.arg_types:\n-          arg_type_symbol_dict_str += arg_type + \",\"\n-        arg_type_symbol_dict_str += f\"]: {(symbol.name, symbol.ret_type)},\"\n-      arg_type_symbol_dict_str += \"}\"\n-\n-      return_str += arg_type_symbol_dict_str\n-      return_str += \", _builder)\\n\"\n-\n-      functions_str += func_name_str + return_str + \"\\n\"\n-\n-    with open(f\"{output_dir}/libdevice.py\", \"w\") as f:\n-      f.write(functions_str)\n-      f.close()\n-\n-\n-class LLVMDisassembler:\n-  def __init__(self, path):\n-    self.path = path\n-\n-  def disasm(self):\n-    subprocess.Popen([self.path, libdevice, '-o', '/tmp/libdevice.ll'],\n-                     stdout=subprocess.PIPE).communicate()\n-\n-\n-def extract_symbols(output):\n-  for line in output:\n-    print(line)\n-\n-\n-parser = argparse.ArgumentParser()\n-parser.add_argument('--llvm-dis-path', help='path to llvm-dis', default='llvm-dis')\n-parser.add_argument('--libdevice-path', help='path to libdevice.10.bc',\n-                    default=\"/usr/local/cuda/nvvm/libdevice/libdevice.10.bc\")\n-parser.add_argument('--output-dir', help='output file path', default='/tmp/')\n-args = parser.parse_args()\n-\n-llvm_disassembler = LLVMDisassembler(args.llvm_dis_path)\n-llvm_disassembler.disasm()\n-\n-libdevice = Libdevice(args.libdevice_path)\n-libdevice.parse_symbols()\n-libdevice.generate_stubs(args.output_dir)"}]