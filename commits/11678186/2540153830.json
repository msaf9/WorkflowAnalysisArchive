[{"filename": "include/triton/codegen/pass.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -30,10 +30,10 @@ namespace codegen{\n \n // TODO:\n // There should be a proper pass manager there!\n-std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMContext& ctx,\n-                                                     codegen::target* target,\n-                                                     int sm, int num_warps,\n-                                                     int num_stages, int &shared_static);\n+std::pair<std::unique_ptr<llvm::Module>, bool> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMContext& ctx,\n+                                                                      codegen::target* target,\n+                                                                      int sm, int num_warps,\n+                                                                      int num_stages, int &shared_static);\n \n \n }"}, {"filename": "include/triton/codegen/selection/generator.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -209,11 +209,14 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   void visit_layout_scanline(analysis::scanline_layout*);\n   void visit_layout_shared(analysis::shared_layout*);\n \n+  std::unique_ptr<Module> get_libdevice_module();\n+  void init_libdevice_module();\n \n private:\n   LLVMContext *ctx_;\n   Builder* builder_;\n   Module *mod_;\n+  std::unique_ptr<Module> libdevice_mod_;\n \n   analysis::axes *a_axes_;\n   analysis::swizzle *swizzle_;"}, {"filename": "include/triton/driver/llvm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -10,7 +10,7 @@ namespace driver{\n \n void init_llvm();\n std::string path_to_ptxas(int& version);\n-std::string llir_to_ptx(llvm::Module* module, int cc, int version);\n+std::string llir_to_ptx(llvm::Module* module, int cc, int version, bool link);\n std::string ptx_to_cubin(const std::string& ptx, const std::string& ptxas_path, int cc);\n CUmodule ptx_to_cumodule(const std::string& ptx, int cc);\n std::string llir_to_amdgpu(llvm::Module* module, const std::string& proc);"}, {"filename": "lib/codegen/pass.cc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "file_content_changes": "@@ -20,13 +20,15 @@\n #include \"llvm/IR/Module.h\"\n #include \"llvm/IR/LegacyPassManager.h\"\n #include \"llvm/IR/Verifier.h\"\n+#include \"llvm/Linker/Linker.h\"\n namespace triton {\n namespace codegen {\n \n // TODO:\n // There should be a proper pass manager there!\n-std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMContext& ctx, codegen::target* target,\n-                                                     int cc, int num_warps, int num_stages, int& shared_static) {\n+std::pair<std::unique_ptr<llvm::Module>, bool> add_passes_to_emit_bin(\n+    ir::module& ir, llvm::LLVMContext& ctx, codegen::target* target, int cc,\n+    int num_warps, int num_stages, int& shared_static) {\n   // generate llvm code\n   std::string name = ir.get_function_list()[0]->get_name();\n   std::unique_ptr<llvm::Module> llvm(new llvm::Module(name, ctx));\n@@ -91,7 +93,11 @@ std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMC\n   // ir.print(std::cout);\n   isel.visit(ir, *llvm);\n   shared_static = allocation.allocated_size();\n-  return llvm;\n+  bool link = false;\n+  if (isel.get_libdevice_module()) {\n+    llvm::Linker::linkModules(*llvm, std::move(isel.get_libdevice_module()));\n+  }\n+  return std::make_pair(std::move(llvm), link);\n }\n \n } // namespace codegen"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "file_content_changes": "@@ -20,6 +20,8 @@\n #include \"llvm/IR/BasicBlock.h\"\n #include \"llvm/IR/Attributes.h\"\n #include \"llvm/IR/InlineAsm.h\"\n+#include \"llvm/IRReader/IRReader.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n #include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\n \n namespace triton{\n@@ -1100,15 +1102,30 @@ void generator::visit_exp_inst(ir::exp_inst* x){\n   }\n }\n \n+std::unique_ptr<Module> generator::get_libdevice_module() {\n+  StringRef module_path = \"/usr/local/cuda/nvvm/libdevice/libdevice.10.bc\";\n+  SMDiagnostic err;\n+  auto libdevice_mod = parseIRFile(module_path, err, *ctx_);\n+  return libdevice_mod;\n+}\n+\n+void generator::init_libdevice_module() {\n+}\n+\n /**\n  * \\brief Code Generation for `cos`\n  */\n void generator::visit_cos_inst(ir::cos_inst* x){\n-  std::vector<llvm::Type*> tys = {f32_ty};\n-  FunctionType *fn_ty = FunctionType::get(f32_ty, tys, false);\n-  InlineAsm *cos = InlineAsm::get(fn_ty, \"cos.approx.f32 $0, $0;\", \"=f,0\", false);\n+  //std::vector<llvm::Type*> tys = {f32_ty};\n+  //FunctionType *fn_ty = FunctionType::get(f32_ty, tys, false);\n+  //InlineAsm *cos = InlineAsm::get(fn_ty, \"cos.approx.f32 $0, $0;\", \"=f,0\", false);\n+  // Replace it with acos to test libdevice for now\n+  FunctionType *FT =\n+      FunctionType::get(f32_ty, f32_ty, false);\n+  Function *F = llvm::cast<llvm::Function>(\n+      mod_->getOrInsertFunction(\"__nv_cosf\", FT).getCallee());\n   for(auto idx: idxs_.at(x)){\n-    vals_[x][idx] = call(cos, std::vector<llvm::Value*>{vals_[x->get_operand(0)][idx]});\n+    vals_[x][idx] = call(F, std::vector<llvm::Value*>{vals_[x->get_operand(0)][idx]});\n   }\n  }\n "}, {"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "file_content_changes": "@@ -45,10 +45,12 @@\n #include \"llvm/Target/TargetMachine.h\"\n #include \"llvm/Target/TargetOptions.h\"\n #include \"llvm/IR/LegacyPassManager.h\"\n+#include \"llvm/IR/GlobalValue.h\"\n #include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n #include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n #include \"llvm/Transforms/Utils/Cloning.h\"\n #include \"llvm/Transforms/Scalar.h\"\n+#include \"llvm/Transforms/IPO.h\"\n \n // begin AMD stuff\n #include \"llvm/Support/FileSystem.h\"\n@@ -149,7 +151,7 @@ int vptx(int version){\n   throw std::runtime_error(\"Triton requires CUDA 10+\");\n }\n \n-std::string llir_to_ptx(llvm::Module* module, int cc, int version){\n+std::string llir_to_ptx(llvm::Module* module, int cc, int version, bool link){\n   // LLVM version in use may not officially support target hardware\n   int max_nvvm_cc = 75;\n   int max_nvvm_ptx = 74;\n@@ -189,17 +191,32 @@ std::string llir_to_ptx(llvm::Module* module, int cc, int version){\n   opt.UnsafeFPMath = false;\n   opt.NoInfsFPMath = false;\n   opt.NoNaNsFPMath = true;\n-  machine = target->createTargetMachine(module->getTargetTriple(), proc, features, opt,\n-                                                             llvm::Reloc::PIC_, llvm::None, llvm::CodeGenOpt::Aggressive);\n+  machine = target->createTargetMachine(\n+      module->getTargetTriple(), proc, features, opt, llvm::Reloc::PIC_,\n+      llvm::None, llvm::CodeGenOpt::Aggressive);\n   // set data layout\n   if(layout.empty())\n     module->setDataLayout(machine->createDataLayout());\n   else\n     module->setDataLayout(layout);\n+  \n+  std::set<llvm::StringRef> function_names; \n   // emit machine code\n-  for (llvm::Function &f : module->functions())\n+  for (llvm::Function &f : module->functions()) {\n     f.addFnAttr(llvm::Attribute::AlwaysInline);\n+    function_names.insert(f.getFunction().getName());\n+  }\n+\n   llvm::legacy::PassManager pass;\n+  if (link) {\n+    pass.add(\n+        llvm::createInternalizePass([&](const llvm::GlobalValue& v) -> bool {\n+          if (function_names.count(v.getName()) != 0) {\n+            return true;\n+          }\n+          return false;\n+        }));\n+  }\n   llvm::raw_svector_ostream stream(buffer);\n   // emit\n   machine->addPassesToEmitFile(pass, stream, nullptr, llvm::CodeGenFileType::CGFT_AssemblyFile);"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -483,14 +483,14 @@ std::tuple<std::string, asm_map_t, int> cu_compile_ttir(const std::string& name,\n   std::string ptxas_path = drv::path_to_ptxas(version);\n   // Triton-IR -> NVPTX LLVM-IR\n   triton::codegen::nvidia_cu_target target(cc);\n-  auto llvm = triton::codegen::add_passes_to_emit_bin(ir, ctx, &target, cc, num_warps, num_stages, n_shared_bytes);\n+  auto[llvm, link] = triton::codegen::add_passes_to_emit_bin(ir, ctx, &target, cc, num_warps, num_stages, n_shared_bytes);\n   std::string tmp;\n   llvm::raw_string_ostream llir(tmp);\n   llir << *llvm;\n   llir.flush();\n   asm_map[\"llir\"] = py::cast(tmp);\n   // LLVM-IR -> PTX\n-  std::string ptx = drv::llir_to_ptx(llvm.get(), cc, version);\n+  std::string ptx = drv::llir_to_ptx(llvm.get(), cc, version, link);\n   asm_map[\"ptx\"] = py::cast(ptx);\n   // PTX -> Binary\n   std::string cubin = drv::ptx_to_cubin(ptx, ptxas_path, cc);\n@@ -509,7 +509,7 @@ std::tuple<std::string, asm_map_t, int> hip_compile_ttir(const std::string& name\n   // Triton-IR -> NVPTX LLVM-IR\n   triton::codegen::amd_cl_target target;\n   int n_shared_bytes;\n-  auto llvm = triton::codegen::add_passes_to_emit_bin(ir, ctx, &target, 70, num_warps, num_stages, n_shared_bytes);\n+  auto[llvm, link] = triton::codegen::add_passes_to_emit_bin(ir, ctx, &target, 70, num_warps, num_stages, n_shared_bytes);\n   std::string tmp;\n   llvm::raw_string_ostream llir(tmp);\n   llir << *llvm;"}]