[{"filename": "python/triton/__init__.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -7,7 +7,8 @@\n import torch\n # submodules\n from .utils import *\n-from .runtime import jit, Config, autotune, heuristics, JITFunction, KernelInterface\n+from .runtime import Config, autotune, heuristics, JITFunction, KernelInterface\n+from .runtime.jit import jit\n from .compiler import compile, CompilationError\n from . import language\n from . import testing"}, {"filename": "python/triton/runtime/__init__.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1,3 +1,3 @@\n from .autotuner import Config, Heuristics, autotune, heuristics  # noqa: F401\n-from .jit import (JITFunction, KernelInterface, build_kernel, jit,  # noqa: F401\n-                  launch_kernel)\n+from .jit import (JITFunction, KernelInterface, build_kernel,  # noqa: F401\n+                  launch_kernel, version_key)"}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "file_content_changes": "@@ -1,6 +1,7 @@\n from __future__ import annotations, division\n \n import ast\n+from collections import namedtuple\n import functools\n import hashlib\n import inspect\n@@ -171,7 +172,7 @@ class JITFunction(KernelInterface):\n     @staticmethod\n     def _key_of(arg):\n         if hasattr(arg, \"dtype\"):\n-            return arg.dtype\n+            return str(arg.dtype)\n         elif isinstance(arg, bool):\n             return \"i1\"\n         elif isinstance(arg, int):\n@@ -209,32 +210,32 @@ def is_divisible_by_16(x):\n             return False\n         divisible_by_16 = {i for i, arg in enumerate(args) if is_divisible_by_16(arg) and i not in self.do_not_specialize}\n         equal_to_1 = {i for i, arg in enumerate(args) if isinstance(arg, int) and arg == 1 and i not in self.do_not_specialize}\n-        return _triton.code_gen.instance_descriptor(divisible_by_16, equal_to_1)\n+        return namedtuple(\"instance_descriptor\", [\"divisible_by_16\", \"equal_to_1\"])(tuple(divisible_by_16), tuple(equal_to_1))\n+        # return _triton.code_gen.instance_descriptor(divisible_by_16, equal_to_1)\n \n     @staticmethod\n     def _type_of(key):\n-        if isinstance(key, (torch.dtype, triton.language.dtype)):\n+        if key is None:\n+            return '*i8'\n+        if \"torch.\" in key or \"triton.\" in key:\n+            key = key.split(\".\")[-1]\n             ty = {\n-                torch.bool: 'i1',\n-                torch.float16: 'fp16',\n-                torch.bfloat16: 'bf16',\n-                torch.float32: 'fp32',\n-                torch.float64: 'fp64',\n-                torch.uint8: 'u8',\n-                torch.int8: 'i8',\n-                torch.int16: 'i16',\n-                torch.int32: 'i32',\n-                torch.int64: 'i64',\n-\n-                triton.language.uint8: 'u8',\n-                triton.language.uint16: 'u16',\n-                triton.language.uint32: 'u32',\n-                triton.language.uint64: 'u64',\n-                triton.language.float8: 'fp8',\n+                \"bool\": 'i1',\n+                \"float8\": 'fp8',\n+                \"float16\": 'fp16',\n+                \"bfloat16\": 'bf16',\n+                \"float32\": 'fp32',\n+                \"float64\": 'fp64',\n+                \"uint8\": 'u8',\n+                \"uint16\": 'u16',\n+                \"uint32\": 'u32',\n+                \"uint64\": 'u64',\n+                \"int8\": 'i8',\n+                \"int16\": 'i16',\n+                \"int32\": 'i32',\n+                \"int64\": 'i64',\n             }[key]\n             return f'*{ty}'\n-        if key is None:\n-            return '*i8'\n         assert isinstance(key, str)\n         return key\n \n@@ -249,24 +250,32 @@ def _make_constants(self, constexpr_key):\n     def _call_hook(self, key, signature, device, constants, num_warps, num_stages, extern_libs, configs):\n         if JITFunction.cache_hook is None:\n             return False\n-        # TODO: assemble compilation-key into human-readable format\n         name = self.fn.__name__\n+        module = self.fn.__module__\n         arg_reprs = ', '.join([f'{name}: {ty}' for name, ty in zip(self.arg_names, key[1])])\n         repr = f\"{name}[num_warps={num_warps}, num_stages={num_stages}]({arg_reprs})\"\n+        key = str(key)\n \n         class LegacyCompiler:\n-            def __init__(self):\n+            def __init__(self, module, name):\n+                self.module = module\n+                self.name = name\n                 pass\n \n-            def warmup(kwargs):\n-                bin = triton.compile(**kwargs)\n-                self.cache[key] = bin\n-\n-        kwargs = dict(fn=self, signature=signature, device=device, constants=constants,\n+        kwargs = dict(signature=signature, device=device, constants=constants,\n                       num_warps=num_warps, num_stages=num_stages, extern_libs=extern_libs,\n                       configs=configs)\n+       \n+        # test = dict()\n+        # import msgpack\n+        # test[key] = {\"fn_name\": name, \"compile\": kwargs, \"repr\": repr}\n+        # with open(\"test.msgpack\", \"wb\") as f:\n+        #   msgpack.dump(test, f)\n+        # with open(\"test.msgpack\", \"rb\") as f:\n+        #   msgpack.load(f, strict_map_key=False)\n+\n \n-        return JITFunction.cache_hook(key=key, repr=repr, fn=LegacyCompiler(), compile={\"key\": key, **kwargs}, is_manual_warmup=False, already_compiled=False)\n+        return JITFunction.cache_hook(key=key, repr=repr, fn=LegacyCompiler(module, name), compile={\"key\": key, **kwargs}, is_manual_warmup=False, already_compiled=False)\n \n     def _make_launcher(self):\n         regular_args = [f'{arg}' for i, arg in enumerate(self.arg_names) if i not in self.constexprs]\n@@ -314,7 +323,7 @@ def {self.fn.__name__}({', '.join(self.arg_names)}, grid, num_warps=4, num_stage\n     except KeyError:\n       # build dict of constant values\n       args = [{args}]\n-      configs = [self._get_config(*args)]\n+      configs = self._get_config(*args),\n       constants = self._make_constants(constexpr_key)\n       constants.update({{i: None for i, arg in enumerate(args) if arg is None}})\n       constants.update({{i: 1 for i in configs[0].equal_to_1}})"}]