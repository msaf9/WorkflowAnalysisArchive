[{"filename": "python/triton/__init__.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -7,7 +7,8 @@\n import torch\n # submodules\n from .utils import *\n-from .runtime import jit, Config, autotune, heuristics, JITFunction, KernelInterface\n+from .runtime import Config, autotune, heuristics, JITFunction, KernelInterface\n+from .runtime.jit import jit\n from .compiler import compile, CompilationError\n from . import language\n from . import testing"}, {"filename": "python/triton/runtime/__init__.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1,3 +1,3 @@\n from .autotuner import Config, Heuristics, autotune, heuristics  # noqa: F401\n-from .jit import (JITFunction, KernelInterface, build_kernel, jit,  # noqa: F401\n-                  launch_kernel)\n+from .jit import (JITFunction, KernelInterface, build_kernel,  # noqa: F401\n+                  launch_kernel, version_key)"}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "file_content_changes": "@@ -8,6 +8,7 @@\n import subprocess\n import tempfile\n import textwrap\n+from collections import namedtuple\n from typing import Any, Dict, List, Optional\n \n import torch\n@@ -209,7 +210,8 @@ def is_divisible_by_16(x):\n             return False\n         divisible_by_16 = {i for i, arg in enumerate(args) if is_divisible_by_16(arg) and i not in self.do_not_specialize}\n         equal_to_1 = {i for i, arg in enumerate(args) if isinstance(arg, int) and arg == 1 and i not in self.do_not_specialize}\n-        return _triton.code_gen.instance_descriptor(divisible_by_16, equal_to_1)\n+        return namedtuple(\"instance_descriptor\", [\"divisible_by_16\", \"equal_to_1\"])(tuple(divisible_by_16), tuple(equal_to_1))\n+        # return _triton.code_gen.instance_descriptor(divisible_by_16, equal_to_1)\n \n     @staticmethod\n     def _type_of(key):\n@@ -236,7 +238,7 @@ def _type_of(key):\n         if key is None:\n             return '*i8'\n         assert isinstance(key, str)\n-        return key\n+        return\n \n     def _make_signature(self, sig_key):\n         signature = \",\".join([self._type_of(k) for i, k in enumerate(sig_key)])\n@@ -249,24 +251,23 @@ def _make_constants(self, constexpr_key):\n     def _call_hook(self, key, signature, device, constants, num_warps, num_stages, extern_libs, configs):\n         if JITFunction.cache_hook is None:\n             return False\n-        # TODO: assemble compilation-key into human-readable format\n         name = self.fn.__name__\n+        module = self.fn.__module__\n         arg_reprs = ', '.join([f'{name}: {ty}' for name, ty in zip(self.arg_names, key[1])])\n         repr = f\"{name}[num_warps={num_warps}, num_stages={num_stages}]({arg_reprs})\"\n+        key = str(key)\n \n         class LegacyCompiler:\n-            def __init__(self):\n+            def __init__(self, module, name):\n+                self.module = module\n+                self.name = name\n                 pass\n \n-            def warmup(kwargs):\n-                bin = triton.compile(**kwargs)\n-                self.cache[key] = bin\n-\n-        kwargs = dict(fn=self, signature=signature, device=device, constants=constants,\n+        kwargs = dict(signature=signature, device=device, constants=constants,\n                       num_warps=num_warps, num_stages=num_stages, extern_libs=extern_libs,\n                       configs=configs)\n \n-        return JITFunction.cache_hook(key=key, repr=repr, fn=LegacyCompiler(), compile={\"key\": key, **kwargs}, is_manual_warmup=False, already_compiled=False)\n+        return JITFunction.cache_hook(key=key, repr=repr, fn=LegacyCompiler(module, name), compile={\"key\": key, **kwargs}, is_manual_warmup=False, already_compiled=False)\n \n     def _make_launcher(self):\n         regular_args = [f'{arg}' for i, arg in enumerate(self.arg_names) if i not in self.constexprs]\n@@ -314,7 +315,7 @@ def {self.fn.__name__}({', '.join(self.arg_names)}, grid, num_warps=4, num_stage\n     except KeyError:\n       # build dict of constant values\n       args = [{args}]\n-      configs = [self._get_config(*args)]\n+      configs = self._get_config(*args),\n       constants = self._make_constants(constexpr_key)\n       constants.update({{i: None for i, arg in enumerate(args) if arg is None}})\n       constants.update({{i: 1 for i in configs[0].equal_to_1}})"}]