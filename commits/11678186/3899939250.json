[{"filename": "lib/Dialect/TritonGPU/Transforms/UpdateMmaForVolta.cpp", "status": "modified", "additions": 122, "deletions": 102, "changes": 224, "file_content_changes": "@@ -15,6 +15,122 @@ using triton::gpu::DotOperandEncodingAttr;\n using triton::gpu::MmaEncodingAttr;\n using triton::gpu::SliceEncodingAttr;\n \n+// This pattern collects the wrong Mma those need to update and create the right\n+// ones for each.\n+// TODO[Superjomn]: RewirtePattern is not needed here, Rewrite this to a method\n+class CollectMmaToUpdateForVolta : public mlir::RewritePattern {\n+  // Holds the mapping from old(wrong) mmaEncodingAttr to the new(correct)\n+  // mmaEncodingAttr.\n+  DenseMap<MmaEncodingAttr, MmaEncodingAttr> &mmaToUpdate;\n+\n+public:\n+  CollectMmaToUpdateForVolta(\n+      mlir::MLIRContext *ctx,\n+      DenseMap<MmaEncodingAttr, MmaEncodingAttr> &mmaToUpdate)\n+      : mlir::RewritePattern(triton::DotOp::getOperationName(), 1, ctx),\n+        mmaToUpdate(mmaToUpdate) {}\n+\n+  mlir::LogicalResult\n+  matchAndRewrite(mlir::Operation *op,\n+                  mlir::PatternRewriter &rewriter) const override {\n+\n+    auto dotOp = cast<triton::DotOp>(op);\n+    auto *ctx = dotOp->getContext();\n+    auto AT = dotOp.a().getType().cast<RankedTensorType>();\n+    auto BT = dotOp.b().getType().cast<RankedTensorType>();\n+    auto DT = dotOp.d().getType().cast<RankedTensorType>();\n+    if (!DT.getEncoding())\n+      return failure();\n+    auto mmaLayout = DT.getEncoding().dyn_cast<MmaEncodingAttr>();\n+    if (!(mmaLayout && mmaLayout.isVolta()))\n+      return failure();\n+\n+    // Has processed.\n+    if (mmaToUpdate.count(mmaLayout))\n+      return failure();\n+\n+    auto dotOperandA = AT.getEncoding().cast<DotOperandEncodingAttr>();\n+    auto dotOperandB = BT.getEncoding().cast<DotOperandEncodingAttr>();\n+    bool isARow = dotOperandA.getIsMMAv1Row().cast<BoolAttr>().getValue();\n+    bool isBRow = dotOperandB.getIsMMAv1Row().cast<BoolAttr>().getValue();\n+    auto [isARow_, isBRow_, isAVec4, isBVec4, mmaId] =\n+        mmaLayout.decodeVoltaLayoutStates();\n+\n+    // The wpt of MMAv1 is also determined by isARow, isBRow and shape, and it\n+    // could only be set here for those states might be updated by previous\n+    // patterns in the Combine Pass.\n+    if (isARow_ == isARow && isBRow_ == isBRow) {\n+      auto tgtWpt =\n+          getWarpsPerCTA(DT.getShape(), isARow, isBRow, isAVec4, isBVec4,\n+                         product(mmaLayout.getWarpsPerCTA()));\n+      // Check if the wpt should be updated.\n+      if (tgtWpt == mmaLayout.getWarpsPerCTA() ||\n+          !MmaEncodingAttr::_mmaV1UpdateWpt)\n+        return failure();\n+    }\n+\n+    MmaEncodingAttr newMmaLayout;\n+    {\n+      // Create a temporary MMA layout to obtain the isAVec4 and isBVec4\n+      auto tmpMmaLayout = MmaEncodingAttr::get(\n+          ctx, mmaLayout.getVersionMajor(), mmaLayout.getWarpsPerCTA(),\n+          AT.getShape(), BT.getShape(), isARow, isBRow, mmaId);\n+      auto [isARow_, isBRow_, isAVec4_, isBVec4_, _] =\n+          tmpMmaLayout.decodeVoltaLayoutStates();\n+\n+      // Recalculate the wpt, for here we could get the latest information, the\n+      // wpt should be updated.\n+      auto updatedWpt =\n+          getWarpsPerCTA(DT.getShape(), isARow_, isBRow_, isAVec4_, isBVec4_,\n+                         product(mmaLayout.getWarpsPerCTA()));\n+      auto newWpt = MmaEncodingAttr::_mmaV1UpdateWpt\n+                        ? updatedWpt\n+                        : mmaLayout.getWarpsPerCTA();\n+      newMmaLayout = MmaEncodingAttr::get(ctx, mmaLayout.getVersionMajor(),\n+                                          newWpt, AT.getShape(), BT.getShape(),\n+                                          isARow, isBRow, mmaId);\n+    }\n+\n+    // Collect the wrong MMA Layouts, and mark need to update.\n+    mmaToUpdate.try_emplace(mmaLayout, newMmaLayout);\n+\n+    return failure();\n+  }\n+\n+  // Get the wpt for MMAv1 using more information.\n+  // Reference the original logic here\n+  // https://github.com/openai/triton/blob/0e4691e6dd91e001a8d33b71badf8b3314325459/lib/codegen/analysis/layout.cc#L223\n+  SmallVector<unsigned, 2> getWarpsPerCTA(ArrayRef<int64_t> shape, bool isARow,\n+                                          bool isBRow, bool isAVec4,\n+                                          bool isBVec4, int numWarps) const {\n+    // TODO[Superjomn]: Share code with\n+    // DotOpMmaV1ConversionHelper::AParam/BParam, since same code to compute the\n+    // rep,spw and fpw.\n+    SmallVector<unsigned, 2> wpt({1, 1});\n+    SmallVector<unsigned, 2> wpt_nm1;\n+\n+    SmallVector<int, 2> rep(2), spw(2);\n+    std::array<int, 3> fpw{{2, 2, 1}};\n+    int packSize0 = (isARow || isAVec4) ? 1 : 2;\n+    rep[0] = 2 * packSize0;\n+    spw[0] = fpw[0] * 4 * rep[0];\n+\n+    int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n+    rep[1] = 2 * packSize1;\n+    spw[1] = fpw[1] * 4 * rep[1];\n+\n+    do {\n+      wpt_nm1 = wpt;\n+      if (wpt[0] * wpt[1] < numWarps)\n+        wpt[0] = std::clamp<int>(wpt[0] * 2, 1, shape[0] / spw[0]);\n+      if (wpt[0] * wpt[1] < numWarps)\n+        wpt[1] = std::clamp<int>(wpt[1] * 2, 1, shape[1] / spw[1]);\n+    } while (wpt_nm1 != wpt);\n+\n+    return wpt;\n+  }\n+};\n+\n class UpdateMMAForMMAv1 : public mlir::RewritePattern {\n   const DenseMap<MmaEncodingAttr, MmaEncodingAttr> &mmaToUpdate;\n \n@@ -196,13 +312,17 @@ class UpdateMmaForVoltaPass\n     : public UpdateMmaForVoltaBase<UpdateMmaForVoltaPass> {\n public:\n   UpdateMmaForVoltaPass() = default;\n-\n   void runOnOperation() override {\n     MLIRContext *context = &getContext();\n     ModuleOp m = getOperation();\n \n     llvm::DenseMap<MmaEncodingAttr, MmaEncodingAttr> mmaToUpdate;\n-    collectMmaToUpdate(m, mmaToUpdate);\n+    {\n+      mlir::RewritePatternSet patterns(context);\n+      patterns.add<CollectMmaToUpdateForVolta>(context, mmaToUpdate);\n+      if (applyPatternsAndFoldGreedily(m, std::move(patterns)).failed())\n+        signalPassFailure();\n+    }\n \n     if (!mmaToUpdate.empty()) {\n       mlir::RewritePatternSet patterns(context);\n@@ -221,106 +341,6 @@ class UpdateMmaForVoltaPass\n       signalPassFailure();\n     }\n   }\n-\n-  // This collects the wrong Mma those need to update and create the right ones\n-  // for each.\n-  void collectMmaToUpdate(\n-      const ModuleOp &m,\n-      llvm::DenseMap<MmaEncodingAttr, MmaEncodingAttr> &mmaToUpdate) {\n-    m->walk([&](DotOp dotOp) {\n-      auto *ctx = dotOp->getContext();\n-      auto AT = dotOp.a().getType().cast<RankedTensorType>();\n-      auto BT = dotOp.b().getType().cast<RankedTensorType>();\n-      auto DT = dotOp.d().getType().cast<RankedTensorType>();\n-      if (!DT.getEncoding())\n-        return;\n-      auto mmaLayout = DT.getEncoding().dyn_cast<MmaEncodingAttr>();\n-      if (!(mmaLayout && mmaLayout.isVolta()))\n-        return;\n-\n-      // Has processed.\n-      if (mmaToUpdate.count(mmaLayout))\n-        return;\n-\n-      auto dotOperandA = AT.getEncoding().cast<DotOperandEncodingAttr>();\n-      auto dotOperandB = BT.getEncoding().cast<DotOperandEncodingAttr>();\n-      bool isARow = dotOperandA.getIsMMAv1Row().cast<BoolAttr>().getValue();\n-      bool isBRow = dotOperandB.getIsMMAv1Row().cast<BoolAttr>().getValue();\n-      auto [isARow_, isBRow_, isAVec4, isBVec4, mmaId] =\n-          mmaLayout.decodeVoltaLayoutStates();\n-\n-      // The wpt of MMAv1 is also determined by isARow, isBRow and shape, and it\n-      // could only be set here for those states might be updated by previous\n-      // patterns in the Combine Pass.\n-      if (isARow_ == isARow && isBRow_ == isBRow) {\n-        auto tgtWpt =\n-            getWarpsPerCTA(DT.getShape(), isARow, isBRow, isAVec4, isBVec4,\n-                           product(mmaLayout.getWarpsPerCTA()));\n-        // Check if the wpt should be updated.\n-        if (tgtWpt == mmaLayout.getWarpsPerCTA() ||\n-            !MmaEncodingAttr::_mmaV1UpdateWpt)\n-          return;\n-      }\n-\n-      MmaEncodingAttr newMmaLayout;\n-      {\n-        // Create a temporary MMA layout to obtain the isAVec4 and isBVec4\n-        auto tmpMmaLayout = MmaEncodingAttr::get(\n-            ctx, mmaLayout.getVersionMajor(), mmaLayout.getWarpsPerCTA(),\n-            AT.getShape(), BT.getShape(), isARow, isBRow, mmaId);\n-        auto [isARow_, isBRow_, isAVec4_, isBVec4_, _] =\n-            tmpMmaLayout.decodeVoltaLayoutStates();\n-\n-        // Recalculate the wpt, for here we could get the latest information,\n-        // the wpt should be updated.\n-        auto updatedWpt =\n-            getWarpsPerCTA(DT.getShape(), isARow_, isBRow_, isAVec4_, isBVec4_,\n-                           product(mmaLayout.getWarpsPerCTA()));\n-        auto newWpt = MmaEncodingAttr::_mmaV1UpdateWpt\n-                          ? updatedWpt\n-                          : mmaLayout.getWarpsPerCTA();\n-        newMmaLayout = MmaEncodingAttr::get(\n-            ctx, mmaLayout.getVersionMajor(), newWpt, AT.getShape(),\n-            BT.getShape(), isARow, isBRow, mmaId);\n-      }\n-\n-      // Collect the wrong MMA Layouts, and mark need to update.\n-      mmaToUpdate.try_emplace(mmaLayout, newMmaLayout);\n-    });\n-  }\n-\n-  // Get the wpt for MMAv1 using more information.\n-  // Reference the original logic here\n-  // https://github.com/openai/triton/blob/0e4691e6dd91e001a8d33b71badf8b3314325459/lib/codegen/analysis/layout.cc#L223\n-  SmallVector<unsigned, 2> getWarpsPerCTA(ArrayRef<int64_t> shape, bool isARow,\n-                                          bool isBRow, bool isAVec4,\n-                                          bool isBVec4, int numWarps) const {\n-    // TODO[Superjomn]: Share code with\n-    // DotOpMmaV1ConversionHelper::AParam/BParam, since same code to compute the\n-    // rep,spw and fpw.\n-    SmallVector<unsigned, 2> wpt({1, 1});\n-    SmallVector<unsigned, 2> wpt_nm1;\n-\n-    SmallVector<int, 2> rep(2), spw(2);\n-    std::array<int, 3> fpw{{2, 2, 1}};\n-    int packSize0 = (isARow || isAVec4) ? 1 : 2;\n-    rep[0] = 2 * packSize0;\n-    spw[0] = fpw[0] * 4 * rep[0];\n-\n-    int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n-    rep[1] = 2 * packSize1;\n-    spw[1] = fpw[1] * 4 * rep[1];\n-\n-    do {\n-      wpt_nm1 = wpt;\n-      if (wpt[0] * wpt[1] < numWarps)\n-        wpt[0] = std::clamp<int>(wpt[0] * 2, 1, shape[0] / spw[0]);\n-      if (wpt[0] * wpt[1] < numWarps)\n-        wpt[1] = std::clamp<int>(wpt[1] * 2, 1, shape[1] / spw[1]);\n-    } while (wpt_nm1 != wpt);\n-\n-    return wpt;\n-  }\n };\n \n std::unique_ptr<Pass> createTritonGPUUpdateMmaForVoltaPass() {"}]