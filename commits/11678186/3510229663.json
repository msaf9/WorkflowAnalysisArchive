[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "file_content_changes": "@@ -472,8 +472,6 @@ def visit_UnaryOp(self, node):\n         if type(node.op) == ast.Not:\n             assert isinstance(op, triton.language.constexpr), \"`not` only supported for constexpr at the moment\"\n             return triton.language.constexpr(not op)\n-        if isinstance(op, triton.language.constexpr):\n-            op = op.value\n         fn = {\n             ast.USub: '__neg__',\n             ast.UAdd: '__pos__',\n@@ -563,27 +561,30 @@ def visit_For(self, node):\n         iterator = self.visit(node.iter.func)\n         if iterator != self.builtins['range']:\n             raise RuntimeError('Only `range` iterator currently supported')\n-        # static for loops: all iterator arguments are constexpr\n+        # visit iterator arguments\n+        # note: only `range` iterator is supported now\n         iter_args = [self.visit(arg) for arg in node.iter.args]\n-        static_unrolling = os.environ.get('TRITON_STATIC_LOOP_UNROLLING', False)\n-        is_static = False\n-        if static_unrolling:\n-            is_static = all([isinstance(x, triton.language.constexpr) for x in iter_args])\n-        if is_static:\n-            iter_args = [arg.value for arg in iter_args]\n-            range = iterator(*iter_args)\n-            if len(range) <= 10:\n-                for i in iterator(*iter_args):\n+        # collect lower bound (lb), upper bound (ub), and step\n+        lb = iter_args[0] if len(iter_args) > 1 else self.visit(ast.Num(0))\n+        ub = iter_args[1] if len(iter_args) > 1 else self.visit(node.iter.args[0])\n+        step = iter_args[2] if len(iter_args) > 2 else self.visit(ast.Num(1))\n+        # static for loops: all iterator arguments are constexpr\n+        if isinstance(lb, triton.language.constexpr) and \\\n+           isinstance(ub, triton.language.constexpr) and \\\n+           isinstance(step, triton.language.constexpr):\n+            sta_range = iterator(lb.value, ub.value, step.value)\n+            static_unrolling = os.environ.get('TRITON_STATIC_LOOP_UNROLLING', False)\n+            if static_unrolling and len(range) <= 10:\n+                for i in sta_range:\n                     self.lscope[node.target.id] = triton.language.constexpr(i)\n                     self.visit_compound_statement(node.body)\n                     for stmt in node.orelse:\n                         ast.NodeVisitor.generic_visit(self, stmt)\n                 return\n-\n-        # collect lower bound (lb), upper bound (ub), and step\n-        lb = self.visit(node.iter.args[0] if len(node.iter.args) > 1 else ast.Num(0))\n-        ub = self.visit(node.iter.args[1] if len(node.iter.args) > 1 else node.iter.args[0])\n-        step = self.visit(node.iter.args[2] if len(node.iter.args) > 2 else ast.Num(1))\n+        # handle negative constant step (not supported by scf.for in MLIR)\n+        if isinstance(step, triton.language.constexpr) and step.value < 0:\n+            step = triton.language.constexpr(-step.value)\n+            lb, ub = ub, lb\n         # lb/ub/step might be constexpr, we need to cast them to tensor\n         lb = triton.language.core._to_tensor(lb, self.builder).handle\n         ub = triton.language.core._to_tensor(ub, self.builder).handle"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "file_content_changes": "@@ -345,67 +345,76 @@ def __repr__(self) -> str:\n         return f\"constexpr[{self.value}]\"\n \n     def __add__(self, other):\n-        return self.value + other.value\n+        return constexpr(self.value + other.value)\n \n     def __radd__(self, other):\n-        return other.value + self.value\n+        return constexpr(other.value + self.value)\n \n     def __sub__(self, other):\n-        return self.value - other.value\n+        return constexpr(self.value - other.value)\n \n     def __rsub__(self, other):\n-        return other.value - self.value\n+        return constexpr(other.value - self.value)\n \n     def __mul__(self, other):\n-        return self.value * other.value\n+        return constexpr(self.value * other.value)\n \n     def __rmul__(self, other):\n-        return other.value * self.value\n+        return constexpr(other.value * self.value)\n \n     def __truediv__(self, other):\n-        return self.value / other.value\n+        return constexpr(self.value / other.value)\n \n     def __rtruediv__(self, other):\n-        return other.value / self.value\n+        return constexpr(other.value / self.value)\n \n     def __floordiv__(self, other):\n-        return self.value // other.value\n+        return constexpr(self.value // other.value)\n \n     def __rfloordiv__(self, other):\n-        return other.value // self.value\n+        return constexpr(other.value // self.value)\n \n     def __gt__(self, other):\n-        return self.value > other.value\n+        return constexpr(self.value > other.value)\n \n     def __rgt__(self, other):\n-        return other.value > self.value\n+        return constexpr(other.value > self.value)\n \n     def __ge__(self, other):\n-        return self.value >= other.value\n+        return constexpr(self.value >= other.value)\n \n     def __rge__(self, other):\n-        return other.value >= self.value\n+        return constexpr(other.value >= self.value)\n \n     def __lt__(self, other):\n-        return self.value < other.value\n+        return constexpr(self.value < other.value)\n \n     def __rlt__(self, other):\n-        return other.value < self.value\n+        return constexpr(other.value < self.value)\n \n     def __le__(self, other):\n-        return self.value <= other.value\n+        return constexpr(self.value <= other.value)\n \n     def __rle__(self, other):\n-        return other.value <= self.value\n+        return constexpr(other.value <= self.value)\n \n     def __eq__(self, other):\n-        return self.value == other.value\n+        return constexpr(self.value == other.value)\n \n     def __ne__(self, other):\n-        return self.value != other.value\n+        return constexpr(self.value != other.value)\n \n     def __bool__(self):\n-        return bool(self.value)\n+        return constexpr(bool(self.value))\n+\n+    def __neg__(self):\n+        return constexpr(-self.value)\n+    \n+    def __pos__(self):\n+        return constexpr(+self.value)\n+    \n+    def __invert__(self):\n+        return constexpr(~self.value)\n \n     def __call__(self, *args, **kwds):\n         return self.value(*args, **kwds)"}]