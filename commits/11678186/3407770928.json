[{"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "file_content_changes": "@@ -151,7 +151,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n     return nullptr;\n   }\n \n-  std::map<std::string, std::string> extern_libs;\n+  std::map<std::string, std::string> externLibs;\n   SmallVector<LLVM::LLVMFuncOp> funcs;\n   module.walk([&](LLVM::LLVMFuncOp func) {\n     if (func.isExternal())\n@@ -166,7 +166,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n           func.getOperation()->getAttr(\"libpath\").dyn_cast<StringAttr>();\n       if (name) {\n         std::string lib_name = name.str();\n-        extern_libs[lib_name] = path.str();\n+        externLibs[lib_name] = path.str();\n       }\n     }\n   }\n@@ -176,7 +176,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n                     ->getAttr(\"triton_gpu.externs\")\n                     .dyn_cast<DictionaryAttr>();\n     for (auto &attr : dict) {\n-      extern_libs[attr.getName().strref().trim().str()] =\n+      externLibs[attr.getName().strref().trim().str()] =\n           attr.getValue().dyn_cast<StringAttr>().strref().trim().str();\n     }\n   }\n@@ -188,7 +188,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n   }\n \n   llvm::SMDiagnostic err;\n-  for (auto &lib : extern_libs) {\n+  for (auto &lib : externLibs) {\n     if (!linkExternLib(*llvmir, lib.second))\n       return nullptr;\n   }\n@@ -220,16 +220,16 @@ bool linkExternLib(llvm::Module &module, llvm::StringRef path) {\n   llvm::SMDiagnostic err;\n   auto &ctx = module.getContext();\n \n-  auto deviceMod = llvm::parseIRFile(path, err, ctx);\n-  if (!deviceMod) {\n+  auto extMod = llvm::parseIRFile(path, err, ctx);\n+  if (!extMod) {\n     llvm::errs() << \"Failed to load libdevice\";\n     return false;\n   }\n \n-  deviceMod->setTargetTriple(module.getTargetTriple());\n-  deviceMod->setDataLayout(module.getDataLayout());\n+  extMod->setTargetTriple(module.getTargetTriple());\n+  extMod->setDataLayout(module.getDataLayout());\n \n-  if (llvm::Linker::linkModules(module, std::move(deviceMod),\n+  if (llvm::Linker::linkModules(module, std::move(extMod),\n                                 llvm::Linker::Flags::LinkOnlyNeeded)) {\n     llvm::errs() << \"Failed to link libdevice\";\n     return false;"}, {"filename": "lib/Target/PTX/PTXTranslation.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -91,12 +91,12 @@ static std::string llir_to_ptx(llvm::Module *module, int capability, int ptx) {\n   {\n     auto &ctx = module->getContext();\n     llvm::Type *I32 = llvm::Type::getInt32Ty(ctx);\n-    llvm::Metadata *md_four =\n+    llvm::Metadata *mdFour =\n         llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 4));\n-    llvm::Metadata *md_name = llvm::MDString::get(ctx, \"nvvm-reflect-ftz\");\n-    llvm::Metadata *md_one =\n+    llvm::Metadata *mdName = llvm::MDString::get(ctx, \"nvvm-reflect-ftz\");\n+    llvm::Metadata *mdOne =\n         llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 1));\n-    llvm::MDNode *reflect = llvm::MDNode::get(ctx, {md_four, md_name, md_one});\n+    llvm::MDNode *reflect = llvm::MDNode::get(ctx, {mdFour, mdName, mdOne});\n     module->addModuleFlag(reflect);\n   }\n   // LLVM version in use may not officially support target hardware"}]