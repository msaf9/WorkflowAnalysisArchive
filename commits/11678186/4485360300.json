[{"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.cpp", "status": "modified", "additions": 56, "deletions": 51, "changes": 107, "file_content_changes": "@@ -122,21 +122,21 @@ struct FpToFpOpConversion\n   convertFp8E4M3x4ToBf16x4(Location loc, ConversionPatternRewriter &rewriter,\n                            const Value &v0, const Value &v1, const Value &v2,\n                            const Value &v3) {\n-    auto *ptxAsm = \"{                                          \\n\"\n-                   \".reg .b32 a<2>, sign<2>, nosign<2>, b<2>;  \\n\"\n-                   \"prmt.b32 a0, 0, $2, 0x5040;                \\n\"\n-                   \"prmt.b32 a1, 0, $2, 0x7060;                \\n\"\n-                   \"and.b32 sign0, a0, 0x80008000;             \\n\"\n-                   \"and.b32 sign1, a1, 0x80008000;             \\n\"\n-                   \"and.b32 nosign0, a0, 0x7fff7fff;           \\n\"\n-                   \"and.b32 nosign1, a1, 0x7fff7fff;           \\n\"\n-                   \"shr.b32 nosign0, nosign0, 4;               \\n\"\n-                   \"shr.b32 nosign1, nosign1, 4;               \\n\"\n-                   \"add.u32 nosign0, nosign0, 0x38003800;      \\n\"\n-                   \"add.u32 nosign1, nosign1, 0x38003800;      \\n\"\n-                   \"or.b32 $0, sign0, nosign0;                 \\n\"\n-                   \"or.b32 $1, sign1, nosign1;                 \\n\"\n-                   \"}\";\n+    auto *ptxAsm = // WARN: subnormal (0bs0000xxx) are not handled\n+        \"{                                      \\n\"\n+        \".reg .b32 a<2>, b<2>;                  \\n\" // if input = 0xf1f2f3f4\n+        \"prmt.b32 a0, 0, $2, 0x5040;            \\n\" // a0 = 0xf300f400\n+        \"prmt.b32 a1, 0, $2, 0x7060;            \\n\" // a1 = 0xf100f200\n+        \"and.b32 b0, a0, 0x7fff7fff;            \\n\" // b0 = a0 & 0x7fff7fff\n+        \"and.b32 b1, a1, 0x7fff7fff;            \\n\" // (strip sign)\n+        \"shr.b32 b0, b0, 4;                     \\n\" // b0 >>= 4\n+        \"shr.b32 b1, b1, 4;                     \\n\" // shift into fp16 position\n+        \"add.u32 b0, b0, 0x3c003c00;            \\n\" // b0.exp += 2**7-2**3\n+                                                    // exponent compensate = 120\n+        \"add.u32 b1, b1, 0x3c003c00;            \\n\" // b1 += 120<<7 | 120<<7<<16\n+        \"lop3.b32 $0, b0, 0x80008000, a0, 0xf8; \\n\" // out0 = b0|(0x80008000&a0)\n+        \"lop3.b32 $1, b1, 0x80008000, a1, 0xf8; \\n\" // (restore sign)\n+        \"}\";\n     return convertFp8x4ToBf16x4(loc, rewriter, ptxAsm, v0, v1, v2, v3);\n   };\n \n@@ -292,42 +292,47 @@ struct FpToFpOpConversion\n   convertBf16x4ToFp8E4M3x4(Location loc, ConversionPatternRewriter &rewriter,\n                            const Value &v0, const Value &v1, const Value &v2,\n                            const Value &v3) {\n-    auto *ptxAsm = \"{                                            \\n\"\n-                   \".reg .u32 sign, sign<2>, nosign, nosign<2>;  \\n\"\n-                   \".reg .u32 fp8_min, fp8_max, rn_, zero;       \\n\"\n-                   \"mov.u32 fp8_min, 0x38003800;                 \\n\"\n-                   \"mov.u32 fp8_max, 0x3ff03ff0;                 \\n\"\n-                   \"mov.u32 rn_, 0x80008;                        \\n\"\n-                   \"mov.u32 zero, 0;                             \\n\"\n-                   \"and.b32 sign0, $1, 0x80008000;               \\n\"\n-                   \"and.b32 sign1, $2, 0x80008000;               \\n\"\n-                   \"prmt.b32 sign, sign0, sign1, 0x7531;         \\n\"\n-                   \"and.b32 nosign0, $1, 0x7fff7fff;             \\n\"\n-                   \"and.b32 nosign1, $2, 0x7fff7fff;             \\n\"\n-                   \".reg .u32 nosign_0_<2>, nosign_1_<2>;        \\n\"\n-                   \"and.b32 nosign_0_0, nosign0, 0xffff0000;     \\n\"\n-                   \"max.u32 nosign_0_0, nosign_0_0, 0x38000000;  \\n\"\n-                   \"min.u32 nosign_0_0, nosign_0_0, 0x3ff00000;  \\n\"\n-                   \"and.b32 nosign_0_1, nosign0, 0x0000ffff;     \\n\"\n-                   \"max.u32 nosign_0_1, nosign_0_1, 0x3800;      \\n\"\n-                   \"min.u32 nosign_0_1, nosign_0_1, 0x3ff0;      \\n\"\n-                   \"or.b32 nosign0, nosign_0_0, nosign_0_1;      \\n\"\n-                   \"and.b32 nosign_1_0, nosign1, 0xffff0000;     \\n\"\n-                   \"max.u32 nosign_1_0, nosign_1_0, 0x38000000;  \\n\"\n-                   \"min.u32 nosign_1_0, nosign_1_0, 0x3ff00000;  \\n\"\n-                   \"and.b32 nosign_1_1, nosign1, 0x0000ffff;     \\n\"\n-                   \"max.u32 nosign_1_1, nosign_1_1, 0x3800;      \\n\"\n-                   \"min.u32 nosign_1_1, nosign_1_1, 0x3ff0;      \\n\"\n-                   \"or.b32 nosign1, nosign_1_0, nosign_1_1;      \\n\"\n-                   \"add.u32 nosign0, nosign0, rn_;               \\n\"\n-                   \"add.u32 nosign1, nosign1, rn_;               \\n\"\n-                   \"sub.u32 nosign0, nosign0, 0x38003800;        \\n\"\n-                   \"sub.u32 nosign1, nosign1, 0x38003800;        \\n\"\n-                   \"shr.u32 nosign0, nosign0, 4;                 \\n\"\n-                   \"shr.u32 nosign1, nosign1, 4;                 \\n\"\n-                   \"prmt.b32 nosign, nosign0, nosign1, 0x6420;   \\n\"\n-                   \"or.b32 $0, nosign, sign;                     \\n\"\n-                   \"}\";\n+    auto *ptxAsm = // bf16 is clamped firstly to fp8 min/max\n+        \"{                                           \\n\" // bf16=fp8>>4 + 120<<7\n+        \".reg .u32 sign, sign<2>, nosign, nosign<2>; \\n\" // fp8_min = 0b00000000\n+        \".reg .u32 fp8_min, fp8_max, rn_;            \\n\" // fp8_max = 0b11111111\n+        \"mov.u32 fp8_min, 0x3c003c00;                \\n\" // so bf16_min = 0x3c00\n+        \"mov.u32 fp8_max, 0x43f043f0;                \\n\" // so bf16_max = 0x43f0\n+        \"mov.u32 rn_, 0x80008;                       \\n\" // round to nearest\n+        \"and.b32 sign0, $1, 0x80008000;              \\n\" // sign0=in0&0x80008000\n+        \"and.b32 sign1, $2, 0x80008000;              \\n\" // (store sign)\n+        \"prmt.b32 sign, sign0, sign1, 0x7531;        \\n\"\n+        \"and.b32 nosign0, $1, 0x7fff7fff;            \\n\" // nosign0=in0&0x7fff7fff\n+        \"and.b32 nosign1, $2, 0x7fff7fff;            \\n\" // (strip sign)\n+\n+        // nosign = clamp(nosign, min, max)\n+        \".reg .u32 nosign_0_<2>, nosign_1_<2>;       \\n\"\n+        \"and.b32 nosign_0_0, nosign0, 0xffff0000;    \\n\"\n+        \"max.u32 nosign_0_0, nosign_0_0, 0x3c000000; \\n\"\n+        \"min.u32 nosign_0_0, nosign_0_0, 0x43f00000; \\n\"\n+        \"and.b32 nosign_0_1, nosign0, 0x0000ffff;    \\n\"\n+        \"max.u32 nosign_0_1, nosign_0_1, 0x3c00;     \\n\"\n+        \"min.u32 nosign_0_1, nosign_0_1, 0x43f0;     \\n\"\n+        \"or.b32 nosign0, nosign_0_0, nosign_0_1;     \\n\"\n+        \"and.b32 nosign_1_0, nosign1, 0xffff0000;    \\n\"\n+        \"max.u32 nosign_1_0, nosign_1_0, 0x3c000000; \\n\"\n+        \"min.u32 nosign_1_0, nosign_1_0, 0x43f00000; \\n\"\n+        \"and.b32 nosign_1_1, nosign1, 0x0000ffff;    \\n\"\n+        \"max.u32 nosign_1_1, nosign_1_1, 0x3c00;     \\n\"\n+        \"min.u32 nosign_1_1, nosign_1_1, 0x43f0;     \\n\"\n+        \"or.b32 nosign1, nosign_1_0, nosign_1_1;     \\n\"\n+\n+        \"add.u32 nosign0, nosign0, rn_;              \\n\" // nosign0 += rn_\n+        \"add.u32 nosign1, nosign1, rn_;              \\n\" // (round to nearest)\n+        \"sub.u32 nosign0, nosign0, 0x3c003c00;       \\n\" // nosign0-=0x3c003c00\n+        \"sub.u32 nosign1, nosign1, 0x3c003c00;       \\n\" // (compensate offset)\n+        \"shr.u32 nosign0, nosign0, 4;                \\n\" // nosign0 >>= 4\n+        \"shr.u32 nosign1, nosign1, 4;                \\n\" // shift into to fp8e4\n+        \"prmt.b32 nosign, nosign0, nosign1, 0x6420;  \\n\" // nosign0 = 0x00f100f2\n+                                                         // nosign1 = 0x00f300f4\n+                                                         // nosign = 0xf3f4f1f2\n+        \"or.b32 $0, nosign, sign;                    \\n\" // restore sign\n+        \"}\";\n     return convertBf16x4ToFp8x4(loc, rewriter, ptxAsm, v0, v1, v2, v3);\n   };\n "}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "file_content_changes": "@@ -971,7 +971,8 @@ def copy_kernel(input_ptr, output_ptr, n_elements, BLOCK_SIZE: tl.constexpr):\n \n \n @pytest.mark.parametrize(\"in_dtype\", [tl.float8e4])\n-def test_f16_to_f8_rounding(in_dtype):\n+@pytest.mark.parametrize(\"out_dtype\", [torch.float16, torch.bfloat16])\n+def test_f16_to_f8_rounding(in_dtype, out_dtype):\n     \"\"\"Takes all float16s, converts them to float8 and back to float16. Checks that the absolute\n     error is the minimum over all float8.\n     Or the same explanation a bit mathier:\n@@ -984,28 +985,22 @@ def copy_kernel(input_ptr, output_ptr, n_elements, BLOCK_SIZE: tl.constexpr):\n         output = input\n         tl.store(output_ptr + offsets, output, mask=mask)\n \n-    # torch.view with a dtype isn't supported in triton's torch yet so use numpy's view\n-    f16_input_np = (\n-        np.array(\n-            range(-int(2 ** (16 - 1)), int(2 ** (16 - 1))), dtype=np.int16,\n-        )\n-        .view(np.float16)\n-    )\n-    f16_input = torch.tensor(f16_input_np, dtype=torch.float16, device='cuda')\n+    i16_input = torch.tensor(range(-int(2 ** (16 - 1)), int(2 ** (16 - 1))), dtype=torch.int16, device='cuda')\n+    f16_input = i16_input.view(out_dtype)\n     n_elements = f16_input.numel()\n     f8_output_tensor = torch.empty_like(f16_input, dtype=torch.int8)\n     f8_output = triton.reinterpret(f8_output_tensor, in_dtype)\n     grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n     copy_kernel[grid](f16_input, f8_output, n_elements, BLOCK_SIZE=1024)\n \n-    f16_output = torch.empty_like(f16_input, dtype=torch.float16)\n+    f16_output = torch.empty_like(f16_input, dtype=out_dtype)\n     copy_kernel[grid](f8_output, f16_output, n_elements, BLOCK_SIZE=1024)\n \n     abs_error = torch.abs(f16_input - f16_output)\n \n     all_f8_vals_tensor = torch.tensor(range(2 ** 8), dtype=torch.uint8, device='cuda')\n     all_f8_vals = triton.reinterpret(all_f8_vals_tensor, in_dtype)\n-    all_f8_vals_in_f16 = torch.empty_like(all_f8_vals_tensor, dtype=torch.float16)\n+    all_f8_vals_in_f16 = torch.empty_like(all_f8_vals_tensor, dtype=out_dtype)\n     copy_kernel[grid](all_f8_vals, all_f8_vals_in_f16, n_elements=256, BLOCK_SIZE=1024)\n \n     all_finite_f8_vals_in_f16 = all_f8_vals_in_f16[\n@@ -1023,9 +1018,10 @@ def copy_kernel(input_ptr, output_ptr, n_elements, BLOCK_SIZE: tl.constexpr):\n     # WARN: only normalized numbers are handled\n     f8_normal_min = 1 << in_dtype.fp_mantissa_width  # 0b00001000 for float8e4\n     f8_normal_max = 0b01111110\n-    f16_min, f16_max = convert_float_to_float32(torch.tensor([f8_normal_min, f8_normal_max], dtype=torch.int8), in_dtype)\n+    f16_min, f16_max, f16_max_minus_1 = convert_float_to_float32(torch.tensor([f8_normal_min, f8_normal_max, f8_normal_max - 1], dtype=torch.int8), in_dtype)\n+    thres_error = f16_max - f16_max_minus_1\n     mismatch = torch.logical_and(\n-        abs_error != min_error, torch.logical_and(torch.isfinite(f16_input), torch.logical_and(torch.abs(f16_input) <= f16_max, torch.abs(f16_input) >= f16_min))\n+        torch.logical_or(abs_error != min_error, abs_error > thres_error), torch.logical_and(torch.isfinite(f16_input), torch.logical_and(torch.abs(f16_input) <= f16_max, torch.abs(f16_input) >= f16_min))\n     )\n     assert torch.all(\n         torch.logical_not(mismatch)"}]