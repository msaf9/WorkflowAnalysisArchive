[{"filename": "lib/Dialect/TritonGPU/Transforms/RemoveLayoutConversions.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -375,7 +375,7 @@ class RematerializeForward : public mlir::RewritePattern {\n       llvm::MapVector<Value, Attribute> toConvert;\n       if (simulateBackwardRematerialization(op, processed, layout, toConvert,\n                                             srcEncoding,\n-                                            /*skipFirst=*/true) > 0)\n+                                            /*skipInit=*/true) > 0)\n         return failure();\n     }\n     // Take out the operations at which we stop slicing."}, {"filename": "lib/Dialect/TritonGPU/Transforms/Utility.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -131,7 +131,7 @@ bool canFoldConversion(Operation *op) {\n int simulateBackwardRematerialization(\n     Operation *initOp, SetVector<Operation *> &processed,\n     SetVector<Attribute> &layout, llvm::MapVector<Value, Attribute> &toConvert,\n-    Attribute targetEncoding, bool skipFirst) {\n+    Attribute targetEncoding, bool skipInit) {\n   // DFS\n   std::vector<std::pair<Operation *, Attribute>> queue;\n   queue.emplace_back(initOp, targetEncoding);\n@@ -145,9 +145,9 @@ int simulateBackwardRematerialization(\n     queue.pop_back();\n     // If the current operation is expensive to rematerialize,\n     // we stop everything\n-    if (!skipFirst && expensiveToRemat(currOp, currLayout))\n+    if (!skipInit && expensiveToRemat(currOp, currLayout))\n       break;\n-    skipFirst = false;\n+    skipInit = false;\n     // A conversion will be removed here (i.e. transferred to operands)\n     numCvts -= 1;\n     // Done processing"}]