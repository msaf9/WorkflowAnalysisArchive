[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "file_content_changes": "@@ -63,9 +63,6 @@ class LoopPipeliner {\n \n   Value lookupOrDefault(Value origin, int stage);\n \n-  /// return true if this op uses any of `loads`\n-  bool isDirectUserOfAsyncLoad(Operation &op);\n-\n   /// returns a empty buffer of size <numStages, ...>\n   ttg::AllocTensorOp allocateEmptyBuffer(Operation *op, OpBuilder &builder);\n \n@@ -131,19 +128,6 @@ void LoopPipeliner::collectDeps(Value v, int stages, DenseSet<Value> &deps) {\n   }\n }\n \n-bool LoopPipeliner::isDirectUserOfAsyncLoad(Operation &op) {\n-  for (Value loadOp : loads) {\n-    assert(loadOp.hasOneUse() &&\n-           \"load should only have one use (ConvertLayout)\");\n-    Value loadUseResult = loadOp.getUsers().begin()->getResult(0);\n-    for (Value opOperand : op.getOperands()) {\n-      if (opOperand == loadUseResult)\n-        return true;\n-    }\n-  }\n-  return false;\n-}\n-\n ttg::AllocTensorOp LoopPipeliner::allocateEmptyBuffer(Operation *op,\n                                                       OpBuilder &builder) {\n   // allocate a buffer for each pipelined tensor"}]