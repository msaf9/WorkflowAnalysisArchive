[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -11,7 +11,6 @@ using ::mlir::triton::gpu::DotOperandEncodingAttr;\n bool isMmaToDotShortcut(MmaEncodingAttr &mmaLayout,\n                         DotOperandEncodingAttr &dotOperandLayout);\n \n-\n void populateConvertLayoutOpToLLVMPatterns(\n     mlir::LLVMTypeConverter &typeConverter, RewritePatternSet &patterns,\n     int numWarps, AxisInfoAnalysis &axisInfoAnalysis,"}, {"filename": "lib/Conversion/TritonGPUToLLVM/LoadStoreOpToLLVM.cpp", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "file_content_changes": "@@ -743,7 +743,9 @@ struct InsertSliceAsyncOpConversion\n     auto sizePerThread = srcBlockedLayout.getSizePerThread();\n     auto threadsPerCTA = getThreadsPerCTA(srcBlockedLayout);\n     auto inOrder = srcBlockedLayout.getOrder();\n-    DenseMap<unsigned, Value> sharedPtrs = getSwizzledSharedPtrs(loc, inVec, srcTy, resSharedLayout, resElemTy, smemObj, rewriter, offsetVals, srcStrides);\n+    DenseMap<unsigned, Value> sharedPtrs =\n+        getSwizzledSharedPtrs(loc, inVec, srcTy, resSharedLayout, resElemTy,\n+                              smemObj, rewriter, offsetVals, srcStrides);\n \n     // If perPhase * maxPhase > threadsPerCTA, we will have elements\n     // that share the same tile indices. The index calculation will"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "file_content_changes": "@@ -219,29 +219,28 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     return base;\n   }\n \n-  DenseMap<unsigned, Value> getSwizzledSharedPtrs(Location loc, unsigned inVec, RankedTensorType srcTy,\n-                                         triton::gpu::SharedEncodingAttr resSharedLayout,\n-                                         Type resElemTy,\n-                                         SharedMemoryObject smemObj,\n-                                         ConversionPatternRewriter &rewriter,\n-                                         SmallVectorImpl<Value>& offsetVals,\n-                                         SmallVectorImpl<Value>& srcStrides\n-                                         ) const {\n+  DenseMap<unsigned, Value>\n+  getSwizzledSharedPtrs(Location loc, unsigned inVec, RankedTensorType srcTy,\n+                        triton::gpu::SharedEncodingAttr resSharedLayout,\n+                        Type resElemTy, SharedMemoryObject smemObj,\n+                        ConversionPatternRewriter &rewriter,\n+                        SmallVectorImpl<Value> &offsetVals,\n+                        SmallVectorImpl<Value> &srcStrides) const {\n     // This utililty computes the pointers for accessing the provided swizzled\n-    // shared memory layout `resSharedLayout`. More specifically, it computes, for all\n-    // indices (row, col) of `srcEncoding` such that idx % inVec = 0, the pointer:\n-    // ptr[(row, col)] = base + (rowOff * strides[ord[1]] + colOff)\n-    // where : \n+    // shared memory layout `resSharedLayout`. More specifically, it computes,\n+    // for all indices (row, col) of `srcEncoding` such that idx % inVec = 0,\n+    // the pointer: ptr[(row, col)] = base + (rowOff * strides[ord[1]] + colOff)\n+    // where :\n     //   compute phase = (row // perPhase) % maxPhase\n     //   rowOff = row\n     //   colOff = colOffSwizzled + colOffOrdered\n     //     colOffSwizzled = ((col // outVec) ^ phase) * outVec\n     //     colOffOrdered = (col % outVec) // minVec * minVec\n     //\n-    // Note 1: \n+    // Note 1:\n     // -------\n     // Because swizzling happens at a granularity of outVec, we need to\n-    // decompose the offset into a swizzled factor and a non-swizzled (ordered) \n+    // decompose the offset into a swizzled factor and a non-swizzled (ordered)\n     // factor\n     //\n     // Note 2:\n@@ -251,8 +250,8 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     // y = 0byyyyy0000\n     // z = 0b00000zzzz\n     // then (x + y) XOR z = 0byyyyxxxx XOR 0b00000zzzz = (x XOR z) + y\n-    // This means that we can use some immediate offsets for shared memory operations.\n-    // More specifically\n+    // This means that we can use some immediate offsets for shared memory\n+    // operations. More specifically\n     auto dstPtrTy = ptr_ty(resElemTy, 3);\n     auto dstOffset = dot(rewriter, loc, offsetVals, smemObj.strides);\n     Value dstPtrBase = gep(dstPtrTy, smemObj.base, dstOffset);\n@@ -279,42 +278,43 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n       auto idx = srcIndices[elemIdx];\n       Value idxCol = idx[inOrder[0]]; // contiguous dimension\n       Value idxRow = idx[inOrder[1]]; // discontiguous dimension\n-      Value strideCol = srcStrides[inOrder[0]]; \n-      Value strideRow = srcStrides[inOrder[1]]; \n+      Value strideCol = srcStrides[inOrder[0]];\n+      Value strideRow = srcStrides[inOrder[1]];\n       // extract dynamic/static offset for immediate offseting\n       unsigned immedateOffCol = 0;\n       if (auto add = dyn_cast_or_null<LLVM::AddOp>(idxCol.getDefiningOp()))\n-      if (auto _cst = dyn_cast_or_null<LLVM::ConstantOp>(add.getRhs().getDefiningOp())) {\n-        unsigned cst = _cst.getValue().cast<IntegerAttr>()\n-                           .getValue().getSExtValue();\n-        unsigned key = cst % (outVec * maxPhase);\n-        cacheCol.insert({key, idxCol});\n-        idxCol = cacheCol[key];\n-        immedateOffCol = cst / (outVec * maxPhase) * (outVec * maxPhase);\n-      }\n+        if (auto _cst = dyn_cast_or_null<LLVM::ConstantOp>(\n+                add.getRhs().getDefiningOp())) {\n+          unsigned cst =\n+              _cst.getValue().cast<IntegerAttr>().getValue().getSExtValue();\n+          unsigned key = cst % (outVec * maxPhase);\n+          cacheCol.insert({key, idxCol});\n+          idxCol = cacheCol[key];\n+          immedateOffCol = cst / (outVec * maxPhase) * (outVec * maxPhase);\n+        }\n       // extract dynamic/static offset for immediate offseting\n       unsigned immedateOffRow = 0;\n       if (auto add = dyn_cast_or_null<LLVM::AddOp>(idxRow.getDefiningOp()))\n-      if (auto _cst = dyn_cast_or_null<LLVM::ConstantOp>(add.getRhs().getDefiningOp())) {\n-        unsigned cst = _cst.getValue().cast<IntegerAttr>()\n-                           .getValue().getSExtValue();\n-        unsigned key = cst % (perPhase * maxPhase);\n-        cacheRow.insert({key, idxRow});\n-        idxRow = cacheRow[key];\n-        immedateOffRow = cst / (perPhase * maxPhase) * (perPhase * maxPhase);\n-      }\n+        if (auto _cst = dyn_cast_or_null<LLVM::ConstantOp>(\n+                add.getRhs().getDefiningOp())) {\n+          unsigned cst =\n+              _cst.getValue().cast<IntegerAttr>().getValue().getSExtValue();\n+          unsigned key = cst % (perPhase * maxPhase);\n+          cacheRow.insert({key, idxRow});\n+          idxRow = cacheRow[key];\n+          immedateOffRow = cst / (perPhase * maxPhase) * (perPhase * maxPhase);\n+        }\n       // compute phase = (row // perPhase) % maxPhase\n       Value phase = urem(udiv(idxRow, i32_val(perPhase)), i32_val(maxPhase));\n       // row offset is simply row index\n       Value rowOff = mul(idxRow, strideRow);\n       // because swizzling happens at a granularity of outVec, we need to\n-      // decompose the offset into a swizzled factor and a non-swizzled (ordered) \n-      // factor:\n-      // colOffSwizzled = ((col // outVec) ^ phase) * outVec\n+      // decompose the offset into a swizzled factor and a non-swizzled\n+      // (ordered) factor: colOffSwizzled = ((col // outVec) ^ phase) * outVec\n       // colOffOrdered = (col % outVec) // minVec * minVec\n       Value colOffSwizzled = xor_(udiv(idxCol, i32_val(outVec)), phase);\n       colOffSwizzled = mul(colOffSwizzled, i32_val(outVec));\n-      Value colOffOrdered =  urem(idxCol, i32_val(outVec));\n+      Value colOffOrdered = urem(idxCol, i32_val(outVec));\n       colOffOrdered = udiv(colOffOrdered, i32_val(minVec));\n       colOffOrdered = mul(colOffOrdered, i32_val(minVec));\n       Value colOff = add(colOffSwizzled, colOffOrdered);\n@@ -330,8 +330,9 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     return ret;\n   }\n \n-  bool isMmaToDotShortcut(MmaEncodingAttr &mmaLayout,\n-                        triton::gpu::DotOperandEncodingAttr &dotOperandLayout) const {\n+  bool isMmaToDotShortcut(\n+      MmaEncodingAttr &mmaLayout,\n+      triton::gpu::DotOperandEncodingAttr &dotOperandLayout) const {\n     // dot_op<opIdx=0, parent=#mma> = #mma\n     // when #mma = MmaEncoding<version=2, warpsPerCTA=[..., 1]>\n     return mmaLayout.getWarpsPerCTA()[1] == 1 &&\n@@ -340,26 +341,30 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n   }\n \n   void storeDistributedToShared(Value src, Value llSrc,\n-                              ArrayRef<Value> dstStrides,\n-                              ArrayRef<SmallVector<Value>> srcIndices,\n-                              Value dst, Value smemBase, Type elemTy,\n-                              Location loc,\n-                              ConversionPatternRewriter &rewriter) const {\n+                                ArrayRef<Value> dstStrides,\n+                                ArrayRef<SmallVector<Value>> srcIndices,\n+                                Value dst, Value smemBase, Type elemTy,\n+                                Location loc,\n+                                ConversionPatternRewriter &rewriter) const {\n     auto srcTy = src.getType().cast<RankedTensorType>();\n     auto srcShape = srcTy.getShape();\n-    assert(srcShape.size() == 2 && \"Unexpected rank of storeDistributedToShared\");\n+    assert(srcShape.size() == 2 &&\n+           \"Unexpected rank of storeDistributedToShared\");\n     auto dstTy = dst.getType().cast<RankedTensorType>();\n     auto srcDistributedLayout = srcTy.getEncoding();\n     if (auto mmaLayout = srcDistributedLayout.dyn_cast<MmaEncodingAttr>()) {\n       assert((!mmaLayout.isVolta()) &&\n              \"ConvertLayout MMAv1->Shared is not suppported yet\");\n     }\n-    auto dstSharedLayout = dstTy.getEncoding().cast<triton::gpu::SharedEncodingAttr>();\n+    auto dstSharedLayout =\n+        dstTy.getEncoding().cast<triton::gpu::SharedEncodingAttr>();\n     auto dstElemTy = dstTy.getElementType();\n     auto inOrd = triton::gpu::getOrder(srcDistributedLayout);\n     auto outOrd = dstSharedLayout.getOrder();\n     unsigned inVec =\n-        inOrd == outOrd ? triton::gpu::getContigPerThread(srcDistributedLayout)[inOrd[0]] : 1;\n+        inOrd == outOrd\n+            ? triton::gpu::getContigPerThread(srcDistributedLayout)[inOrd[0]]\n+            : 1;\n     unsigned outVec = dstSharedLayout.getVec();\n     unsigned minVec = std::min(outVec, inVec);\n     unsigned perPhase = dstSharedLayout.getPerPhase();\n@@ -377,7 +382,9 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     SmallVector<Value> offsetVals = {i32_val(0), i32_val(0)};\n     SharedMemoryObject smemObj(smemBase, srcStrides, offsetVals);\n \n-    DenseMap<unsigned, Value> sharedPtrs = getSwizzledSharedPtrs(loc, inVec, srcTy, dstSharedLayout, dstElemTy, smemObj, rewriter, offsetVals, srcStrides);\n+    DenseMap<unsigned, Value> sharedPtrs =\n+        getSwizzledSharedPtrs(loc, inVec, srcTy, dstSharedLayout, dstElemTy,\n+                              smemObj, rewriter, offsetVals, srcStrides);\n \n     std::map<unsigned, Value> cache0;\n     std::map<unsigned, Value> cache1;\n@@ -386,14 +393,13 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n         word = undef(wordTy);\n       word = insert_element(wordTy, word, inVals[i], i32_val(i % minVec));\n       if (i % minVec == minVec - 1) {\n-        Value smemAddr = sharedPtrs[i/minVec*minVec];\n+        Value smemAddr = sharedPtrs[i / minVec * minVec];\n         smemAddr = bitcast(smemAddr, ptr_ty(wordTy, 3));\n         store(word, smemAddr);\n       }\n     }\n   }\n \n-\n   // -----------------------------------------------------------------------\n   // Utilities\n   // -----------------------------------------------------------------------"}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -363,7 +363,6 @@ static Value shflSync(Location loc, ConversionPatternRewriter &rewriter,\n   return builder.launch(rewriter, loc, val.getType(), false);\n }\n \n-\n } // namespace LLVM\n } // namespace mlir\n "}]