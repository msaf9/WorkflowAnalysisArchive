[{"filename": "test/Analysis/test-membar.mlir", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "file_content_changes": "@@ -49,7 +49,7 @@ func.func @raw_single_block(%A : !tt.ptr<f16>) {\n   %1 = tt.load %0, %cst1, %cst2 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<128x32xf16, #AL>\n   %2 = triton_gpu.convert_layout %1 : (tensor<128x32xf16, #AL>) -> tensor<128x32xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %3 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %3 = triton_gpu.convert_layout %2 : (tensor<128x32xf16, #A_SHARED>) -> tensor<128x32xf16, #A_SHARED>\n   return\n }\n@@ -62,7 +62,7 @@ func.func @war_single_block(%A : !tt.ptr<f16>) {\n   %1 = tt.load %0, %cst1, %cst2 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<128x32xf16, #AL>\n   %2 = triton_gpu.convert_layout %1 : (tensor<128x32xf16, #AL>) -> tensor<128x32xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %3 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %3 = triton_gpu.convert_layout %2 : (tensor<128x32xf16, #A_SHARED>) -> tensor<128x32xf16, #AL>\n   // CHECK: gpu.barrier\n   // CHECK-NEXT: %4 = triton_gpu.convert_layout\n@@ -74,10 +74,10 @@ func.func @war_single_block(%A : !tt.ptr<f16>) {\n func.func @scratch() {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %0 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %0 = tt.cat %cst0, %cst0 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %1 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %1 = triton_gpu.convert_layout %0 : (tensor<32x16xf16, #A_SHARED>) -> tensor<32x16xf16, #AL>\n   %2 = tt.reduce %1 {redOp = 1 : i32, axis = 0 : i32} : tensor<32x16xf16, #AL> -> tensor<16xf16, #sliceAd0>\n   return\n@@ -87,11 +87,11 @@ func.func @scratch() {\n func.func @async_wait() {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %0 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %0 = tt.cat %cst0, %cst0 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n   triton_gpu.async_wait {num = 4 : i32}\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %1 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %1 = triton_gpu.convert_layout %0 : (tensor<32x16xf16, #A_SHARED>) -> tensor<32x16xf16, #AL>\n   return\n }\n@@ -101,7 +101,7 @@ func.func @alloc() {\n   %0 = triton_gpu.alloc_tensor : tensor<16x16xf16, #A_SHARED>\n   %1 = tt.cat %0, %0 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %2 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %2 = triton_gpu.convert_layout %1 : (tensor<32x16xf16, #A_SHARED>) -> tensor<32x16xf16, #AL>\n   return\n }\n@@ -112,10 +112,10 @@ func.func @extract_slice() {\n   %index = arith.constant 0 : index\n   %0 = tensor.extract_slice %cst0[%index, 0, 0][1, 16, 16][1, 1, 1] : tensor<1x16x16xf16, #A_SHARED> to tensor<16x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %1 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %1 = triton_gpu.convert_layout %0 : (tensor<16x16xf16, #A_SHARED>) -> tensor<16x16xf16, #AL>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %2 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %2 = triton_gpu.convert_layout %1 : (tensor<16x16xf16, #AL>) -> tensor<16x16xf16, #A_SHARED>\n   return\n }\n@@ -137,10 +137,10 @@ func.func @insert_slice_async_op(%A : !tt.ptr<f16>, %i1 : i1) {\n   %index = arith.constant 0 : i32\n   %3 = triton_gpu.insert_slice_async %a_ptr, %tensor, %index, %mask, %other {axis = 0 : i32, cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<16x16x!tt.ptr<f16>, #AL> -> tensor<1x16x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %4 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %4 = tt.cat %3, %3 {axis = 0} : (tensor<1x16x16xf16, #A_SHARED>, tensor<1x16x16xf16, #A_SHARED>) -> tensor<2x16x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %5 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %5 = tt.cat %4, %4 {axis = 0} : (tensor<2x16x16xf16, #A_SHARED>, tensor<2x16x16xf16, #A_SHARED>) -> tensor<4x16x16xf16, #A_SHARED>\n   return\n }\n@@ -154,13 +154,13 @@ func.func @insert_slice_op(%A : !tt.ptr<f16>, %i1 : i1) {\n   %index = arith.constant 0 : index\n   %2 = tt.load %a_ptr, %mask, %other {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<16x16xf16, #AL>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %3 = tensor.insert_slice\n+  // CHECK-NEXT: tensor.insert_slice\n   %3 = tensor.insert_slice %2 into %tensor[%index, 0, 0][1, 16, 16][1, 1, 1]: tensor<16x16xf16, #AL> into tensor<1x16x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %4 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %4 = tt.cat %3, %3 {axis = 0} : (tensor<1x16x16xf16, #A_SHARED>, tensor<1x16x16xf16, #A_SHARED>) -> tensor<2x16x16xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %5 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %5 = tt.cat %4, %4 {axis = 0} : (tensor<2x16x16xf16, #A_SHARED>, tensor<2x16x16xf16, #A_SHARED>) -> tensor<4x16x16xf16, #A_SHARED>\n   return\n }\n@@ -172,19 +172,19 @@ func.func @multi_blocks(%i1 : i1) {\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   scf.if %i1 {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %0 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %0 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n     scf.yield\n   } else {\n     %cst2 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n     %cst3 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %1 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %1 = tt.cat %cst2, %cst3 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n     scf.yield\n   }\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %2 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %2 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n   return\n }\n@@ -196,12 +196,12 @@ func.func @multi_blocks_join_barrier(%i1 : i1) {\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   scf.if %i1 {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %0 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %0 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n     scf.yield\n   } else {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %1 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %1 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n     scf.yield\n   }\n@@ -216,18 +216,18 @@ func.func @multi_blocks_yield(%i1 : i1) {\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %a = scf.if %i1 -> (tensor<32x16xf16, #A_SHARED>) {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %0 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %0 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n     scf.yield %0 : tensor<32x16xf16, #A_SHARED>\n   } else {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %1 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %1 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n     scf.yield %1 : tensor<32x16xf16, #A_SHARED>\n   }\n   %a_ = triton_gpu.convert_layout %cst0 : (tensor<16x16xf16, #A_SHARED>) -> tensor<16x16xf16, #AL>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %4 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %4 = tt.cat %a, %a {axis = 0} : (tensor<32x16xf16, #A_SHARED>, tensor<32x16xf16, #A_SHARED>) -> tensor<64x16xf16, #A_SHARED>\n   return\n }\n@@ -239,12 +239,12 @@ func.func @multi_blocks_noelse(%i1 : i1) {\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   scf.if %i1 {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %0 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %0 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n     scf.yield\n   }\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %1 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %1 = triton_gpu.convert_layout %cst0 : (tensor<16x16xf16, #A_SHARED>) -> tensor<16x16xf16, #AL>\n   return\n }\n@@ -257,19 +257,19 @@ func.func @multi_blocks_nested_scf(%i1 : i1, %i2 : i1) {\n   scf.if %i1 {\n     scf.if %i2 {\n       // CHECK: gpu.barrier\n-      // CHECK-NEXT: %0 = tt.cat\n+      // CHECK-NEXT: tt.cat\n       %0 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n       scf.yield\n     }\n     scf.yield\n   } else {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %1 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %1 = tt.cat %cst0, %cst1 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n     scf.yield\n   }\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %2 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %2 = triton_gpu.convert_layout %cst0 : (tensor<16x16xf16, #A_SHARED>) -> tensor<16x16xf16, #AL>\n   return\n }\n@@ -281,7 +281,7 @@ func.func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B :\n   %c_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %a_shared, %b_shared, %c_shared = scf.for %iv = %lb to %ub step %step iter_args(%a_shared = %a_shared_init, %b_shared = %b_shared_init, %c_shared = %c_shared_init) -> (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %5 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %5 = tt.cat %a_shared, %b_shared {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #A_SHARED>\n     scf.yield %b_shared, %a_shared, %a_shared : tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>\n   }\n@@ -295,18 +295,18 @@ func.func @for_alias(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>,\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %b_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %0 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %0 = tt.cat %a_shared_init, %b_shared_init {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #A_SHARED>\n   %c_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %a_shared, %b_shared, %c_shared = scf.for %iv = %lb to %ub step %step iter_args(%a_shared = %a_shared_init, %b_shared = %b_shared_init, %c_shared = %c_shared_init) -> (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) {\n     %cst1 = tt.cat %a_shared_init, %b_shared_init {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #AL>\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %7 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %7 = tt.cat %a_shared, %b_shared {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #AL>\n     scf.yield %c_shared, %a_shared, %b_shared : tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>\n   }\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %9 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %9 = tt.cat %0, %0 {axis = 0} : (tensor<256x32xf16, #A_SHARED>, tensor<256x32xf16, #A_SHARED>) -> tensor<512x32xf16, #A_SHARED>\n   return\n }\n@@ -318,20 +318,20 @@ func.func @for_reuse(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>,\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %b_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %0 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %0 = tt.cat %a_shared_init, %b_shared_init {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #A_SHARED>\n   %c_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %a_shared, %b_shared, %c_shared = scf.for %iv = %lb to %ub step %step iter_args(%a_shared = %a_shared_init, %b_shared = %b_shared_init, %c_shared = %c_shared_init) -> (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %6 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %6 = tt.cat %a_shared_init, %b_shared_init {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #A_SHARED>\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %7 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %7 = tt.cat %a_shared, %b_shared {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #A_SHARED>\n     scf.yield %c_shared, %a_shared, %b_shared : tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>\n   }\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %9 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %9 = tt.cat %0, %0 {axis = 0} : (tensor<256x32xf16, #A_SHARED>, tensor<256x32xf16, #A_SHARED>) -> tensor<512x32xf16, #A_SHARED>\n   return\n }\n@@ -341,23 +341,23 @@ func.func @for_reuse_nested(%lb : index, %ub : index, %step : index, %A : !tt.pt\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %b_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %0 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %0 = tt.cat %a_shared_init, %b_shared_init {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #A_SHARED>\n   %c_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %a_shared, %b_shared, %c_shared = scf.for %iv = %lb to %ub step %step iter_args(%a_shared = %a_shared_init, %b_shared = %b_shared_init, %c_shared = %c_shared_init) -> (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) {\n     // CHECK: gpu.barrier\n-    // CHECK-NEXT: %6 = tt.cat\n+    // CHECK-NEXT: tt.cat\n     %6 = tt.cat %a_shared_init, %b_shared_init {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #A_SHARED>\n     %a_shared_next, %b_shared_next, %c_shared_next = scf.for %ivv = %lb to %ub step %step iter_args(%a_shared_nested = %a_shared_init, %b_shared_nested = %b_shared_init, %c_shared_nested = %c_shared_init) -> (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) {\n       // CHECK: gpu.barrier\n-      // CHECK-NEXT: %12 = tt.cat\n+      // CHECK-NEXT:  tt.cat\n       %12 = tt.cat %a_shared_nested, %b_shared_nested {axis = 0} : (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) -> tensor<256x32xf16, #A_SHARED>\n       scf.yield %c_shared_nested, %a_shared_nested, %b_shared_nested : tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>\n     }\n     scf.yield %c_shared, %a_shared, %b_shared : tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>\n   }\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %15 = tt.cat\n+  // CHECK-NEXT:  tt.cat\n   %15 = tt.cat %0, %0 {axis = 0} : (tensor<256x32xf16, #A_SHARED>, tensor<256x32xf16, #A_SHARED>) -> tensor<512x32xf16, #A_SHARED>\n   return\n }\n@@ -370,12 +370,12 @@ func.func @cf_if(%i1 : i1) {\n   cf.cond_br %i1, ^bb1, ^bb2\n ^bb1:  // pred: ^bb0\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %0 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %0 = tt.cat %cst, %cst_0 {axis = 0 : i64} : (tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>, tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>) -> tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>\n   cf.br ^bb2\n ^bb2:  // 2 preds: ^bb0, ^bb1\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %1 = triton_gpu.convert_layout\n+  // CHECK-NEXT: triton_gpu.convert_layout\n   %1 = triton_gpu.convert_layout %cst : (tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>) -> tensor<16x16xf16, #triton_gpu.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>\n   return\n }\n@@ -386,20 +386,20 @@ func.func @cf_if_else(%i1 : i1) {\n   cf.cond_br %i1, ^bb1, ^bb2\n ^bb1:  // pred: ^bb0\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %0 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %0 = tt.cat %cst, %cst_0 {axis = 0 : i64} : (tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>, tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>) -> tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>\n   cf.br ^bb3(%0 : tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>)\n ^bb2:  // pred: ^bb0\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %1 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %1 = tt.cat %cst, %cst_0 {axis = 0 : i64} : (tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>, tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>) -> tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>\n   cf.br ^bb3(%1 : tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>)\n ^bb3(%2: tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>):  // 2 preds: ^bb1, ^bb2\n   cf.br ^bb4\n ^bb4:  // pred: ^bb3\n   %3 = triton_gpu.convert_layout %cst : (tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>) -> tensor<16x16xf16, #triton_gpu.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %4 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %4 = tt.cat %2, %2 {axis = 0 : i64} : (tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>, tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>) -> tensor<64x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>\n   return\n }\n@@ -410,12 +410,12 @@ func.func @cf_if_else_return(%i1 : i1) {\n   cf.cond_br %i1, ^bb1, ^bb2\n ^bb1:  // pred: ^bb0\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %0 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %0 = tt.cat %cst, %cst_0 {axis = 0 : i64} : (tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>, tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>) -> tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>\n   return\n ^bb2:  // pred: ^bb0\n   // CHECK: gpu.barrier\n-  // CHECK-NEXT: %1 = tt.cat\n+  // CHECK-NEXT: tt.cat\n   %1 = tt.cat %cst, %cst_0 {axis = 0 : i64} : (tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>, tensor<16x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>) -> tensor<32x16xf16, #triton_gpu.shared<{vec = 2, perPhase = 2, maxPhase = 4, order = [1, 0]}>>\n   return\n }"}]