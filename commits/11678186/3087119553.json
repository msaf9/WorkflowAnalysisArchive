[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "file_content_changes": "@@ -6,11 +6,13 @@\n import hashlib\n import io\n import os\n+import shutil\n import subprocess\n import sys\n import sysconfig\n import tempfile\n import warnings\n+from sysconfig import get_paths\n from typing import Any, Dict, Set, Tuple, Union\n \n import setuptools\n@@ -20,10 +22,6 @@\n import triton\n import triton._C.libtriton.triton as _triton\n \n-import shutil\n-import subprocess\n-from sysconfig import get_paths\n-\n \n def str_to_ty(name):\n     if name[0] == \"*\":\n@@ -921,7 +919,6 @@ def generate_name_initializer(signature):\n         src\n \n \n-\n def binary_name_to_header_name(name):\n     if len(name) > 128:\n         # avoid filename too long errors (filename limit is 255)\n@@ -1164,11 +1161,13 @@ def make_cache_key(fn, signature, configs, constants, num_warps, num_stages):\n \n # utilties for generating and compiling C wrappers\n \n+\n @functools.lru_cache()\n def libcuda_dir():\n     loc = subprocess.check_output([\"whereis\", \"libcuda.so\"]).decode().strip().split()[-1]\n     return os.path.dirname(loc)\n \n+\n @contextlib.contextmanager\n def quiet():\n     old_stdout, old_stderr = sys.stdout, sys.stderr\n@@ -1178,6 +1177,7 @@ def quiet():\n     finally:\n         sys.stdout, sys.stderr = old_stdout, old_stderr\n \n+\n def _build(name, src, srcdir):\n     cuda_lib_dir = libcuda_dir()\n     cu_include_dir = \"/usr/local/cuda/include\"\n@@ -1186,14 +1186,14 @@ def _build(name, src, srcdir):\n     # try to avoid setuptools if possible\n     cc = os.environ.get(\"CC\")\n     if cc is None:\n-      # TODO: support more things here.\n-      clang = shutil.which(\"clang\")\n-      gcc = shutil.which(\"gcc\")\n-      cc = gcc if gcc is not None else clang\n+        # TODO: support more things here.\n+        clang = shutil.which(\"clang\")\n+        gcc = shutil.which(\"gcc\")\n+        cc = gcc if gcc is not None else clang\n     py_include_dir = get_paths()[\"include\"]\n-    ret = subprocess.check_call([cc, src, \"-O3\", f\"-I{cu_include_dir}\", f\"-I{py_include_dir}\",  f\"-I{srcdir}\", \"-shared\", \"-fPIC\", f\"-L{cuda_lib_dir}\", f\"-lcuda\", \"-o\", so])\n+    ret = subprocess.check_call([cc, src, \"-O3\", f\"-I{cu_include_dir}\", f\"-I{py_include_dir}\", f\"-I{srcdir}\", \"-shared\", \"-fPIC\", f\"-L{cuda_lib_dir}\", \"-lcuda\", \"-o\", so])\n     if ret == 0:\n-      return so\n+        return so\n     # fallback on setuptools\n     extra_compile_args = []\n     library_dirs = [cuda_lib_dir]\n@@ -1223,11 +1223,10 @@ def _build(name, src, srcdir):\n         script_args=args,\n     )\n     with quiet():\n-      setuptools.setup(**args)\n+        setuptools.setup(**args)\n     return so\n \n \n-\n def compile(fn, signature: str, device: int = -1, constants=dict(), num_warps: int = 4, num_stages: int = 3, extern_libs=None, configs=None):\n     # we get the kernel, i.e. the first function generated in the module\n     if configs is None:\n@@ -1256,7 +1255,7 @@ def compile(fn, signature: str, device: int = -1, constants=dict(), num_warps: i\n             f.write(src)\n         so = _build(fn.__name__, src_path, tmpdir)\n         with open(so, \"rb\") as f:\n-          cache_manager.put(f.read())\n+            cache_manager.put(f.read())\n \n     return CompiledKernel(fn.__name__, cache_manager.bin_path)\n "}]