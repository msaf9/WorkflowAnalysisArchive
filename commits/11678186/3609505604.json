[{"filename": "include/triton/Dialect/TritonGPU/IR/TritonGPUAttrDefs.td", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "file_content_changes": "@@ -293,37 +293,37 @@ partitioned between warps.\n // -------------------------------- version = 1 --------------------------- //\n \n For first-gen tensor cores, the implicit warpTileSize is [16, 16].\n-Information about this layout can be found in the official PTX documentation\n+Note: the layout is different from the recommended in PTX ISA\n https://docs.nvidia.com/cuda/parallel-thread-execution/index.html\n (mma.884 section, FP32 accumulator).\n \n For example, the matrix L corresponding to blockTileSize=[32,16] is:\n \n                                warp 0\n --------------------------------/\\-------------------------------\n-[ 0   0   2   2   0   0   2   2    4   4   6   6   4   4   6   6 ]\n-[ 1   1   3   3   1   1   3   3    5   5   7   7   5   5   7   7 ]\n-[ 0   0   2   2   0   0   2   2    4   4   6   6   4   4   6   6 ]\n-[ 1   1   3   3   1   1   3   3    5   5   7   7   5   5   7   7 ]\n-[ 16  16  18  18  16  16  18  18   20  20  22  22  20  20  22  22]\n-[ 17  17  19  19  17  17  19  19   21  21  23  23  21  21  23  23]\n-[ 16  16  18  18  16  16  18  18   20  20  22  22  20  20  22  22]\n-[ 17  17  19  19  17  17  19  19   21  21  23  23  21  21  23  23]\n-[ 8   8   10  10  8   8   10  10   12  12  14  14  12  12  14  14]\n-[ 9   9   11  11  9   9   11  11   13  13  15  15  13  13  15  15]\n-[ ..............................................................\n-[ ..............................................................\n-[ 24  24  26  26  24  24  26  26   28  28  30  30  28  28  30  30]\n-[ 25  25  27  27  25  25  27  27   29  29  31  31  29  29  31  31]\n-\n-                         warp 1 = warp0 + 32\n+[ 0   0   2   2   8   8   10  10   0   0   2   2   8   8   10  10 ]\n+[ 1   1   3   3   9   9   11  11   1   1   3   3   9   9   11  11 ]\n+[ 0   0   2   2   8   8   10  10   0   0   2   2   8   8   10  10 ]\n+[ 1   1   3   3   9   9   11  11   1   1   3   3   9   9   11  11 ]\n+[ 4   4   6   6   12  12  14  14   4   4   6   6   12  12  14  14 ]\n+[ 5   5   7   7   13  13  15  15   5   5   7   7   13  13  15  15 ]\n+[ 4   4   6   6   12  12  14  14   4   4   6   6   12  12  14  14 ]\n+[ 5   5   7   7   13  13  15  15   5   5   7   7   13  13  15  15 ]\n+[ 16  16  18  18  20  20  22  22   16  16  18  18  20  20  22  22 ]\n+[ 17  17  19  19  21  21  23  23   17  17  19  19  21  21  23  23 ]\n+[ 16  16  18  18  20  20  22  22   16  16  18  18  20  20  22  22 ]\n+[ 17  17  19  19  21  21  23  23   17  17  19  19  21  21  23  23 ]\n+[ 24  24  26  26  28  28  30  30   24  24  26  26  28  28  30  30 ]\n+[ 25  25  27  27  29  29  31  31   25  25  27  27  29  29  31  31 ]\n+[ 24  24  26  26  28  28  30  30   24  24  26  26  28  28  30  30 ]\n+[ 25  25  27  27  29  29  31  31   25  25  27  27  29  29  31  31 ]\n+\n+                          warp 1 = warp0 + 32\n --------------------------------/\\-------------------------------\n-[ 32  32  34  34  32  32  34  34   36  36  38  38  36  36  38  38]\n-[ 33  33  35  35  33  33  35  35   37  37  39  39  37  37  39  39]\n-[ ..............................................................\n-[ ..............................................................\n-[ 56  56  58  58  56  56  58  58   60  60  62  62  60  60  62  62]\n-[ 57  57  59  59  57  57  59  59   61  61  63  63  61  61  63  63]\n+[ 32  32  34  34  40  40  42  42   32  32  34  34  40  40  42  42 ]\n+[ 33  33  35  35  41  41  43  43   33  33  35  35  41  41  43  43 ]\n+[ ............................................................... ]\n+\n \n // -------------------------------- version = 2 --------------------------- //\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "file_content_changes": "@@ -2880,20 +2880,21 @@ struct ConvertLayoutOpConversion\n       } else if (mmaLayout.getVersion() == 1) {\n         multiDimWarpId[0] = urem(multiDimWarpId[0], idx_val(shape[0] / 16));\n         multiDimWarpId[1] = urem(multiDimWarpId[1], idx_val(shape[1] / 16));\n-        Value partId = udiv(laneId, _4);\n-        Value partIdDiv4 = udiv(partId, _4);\n-        Value partIdRem4 = urem(partId, _4);\n-        Value partRowOffset = mul(udiv(partIdRem4, _2), _8);\n-        partRowOffset = add(mul(partIdDiv4, _4), partRowOffset);\n-        Value partColOffset = mul(urem(partIdRem4, _2), _8);\n-        Value colOffset = add(mul(multiDimWarpId[0], _16), partColOffset);\n-        Value rowOffset = add(mul(multiDimWarpId[1], _16), partRowOffset);\n-        mmaRowIdx[0] = add(urem(laneId, _2), rowOffset);\n+        Value laneIdDiv16 = udiv(laneId, _16);\n+        Value laneIdRem16 = urem(laneId, _16);\n+        Value laneIdRem2 = urem(laneId, _2);\n+        Value laneIdRem16Div8 = udiv(laneIdRem16, _8);\n+        Value laneIdRem16Div4 = udiv(laneIdRem16, _4);\n+        Value laneIdRem16Div4Rem2 = urem(laneIdRem16Div4, _2);\n+        Value laneIdRem4Div2 = udiv(urem(laneId, _4), _2);\n+        mmaRowIdx[0] =\n+            add(add(mul(laneIdDiv16, _8), mul(laneIdRem16Div4Rem2, _4)),\n+                laneIdRem2);\n         mmaRowIdx[1] = add(mmaRowIdx[0], _2);\n-        mmaColIdx[0] = add(mul(udiv(urem(laneId, _4), _2), _2), colOffset);\n+        mmaColIdx[0] = add(mul(laneIdRem16Div8, _4), mul(laneIdRem4Div2, _2));\n         mmaColIdx[1] = add(mmaColIdx[0], _1);\n-        mmaColIdx[2] = add(mmaColIdx[0], _4);\n-        mmaColIdx[3] = add(mmaColIdx[0], idx_val(5));\n+        mmaColIdx[2] = add(mmaColIdx[0], _8);\n+        mmaColIdx[3] = add(mmaColIdx[0], idx_val(9));\n       } else {\n         llvm_unreachable(\"Unexpected MMALayout version\");\n       }\n@@ -3547,6 +3548,8 @@ DotOpConversion::convertMMA884(triton::DotOp op, DotOpAdaptor adaptor,\n \n   // initialize accumulators\n   SmallVector<Value> acc = getElementsFromStruct(loc, loadedC, rewriter);\n+  size_t resSize = acc.size();\n+  SmallVector<Value> resVals(resSize);\n \n   auto callMMA = [&](unsigned m, unsigned n, unsigned k) {\n     auto ha = has[{m, k}];\n@@ -3590,8 +3593,14 @@ DotOpConversion::convertMMA884(triton::DotOp op, DotOpAdaptor adaptor,\n     auto getIntAttr = [&](int v) {\n       return ArrayAttr::get(ctx, {IntegerAttr::get(i32_ty, v)});\n     };\n-    for (unsigned i = 0; i < 8; i++)\n-      acc[idx[i]] = extract_val(f32_ty, res, getIntAttr(i));\n+\n+    for (unsigned i = 0; i < 8; i++) {\n+      Value elem = extract_val(f32_ty, res, getIntAttr(i));\n+      acc[idx[i]] = elem;\n+      // TODO[goostavz]: double confirm this when m/n/k = [32, 32, x] has been\n+      // verified before MMA\n+      resVals[(m * numN / 2 + n) * 8 + i] = elem;\n+    }\n   };\n \n   for (unsigned k = 0; k < NK; k += 4)\n@@ -3600,12 +3609,10 @@ DotOpConversion::convertMMA884(triton::DotOp op, DotOpAdaptor adaptor,\n         callMMA(m, n, k);\n       }\n \n-  // replace with new packed result\n   Type structTy = LLVM::LLVMStructType::getLiteral(\n-      ctx, SmallVector<Type>(acc.size(), type::f32Ty(ctx)));\n-  Value res = getStructFromElements(loc, acc, rewriter, structTy);\n+      ctx, SmallVector<Type>(resSize, type::f32Ty(ctx)));\n+  Value res = getStructFromElements(loc, resVals, rewriter, structTy);\n   rewriter.replaceOp(op, res);\n-\n   return success();\n }\n "}, {"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPU.cpp", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "file_content_changes": "@@ -502,10 +502,55 @@ struct SCFYieldPattern : public OpConversionPattern<scf::YieldOp> {\n   }\n };\n \n+// This is borrowed from ConvertFIfOpTypes in\n+//    SCF/Transforms/StructuralTypeConversions.cpp\n+class SCFIfPattern : public OpConversionPattern<scf::IfOp> {\n+public:\n+  using OpConversionPattern<scf::IfOp>::OpConversionPattern;\n+  LogicalResult\n+  matchAndRewrite(scf::IfOp op, OpAdaptor adaptor,\n+                  ConversionPatternRewriter &rewriter) const override {\n+    // TODO: Generalize this to any type conversion, not just 1:1.\n+    //\n+    // We need to implement something more sophisticated here that tracks which\n+    // types convert to which other types and does the appropriate\n+    // materialization logic.\n+    // For example, it's possible that one result type converts to 0 types and\n+    // another to 2 types, so newResultTypes would at least be the right size to\n+    // not crash in the llvm::zip call below, but then we would set the the\n+    // wrong type on the SSA values! These edge cases are also why we cannot\n+    // safely use the TypeConverter::convertTypes helper here.\n+    SmallVector<Type> newResultTypes;\n+    for (auto type : op.getResultTypes()) {\n+      Type newType = typeConverter->convertType(type);\n+      if (!newType)\n+        return rewriter.notifyMatchFailure(op, \"not a 1:1 type conversion\");\n+      newResultTypes.push_back(newType);\n+    }\n+\n+    // See comments in the ForOp pattern for why we clone without regions and\n+    // then inline.\n+    scf::IfOp newOp =\n+        cast<scf::IfOp>(rewriter.cloneWithoutRegions(*op.getOperation()));\n+    rewriter.inlineRegionBefore(op.getThenRegion(), newOp.getThenRegion(),\n+                                newOp.getThenRegion().end());\n+    rewriter.inlineRegionBefore(op.getElseRegion(), newOp.getElseRegion(),\n+                                newOp.getElseRegion().end());\n+\n+    // Update the operands and types.\n+    newOp->setOperands(adaptor.getOperands());\n+    for (auto t : llvm::zip(newOp.getResults(), newResultTypes))\n+      std::get<0>(t).setType(std::get<1>(t));\n+    rewriter.replaceOp(op, newOp.getResults());\n+    return success();\n+  }\n+};\n+\n void populateSCFPatterns(TritonGPUTypeConverter &typeConverter,\n                          RewritePatternSet &patterns) {\n   MLIRContext *context = patterns.getContext();\n-  patterns.add<SCFYieldPattern, SCFForPattern>(typeConverter, context);\n+  patterns.add<SCFYieldPattern, SCFForPattern, SCFIfPattern>(typeConverter,\n+                                                             context);\n }\n \n class ConvertTritonToTritonGPU"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "file_content_changes": "@@ -359,7 +359,7 @@ def visit_If(self, node):\n             cond = cond.to(triton.language.int1, _builder=self.builder)\n             with enter_sub_region(self) as sr:\n                 liveins, ip_block = sr\n-\n+                liveins_copy = liveins.copy()\n                 then_block = self.builder.create_block()\n                 self.builder.set_insertion_point_to_start(then_block)\n                 self.visit_compound_statement(node.body)\n@@ -394,7 +394,15 @@ def visit_If(self, node):\n                             if then_defs[then_name].type == else_defs[else_name].type:\n                                 names.append(then_name)\n                                 ret_types.append(then_defs[then_name].type)\n-\n+                \n+                # defined in else block but not in then block\n+                # to find in parent scope and yield them\n+                for else_name in else_defs:\n+                    if else_name in liveins and else_name not in then_defs:\n+                        if else_defs[else_name].type == liveins[else_name].type:\n+                            names.append(else_name)\n+                            ret_types.append(else_defs[else_name].type)\n+                            then_defs[else_name] = liveins_copy[else_name]\n                 self.builder.set_insertion_point_to_end(ip_block)\n \n                 if then_defs or node.orelse:  # with else block"}]