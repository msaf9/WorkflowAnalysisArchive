[{"filename": "include/triton/Analysis/Allocation.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -156,7 +156,7 @@ class Allocation {\n \n private:\n   template <BufferT::BufferKind Kind, typename KeyType, typename... Args>\n-  void addBuffer(KeyType &key, Args &&... args) {\n+  void addBuffer(KeyType &key, Args &&...args) {\n     auto buffer = BufferT(Kind, std::forward<Args>(args)...);\n     bufferSet[buffer.id] = std::move(buffer);\n     if constexpr (Kind == BufferT::BufferKind::Explicit) {"}, {"filename": "include/triton/tools/thread_pool.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -35,7 +35,7 @@ class ThreadPool {\n   }\n \n   template <class F, class... Args>\n-  auto enqueue(F &&f, Args &&... args)\n+  auto enqueue(F &&f, Args &&...args)\n       -> std::future<typename std::result_of<F(Args...)>::type> {\n     using return_type = typename std::result_of<F(Args...)>::type;\n "}, {"filename": "python/src/pybind11/attr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -554,13 +554,13 @@ struct process_attribute<keep_alive<Nurse, Patient>>\n \n /// Recursively iterate over variadic template arguments\n template <typename... Args> struct process_attributes {\n-  static void init(const Args &... args, function_record *r) {\n+  static void init(const Args &...args, function_record *r) {\n     int unused[] = {\n         0, (process_attribute<typename std::decay<Args>::type>::init(args, r),\n             0)...};\n     ignore_unused(unused);\n   }\n-  static void init(const Args &... args, type_record *r) {\n+  static void init(const Args &...args, type_record *r) {\n     int unused[] = {\n         0, (process_attribute<typename std::decay<Args>::type>::init(args, r),\n             0)...};"}, {"filename": "python/src/pybind11/cast.h", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "file_content_changes": "@@ -1231,7 +1231,7 @@ template <> class type_caster<void> : public type_caster<void_type> {\n   }\n \n   template <typename T> using cast_op_type = void *&;\n-  operator void * &() { return value; }\n+  operator void *&() { return value; }\n   static constexpr auto name = _(\"capsule\");\n \n private:\n@@ -1336,9 +1336,12 @@ template <typename StringType, bool IsView = false> struct string_caster {\n #endif\n     }\n \n-    object utfNbytes = reinterpret_steal<object>(PyUnicode_AsEncodedString(\n-        load_src.ptr(),\n-        UTF_N == 8 ? \"utf-8\" : UTF_N == 16 ? \"utf-16\" : \"utf-32\", nullptr));\n+    object utfNbytes = reinterpret_steal<object>(\n+        PyUnicode_AsEncodedString(load_src.ptr(),\n+                                  UTF_N == 8    ? \"utf-8\"\n+                                  : UTF_N == 16 ? \"utf-16\"\n+                                                : \"utf-32\",\n+                                  nullptr));\n     if (!utfNbytes) {\n       PyErr_Clear();\n       return false;\n@@ -1377,20 +1380,21 @@ template <typename StringType, bool IsView = false> struct string_caster {\n private:\n   static handle decode_utfN(const char *buffer, ssize_t nbytes) {\n #if !defined(PYPY_VERSION)\n-    return UTF_N == 8\n-               ? PyUnicode_DecodeUTF8(buffer, nbytes, nullptr)\n-               : UTF_N == 16\n-                     ? PyUnicode_DecodeUTF16(buffer, nbytes, nullptr, nullptr)\n-                     : PyUnicode_DecodeUTF32(buffer, nbytes, nullptr, nullptr);\n+    return UTF_N == 8 ? PyUnicode_DecodeUTF8(buffer, nbytes, nullptr)\n+           : UTF_N == 16\n+               ? PyUnicode_DecodeUTF16(buffer, nbytes, nullptr, nullptr)\n+               : PyUnicode_DecodeUTF32(buffer, nbytes, nullptr, nullptr);\n #else\n     // PyPy seems to have multiple problems related to PyUnicode_UTF*: the UTF8\n     // version sometimes segfaults for unknown reasons, while the UTF16 and 32\n     // versions require a non-const char * arguments, which is also a nuisance,\n     // so bypass the whole thing by just passing the encoding as a string value,\n     // which works properly:\n-    return PyUnicode_Decode(\n-        buffer, nbytes,\n-        UTF_N == 8 ? \"utf-8\" : UTF_N == 16 ? \"utf-16\" : \"utf-32\", nullptr);\n+    return PyUnicode_Decode(buffer, nbytes,\n+                            UTF_N == 8    ? \"utf-8\"\n+                            : UTF_N == 16 ? \"utf-16\"\n+                                          : \"utf-32\",\n+                            nullptr);\n #endif\n   }\n \n@@ -1495,11 +1499,12 @@ struct type_caster<CharT, enable_if_t<is_std_char_type<CharT>::value>> {\n     if (StringCaster::UTF_N == 8 && str_len > 1 && str_len <= 4) {\n       unsigned char v0 = static_cast<unsigned char>(value[0]);\n       size_t char0_bytes =\n-          !(v0 & 0x80) ? 1 :            // low bits only: 0-127\n-              (v0 & 0xE0) == 0xC0 ? 2 : // 0b110xxxxx - start of 2-byte sequence\n-                  (v0 & 0xF0) == 0xE0 ? 3\n-                                      : // 0b1110xxxx - start of 3-byte sequence\n-                      4;                // 0b11110xxx - start of 4-byte sequence\n+          !(v0 & 0x80) ? 1 : // low bits only: 0-127\n+              (v0 & 0xE0) == 0xC0 ? 2\n+                                  : // 0b110xxxxx - start of 2-byte sequence\n+              (v0 & 0xF0) == 0xE0 ? 3\n+                                  : // 0b1110xxxx - start of 3-byte sequence\n+              4;                    // 0b11110xxx - start of 4-byte sequence\n \n       if (char0_bytes == str_len) {\n         // If we have a 128-255 value, we can decode it into a single char:\n@@ -2040,7 +2045,7 @@ tuple make_tuple() {\n \n template <return_value_policy policy = return_value_policy::automatic_reference,\n           typename... Args>\n-tuple make_tuple(Args &&... args_) {\n+tuple make_tuple(Args &&...args_) {\n   constexpr size_t size = sizeof...(Args);\n   std::array<object, size> args{\n       {reinterpret_steal<object>(detail::make_caster<Args>::cast(\n@@ -2261,7 +2266,7 @@ template <typename... Args> class argument_loader {\n template <return_value_policy policy> class simple_collector {\n public:\n   template <typename... Ts>\n-  explicit simple_collector(Ts &&... values)\n+  explicit simple_collector(Ts &&...values)\n       : m_args(pybind11::make_tuple<policy>(std::forward<Ts>(values)...)) {}\n \n   const tuple &args() const & { return m_args; }\n@@ -2285,7 +2290,7 @@ template <return_value_policy policy> class simple_collector {\n /// Python function call\n template <return_value_policy policy> class unpacking_collector {\n public:\n-  template <typename... Ts> explicit unpacking_collector(Ts &&... values) {\n+  template <typename... Ts> explicit unpacking_collector(Ts &&...values) {\n     // Tuples aren't (easily) resizable so a list is needed for collection,\n     // but the actual function call strictly requires a tuple.\n     auto args_list = list();\n@@ -2407,15 +2412,15 @@ template <return_value_policy policy> class unpacking_collector {\n /// Collect only positional arguments for a Python function call\n template <return_value_policy policy, typename... Args,\n           typename = enable_if_t<all_of<is_positional<Args>...>::value>>\n-simple_collector<policy> collect_arguments(Args &&... args) {\n+simple_collector<policy> collect_arguments(Args &&...args) {\n   return simple_collector<policy>(std::forward<Args>(args)...);\n }\n \n /// Collect all arguments, including keywords and unpacking (only instantiated\n /// when needed)\n template <return_value_policy policy, typename... Args,\n           typename = enable_if_t<!all_of<is_positional<Args>...>::value>>\n-unpacking_collector<policy> collect_arguments(Args &&... args) {\n+unpacking_collector<policy> collect_arguments(Args &&...args) {\n   // Following argument order rules for generalized unpacking according to PEP\n   // 448\n   static_assert(constexpr_last<is_positional, Args...>() <\n@@ -2430,14 +2435,14 @@ unpacking_collector<policy> collect_arguments(Args &&... args) {\n \n template <typename Derived>\n template <return_value_policy policy, typename... Args>\n-object object_api<Derived>::operator()(Args &&... args) const {\n+object object_api<Derived>::operator()(Args &&...args) const {\n   return detail::collect_arguments<policy>(std::forward<Args>(args)...)\n       .call(derived().ptr());\n }\n \n template <typename Derived>\n template <return_value_policy policy, typename... Args>\n-object object_api<Derived>::call(Args &&... args) const {\n+object object_api<Derived>::call(Args &&...args) const {\n   return operator()<policy>(std::forward<Args>(args)...);\n }\n "}, {"filename": "python/src/pybind11/detail/common.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -808,9 +808,9 @@ struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {\n           ? 0\n           : 1 + (std::is_integral<T>::value\n                      ? detail::log2(sizeof(T)) * 2 + std::is_unsigned<T>::value\n-                     : 8 + (std::is_same<T, double>::value\n-                                ? 1\n-                                : std::is_same<T, long double>::value ? 2 : 0));\n+                     : 8 + (std::is_same<T, double>::value        ? 1\n+                            : std::is_same<T, long double>::value ? 2\n+                                                                  : 0));\n };\n NAMESPACE_END(detail)\n "}, {"filename": "python/src/pybind11/detail/descr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -104,7 +104,7 @@ constexpr descr<N, Ts...> concat(const descr<N, Ts...> &descr) {\n }\n \n template <size_t N, typename... Ts, typename... Args>\n-constexpr auto concat(const descr<N, Ts...> &d, const Args &... args)\n+constexpr auto concat(const descr<N, Ts...> &d, const Args &...args)\n     -> decltype(std::declval<descr<N + 2, Ts...>>() + concat(args...)) {\n   return d + _(\", \") + concat(args...);\n }"}, {"filename": "python/src/pybind11/detail/init.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "file_content_changes": "@@ -66,13 +66,13 @@ template <typename /*Class*/> constexpr bool is_alias(void *) { return false; }\n template <\n     typename Class, typename... Args,\n     detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>\n-inline Class *construct_or_initialize(Args &&... args) {\n+inline Class *construct_or_initialize(Args &&...args) {\n   return new Class(std::forward<Args>(args)...);\n }\n template <\n     typename Class, typename... Args,\n     detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>\n-inline Class *construct_or_initialize(Args &&... args) {\n+inline Class *construct_or_initialize(Args &&...args) {\n   return new Class{std::forward<Args>(args)...};\n }\n \n@@ -200,7 +200,7 @@ void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {\n template <typename... Args> struct constructor {\n   template <typename Class, typename... Extra,\n             enable_if_t<!Class::has_alias, int> = 0>\n-  static void execute(Class &cl, const Extra &... extra) {\n+  static void execute(Class &cl, const Extra &...extra) {\n     cl.def(\n         \"__init__\",\n         [](value_and_holder &v_h, Args... args) {\n@@ -214,7 +214,7 @@ template <typename... Args> struct constructor {\n             enable_if_t<Class::has_alias &&\n                             std::is_constructible<Cpp<Class>, Args...>::value,\n                         int> = 0>\n-  static void execute(Class &cl, const Extra &... extra) {\n+  static void execute(Class &cl, const Extra &...extra) {\n     cl.def(\n         \"__init__\",\n         [](value_and_holder &v_h, Args... args) {\n@@ -232,7 +232,7 @@ template <typename... Args> struct constructor {\n             enable_if_t<Class::has_alias &&\n                             !std::is_constructible<Cpp<Class>, Args...>::value,\n                         int> = 0>\n-  static void execute(Class &cl, const Extra &... extra) {\n+  static void execute(Class &cl, const Extra &...extra) {\n     cl.def(\n         \"__init__\",\n         [](value_and_holder &v_h, Args... args) {\n@@ -249,7 +249,7 @@ template <typename... Args> struct alias_constructor {\n             enable_if_t<Class::has_alias &&\n                             std::is_constructible<Alias<Class>, Args...>::value,\n                         int> = 0>\n-  static void execute(Class &cl, const Extra &... extra) {\n+  static void execute(Class &cl, const Extra &...extra) {\n     cl.def(\n         \"__init__\",\n         [](value_and_holder &v_h, Args... args) {\n@@ -280,7 +280,7 @@ struct factory<Func, void_type (*)(), Return(Args...)> {\n   // either already be an alias instance, or the alias needs to be constructible\n   // from a `Class &&` argument.\n   template <typename Class, typename... Extra>\n-  void execute(Class &cl, const Extra &... extra) && {\n+  void execute(Class &cl, const Extra &...extra) && {\n #if defined(PYBIND11_CPP14)\n     cl.def(\n         \"__init__\",\n@@ -323,7 +323,7 @@ struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {\n   // the direct class (i.e. not inherited), the alias factory when `self` is a\n   // Python-side subtype.\n   template <typename Class, typename... Extra>\n-  void execute(Class &cl, const Extra &... extra) && {\n+  void execute(Class &cl, const Extra &...extra) && {\n     static_assert(Class::has_alias,\n                   \"The two-argument version of `py::init()` can \"\n                   \"only be used if the class has an alias\");\n@@ -389,7 +389,7 @@ struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {\n       : get(std::forward<Get>(get)), set(std::forward<Set>(set)) {}\n \n   template <typename Class, typename... Extra>\n-  void execute(Class &cl, const Extra &... extra) && {\n+  void execute(Class &cl, const Extra &...extra) && {\n     cl.def(\"__getstate__\", std::move(get));\n \n #if defined(PYBIND11_CPP14)"}, {"filename": "python/src/pybind11/detail/internals.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -297,7 +297,7 @@ inline type_map<type_info *> &registered_local_types_cpp() {\n /// duration -- the internal strings are only cleared when the program exits or\n /// after interpreter shutdown (when embedding), and so are suitable for c-style\n /// strings needed by Python internals (such as PyTypeObject's tp_name).\n-template <typename... Args> const char *c_str(Args &&... args) {\n+template <typename... Args> const char *c_str(Args &&...args) {\n   auto &strings = get_internals().static_strings;\n   strings.emplace_front(std::forward<Args>(args)...);\n   return strings.front().c_str();"}, {"filename": "python/src/pybind11/eigen.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "file_content_changes": "@@ -164,7 +164,9 @@ template <typename Type_> struct EigenProps {\n   static constexpr EigenIndex\n       inner_stride = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,\n       outer_stride = if_zero < StrideType::OuterStrideAtCompileTime,\n-      vector ? size : row_major ? cols : rows > ::value;\n+      vector      ? size\n+      : row_major ? cols\n+                  : rows > ::value;\n   static constexpr bool dynamic_stride =\n       inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;\n   static constexpr bool requires_row_major =\n@@ -471,15 +473,14 @@ struct type_caster<Eigen::Ref<PlainObjectType, 0, StrideType>,\n   using props = EigenProps<Type>;\n   using Scalar = typename props::Scalar;\n   using MapType = Eigen::Map<PlainObjectType, 0, StrideType>;\n-  using Array =\n-      array_t<Scalar, array::forcecast |\n-                          ((props::row_major ? props::inner_stride\n-                                             : props::outer_stride) == 1\n-                               ? array::c_style\n-                               : (props::row_major ? props::outer_stride\n-                                                   : props::inner_stride) == 1\n-                                     ? array::f_style\n-                                     : 0)>;\n+  using Array = array_t<\n+      Scalar,\n+      array::forcecast |\n+          ((props::row_major ? props::inner_stride : props::outer_stride) == 1\n+               ? array::c_style\n+           : (props::row_major ? props::outer_stride : props::inner_stride) == 1\n+               ? array::f_style\n+               : 0)>;\n   static constexpr bool need_writeable = is_eigen_mutable_map<Type>::value;\n   // Delay construction (these have no default constructor)\n   std::unique_ptr<MapType> map;"}, {"filename": "python/src/pybind11/numpy.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "file_content_changes": "@@ -1299,10 +1299,10 @@ template <typename T, typename SFINAE> struct npy_format_descriptor {\n #define PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, Name)                           \\\n   ::pybind11::detail::field_descriptor {                                       \\\n     Name, offsetof(T, Field), sizeof(decltype(std::declval<T>().Field)),       \\\n-        ::pybind11::format_descriptor<decltype(                                \\\n-            std::declval<T>().Field)>::format(),                               \\\n-        ::pybind11::detail::npy_format_descriptor<decltype(                    \\\n-            std::declval<T>().Field)>::dtype()                                 \\\n+        ::pybind11::format_descriptor<                                         \\\n+            decltype(std::declval<T>().Field)>::format(),                      \\\n+        ::pybind11::detail::npy_format_descriptor<                             \\\n+            decltype(std::declval<T>().Field)>::dtype()                        \\\n   }\n \n // Extract name, offset and format descriptor for a struct field\n@@ -1576,10 +1576,9 @@ broadcast_trivial broadcast(const std::array<buffer_info, N> &buffers,\n     }\n   }\n \n-  return trivial_broadcast_c\n-             ? broadcast_trivial::c_trivial\n-             : trivial_broadcast_f ? broadcast_trivial::f_trivial\n-                                   : broadcast_trivial::non_trivial;\n+  return trivial_broadcast_c   ? broadcast_trivial::c_trivial\n+         : trivial_broadcast_f ? broadcast_trivial::f_trivial\n+                               : broadcast_trivial::non_trivial;\n }\n \n template <typename T> struct vectorize_arg {\n@@ -1643,7 +1642,7 @@ struct vectorize_helper {\n   //       we can store vectorized buffer_infos in an array (argument VIndex has\n   //       its buffer at index BIndex in the array).\n   template <size_t... Index, size_t... VIndex, size_t... BIndex>\n-  object run(typename vectorize_arg<Args>::type &... args,\n+  object run(typename vectorize_arg<Args>::type &...args,\n              index_sequence<Index...> i_seq, index_sequence<VIndex...> vi_seq,\n              index_sequence<BIndex...> bi_seq) {\n "}, {"filename": "python/src/pybind11/operators.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "file_content_changes": "@@ -93,7 +93,7 @@ template <op_id, op_type, typename B, typename L, typename R> struct op_impl {};\n /// Operator implementation generator\n template <op_id id, op_type ot, typename L, typename R> struct op_ {\n   template <typename Class, typename... Extra>\n-  void execute(Class &cl, const Extra &... extra) const {\n+  void execute(Class &cl, const Extra &...extra) const {\n     using Base = typename Class::type;\n     using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;\n     using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;\n@@ -102,12 +102,13 @@ template <op_id id, op_type ot, typename L, typename R> struct op_ {\n #if PY_MAJOR_VERSION < 3\n     if (id == op_truediv || id == op_itruediv)\n       cl.def(id == op_itruediv ? \"__idiv__\"\n-                               : ot == op_l ? \"__div__\" : \"__rdiv__\",\n+             : ot == op_l      ? \"__div__\"\n+                               : \"__rdiv__\",\n              &op::execute, is_operator(), extra...);\n #endif\n   }\n   template <typename Class, typename... Extra>\n-  void execute_cast(Class &cl, const Extra &... extra) const {\n+  void execute_cast(Class &cl, const Extra &...extra) const {\n     using Base = typename Class::type;\n     using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;\n     using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;\n@@ -116,7 +117,8 @@ template <op_id id, op_type ot, typename L, typename R> struct op_ {\n #if PY_MAJOR_VERSION < 3\n     if (id == op_truediv || id == op_itruediv)\n       cl.def(id == op_itruediv ? \"__idiv__\"\n-                               : ot == op_l ? \"__div__\" : \"__rdiv__\",\n+             : ot == op_l      ? \"__div__\"\n+                               : \"__rdiv__\",\n              &op::execute, is_operator(), extra...);\n #endif\n   }\n@@ -177,19 +179,19 @@ template <op_id id, op_type ot, typename L, typename R> struct op_ {\n \n PYBIND11_BINARY_OPERATOR(sub, rsub, operator-, l - r)\n PYBIND11_BINARY_OPERATOR(add, radd, operator+, l + r)\n-PYBIND11_BINARY_OPERATOR(mul, rmul, operator*, l * r)\n+PYBIND11_BINARY_OPERATOR(mul, rmul, operator*, l *r)\n PYBIND11_BINARY_OPERATOR(truediv, rtruediv, operator/, l / r)\n PYBIND11_BINARY_OPERATOR(mod, rmod, operator%, l % r)\n PYBIND11_BINARY_OPERATOR(lshift, rlshift, operator<<, l << r)\n-PYBIND11_BINARY_OPERATOR(rshift, rrshift, operator>>, l>> r)\n-PYBIND11_BINARY_OPERATOR(and, rand, operator&, l & r)\n+PYBIND11_BINARY_OPERATOR(rshift, rrshift, operator>>, l >> r)\n+PYBIND11_BINARY_OPERATOR(and, rand, operator&, l &r)\n PYBIND11_BINARY_OPERATOR(xor, rxor, operator^, l ^ r)\n PYBIND11_BINARY_OPERATOR(eq, eq, operator==, l == r)\n PYBIND11_BINARY_OPERATOR(ne, ne, operator!=, l != r)\n PYBIND11_BINARY_OPERATOR(or, ror, operator|, l | r)\n-PYBIND11_BINARY_OPERATOR(gt, lt, operator>, l> r)\n+PYBIND11_BINARY_OPERATOR(gt, lt, operator>, l > r)\n PYBIND11_BINARY_OPERATOR(ge, le, operator>=, l >= r)\n-PYBIND11_BINARY_OPERATOR(lt, gt, operator<, l<r)\n+PYBIND11_BINARY_OPERATOR(lt, gt, operator<, l < r)\n PYBIND11_BINARY_OPERATOR(le, ge, operator<=, l <= r)\n // PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,\n // r))\n@@ -203,11 +205,11 @@ PYBIND11_INPLACE_OPERATOR(irshift, operator>>=, l >>= r)\n PYBIND11_INPLACE_OPERATOR(iand, operator&=, l &= r)\n PYBIND11_INPLACE_OPERATOR(ixor, operator^=, l ^= r)\n PYBIND11_INPLACE_OPERATOR(ior, operator|=, l |= r)\n-PYBIND11_UNARY_OPERATOR(neg, operator-, - l)\n-PYBIND11_UNARY_OPERATOR(pos, operator+, + l)\n+PYBIND11_UNARY_OPERATOR(neg, operator-, -l)\n+PYBIND11_UNARY_OPERATOR(pos, operator+, +l)\n PYBIND11_UNARY_OPERATOR(abs, abs, std::abs(l))\n PYBIND11_UNARY_OPERATOR(hash, hash, std::hash<L>()(l))\n-PYBIND11_UNARY_OPERATOR(invert, operator~,(~l))\n+PYBIND11_UNARY_OPERATOR(invert, operator~, (~l))\n PYBIND11_UNARY_OPERATOR(bool, operator!, !!l)\n PYBIND11_UNARY_OPERATOR(int, int_, (int)l)\n PYBIND11_UNARY_OPERATOR(float, float_, (double)l)"}, {"filename": "python/src/pybind11/pybind11.h", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "file_content_changes": "@@ -74,30 +74,30 @@ class cpp_function : public function {\n \n   /// Construct a cpp_function from a vanilla function pointer\n   template <typename Return, typename... Args, typename... Extra>\n-  cpp_function(Return (*f)(Args...), const Extra &... extra) {\n+  cpp_function(Return (*f)(Args...), const Extra &...extra) {\n     initialize(f, f, extra...);\n   }\n \n   /// Construct a cpp_function from a lambda function (possibly with internal\n   /// state)\n   template <typename Func, typename... Extra,\n             typename = detail::enable_if_t<detail::is_lambda<Func>::value>>\n-  cpp_function(Func &&f, const Extra &... extra) {\n+  cpp_function(Func &&f, const Extra &...extra) {\n     initialize(std::forward<Func>(f),\n                (detail::function_signature_t<Func> *)nullptr, extra...);\n   }\n \n   /// Construct a cpp_function from a class method (non-const)\n   template <typename Return, typename Class, typename... Arg, typename... Extra>\n-  cpp_function(Return (Class::*f)(Arg...), const Extra &... extra) {\n+  cpp_function(Return (Class::*f)(Arg...), const Extra &...extra) {\n     initialize(\n         [f](Class *c, Arg... args) -> Return { return (c->*f)(args...); },\n         (Return(*)(Class *, Arg...)) nullptr, extra...);\n   }\n \n   /// Construct a cpp_function from a class method (const)\n   template <typename Return, typename Class, typename... Arg, typename... Extra>\n-  cpp_function(Return (Class::*f)(Arg...) const, const Extra &... extra) {\n+  cpp_function(Return (Class::*f)(Arg...) const, const Extra &...extra) {\n     initialize(\n         [f](const Class *c, Arg... args) -> Return { return (c->*f)(args...); },\n         (Return(*)(const Class *, Arg...)) nullptr, extra...);\n@@ -114,7 +114,7 @@ class cpp_function : public function {\n \n   /// Special internal constructor for functors, lambda functions, etc.\n   template <typename Func, typename Return, typename... Args, typename... Extra>\n-  void initialize(Func &&f, Return (*)(Args...), const Extra &... extra) {\n+  void initialize(Func &&f, Return (*)(Args...), const Extra &...extra) {\n     using namespace detail;\n     struct capture {\n       remove_reference_t<Func> f;\n@@ -924,7 +924,7 @@ class module : public object {\n       details on the ``Extra&& ... extra`` argument, see section :ref:`extras`.\n   \\endrst */\n   template <typename Func, typename... Extra>\n-  module &def(const char *name_, Func &&f, const Extra &... extra) {\n+  module &def(const char *name_, Func &&f, const Extra &...extra) {\n     cpp_function func(std::forward<Func>(f), name(name_), scope(*this),\n                       sibling(getattr(*this, name_, none())), extra...);\n     // NB: allow overwriting here because cpp_function sets up a chain with the\n@@ -1104,8 +1104,8 @@ class generic_type : public object {\n \n /// Set the pointer to operator new if it exists. The cast is needed because it\n /// can be overloaded.\n-template <typename T, typename = void_t<decltype(\n-                          static_cast<void *(*)(size_t)>(T::operator new))>>\n+template <typename T, typename = void_t<decltype(static_cast<void *(*)(size_t)>(\n+                          T::operator new))>>\n void set_operator_new(type_record *r) {\n   r->operator_new = &T::operator new;\n }\n@@ -1204,7 +1204,7 @@ class class_ : public detail::generic_type {\n   PYBIND11_OBJECT(class_, generic_type, PyType_Check)\n \n   template <typename... Extra>\n-  class_(handle scope, const char *name, const Extra &... extra) {\n+  class_(handle scope, const char *name, const Extra &...extra) {\n     using namespace detail;\n \n     // MI can only be specified via class_ template options, not constructor\n@@ -1263,7 +1263,7 @@ class class_ : public detail::generic_type {\n   static void add_base(detail::type_record &) {}\n \n   template <typename Func, typename... Extra>\n-  class_ &def(const char *name_, Func &&f, const Extra &... extra) {\n+  class_ &def(const char *name_, Func &&f, const Extra &...extra) {\n     cpp_function cf(method_adaptor<type>(std::forward<Func>(f)), name(name_),\n                     is_method(*this), sibling(getattr(*this, name_, none())),\n                     extra...);\n@@ -1272,7 +1272,7 @@ class class_ : public detail::generic_type {\n   }\n \n   template <typename Func, typename... Extra>\n-  class_ &def_static(const char *name_, Func &&f, const Extra &... extra) {\n+  class_ &def_static(const char *name_, Func &&f, const Extra &...extra) {\n     static_assert(\n         !std::is_member_function_pointer<Func>::value,\n         \"def_static(...) called with a non-static member function pointer\");\n@@ -1284,43 +1284,42 @@ class class_ : public detail::generic_type {\n \n   template <detail::op_id id, detail::op_type ot, typename L, typename R,\n             typename... Extra>\n-  class_ &def(const detail::op_<id, ot, L, R> &op, const Extra &... extra) {\n+  class_ &def(const detail::op_<id, ot, L, R> &op, const Extra &...extra) {\n     op.execute(*this, extra...);\n     return *this;\n   }\n \n   template <detail::op_id id, detail::op_type ot, typename L, typename R,\n             typename... Extra>\n-  class_ &def_cast(const detail::op_<id, ot, L, R> &op,\n-                   const Extra &... extra) {\n+  class_ &def_cast(const detail::op_<id, ot, L, R> &op, const Extra &...extra) {\n     op.execute_cast(*this, extra...);\n     return *this;\n   }\n \n   template <typename... Args, typename... Extra>\n   class_ &def(const detail::initimpl::constructor<Args...> &init,\n-              const Extra &... extra) {\n+              const Extra &...extra) {\n     init.execute(*this, extra...);\n     return *this;\n   }\n \n   template <typename... Args, typename... Extra>\n   class_ &def(const detail::initimpl::alias_constructor<Args...> &init,\n-              const Extra &... extra) {\n+              const Extra &...extra) {\n     init.execute(*this, extra...);\n     return *this;\n   }\n \n   template <typename... Args, typename... Extra>\n   class_ &def(detail::initimpl::factory<Args...> &&init,\n-              const Extra &... extra) {\n+              const Extra &...extra) {\n     std::move(init).execute(*this, extra...);\n     return *this;\n   }\n \n   template <typename... Args, typename... Extra>\n   class_ &def(detail::initimpl::pickle_factory<Args...> &&pf,\n-              const Extra &... extra) {\n+              const Extra &...extra) {\n     std::move(pf).execute(*this, extra...);\n     return *this;\n   }\n@@ -1352,7 +1351,7 @@ class class_ : public detail::generic_type {\n   }\n \n   template <typename C, typename D, typename... Extra>\n-  class_ &def_readwrite(const char *name, D C::*pm, const Extra &... extra) {\n+  class_ &def_readwrite(const char *name, D C::*pm, const Extra &...extra) {\n     static_assert(\n         std::is_same<C, type>::value || std::is_base_of<C, type>::value,\n         \"def_readwrite() requires a class member (or base class member)\");\n@@ -1367,7 +1366,7 @@ class class_ : public detail::generic_type {\n \n   template <typename C, typename D, typename... Extra>\n   class_ &def_readonly(const char *name, const D C::*pm,\n-                       const Extra &... extra) {\n+                       const Extra &...extra) {\n     static_assert(\n         std::is_same<C, type>::value || std::is_base_of<C, type>::value,\n         \"def_readonly() requires a class member (or base class member)\");\n@@ -1379,8 +1378,7 @@ class class_ : public detail::generic_type {\n   }\n \n   template <typename D, typename... Extra>\n-  class_ &def_readwrite_static(const char *name, D *pm,\n-                               const Extra &... extra) {\n+  class_ &def_readwrite_static(const char *name, D *pm, const Extra &...extra) {\n     cpp_function fget([pm](object) -> const D & { return *pm; }, scope(*this)),\n         fset([pm](object, const D &value) { *pm = value; }, scope(*this));\n     def_property_static(name, fget, fset, return_value_policy::reference,\n@@ -1390,7 +1388,7 @@ class class_ : public detail::generic_type {\n \n   template <typename D, typename... Extra>\n   class_ &def_readonly_static(const char *name, const D *pm,\n-                              const Extra &... extra) {\n+                              const Extra &...extra) {\n     cpp_function fget([pm](object) -> const D & { return *pm; }, scope(*this));\n     def_property_readonly_static(name, fget, return_value_policy::reference,\n                                  extra...);\n@@ -1400,7 +1398,7 @@ class class_ : public detail::generic_type {\n   /// Uses return_value_policy::reference_internal by default\n   template <typename Getter, typename... Extra>\n   class_ &def_property_readonly(const char *name, const Getter &fget,\n-                                const Extra &... extra) {\n+                                const Extra &...extra) {\n     return def_property_readonly(name, cpp_function(method_adaptor<type>(fget)),\n                                  return_value_policy::reference_internal,\n                                  extra...);\n@@ -1409,14 +1407,14 @@ class class_ : public detail::generic_type {\n   /// Uses cpp_function's return_value_policy by default\n   template <typename... Extra>\n   class_ &def_property_readonly(const char *name, const cpp_function &fget,\n-                                const Extra &... extra) {\n+                                const Extra &...extra) {\n     return def_property(name, fget, nullptr, extra...);\n   }\n \n   /// Uses return_value_policy::reference by default\n   template <typename Getter, typename... Extra>\n   class_ &def_property_readonly_static(const char *name, const Getter &fget,\n-                                       const Extra &... extra) {\n+                                       const Extra &...extra) {\n     return def_property_readonly_static(\n         name, cpp_function(fget), return_value_policy::reference, extra...);\n   }\n@@ -1425,45 +1423,43 @@ class class_ : public detail::generic_type {\n   template <typename... Extra>\n   class_ &def_property_readonly_static(const char *name,\n                                        const cpp_function &fget,\n-                                       const Extra &... extra) {\n+                                       const Extra &...extra) {\n     return def_property_static(name, fget, nullptr, extra...);\n   }\n \n   /// Uses return_value_policy::reference_internal by default\n   template <typename Getter, typename Setter, typename... Extra>\n   class_ &def_property(const char *name, const Getter &fget, const Setter &fset,\n-                       const Extra &... extra) {\n+                       const Extra &...extra) {\n     return def_property(name, fget, cpp_function(method_adaptor<type>(fset)),\n                         extra...);\n   }\n   template <typename Getter, typename... Extra>\n   class_ &def_property(const char *name, const Getter &fget,\n-                       const cpp_function &fset, const Extra &... extra) {\n+                       const cpp_function &fset, const Extra &...extra) {\n     return def_property(name, cpp_function(method_adaptor<type>(fget)), fset,\n                         return_value_policy::reference_internal, extra...);\n   }\n \n   /// Uses cpp_function's return_value_policy by default\n   template <typename... Extra>\n   class_ &def_property(const char *name, const cpp_function &fget,\n-                       const cpp_function &fset, const Extra &... extra) {\n+                       const cpp_function &fset, const Extra &...extra) {\n     return def_property_static(name, fget, fset, is_method(*this), extra...);\n   }\n \n   /// Uses return_value_policy::reference by default\n   template <typename Getter, typename... Extra>\n   class_ &def_property_static(const char *name, const Getter &fget,\n-                              const cpp_function &fset,\n-                              const Extra &... extra) {\n+                              const cpp_function &fset, const Extra &...extra) {\n     return def_property_static(name, cpp_function(fget), fset,\n                                return_value_policy::reference, extra...);\n   }\n \n   /// Uses cpp_function's return_value_policy by default\n   template <typename... Extra>\n   class_ &def_property_static(const char *name, const cpp_function &fget,\n-                              const cpp_function &fset,\n-                              const Extra &... extra) {\n+                              const cpp_function &fset, const Extra &...extra) {\n     static_assert(\n         0 == detail::constexpr_sum(std::is_base_of<arg, Extra>::value...),\n         \"Argument annotations are not allowed for properties\");\n@@ -1782,7 +1778,7 @@ template <typename Type> class enum_ : public class_<Type> {\n   using Scalar = typename std::underlying_type<Type>::type;\n \n   template <typename... Extra>\n-  enum_(const handle &scope, const char *name, const Extra &... extra)\n+  enum_(const handle &scope, const char *name, const Extra &...extra)\n       : class_<Type>(scope, name, extra...), m_base(*this, scope) {\n     constexpr bool is_arithmetic =\n         detail::any_of<std::is_same<arithmetic, Extra>...>::value;\n@@ -1898,7 +1894,7 @@ template <return_value_policy Policy = return_value_policy::reference_internal,\n           typename Iterator, typename Sentinel,\n           typename ValueType = decltype(*std::declval<Iterator>()),\n           typename... Extra>\n-iterator make_iterator(Iterator first, Sentinel last, Extra &&... extra) {\n+iterator make_iterator(Iterator first, Sentinel last, Extra &&...extra) {\n   typedef detail::iterator_state<Iterator, Sentinel, false, Policy> state;\n \n   if (!detail::get_type_info(typeid(state), false)) {\n@@ -1929,7 +1925,7 @@ template <return_value_policy Policy = return_value_policy::reference_internal,\n           typename Iterator, typename Sentinel,\n           typename KeyType = decltype((*std::declval<Iterator>()).first),\n           typename... Extra>\n-iterator make_key_iterator(Iterator first, Sentinel last, Extra &&... extra) {\n+iterator make_key_iterator(Iterator first, Sentinel last, Extra &&...extra) {\n   typedef detail::iterator_state<Iterator, Sentinel, true, Policy> state;\n \n   if (!detail::get_type_info(typeid(state), false)) {\n@@ -1958,15 +1954,15 @@ iterator make_key_iterator(Iterator first, Sentinel last, Extra &&... extra) {\n /// supporting `std::begin()`/`std::end()`\n template <return_value_policy Policy = return_value_policy::reference_internal,\n           typename Type, typename... Extra>\n-iterator make_iterator(Type &value, Extra &&... extra) {\n+iterator make_iterator(Type &value, Extra &&...extra) {\n   return make_iterator<Policy>(std::begin(value), std::end(value), extra...);\n }\n \n /// Makes an iterator over the keys (`.first`) of a stl map-like container\n /// supporting `std::begin()`/`std::end()`\n template <return_value_policy Policy = return_value_policy::reference_internal,\n           typename Type, typename... Extra>\n-iterator make_key_iterator(Type &value, Extra &&... extra) {\n+iterator make_key_iterator(Type &value, Extra &&...extra) {\n   return make_key_iterator<Policy>(std::begin(value), std::end(value),\n                                    extra...);\n }\n@@ -2106,7 +2102,7 @@ NAMESPACE_END(detail)\n \n template <return_value_policy policy = return_value_policy::automatic_reference,\n           typename... Args>\n-void print(Args &&... args) {\n+void print(Args &&...args) {\n   auto c = detail::collect_arguments<policy>(std::forward<Args>(args)...);\n   detail::print(c.args(), c.kwargs());\n }"}, {"filename": "python/src/pybind11/pytypes.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "file_content_changes": "@@ -112,12 +112,12 @@ template <typename Derived> class object_api : public pyobject_tag {\n   template <\n       return_value_policy policy = return_value_policy::automatic_reference,\n       typename... Args>\n-  object operator()(Args &&... args) const;\n+  object operator()(Args &&...args) const;\n   template <\n       return_value_policy policy = return_value_policy::automatic_reference,\n       typename... Args>\n   PYBIND11_DEPRECATED(\"call(...) was deprecated in favor of operator()(...)\")\n-  object call(Args &&... args) const;\n+  object call(Args &&...args) const;\n \n   /// Equivalent to ``obj is other`` in Python.\n   bool is(object_api const &other) const {\n@@ -1109,7 +1109,7 @@ class str : public object {\n     return std::string(buffer, (size_t)length);\n   }\n \n-  template <typename... Args> str format(Args &&... args) const {\n+  template <typename... Args> str format(Args &&...args) const {\n     return attr(\"format\")(std::forward<Args>(args)...);\n   }\n \n@@ -1282,11 +1282,9 @@ class int_ : public object {\n   template <typename T,\n             detail::enable_if_t<std::is_integral<T>::value, int> = 0>\n   operator T() const {\n-    return std::is_unsigned<T>::value\n-               ? detail::as_unsigned<T>(m_ptr)\n-               : sizeof(T) <= sizeof(long)\n-                     ? (T)PyLong_AsLong(m_ptr)\n-                     : (T)PYBIND11_LONG_AS_LONGLONG(m_ptr);\n+    return std::is_unsigned<T>::value  ? detail::as_unsigned<T>(m_ptr)\n+           : sizeof(T) <= sizeof(long) ? (T)PyLong_AsLong(m_ptr)\n+                                       : (T)PYBIND11_LONG_AS_LONGLONG(m_ptr);\n   }\n };\n \n@@ -1438,7 +1436,7 @@ class dict : public object {\n             // defer the collector\n             typename collector =\n                 detail::deferred_t<detail::unpacking_collector<>, Args...>>\n-  explicit dict(Args &&... args)\n+  explicit dict(Args &&...args)\n       : dict(collector(std::forward<Args>(args)...).kwargs()) {}\n \n   size_t size() const { return (size_t)PyDict_Size(m_ptr); }"}, {"filename": "python/src/pybind11/stl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -356,7 +356,7 @@ struct variant_caster_visitor {\n /// `boost::variant` and `boost::apply_visitor`.\n template <template <typename...> class Variant> struct visit_helper {\n   template <typename... Args>\n-  static auto call(Args &&... args)\n+  static auto call(Args &&...args)\n       -> decltype(visit(std::forward<Args>(args)...)) {\n     return visit(std::forward<Args>(args)...);\n   }"}, {"filename": "python/src/pybind11/stl_bind.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -432,7 +432,7 @@ NAMESPACE_END(detail)\n template <typename Vector, typename holder_type = std::unique_ptr<Vector>,\n           typename... Args>\n class_<Vector, holder_type> bind_vector(handle scope, std::string const &name,\n-                                        Args &&... args) {\n+                                        Args &&...args) {\n   using Class_ = class_<Vector, holder_type>;\n \n   // If the value_type is unregistered (e.g. a converting type) or is itself\n@@ -596,7 +596,7 @@ NAMESPACE_END(detail)\n template <typename Map, typename holder_type = std::unique_ptr<Map>,\n           typename... Args>\n class_<Map, holder_type> bind_map(handle scope, const std::string &name,\n-                                  Args &&... args) {\n+                                  Args &&...args) {\n   using KeyType = typename Map::key_type;\n   using MappedType = typename Map::mapped_type;\n   using Class_ = class_<Map, holder_type>;"}]