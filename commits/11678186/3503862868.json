[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "file_content_changes": "@@ -5921,11 +5921,13 @@ struct AtomicRMWOpConversion\n \n     Value llPtr = adaptor.ptr();\n     Value llVal = adaptor.val();\n+    Value llMask = adaptor.mask();\n \n     auto valElements = getElementsFromStruct(loc, llVal, rewriter);\n     auto ptrElements = getElementsFromStruct(loc, llPtr, rewriter);\n+    auto maskElements = getElementsFromStruct(loc, llMask, rewriter);\n \n-    // TODO[dongdongl]: Support mask and scalar\n+    // TODO[dongdongl]: Support scalar\n \n     auto valueTy = op.getResult().getType().dyn_cast<RankedTensorType>();\n     if (!valueTy)\n@@ -5940,6 +5942,14 @@ struct AtomicRMWOpConversion\n \n     auto vecTy = vec_ty(valueElemTy, vec);\n     auto elemsPerThread = getElemsPerThread(val.getType());\n+    // mask\n+    Value mask = int_val(1, 1);\n+    auto shape = valueTy.getShape();\n+    auto numElements = product(shape);\n+    auto tid = tid_val();\n+    mask = and_(mask, icmp_slt(mul(tid, i32_val(elemsPerThread)),\n+                               i32_val(numElements)));\n+\n     SmallVector<Value> resultVals(elemsPerThread);\n     for (size_t i = 0; i < elemsPerThread; i += vec) {\n       Value rmwVal = undef(vecTy);\n@@ -5949,6 +5959,8 @@ struct AtomicRMWOpConversion\n         rmwVal = insert_element(vecTy, rmwVal, valElements[i + ii], iiVal);\n       }\n       Value rmwPtr = ptrElements[i];\n+      Value rmwMask = maskElements[i];\n+      rmwMask = and_(rmwMask, mask);\n       std::string sTy;\n       PTXBuilder ptxBuilder;\n \n@@ -5996,9 +6008,7 @@ struct AtomicRMWOpConversion\n         return failure();\n       }\n       atom.o(rmwOp).o(sTy);\n-      //TODO:[dongdongl] actual mask support\n-      Value pred = int_val(1, 1);\n-      atom(dstOpr, ptrOpr, valOpr).predicate(pred);\n+      atom(dstOpr, ptrOpr, valOpr).predicate(rmwMask);\n       auto ret = ptxBuilder.launch(rewriter, loc, valueElemTy);\n       for (int ii = 0; ii < vec; ++ii) {\n         resultVals[i * vec + ii] ="}, {"filename": "python/tests/test_core.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -672,7 +672,7 @@ def without_fn(X, Y, A, B, C):\n #     np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=1e-4)\n \n def test_tensor_atomic_rmw_add_elementwise(device=\"cuda\"):\n-    shape0, shape1 = 16, 16\n+    shape0, shape1 = 2, 8\n     @triton.jit\n     def kernel(Z, X, SHAPE0: tl.constexpr, SHAPE1: tl.constexpr):\n         off0 = tl.arange(0, SHAPE0)"}]