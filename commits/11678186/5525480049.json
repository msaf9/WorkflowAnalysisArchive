[{"filename": "python/src/triton.cc", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "file_content_changes": "@@ -65,7 +65,7 @@ enum backend_t {\n \n void init_triton_runtime(py::module &&m) {\n   // wrap backend_t\n-  py::enum_<backend_t>(m, \"backend\")\n+  py::enum_<backend_t>(m, \"backend\", py::module_local())\n       .value(\"HOST\", HOST)\n       .value(\"CUDA\", CUDA)\n       .value(\"ROCM\", ROCM)\n@@ -164,12 +164,14 @@ void init_triton_ir(py::module &&m) {\n   using ret = py::return_value_policy;\n   using namespace pybind11::literals;\n \n-  py::enum_<mlir::triton::PaddingOption>(m, \"PADDING_OPTION\")\n+  py::enum_<mlir::triton::PaddingOption>(m, \"PADDING_OPTION\",\n+                                         py::module_local())\n       .value(\"PAD_ZERO\", mlir::triton::PaddingOption::PAD_ZERO)\n       .value(\"PAD_NAN\", mlir::triton::PaddingOption::PAD_NAN)\n       .export_values();\n \n-  py::enum_<mlir::triton::CacheModifier>(m, \"CACHE_MODIFIER\")\n+  py::enum_<mlir::triton::CacheModifier>(m, \"CACHE_MODIFIER\",\n+                                         py::module_local())\n       .value(\"NONE\", mlir::triton::CacheModifier::NONE)\n       .value(\"CA\", mlir::triton::CacheModifier::CA)\n       .value(\"CG\", mlir::triton::CacheModifier::CG)\n@@ -178,20 +180,21 @@ void init_triton_ir(py::module &&m) {\n       .value(\"WT\", mlir::triton::CacheModifier::WT)\n       .export_values();\n \n-  py::enum_<mlir::triton::MemSemantic>(m, \"MEM_SEMANTIC\")\n+  py::enum_<mlir::triton::MemSemantic>(m, \"MEM_SEMANTIC\", py::module_local())\n       .value(\"ACQUIRE_RELEASE\", mlir::triton::MemSemantic::ACQUIRE_RELEASE)\n       .value(\"ACQUIRE\", mlir::triton::MemSemantic::ACQUIRE)\n       .value(\"RELEASE\", mlir::triton::MemSemantic::RELEASE)\n       .value(\"RELAXED\", mlir::triton::MemSemantic::RELAXED)\n       .export_values();\n \n-  py::enum_<mlir::triton::EvictionPolicy>(m, \"EVICTION_POLICY\")\n+  py::enum_<mlir::triton::EvictionPolicy>(m, \"EVICTION_POLICY\",\n+                                          py::module_local())\n       .value(\"NORMAL\", mlir::triton::EvictionPolicy::NORMAL)\n       .value(\"EVICT_FIRST\", mlir::triton::EvictionPolicy::EVICT_FIRST)\n       .value(\"EVICT_LAST\", mlir::triton::EvictionPolicy::EVICT_LAST)\n       .export_values();\n \n-  py::enum_<mlir::triton::RMWOp>(m, \"ATOMIC_OP\")\n+  py::enum_<mlir::triton::RMWOp>(m, \"ATOMIC_OP\", py::module_local())\n       .value(\"ADD\", mlir::triton::RMWOp::ADD)\n       .value(\"FADD\", mlir::triton::RMWOp::FADD)\n       .value(\"AND\", mlir::triton::RMWOp::AND)\n@@ -203,7 +206,7 @@ void init_triton_ir(py::module &&m) {\n       .value(\"UMIN\", mlir::triton::RMWOp::UMIN)\n       .value(\"UMAX\", mlir::triton::RMWOp::UMAX);\n \n-  py::class_<mlir::MLIRContext>(m, \"context\")\n+  py::class_<mlir::MLIRContext>(m, \"context\", py::module_local())\n       .def(py::init<>())\n       .def(\"load_triton\", [](mlir::MLIRContext &self) {\n         self.getOrLoadDialect<mlir::triton::TritonDialect>();\n@@ -259,7 +262,7 @@ void init_triton_ir(py::module &&m) {\n   // // py::class_<ir::undef_value, ir::constant>(m, \"undef\")\n   // //     .def(\"get\", &ir::undef_value::get, ret::reference);\n \n-  py::class_<mlir::Type>(m, \"type\")\n+  py::class_<mlir::Type>(m, \"type\", py::module_local())\n       .def(\"is_integer\", &mlir::Type::isInteger)\n       .def(\"is_fp16\", &mlir::Type::isF16)\n       .def(\"__str__\", [](mlir::Type &self) {\n@@ -269,21 +272,21 @@ void init_triton_ir(py::module &&m) {\n         return os.str();\n       });\n \n-  py::class_<mlir::FunctionType>(m, \"function_type\")\n+  py::class_<mlir::FunctionType>(m, \"function_type\", py::module_local())\n       .def(\"param_types\", [](mlir::FunctionType &self) {\n         return std::vector<mlir::Type>(self.getInputs().begin(),\n                                        self.getInputs().end());\n       });\n \n-  py::class_<mlir::Location>(m, \"location\")\n+  py::class_<mlir::Location>(m, \"location\", py::module_local())\n       .def(\"__str__\", [](mlir::Location &self) {\n         std::string str;\n         llvm::raw_string_ostream os(str);\n         self.print(os);\n         return os.str();\n       });\n \n-  py::class_<mlir::Value>(m, \"value\")\n+  py::class_<mlir::Value>(m, \"value\", py::module_local())\n       .def(\"set_attr\",\n            [](mlir::Value &self, std::string &name,\n               mlir::Attribute &attr) -> void {\n@@ -307,14 +310,15 @@ void init_triton_ir(py::module &&m) {\n            })\n       .def(\"get_type\", &mlir::Value::getType);\n \n-  py::class_<mlir::BlockArgument, mlir::Value>(m, \"block_argument\");\n+  py::class_<mlir::BlockArgument, mlir::Value>(m, \"block_argument\",\n+                                               py::module_local());\n \n-  py::class_<mlir::Region>(m, \"region\")\n+  py::class_<mlir::Region>(m, \"region\", py::module_local())\n       .def(\"get_parent_region\", &mlir::Region::getParentRegion, ret::reference)\n       .def(\"size\", [](mlir::Region &self) { return self.getBlocks().size(); })\n       .def(\"empty\", &mlir::Region::empty);\n \n-  py::class_<mlir::Block>(m, \"block\")\n+  py::class_<mlir::Block>(m, \"block\", py::module_local())\n       .def(\"arg\",\n            [](mlir::Block &self, int index) -> mlir::BlockArgument {\n              return self.getArgument(index);\n@@ -383,12 +387,14 @@ void init_triton_ir(py::module &&m) {\n   //     .value(\"retune\", eattr::retune)\n   //     .value(\"not_implemented\", eattr::not_implemented);\n \n-  py::class_<mlir::Attribute>(m, \"attribute\");\n-  py::class_<mlir::IntegerAttr, mlir::Attribute>(m, \"integer_attr\");\n-  py::class_<mlir::BoolAttr, mlir::Attribute>(m, \"bool_attr\");\n+  py::class_<mlir::Attribute>(m, \"attribute\", py::module_local());\n+  py::class_<mlir::IntegerAttr, mlir::Attribute>(m, \"integer_attr\",\n+                                                 py::module_local());\n+  py::class_<mlir::BoolAttr, mlir::Attribute>(m, \"bool_attr\",\n+                                              py::module_local());\n \n   // Ops\n-  py::class_<mlir::OpState>(m, \"OpState\")\n+  py::class_<mlir::OpState>(m, \"OpState\", py::module_local())\n       .def(\"set_attr\",\n            [](mlir::OpState &self, std::string &name,\n               mlir::Attribute &attr) -> void { self->setAttr(name, attr); })\n@@ -427,23 +433,27 @@ void init_triton_ir(py::module &&m) {\n         return mlir::succeeded(mlir::verify(self.getOperation()));\n       });\n   // scf Ops\n-  py::class_<mlir::scf::ForOp, mlir::OpState>(m, \"ForOp\")\n+  py::class_<mlir::scf::ForOp, mlir::OpState>(m, \"ForOp\", py::module_local())\n       .def(\"get_induction_var\", &mlir::scf::ForOp::getInductionVar);\n \n-  py::class_<mlir::scf::IfOp, mlir::OpState>(m, \"IfOp\")\n+  py::class_<mlir::scf::IfOp, mlir::OpState>(m, \"IfOp\", py::module_local())\n       .def(\"get_then_block\", &mlir::scf::IfOp::thenBlock, ret::reference)\n       .def(\"get_else_block\", &mlir::scf::IfOp::elseBlock, ret::reference)\n       .def(\"get_then_yield\", &mlir::scf::IfOp::thenYield)\n       .def(\"get_else_yield\", &mlir::scf::IfOp::elseYield);\n-  py::class_<mlir::scf::YieldOp, mlir::OpState>(m, \"YieldOp\");\n-  py::class_<mlir::scf::WhileOp, mlir::OpState>(m, \"WhileOp\")\n+  py::class_<mlir::scf::YieldOp, mlir::OpState>(m, \"YieldOp\",\n+                                                py::module_local());\n+  py::class_<mlir::scf::WhileOp, mlir::OpState>(m, \"WhileOp\",\n+                                                py::module_local())\n       .def(\"get_before\", &mlir::scf::WhileOp::getBefore, ret::reference)\n       .def(\"get_after\", &mlir::scf::WhileOp::getAfter, ret::reference);\n-  py::class_<mlir::scf::ConditionOp, mlir::OpState>(m, \"ConditionOp\");\n+  py::class_<mlir::scf::ConditionOp, mlir::OpState>(m, \"ConditionOp\",\n+                                                    py::module_local());\n \n   // dynamic_attr is used to transfer ownership of the MLIR context to the\n   // module\n-  py::class_<mlir::ModuleOp, mlir::OpState>(m, \"module\", py::dynamic_attr())\n+  py::class_<mlir::ModuleOp, mlir::OpState>(m, \"module\", py::module_local(),\n+                                            py::dynamic_attr())\n       .def(\"dump\", &mlir::ModuleOp::dump)\n       .def(\"str\",\n            [](mlir::ModuleOp &self) -> std::string {\n@@ -523,7 +533,8 @@ void init_triton_ir(py::module &&m) {\n       },\n       ret::take_ownership);\n \n-  py::class_<mlir::triton::FuncOp, mlir::OpState>(m, \"function\")\n+  py::class_<mlir::triton::FuncOp, mlir::OpState>(m, \"function\",\n+                                                  py::module_local())\n       // .def_property_readonly(\"attrs\", &ir::function::attrs)\n       // .def(\"add_attr\", &ir::function::add_attr);\n       .def(\"args\",\n@@ -571,9 +582,11 @@ void init_triton_ir(py::module &&m) {\n       .def_property_readonly(\"type\", &mlir::triton::FuncOp::getFunctionType)\n       .def(\"reset_type\", &mlir::triton::FuncOp::setType);\n \n-  py::class_<mlir::OpBuilder::InsertPoint>(m, \"InsertPoint\");\n+  py::class_<mlir::OpBuilder::InsertPoint>(m, \"InsertPoint\",\n+                                           py::module_local());\n \n-  py::class_<TritonOpBuilder>(m, \"builder\", py::dynamic_attr())\n+  py::class_<TritonOpBuilder>(m, \"builder\", py::module_local(),\n+                              py::dynamic_attr())\n       .def(py::init<mlir::MLIRContext *>())\n       // getters\n       .def(\"create_module\",\n@@ -1507,7 +1520,7 @@ void init_triton_ir(py::module &&m) {\n                                                          offsets);\n            });\n \n-  py::class_<mlir::PassManager>(m, \"pass_manager\")\n+  py::class_<mlir::PassManager>(m, \"pass_manager\", py::module_local())\n       .def(py::init<mlir::MLIRContext *>())\n       .def(\"enable_debug\",\n            [](mlir::PassManager &self) {"}]