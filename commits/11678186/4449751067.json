[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 127, "deletions": 138, "changes": 265, "file_content_changes": "@@ -1346,147 +1346,136 @@ def format_of(ty):\n     \"\"\"\n     else:\n         src = f\"\"\"\n-    #include \\\"cuda.h\\\"\n-    #include <stdbool.h>\n-    #include <Python.h>\n-    static inline void gpuAssert(CUresult code, const char *file, int line)\n-    {{\n-       if (code != CUDA_SUCCESS)\n-       {{\n-          const char* prefix = \"Triton Error [CUDA]: \";\n-          const char* str;\n-          cuGetErrorString(code, &str);\n-          char err[1024] = {{0}};\n-          strcat(err, prefix);\n-          strcat(err, str);\n-          PyErr_SetString(PyExc_RuntimeError, err);\n-       }}\n-    }}\n-\n-    #define CUDA_CHECK(ans) {{ gpuAssert((ans), __FILE__, __LINE__); }}\n-\n-    void _launch(int gridX, int gridY, int gridZ, int num_warps, int shared_memory, CUstream stream, CUfunction function, {arg_decls}) {{\n-      void *params[] = {{ {', '.join(f\"&arg{i}\" for i in signature.keys() if i not in constants)} }};\n-      if(gridX*gridY*gridZ > 0){{\n-        CUDA_CHECK(cuLaunchKernel(function, gridX, gridY, gridZ, 32*num_warps, 1, 1, shared_memory, stream, params, 0));\n-      }}\n-    }}\n-\n-    typedef struct _DevicePtrInfo {{\n-        CUdeviceptr dev_ptr;\n-        bool valid;\n-    }} DevicePtrInfo;\n-\n-    static inline DevicePtrInfo getPointer(PyObject *obj, int idx) {{\n-      DevicePtrInfo ptr_info;\n-      ptr_info.dev_ptr = 0;\n-      ptr_info.valid = true;\n-      if (PyLong_Check(obj)) {{\n-        ptr_info.dev_ptr = PyLong_AsUnsignedLongLong(obj);\n-        return ptr_info;\n-      }}\n-      if (obj == Py_None) {{\n-        // valid nullptr\n-        return ptr_info;\n-      }}\n-      PyObject *ptr = PyObject_GetAttrString(obj, \"data_ptr\");\n-      if(ptr){{\n-        PyObject *empty_tuple = PyTuple_New(0);\n-        PyObject *ret = PyObject_Call(ptr, empty_tuple, NULL);\n-        Py_DECREF(empty_tuple);\n-        Py_DECREF(ptr);\n-        if (!PyLong_Check(ret)) {{\n-          PyErr_SetString(PyExc_TypeError, \"data_ptr method of Pointer object must return 64-bit int\");\n-          ptr_info.valid = false;\n-          return ptr_info;\n-        }}\n-        ptr_info.dev_ptr = PyLong_AsUnsignedLongLong(ret);\n-        unsigned attr;\n-        CUresult status =\n-            cuPointerGetAttribute(&attr, CU_POINTER_ATTRIBUTE_MEMORY_TYPE, ptr_info.dev_ptr);\n-        if (ptr_info.dev_ptr &&\n-           (!(attr == CU_MEMORYTYPE_DEVICE || attr == CU_MEMORYTYPE_UNIFIED) ||\n-            !(status == CUDA_SUCCESS))) {{\n-            PyErr_Format(PyExc_ValueError,\n-                         \"Pointer argument (at %d) cannot be accessed from Triton (cpu tensor?)\", idx);\n-            ptr_info.valid = false;\n-        }}\n-        return ptr_info;\n-      }}\n-      PyErr_SetString(PyExc_TypeError, \"Pointer argument must be either uint64 or have data_ptr method\");\n+#include \\\"cuda.h\\\"\n+#include <stdbool.h>\n+#include <Python.h>\n+\n+static inline void gpuAssert(CUresult code, const char *file, int line)\n+{{\n+   if (code != CUDA_SUCCESS)\n+   {{\n+      const char* prefix = \"Triton Error [CUDA]: \";\n+      const char* str;\n+      cuGetErrorString(code, &str);\n+      char err[1024] = {{0}};\n+      strcat(err, prefix);\n+      strcat(err, str);\n+      PyErr_SetString(PyExc_RuntimeError, err);\n+   }}\n+}}\n+\n+#define CUDA_CHECK(ans) {{ gpuAssert((ans), __FILE__, __LINE__); }}\n+\n+static void _launch(int gridX, int gridY, int gridZ, int num_warps, int shared_memory, CUstream stream, CUfunction function, {arg_decls}) {{\n+  void *params[] = {{ {', '.join(f\"&arg{i}\" for i in signature.keys() if i not in constants)} }};\n+  if(gridX*gridY*gridZ > 0){{\n+    CUDA_CHECK(cuLaunchKernel(function, gridX, gridY, gridZ, 32*num_warps, 1, 1, shared_memory, stream, params, 0));\n+  }}\n+}}\n+\n+typedef struct _DevicePtrInfo {{\n+    CUdeviceptr dev_ptr;\n+    bool valid;\n+}} DevicePtrInfo;\n+\n+static inline DevicePtrInfo getPointer(PyObject *obj, int idx) {{\n+  DevicePtrInfo ptr_info;\n+  ptr_info.dev_ptr = 0;\n+  ptr_info.valid = true;\n+  if (PyLong_Check(obj)) {{\n+    ptr_info.dev_ptr = PyLong_AsUnsignedLongLong(obj);\n+    return ptr_info;\n+  }}\n+  if (obj == Py_None) {{\n+    // valid nullptr\n+    return ptr_info;\n+  }}\n+  PyObject *ptr = PyObject_GetAttrString(obj, \"data_ptr\");\n+  if(ptr){{\n+    PyObject *empty_tuple = PyTuple_New(0);\n+    PyObject *ret = PyObject_Call(ptr, empty_tuple, NULL);\n+    Py_DECREF(empty_tuple);\n+    Py_DECREF(ptr);\n+    if (!PyLong_Check(ret)) {{\n+      PyErr_SetString(PyExc_TypeError, \"data_ptr method of Pointer object must return 64-bit int\");\n+      ptr_info.valid = false;\n       return ptr_info;\n     }}\n-\n-    static PyObject* launch(PyObject* self, PyObject* args) {{\n-      int gridX, gridY, gridZ;\n-      uint64_t _stream;\n-      uint64_t _function;\n-      int num_warps;\n-      int shared_memory;\n-      PyObject *launch_enter_hook = NULL;\n-      PyObject *launch_exit_hook = NULL;\n-      PyObject *compiled_kernel = NULL;\n-      PyObject *hook_ret = NULL;\n-      {' '.join([f\"{_extracted_type(ty)} _arg{i}; \" for i, ty in signature.items()])}\n-      if(!PyArg_ParseTuple(args, \\\"{format}\\\", &gridX, &gridY, &gridZ, &num_warps, &shared_memory, &_stream, &_function, &launch_enter_hook, &launch_exit_hook, &compiled_kernel, {', '.join(f\"&_arg{i}\" for i, ty in signature.items())})) {{\n-        return NULL;\n-      }}\n-\n-      if (launch_enter_hook != Py_None) {{\n-        PyObject *new_args = PyTuple_Pack(1, compiled_kernel);\n-        hook_ret = PyObject_CallObject(launch_enter_hook, new_args);\n-        Py_DECREF(new_args);\n-      }}\n-\n-\n-      // raise exception asap\n-      {\"; \".join([f\"DevicePtrInfo ptr_info{i} = getPointer(_arg{i}, {i}); if (!ptr_info{i}.valid) return NULL;\" if ty[0] == \"*\" else \"\" for i, ty in signature.items()])};\n-      _launch(gridX, gridY, gridZ, num_warps, shared_memory, (CUstream)_stream, (CUfunction)_function, {', '.join(f\"ptr_info{i}.dev_ptr\" if ty[0]==\"*\" else f\"_arg{i}\"for i, ty in signature.items())});\n-\n-      if (launch_exit_hook != Py_None) {{\n-        PyObject *new_args = NULL;\n-        if (hook_ret) {{\n-            new_args = PyTuple_Pack(2, compiled_kernel, hook_ret);\n-        }} else {{\n-            new_args = PyTuple_Pack(1, compiled_kernel);\n-        }}\n-        hook_ret = PyObject_CallObject(launch_exit_hook, new_args);\n-        Py_DECREF(new_args);\n-      }}\n-\n-      if (hook_ret) {{\n-          Py_DECREF(hook_ret);\n-      }}\n-      if(PyErr_Occurred()) {{\n-          return NULL;\n-      }}\n-      // return None\n-      Py_INCREF(Py_None);\n-      return Py_None;\n-    }}\n-\n-    static PyMethodDef ModuleMethods[] = {{\n-      {{\"launch\", launch, METH_VARARGS, \"Entry point for all kernels with this signature\"}},\n-      {{NULL, NULL, 0, NULL}} // sentinel\n-    }};\n-\n-    static struct PyModuleDef ModuleDef = {{\n-      PyModuleDef_HEAD_INIT,\n-      \\\"launcher\\\",\n-      NULL, //documentation\n-      -1, //size\n-      ModuleMethods\n-    }};\n-\n-    PyMODINIT_FUNC PyInit_launcher(void) {{\n-      PyObject *m = PyModule_Create(&ModuleDef);\n-      if(m == NULL) {{\n-          return NULL;\n-      }}\n-      PyModule_AddFunctions(m, ModuleMethods);\n-      return m;\n+    ptr_info.dev_ptr = PyLong_AsUnsignedLongLong(ret);\n+    if(!ptr_info.dev_ptr)\n+      return ptr_info;\n+    uint64_t dev_ptr;\n+    int status = cuPointerGetAttribute(&dev_ptr, CU_POINTER_ATTRIBUTE_DEVICE_POINTER, ptr_info.dev_ptr);\n+    if (status == CUDA_ERROR_INVALID_VALUE) {{\n+        PyErr_Format(PyExc_ValueError,\n+                     \"Pointer argument (at %d) cannot be accessed from Triton (cpu tensor?)\", idx);\n+        ptr_info.valid = false;\n     }}\n-      \"\"\"\n+    ptr_info.dev_ptr = dev_ptr;\n+    Py_DECREF(ret);  // Thanks ChatGPT!\n+    return ptr_info;\n+  }}\n+  PyErr_SetString(PyExc_TypeError, \"Pointer argument must be either uint64 or have data_ptr method\");\n+  return ptr_info;\n+}}\n+\n+static PyObject* launch(PyObject* self, PyObject* args) {{\n+  int gridX, gridY, gridZ;\n+  uint64_t _stream;\n+  uint64_t _function;\n+  int num_warps;\n+  int shared_memory;\n+  PyObject *launch_enter_hook = NULL;\n+  PyObject *launch_exit_hook = NULL;\n+  PyObject *compiled_kernel = NULL;\n+  {' '.join([f\"{_extracted_type(ty)} _arg{i}; \" for i, ty in signature.items()])}\n+  if(!PyArg_ParseTuple(args, \\\"{format}\\\", &gridX, &gridY, &gridZ, &num_warps, &shared_memory, &_stream, &_function, &launch_enter_hook, &launch_exit_hook, &compiled_kernel, {', '.join(f\"&_arg{i}\" for i, ty in signature.items())})) {{\n+    return NULL;\n+  }}\n+\n+  if (launch_enter_hook != Py_None) {{\n+    PyObject_CallObject(launch_enter_hook, args);\n+  }}\n+\n+\n+  // raise exception asap\n+  {\"; \".join([f\"DevicePtrInfo ptr_info{i} = getPointer(_arg{i}, {i}); if (!ptr_info{i}.valid) return NULL;\" if ty[0] == \"*\" else \"\" for i, ty in signature.items()])};\n+  _launch(gridX, gridY, gridZ, num_warps, shared_memory, (CUstream)_stream, (CUfunction)_function, {', '.join(f\"ptr_info{i}.dev_ptr\" if ty[0]==\"*\" else f\"_arg{i}\"for i, ty in signature.items())});\n+\n+  if (launch_exit_hook != Py_None) {{\n+    PyObject_CallObject(launch_exit_hook, args);\n+  }}\n+\n+  if(PyErr_Occurred()) {{\n+    return NULL;\n+  }}\n+  // return None\n+  Py_INCREF(Py_None);\n+  return Py_None;\n+}}\n+\n+static PyMethodDef ModuleMethods[] = {{\n+  {{\"launch\", launch, METH_VARARGS, \"Entry point for all kernels with this signature\"}},\n+  {{NULL, NULL, 0, NULL}} // sentinel\n+}};\n+\n+static struct PyModuleDef ModuleDef = {{\n+  PyModuleDef_HEAD_INIT,\n+  \\\"__triton_launcher\\\",\n+  NULL, //documentation\n+  -1, //size\n+  ModuleMethods\n+}};\n+\n+PyMODINIT_FUNC PyInit___triton_launcher(void) {{\n+  PyObject *m = PyModule_Create(&ModuleDef);\n+  if(m == NULL) {{\n+    return NULL;\n+  }}\n+  PyModule_AddFunctions(m, ModuleMethods);\n+  return m;\n+}}\n+\"\"\"\n     return src\n \n "}]