[{"filename": "lib/Conversion/TritonGPUToLLVM/DotHelpers.h", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "file_content_changes": "@@ -145,9 +145,9 @@ struct DotOpMmaV1ConversionHelper {\n                  ConversionPatternRewriter &rewriter, Location loc) const;\n \n   // Extract values belong to $a or $b from a LLVMStruct, the shape is n0xn1.\n-  DotOpMmaV1ConversionHelper::ValueTable extractLoadedOperand(Value llStruct,\n-                                                              int NK,\n-                                                              ConversionPatternRewriter &rewriter) const;\n+  DotOpMmaV1ConversionHelper::ValueTable\n+  extractLoadedOperand(Value llStruct, int NK,\n+                       ConversionPatternRewriter &rewriter) const;\n \n private:\n   static constexpr unsigned instrShape[] = {16, 16, 4};\n@@ -1464,9 +1464,11 @@ Value DotOpMmaV1ConversionHelper::loadB(\n   // TODO [Superjomn]: transB cannot be accessed here.\n   bool transB = false;\n \n-  SmallVector<int64_t> shape (tensorTy.getShape().begin(), tensorTy.getShape().end());\n-  SmallVector<unsigned> order (sharedLayout.getOrder().begin(), sharedLayout.getOrder().end());\n-  if(transB) {\n+  SmallVector<int64_t> shape(tensorTy.getShape().begin(),\n+                             tensorTy.getShape().end());\n+  SmallVector<unsigned> order(sharedLayout.getOrder().begin(),\n+                              sharedLayout.getOrder().end());\n+  if (transB) {\n     std::swap(order[0], order[1]);\n     std::swap(shape[0], shape[1]);\n   }\n@@ -1496,8 +1498,8 @@ Value DotOpMmaV1ConversionHelper::loadB(\n \n   auto [_0, _1, offsetBN, offsetBK] =\n       computeOffsets(thread, false, isBRow, fpw, spw, rep, rewriter, loc);\n-  if (transB) std::swap(offsetBK, offsetBN);\n-\n+  if (transB)\n+    std::swap(offsetBK, offsetBN);\n \n   Value offB0 = isBRow ? offsetBN : offsetBK;\n   Value offB1 = isBRow ? offsetBK : offsetBN;\n@@ -1630,16 +1632,16 @@ DotOpMmaV1ConversionHelper::computeOffsets(Value threadId, bool isARow,\n }\n \n DotOpMmaV1ConversionHelper::ValueTable\n-DotOpMmaV1ConversionHelper::extractLoadedOperand(Value llStruct,\n-                                                 int NK,\n-                                                 ConversionPatternRewriter &rewriter) const {\n+DotOpMmaV1ConversionHelper::extractLoadedOperand(\n+    Value llStruct, int NK, ConversionPatternRewriter &rewriter) const {\n   ValueTable rcds;\n   SmallVector<Value> elems =\n       getElementsFromStruct(llStruct.getLoc(), llStruct, rewriter);\n \n-    for (int k = 0, offset=0, i=0; k < NK && offset < elems.size(); k += 4, i++, offset+=2) {\n-      rcds[{i, k}] = std::make_pair(elems[offset], elems[offset + 1]);\n-    }\n+  for (int k = 0, offset = 0, i = 0; k < NK && offset < elems.size();\n+       k += 4, i++, offset += 2) {\n+    rcds[{i, k}] = std::make_pair(elems[offset], elems[offset + 1]);\n+  }\n \n   return rcds;\n }"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "file_content_changes": "@@ -3381,22 +3381,23 @@ DotOpConversion::convertMMA884(triton::DotOp op, DotOpAdaptor adaptor,\n   auto ATensorTy = A.getType().cast<RankedTensorType>();\n   auto BTensorTy = B.getType().cast<RankedTensorType>();\n   auto DTensorTy = D.getType().cast<RankedTensorType>();\n-  SmallVector<int> AShape (ATensorTy.getShape().begin(), ATensorTy.getShape().end());\n-  SmallVector<int> BShape  (BTensorTy.getShape().begin(), BTensorTy.getShape().end());\n+  SmallVector<int> AShape(ATensorTy.getShape().begin(),\n+                          ATensorTy.getShape().end());\n+  SmallVector<int> BShape(BTensorTy.getShape().begin(),\n+                          BTensorTy.getShape().end());\n   auto DShape = DTensorTy.getShape();\n   auto wpt = mmaLayout.getWarpsPerCTA();\n \n   bool transA = op.transA();\n   bool transB = op.transB();\n \n   // TODO[Superjomn]: order cannot accessed here.\n-  SmallVector<unsigned > AOrder({1, 0});\n-  SmallVector<unsigned > BOrder({1, 0});\n+  SmallVector<unsigned> AOrder({1, 0});\n+  SmallVector<unsigned> BOrder({1, 0});\n \n   if (transA) {\n     std::swap(AShape[0], AShape[1]);\n     std::swap(AOrder[0], AOrder[1]);\n-\n   }\n   if (transB) {\n     std::swap(BShape[0], BShape[1]);"}]