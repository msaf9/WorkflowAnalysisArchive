[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1396,7 +1396,7 @@ def kernel(X, Z, BLOCK: tl.constexpr):\n     # input\n     rs = RandomState(17)\n     # limit the range of integers so that the sum does not overflow\n-    x = numpy_random((shape,), dtype_str=dtype_str, rs=rs) * 20\n+    x = numpy_random((shape,), dtype_str=dtype_str, rs=rs)\n     numpy_op = {'sum': np.sum, 'max': np.max, 'min': np.min,\n                 'max-with-indices': np.max,\n                 'min-with-indices': np.min,"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "file_content_changes": "@@ -1255,15 +1255,21 @@ def abs(x, _builder=None):\n # Reductions\n # -----------------------\n \n-def _add_reduction_docstr(name: str) -> Callable[[T], T]:\n+def _add_reduction_docstr(name: str, return_indices_arg: str = None, tie_break_arg: str = None) -> Callable[[T], T]:\n \n     def _decorator(func: T) -> T:\n         docstr = \"\"\"\n     Returns the {name} of all elements in the :code:`input` tensor along the provided :code:`axis`\n \n     :param input: the input values\n-    :param axis: the dimension along which the reduction should be done\n-    \"\"\"\n+    :param axis: the dimension along which the reduction should be done\"\"\"\n+        if return_indices_arg is not None:\n+            docstr += f\"\"\"\n+    :param {return_indices_arg}: if true, return index corresponding to the {name} value\"\"\"\n+        if tie_break_arg is not None:\n+            docstr += f\"\"\"\n+    :param {tie_break_arg}: if true, return the left-most indices in case of ties for values that aren't NaN\"\"\"\n+\n         func.__doc__ = docstr.format(name=name)\n         return func\n \n@@ -1396,7 +1402,9 @@ def _argmax_combine_tie_break_fast(value1, index1, value2, index2):\n \n \n @jit\n-@_add_reduction_docstr(\"maximum\")\n+@_add_reduction_docstr(\"maximum\",\n+                       return_indices_arg=\"return_indices\",\n+                       tie_break_arg=\"return_indices_tie_break_left\")\n def max(input, axis=None, return_indices=False, return_indices_tie_break_left=True):\n     input = _promote_reduction_input(input)\n     if return_indices:\n@@ -1409,7 +1417,7 @@ def max(input, axis=None, return_indices=False, return_indices_tie_break_left=Tr\n \n \n @jit\n-@_add_reduction_docstr(\"maximum index\")\n+@_add_reduction_docstr(\"maximum index\", tie_break_arg=\"tie_break_left\")\n def argmax(input, axis, tie_break_left=True):\n     (_, ret) = max(input, axis, return_indices=True, return_indices_tie_break_left=tie_break_left)\n     return ret\n@@ -1440,7 +1448,9 @@ def _argmin_combine_tie_break_fast(value1, index1, value2, index2):\n \n \n @jit\n-@_add_reduction_docstr(\"minimum\")\n+@_add_reduction_docstr(\"minimum\",\n+                       return_indices_arg=\"return_indices\",\n+                       tie_break_arg=\"return_indices_tie_break_left\")\n def min(input, axis=None, return_indices=False, return_indices_tie_break_left=True):\n     input = _promote_reduction_input(input)\n     if return_indices:\n@@ -1453,7 +1463,8 @@ def min(input, axis=None, return_indices=False, return_indices_tie_break_left=Tr\n \n \n @jit\n-@_add_reduction_docstr(\"minimum index\")\n+@_add_reduction_docstr(\"minimum index\",\n+                       tie_break_arg=\"tie_break_left\")\n def argmin(input, axis, tie_break_left=True):\n     _, ret = min(input, axis, return_indices=True, return_indices_tie_break_left=tie_break_left)\n     return ret"}]