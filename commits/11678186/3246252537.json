[{"filename": "lib/Dialect/Triton/IR/Ops.cpp", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "file_content_changes": "@@ -50,21 +50,34 @@ ParseResult parseLoadOp(OpAsmParser &parser, OperationState &result) {\n \n   SmallVector<Type> operandTypes;\n   operandTypes.push_back(getPointerTypeFromTensor(resultTypes[0])); // ptr\n-  if (allOperands.size() >= 2)\n+  int hasMask = 0, hasOther = 0;\n+  if (allOperands.size() >= 2) {\n     operandTypes.push_back(getI1SameShape(resultTypes[0])); // mask\n-  if (allOperands.size() >= 3)\n+    hasMask = 1;\n+  }\n+  if (allOperands.size() >= 3) {\n     operandTypes.push_back(resultTypes[0]); // other\n+    hasOther = 1;\n+  }\n \n   if (parser.resolveOperands(allOperands, operandTypes, allOperandLoc,\n                              result.operands))\n     return failure();\n+  // Deduce operand_segment_sizes from the number of the operands.\n+  auto operand_segment_sizesAttrName =\n+      LoadOp::operand_segment_sizesAttrName(result.name);\n+  result.addAttribute(\n+      operand_segment_sizesAttrName,\n+      parser.getBuilder().getI32VectorAttr({1, hasMask, hasOther}));\n   return success();\n }\n \n void printLoadOp(OpAsmPrinter &printer, LoadOp loadOp) {\n   printer << \" \";\n   printer << loadOp.getOperation()->getOperands();\n-  printer.printOptionalAttrDict(loadOp->getAttrs(), /*elidedAttrs=*/{});\n+  // \"operand_segment_sizes\" can be deduced, so we don't print it.\n+  printer.printOptionalAttrDict(loadOp->getAttrs(),\n+                                {loadOp.operand_segment_sizesAttrName()});\n   printer << \" : \";\n   printer.printStrippedAttrOrType(loadOp.result().getType());\n }"}]