[{"filename": ".gitmodules", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "file_content_changes": "@@ -1,3 +0,0 @@\n-[submodule \"deps/dlfcn-win32\"]\n-\tpath = deps/dlfcn-win32\n-\turl = https://github.com/dlfcn-win32/dlfcn-win32.git"}, {"filename": "CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "file_content_changes": "@@ -46,12 +46,6 @@ include_directories(${CMAKE_CURRENT_SOURCE_DIR}/include)\n # Third-party\n include_directories(${PYBIND11_INCLUDE_DIR})\n \n-if(WIN32)\n-  SET(BUILD_SHARED_LIBS OFF)\n-  find_package(dlfcn-win32 REQUIRED)\n-  set(CMAKE_DL_LIBS dlfcn-win32::dl)\n-endif()\n-\n set(CMAKE_CXX_FLAGS \"${CMAKE_C_FLAGS} -D__STDC_FORMAT_MACROS  -fPIC -std=gnu++17 -fvisibility=hidden -fvisibility-inlines-hidden\")\n \n if(APPLE)"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "file_content_changes": "@@ -25,10 +25,17 @@\n #include \"llvm/IRReader/IRReader.h\"\n #include \"llvm/Linker/Linker.h\"\n #include \"llvm/Support/SourceMgr.h\"\n+#ifdef _WIN32\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+#else\n #include <dlfcn.h>\n+#endif\n #include <filesystem>\n #include <iterator>\n \n+namespace fs = std::filesystem;\n+\n namespace mlir {\n namespace triton {\n \n@@ -113,6 +120,32 @@ extractNVVMMetadata(mlir::ModuleOp module,\n   }\n }\n \n+static std::filesystem::path getThisLibraryPath() {\n+#ifdef _WIN32\n+  /* Get module of the specified address */\n+  HMODULE hModule;\n+  GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |\n+                         GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n+                     reinterpret_cast<LPCSTR>(&getThisLibraryPath), &hModule);\n+  if (NULL == hModule) {\n+    return std::filesystem::path();\n+  }\n+\n+  char fileName[1024]; // this is way beyond Windows MAX_PATH limit.\n+  DWORD dwSize = GetModuleFileNameA(hModule, fileName, sizeof(fileName));\n+  if (0 == dwSize || sizeof(fileName) == dwSize) {\n+    return std::filesystem::path();\n+  }\n+  return std::filesystem::path(fileName);\n+#else\n+  Dl_info fileinfo;\n+  if (dladdr(reinterpret_cast<void *>(&getThisLibraryPath), &fileinfo) == 0) {\n+    return std::filesystem::path();\n+  }\n+  return std::filesystem::path(fileinfo.dli_fname);\n+#endif\n+}\n+\n static std::map<std::string, std::string> getExternLibs(mlir::ModuleOp module) {\n   std::map<std::string, std::string> externLibs;\n   SmallVector<LLVM::LLVMFuncOp> funcs;\n@@ -152,17 +185,10 @@ static std::map<std::string, std::string> getExternLibs(mlir::ModuleOp module) {\n       externLibs.try_emplace(libdevice, env_path);\n       return externLibs;\n     }\n-    namespace fs = std::filesystem;\n     // Search for libdevice relative to its library path if used from Python\n     // Then native code is in `triton/_C/libtriton.so` and libdevice in\n     // `triton/third_party/cuda/lib/libdevice.10.bc`\n-    static const auto this_library_path = [] {\n-      Dl_info fileinfo;\n-      if (dladdr(reinterpret_cast<void *>(&getExternLibs), &fileinfo) == 0) {\n-        return std::filesystem::path();\n-      }\n-      return std::filesystem::path(fileinfo.dli_fname);\n-    }();\n+    static const auto this_library_path = getThisLibraryPath();\n     static const auto runtime_path =\n         this_library_path.parent_path().parent_path() / \"third_party\" / \"cuda\" /\n         \"lib\" / \"libdevice.10.bc\";"}]