[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "file_content_changes": "@@ -508,22 +508,17 @@ struct ConvertLayoutOpConversion\n     auto srcSharedLayout = srcTy.getEncoding().cast<SharedEncodingAttr>();\n     auto dstLayout = dstTy.getEncoding();\n     auto inOrd = getOrder(srcSharedLayout);\n-    auto outOrd = getOrder(dstLayout);\n \n     auto smemObj =\n         getSharedMemoryObjectFromStruct(loc, adaptor.getSrc(), rewriter);\n-    Value smemBase = smemObj.getBaseBeforeSwizzle(inOrd[0], loc, rewriter);\n     auto elemTy = getTypeConverter()->convertType(dstTy.getElementType());\n-    auto elemPtrTy = ptr_ty(getTypeConverter()->convertType(elemTy), 3);\n-    smemBase = bitcast(smemBase, elemPtrTy);\n \n     auto srcStrides =\n         getStridesFromShapeAndOrder(srcShape, inOrd, loc, rewriter);\n     auto dstIndices = emitIndices(loc, rewriter, dstLayout, dstTy);\n-    unsigned outElems = getTotalElemsPerThread(dstTy);\n-    SmallVector<Value> outVals(outElems);\n-    loadSharedToDistributed(dst, adaptor.getSrc(), srcStrides, dstIndices, src,\n-                            smemBase, elemTy, outVals, loc, rewriter);\n+\n+    SmallVector<Value> outVals = loadSharedToDistributed(\n+        dst, dstIndices, src, smemObj, elemTy, loc, rewriter);\n \n     Value result =\n         getTypeConverter()->packLLElements(loc, outVals, rewriter, dstTy);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "file_content_changes": "@@ -359,12 +359,11 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     return ret;\n   }\n \n-  void loadSharedToDistributed(Value dst, Value lldst,\n-                               ArrayRef<Value> srcStrides,\n-                               ArrayRef<SmallVector<Value>> dstIndices,\n-                               Value src, Value smemBase, Type elemTy,\n-                               SmallVector<Value> &vals, Location loc,\n-                               ConversionPatternRewriter &rewriter) const {\n+  SmallVector<Value>\n+  loadSharedToDistributed(Value dst, ArrayRef<SmallVector<Value>> dstIndices,\n+                          Value src, SharedMemoryObject smemObj, Type elemTy,\n+                          Location loc,\n+                          ConversionPatternRewriter &rewriter) const {\n     auto dstTy = dst.getType().cast<RankedTensorType>();\n     auto dstShape = dstTy.getShape();\n     assert(dstShape.size() == 2 &&\n@@ -387,30 +386,26 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n             : 1;\n     unsigned inVec = srcSharedLayout.getVec();\n     unsigned minVec = std::min(outVec, inVec);\n-    unsigned numElems = triton::gpu::getTotalElemsPerThread(dstTy);\n-    assert(numElems == dstIndices.size());\n-\n+    unsigned outElems = triton::gpu::getTotalElemsPerThread(dstTy);\n+    assert(outElems == dstIndices.size());\n+\n+    DenseMap<unsigned, Value> sharedPtrs = getSwizzledSharedPtrs(\n+        loc, outVec, dstTy, srcSharedLayout, srcElemTy, smemObj, rewriter,\n+        smemObj.offsets, smemObj.strides);\n+    assert(outElems % minVec == 0 && \"Unexpected number of elements\");\n+    unsigned numVecs = outElems / minVec;\n     auto wordTy = vec_ty(elemTy, minVec);\n-\n-    SmallVector<Value> strides = {srcStrides[0], srcStrides[1]};\n-    SmallVector<Value> offsetVals = {i32_val(0), i32_val(0)};\n-    SharedMemoryObject smemObj(smemBase, strides, offsetVals);\n-\n-    DenseMap<unsigned, Value> sharedPtrs =\n-        getSwizzledSharedPtrs(loc, outVec, dstTy, srcSharedLayout, srcElemTy,\n-                              smemObj, rewriter, offsetVals, strides);\n-\n-    assert(numElems % minVec == 0 && \"Unexpected number of elements\");\n-    unsigned numVecs = numElems / minVec;\n+    SmallVector<Value> outVals(outElems);\n     for (unsigned i = 0; i < numVecs; ++i) {\n       Value smemAddr = sharedPtrs[i / minVec * minVec];\n       smemAddr = bitcast(smemAddr, ptr_ty(wordTy, 3));\n       Value valVec = load(smemAddr);\n       for (unsigned v = 0; v < minVec; ++v) {\n         Value currVal = extract_element(dstElemTy, valVec, i32_val(v));\n-        vals[i * minVec + v] = currVal;\n+        outVals[i * minVec + v] = currVal;\n       }\n     }\n+    return outVals;\n   }\n \n   void storeDistributedToShared(Value src, Value llSrc,"}]