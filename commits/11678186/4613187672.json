[{"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.cpp", "status": "modified", "additions": 1, "deletions": 152, "changes": 153, "file_content_changes": "@@ -1121,155 +1121,4 @@ void populateElementwiseOpToLLVMPatterns(\n   // ElementwiseOpConversion<math::ExpOp, math::ExpOp> defined below will call\n   // __nv_expf for higher-precision calculation\n   patterns.add<ExpOpConversionApprox>(typeConverter, benefit);\n-}\n-\n-struct FPExtOpConversion\n-    : ElementwiseOpConversionBase<LLVM::FPExtOp, FPExtOpConversion> {\n-  using Base = ElementwiseOpConversionBase<LLVM::FPExtOp, FPExtOpConversion>;\n-  using Base::Base;\n-  using Adaptor = typename Base::OpAdaptor;\n-\n-  static bool isLegalOp(LLVM::FPExtOp op) {\n-    auto retTy = op.getResult().getType();\n-    auto srcTy = op.getOperand().getType();\n-    if (retTy.isF32() && srcTy.isF16()) {\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  Value createDestOp(LLVM::FPExtOp op, OpAdaptor adaptor,\n-                     ConversionPatternRewriter &rewriter, Type elemTy,\n-                     ValueRange operands, Location loc) const {\n-    return FpToFpOpConversion::convertFp16ToFp32(loc, rewriter, operands[0]);\n-  }\n-};\n-\n-struct FPTruncOpConversion\n-    : ElementwiseOpConversionBase<LLVM::FPTruncOp, FPTruncOpConversion> {\n-  using Base =\n-      ElementwiseOpConversionBase<LLVM::FPTruncOp, FPTruncOpConversion>;\n-  using Base::Base;\n-  using Adaptor = typename Base::OpAdaptor;\n-\n-  static bool isLegalOp(LLVM::FPTruncOp op) {\n-    auto retTy = op.getResult().getType();\n-    auto srcTy = op.getOperand().getType();\n-    if (retTy.isF16() && srcTy.isF32()) {\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  Value createDestOp(LLVM::FPTruncOp op, OpAdaptor adaptor,\n-                     ConversionPatternRewriter &rewriter, Type elemTy,\n-                     ValueRange operands, Location loc) const {\n-    return FpToFpOpConversion::convertFp32ToFp16(loc, rewriter, operands[0]);\n-  }\n-};\n-\n-struct TruncOpConversion\n-    : ElementwiseOpConversionBase<LLVM::TruncOp, TruncOpConversion> {\n-  using Base = ElementwiseOpConversionBase<LLVM::TruncOp, TruncOpConversion>;\n-  using Base::Base;\n-  using Adaptor = typename Base::OpAdaptor;\n-\n-  static bool isLegalOp(LLVM::TruncOp op) {\n-    auto retTy = op.getResult().getType();\n-    auto srcTy = op.getOperand().getType();\n-    if (retTy.isInteger(16) && srcTy.isInteger(32)) {\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  Value createDestOp(LLVM::TruncOp op, OpAdaptor adaptor,\n-                     ConversionPatternRewriter &rewriter, Type elemTy,\n-                     ValueRange operands, Location loc) const {\n-    PTXBuilder builder;\n-    auto &cvt = *builder.create(\"cvt.u16.u32\");\n-    auto res = builder.newOperand(\"=h\");\n-    auto operand = builder.newOperand(operands[0], \"r\");\n-    cvt(res, operand);\n-    return builder.launch(rewriter, loc, i16_ty, false);\n-  }\n-};\n-\n-struct SExtOpConversion\n-    : ElementwiseOpConversionBase<LLVM::SExtOp, SExtOpConversion> {\n-  using Base = ElementwiseOpConversionBase<LLVM::SExtOp, SExtOpConversion>;\n-  using Base::Base;\n-  using Adaptor = typename Base::OpAdaptor;\n-\n-  static bool isLegalOp(LLVM::SExtOp op) {\n-    auto retTy = op.getResult().getType();\n-    auto srcTy = op.getOperand().getType();\n-    if (retTy.isInteger(32) && srcTy.isInteger(16)) {\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  Value createDestOp(LLVM::SExtOp op, OpAdaptor adaptor,\n-                     ConversionPatternRewriter &rewriter, Type elemTy,\n-                     ValueRange operands, Location loc) const {\n-    PTXBuilder builder;\n-    auto &cvt = *builder.create(\"cvt.s32.s16\");\n-    auto res = builder.newOperand(\"=r\");\n-    auto operand = builder.newOperand(operands[0], \"h\");\n-    cvt(res, operand);\n-    return builder.launch(rewriter, loc, i32_ty, false);\n-  }\n-};\n-\n-struct ZExtOpConversion\n-    : ElementwiseOpConversionBase<LLVM::ZExtOp, ZExtOpConversion> {\n-  using Base = ElementwiseOpConversionBase<LLVM::ZExtOp, ZExtOpConversion>;\n-  using Base::Base;\n-  using Adaptor = typename Base::OpAdaptor;\n-\n-  static bool isLegalOp(LLVM::ZExtOp op) {\n-    auto retTy = op.getResult().getType();\n-    auto srcTy = op.getOperand().getType();\n-    if (retTy.isInteger(32) && srcTy.isInteger(16)) {\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  Value createDestOp(LLVM::ZExtOp op, OpAdaptor adaptor,\n-                     ConversionPatternRewriter &rewriter, Type elemTy,\n-                     ValueRange operands, Location loc) const {\n-    PTXBuilder builder;\n-    auto &cvt = *builder.create(\"cvt.u32.u16\");\n-    auto res = builder.newOperand(\"=r\");\n-    auto operand = builder.newOperand(operands[0], \"h\");\n-    cvt(res, operand);\n-    return builder.launch(rewriter, loc, i32_ty, false);\n-  }\n-};\n-\n-bool isLegalElementwiseOp(Operation *op) {\n-  if (isa<LLVM::FPExtOp>(op)) {\n-    return FPExtOpConversion::isLegalOp(cast<LLVM::FPExtOp>(op));\n-  } else if (isa<LLVM::FPTruncOp>(op)) {\n-    return FPTruncOpConversion::isLegalOp(cast<LLVM::FPTruncOp>(op));\n-  } else if (isa<LLVM::TruncOp>(op)) {\n-    return TruncOpConversion::isLegalOp(cast<LLVM::TruncOp>(op));\n-  } else if (isa<LLVM::SExtOp>(op)) {\n-    return SExtOpConversion::isLegalOp(cast<LLVM::SExtOp>(op));\n-  } else if (isa<LLVM::ZExtOp>(op)) {\n-    return ZExtOpConversion::isLegalOp(cast<LLVM::ZExtOp>(op));\n-  }\n-  return true;\n-}\n-\n-void populateElementwiseOpToPTXPatterns(\n-    TritonGPUToLLVMTypeConverter &typeConverter, RewritePatternSet &patterns,\n-    PatternBenefit benefit) {\n-  patterns.add<FPExtOpConversion>(typeConverter, benefit);\n-  patterns.add<FPTruncOpConversion>(typeConverter, benefit);\n-  patterns.add<TruncOpConversion>(typeConverter, benefit);\n-  patterns.add<SExtOpConversion>(typeConverter, benefit);\n-  patterns.add<ZExtOpConversion>(typeConverter, benefit);\n-}\n+}\n\\ No newline at end of file"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "file_content_changes": "@@ -13,8 +13,4 @@ void populateElementwiseOpToLLVMPatterns(\n \n bool isLegalElementwiseOp(Operation *op);\n \n-void populateElementwiseOpToPTXPatterns(\n-    TritonGPUToLLVMTypeConverter &typeConverter, RewritePatternSet &patterns,\n-    PatternBenefit benefit);\n-\n #endif"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "file_content_changes": "@@ -59,9 +59,6 @@ class TritonLLVMFunctionConversionTarget : public ConversionTarget {\n class TritonPTXConversionTarget : public ConversionTarget {\n public:\n   explicit TritonPTXConversionTarget(MLIRContext &ctx) : ConversionTarget(ctx) {\n-    addDynamicallyLegalDialect<LLVM::LLVMDialect>(\n-        [&](Operation *op) { return isLegalElementwiseOp(op); });\n-\n     addLegalDialect<NVVM::NVVMDialect>();\n     addLegalOp<mlir::UnrealizedConversionCastOp>();\n   }\n@@ -70,9 +67,6 @@ class TritonPTXConversionTarget : public ConversionTarget {\n class TritonGCNConversionTarget : public ConversionTarget {\n public:\n   explicit TritonGCNConversionTarget(MLIRContext &ctx) : ConversionTarget(ctx) {\n-    addDynamicallyLegalDialect<LLVM::LLVMDialect>(\n-        [&](Operation *op) { return isLegalElementwiseOp(op); });\n-\n     addLegalDialect<ROCDL::ROCDLDialect>();\n     addLegalOp<mlir::UnrealizedConversionCastOp>();\n   }\n@@ -240,8 +234,6 @@ class ConvertTritonGPUToLLVM\n     if (isROCM) {\n       TritonGCNConversionTarget gcnTarget(*context);\n       RewritePatternSet gcnPatterns(context);\n-      populateElementwiseOpToPTXPatterns(typeConverter, gcnPatterns,\n-                                         /*benefits=*/10);\n       if (failed(\n               applyPartialConversion(mod, gcnTarget, std::move(gcnPatterns))))\n         return signalPassFailure();\n@@ -252,9 +244,6 @@ class ConvertTritonGPUToLLVM\n       // 2. In some cases, we may generate faster PTX code than NVPTX backend\n       TritonPTXConversionTarget ptxTarget(*context);\n       RewritePatternSet ptxPatterns(context);\n-      // Add patterns to convert LLVM to PTX\n-      populateElementwiseOpToPTXPatterns(typeConverter, ptxPatterns,\n-                                         /*benefits=*/10);\n       if (failed(\n               applyPartialConversion(mod, ptxTarget, std::move(ptxPatterns))))\n         return signalPassFailure();"}]