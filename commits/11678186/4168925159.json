[{"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "file_content_changes": "@@ -388,11 +388,19 @@ unsigned MmaEncodingAttr::getElemsPerThread(ArrayRef<int64_t> shape) const {\n \n   int res = 0;\n   if (isVolta()) {\n-    unsigned mmasRow = ceil<unsigned>(shape[0], 16 * getWarpsPerCTA()[0]);\n-    unsigned mmasCol = ceil<unsigned>(shape[1], 16 * getWarpsPerCTA()[1]);\n-    // Each warp-level mma884 will perform a m16xn16xk4 mma, thus get a m16xn16\n-    // matrix as result.\n-    res = mmasRow * mmasCol * (16 * 16 / 32);\n+    auto [isARow, isBRow, isAVec4, isBVec4, id] = decodeVoltaLayoutStates();\n+    static constexpr std::array<unsigned, 2> fpw{{2, 2}};\n+    unsigned packSize0 = (isARow || isAVec4) ? 1 : 2;\n+    unsigned packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n+    unsigned repM = 2 * packSize0;\n+    unsigned repN = 2 * packSize1;\n+    unsigned spwM = fpw[0] * 4 * repM;\n+    unsigned spwN = fpw[1] * 4 * repN;\n+    unsigned wptM = getWarpsPerCTA()[0];\n+    unsigned wptN = getWarpsPerCTA()[1];\n+    unsigned resM = repM * std::max<int>(1, shape[0] / (spwM * wptM));\n+    unsigned resN = 2 * repN * std::max<int>(1, shape[1] / (spwN * wptN));\n+    res = resM * resN;\n   } else if (isAmpere()) {\n     unsigned elemsCol = ceil<unsigned>(shape[0], 16 * getWarpsPerCTA()[0]) * 2;\n     unsigned elemsRow = ceil<unsigned>(shape[1], 8 * getWarpsPerCTA()[1]) * 2;"}, {"filename": "python/tutorials/03-matrix-multiplication.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -240,7 +240,7 @@ def matmul_kernel(\n     bias_ptrs = bias_ptr + offs_cm\n     bias = tl.load(bias_ptrs)\n     accumulator += bias[:, None]\n-    accumulator += (offs_cm[:, None] + offs_cn[None, :])\n+    # accumulator += (offs_cm[:, None] + offs_cn[None, :])\n     # write-back result\n     c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n     c = accumulator.to(tl.float16)"}]