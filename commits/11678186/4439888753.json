[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "file_content_changes": "@@ -117,10 +117,19 @@ struct FuncOpConversion : public FuncOpConversionBase {\n \n     auto ctx = funcOp->getContext();\n \n-    // Set an attribute to indicate this function is a kernel entry.\n-    newFuncOp->setAttr(\"nvvm.kernel\",\n-                       rewriter.getIntegerAttr(type::u1Ty(ctx), 1));\n-    if (!isROCM()) {\n+    if (isROCM()) {\n+      // Set an attribute to indicate this function is a kernel entry.\n+      newFuncOp->setAttr(\"rocdl.kernel\",\n+                         rewriter.getIntegerAttr(type::u1Ty(ctx), 1));\n+      \n+      // Set an attribute for maxntidx, it could be used in latter LLVM codegen\n+      newFuncOp->setAttr(\"rocdl.maxntid\",\n+                         rewriter.getIntegerAttr(i32_ty, 32 * numWarps));\n+    } else {\n+      // Set an attribute to indicate this function is a kernel entry.\n+      newFuncOp->setAttr(\"nvvm.kernel\",\n+                         rewriter.getIntegerAttr(type::u1Ty(ctx), 1));\n+\n       // Set an attribute for maxntidx, it could be used in latter LLVM codegen\n       // for `nvvm.annotation` metadata.\n       newFuncOp->setAttr(\"nvvm.maxntid\","}, {"filename": "test/Conversion/tritongpu_to_llvm.mlir", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -2,8 +2,6 @@\n \n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK: llvm.func @test_empty_kernel(%arg0: i64, %arg1: !llvm.ptr<f16, 1>)\n-  // Here the 128 comes from the 4 in module attribute multiples 32\n-  // CHECK:  attributes {nvvm.kernel = 1 : ui1, nvvm.maxntid = [128 : i32]} {{.*}}\n   func.func @test_empty_kernel(%lb : index, %A : !tt.ptr<f16>) {\n     // CHECK:  llvm.return\n     return"}]