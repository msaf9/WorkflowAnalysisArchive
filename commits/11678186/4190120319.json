[{"filename": "python/triton/ops/matmul.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -71,8 +71,8 @@ def _kernel(A, B, C, M, N, K,\n     # matrix multiplication\n     pid = tl.program_id(0)\n     pid_z = tl.program_id(1)\n-    grid_m = (M + BLOCK_M - 1) // BLOCK_M\n-    grid_n = (N + BLOCK_N - 1) // BLOCK_N\n+    grid_m = tl.cdiv(M, BLOCK_M)\n+    grid_n = tl.cdiv(N, BLOCK_N)\n     # re-order program ID for better L2 performance\n     width = GROUP_M * grid_n\n     group_id = pid // width\n@@ -89,7 +89,7 @@ def _kernel(A, B, C, M, N, K,\n     A = A + (ram[:, None] * stride_am + rk[None, :] * stride_ak)\n     B = B + (rk[:, None] * stride_bk + rbn[None, :] * stride_bn)\n     acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=ACC_TYPE)\n-    for k in range(K, 0, -BLOCK_K * SPLIT_K):\n+    for k in range(0, tl.cdiv(K, BLOCK_K * SPLIT_K)):\n         if EVEN_K:\n             a = tl.load(A)\n             b = tl.load(B)"}, {"filename": "python/tutorials/03-matrix-multiplication.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -187,6 +187,7 @@ def matmul_kernel(\n     pid = tl.program_id(axis=0)\n     num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n     num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n+    num_pid_k = tl.cdiv(K, BLOCK_SIZE_K)\n     num_pid_in_group = GROUP_SIZE_M * num_pid_n\n     group_id = pid // num_pid_in_group\n     first_pid_m = group_id * GROUP_SIZE_M\n@@ -213,7 +214,7 @@ def matmul_kernel(\n     # of fp32 values for higher accuracy.\n     # `accumulator` will be converted back to fp16 after the loop\n     accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n-    for k in range(0, K, BLOCK_SIZE_K):\n+    for k in range(0, num_pid_k):\n         # Note that for simplicity, we don't apply a mask here.\n         # This means that if K is not a multiple of BLOCK_SIZE_K,\n         # this will access out-of-bounds memory and produce an"}]