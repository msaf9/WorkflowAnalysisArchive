[{"filename": "include/triton/Dialect/Triton/IR/TritonAttrDefs.td", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -59,7 +59,8 @@ def TT_AtomicRMWAttr : I32EnumAttr<\n         I32EnumAttrCase<\"MAX\", 6, \"max\">,\n         I32EnumAttrCase<\"MIN\", 7, \"min\">,\n         I32EnumAttrCase<\"UMAX\", 8, \"umax\">,\n-        I32EnumAttrCase<\"UMIN\", 9, \"umin\">\n+        I32EnumAttrCase<\"UMIN\", 9, \"umin\">,\n+        I32EnumAttrCase<\"XCHG\", 10, \"exch\">\n     ]> {\n     let cppNamespace = \"::mlir::triton\";\n }"}, {"filename": "lib/Analysis/Allocation.cpp", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "file_content_changes": "@@ -115,8 +115,7 @@ SmallVector<unsigned> getScratchConfigForReduce(triton::ReduceOp op) {\n // TODO: extend beyond scalars\n SmallVector<unsigned> getScratchConfigForAtomicRMW(triton::AtomicRMWOp op) {\n   SmallVector<unsigned> smemShape;\n-  auto ptrTy = op.ptr().getType();\n-  if (auto tensorType = ptrTy.dyn_cast<RankedTensorType>()) {\n+  if (auto tensorType = op.ptr().getType().dyn_cast<RankedTensorType>()) {\n     // do nothing or just assert because shared memory is not used in tensor\n   } else {\n     // need only bytes for scalar\n@@ -126,6 +125,12 @@ SmallVector<unsigned> getScratchConfigForAtomicRMW(triton::AtomicRMWOp op) {\n   return smemShape;\n }\n \n+SmallVector<unsigned> getScratchConfigForAtomicCAS(triton::AtomicCASOp op) {\n+  SmallVector<unsigned> smemShape;\n+  smemShape.push_back(1);\n+  return smemShape;\n+}\n+\n class AllocationAnalysis {\n public:\n   AllocationAnalysis(Operation *operation, Allocation *allocation)\n@@ -231,6 +236,17 @@ class AllocationAnalysis {\n                          : elems * elemTy.getIntOrFloatBitWidth() / 8;\n         allocation->addBuffer<BufferT::BufferKind::Scratch>(op, bytes);\n       }\n+    } else if (auto atomicCASOp = dyn_cast<triton::AtomicCASOp>(op)) {\n+      auto value = op->getOperand(0);\n+      auto smemShape = getScratchConfigForAtomicCAS(atomicCASOp);\n+      unsigned elems = std::accumulate(smemShape.begin(), smemShape.end(), 1,\n+                                       std::multiplies{});\n+      auto elemTy =\n+          value.getType().cast<triton::PointerType>().getPointeeType();\n+      auto bytes = elemTy.isa<triton::PointerType>()\n+                       ? elems * kPtrBitWidth / 8\n+                       : elems * elemTy.getIntOrFloatBitWidth() / 8;\n+      allocation->addBuffer<BufferT::BufferKind::Scratch>(op, bytes);\n     }\n   }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "file_content_changes": "@@ -5938,6 +5938,76 @@ struct ExpOpConversionApprox\n     return ptxBuilder.launch(rewriter, loc, f32_ty, false);\n   }\n };\n+/// ====================== atomic_cas codegen begin ==========================\n+struct AtomicCASOpConversion\n+    : public ConvertTritonGPUOpToLLVMPattern<triton::AtomicCASOp>,\n+      public LoadStoreConversionBase {\n+  using ConvertTritonGPUOpToLLVMPattern<\n+      triton::AtomicCASOp>::ConvertTritonGPUOpToLLVMPattern;\n+\n+  AtomicCASOpConversion(LLVMTypeConverter &converter,\n+                        const Allocation *allocation, Value smem,\n+                        AxisInfoAnalysis &axisAnalysisPass,\n+                        PatternBenefit benefit)\n+      : ConvertTritonGPUOpToLLVMPattern<triton::AtomicCASOp>(\n+            converter, allocation, smem, benefit),\n+        LoadStoreConversionBase(axisAnalysisPass) {}\n+\n+  LogicalResult\n+  matchAndRewrite(triton::AtomicCASOp op, OpAdaptor adaptor,\n+                  ConversionPatternRewriter &rewriter) const override {\n+    auto loc = op.getLoc();\n+    MLIRContext *ctx = rewriter.getContext();\n+    Value ptr = op.ptr();\n+\n+    Value llPtr = adaptor.ptr();\n+    Value llCmp = adaptor.cmp();\n+    Value llVal = adaptor.val();\n+\n+    auto ptrElements = getElementsFromStruct(loc, llPtr, rewriter);\n+    auto cmpElements = getElementsFromStruct(loc, llCmp, rewriter);\n+    auto valElements = getElementsFromStruct(loc, llVal, rewriter);\n+\n+    auto valueTy = op.getResult().getType().dyn_cast<RankedTensorType>();\n+    Type valueElemTy =\n+        valueTy ? getTypeConverter()->convertType(valueTy.getElementType())\n+                : op.getResult().getType();\n+    auto tid = tid_val();\n+    Value pred = icmp_eq(tid, i32_val(0));\n+    Value atomPtr = getSharedMemoryBase(loc, rewriter, op.getOperation());\n+    atomPtr = bitcast(atomPtr, ptr_ty(valueElemTy, 3));\n+\n+    Value casPtr = ptrElements[0];\n+    Value casCmp = cmpElements[0];\n+    Value casVal = valElements[0];\n+\n+    PTXBuilder ptxBuilder;\n+    auto *dstOpr = ptxBuilder.newOperand(\"=r\");\n+    auto *ptrOpr = ptxBuilder.newAddrOperand(casPtr, \"l\");\n+    auto *cmpOpr = ptxBuilder.newOperand(casCmp, \"r\");\n+    auto *valOpr = ptxBuilder.newOperand(casVal, \"r\");\n+    auto &atom = *ptxBuilder.create<PTXInstr>(\"atom\");\n+    atom.global().o(\"cas\").o(\"b32\");\n+    atom(dstOpr, ptrOpr, cmpOpr, valOpr).predicate(pred);\n+    auto old = ptxBuilder.launch(rewriter, loc, valueElemTy);\n+    barrier();\n+\n+    PTXBuilder ptxBuilderStore;\n+    auto *dstOprStore = ptxBuilderStore.newAddrOperand(atomPtr, \"l\");\n+    auto *valOprStore = ptxBuilderStore.newOperand(old, \"r\");\n+    auto &st = *ptxBuilderStore.create<PTXInstr>(\"st\");\n+    st.shared().o(\"b32\");\n+    st(dstOprStore, valOprStore).predicate(pred);\n+    auto ASMReturnTy = void_ty(ctx);\n+    ptxBuilderStore.launch(rewriter, loc, ASMReturnTy);\n+    barrier();\n+    Value ret = load(atomPtr);\n+    barrier();\n+    rewriter.replaceOp(op, {ret});\n+    return success();\n+  }\n+};\n+/// ====================== atomic_cas codegen end ==========================\n \n /// ====================== atomic_rmw codegen begin ==========================\n struct AtomicRMWOpConversion\n@@ -6051,6 +6121,9 @@ struct AtomicRMWOpConversion\n         rmwOp = \"min\";\n         sTy = \"u\" + sBits;\n         break;\n+      case RMWOp::XCHG:\n+        sTy = \"b\" + sBits;\n+        break;\n       default:\n         return failure();\n       }\n@@ -6166,7 +6239,10 @@ void populateTritonToLLVMPatterns(mlir::LLVMTypeConverter &typeConverter,\n   patterns.add<ReduceOpConversion>(typeConverter, allocation, smem, benefit);\n   patterns.add<ConvertLayoutOpConversion>(typeConverter, allocation, smem,\n                                           benefit);\n-  patterns.add<AtomicRMWOpConversion>(typeConverter, allocation, smem, axisInfoAnalysis, benefit);\n+  patterns.add<AtomicCASOpConversion>(typeConverter, allocation, smem,\n+                                      axisInfoAnalysis, benefit);\n+  patterns.add<AtomicRMWOpConversion>(typeConverter, allocation, smem,\n+                                      axisInfoAnalysis, benefit);\n   patterns.add<ExtractSliceOpConversion>(typeConverter, allocation, smem,\n                                          benefit);\n   patterns.add<GetProgramIdOpConversion>(typeConverter, benefit);\n@@ -6329,7 +6405,7 @@ void ConvertTritonGPUToLLVM::initSharedMemory(\n   smem = b.create<LLVM::BitcastOp>(loc, ptrTy, smem);\n }\n \n-} // namespace\n+}; // namespace\n \n namespace mlir {\n "}, {"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPU.cpp", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "file_content_changes": "@@ -278,6 +278,20 @@ struct TritonStorePattern : public OpConversionPattern<triton::StoreOp> {\n   }\n };\n \n+struct TritonAtomicCASPattern\n+    : public OpConversionPattern<triton::AtomicCASOp> {\n+  using OpConversionPattern<triton::AtomicCASOp>::OpConversionPattern;\n+\n+  LogicalResult\n+  matchAndRewrite(triton::AtomicCASOp op, OpAdaptor adaptor,\n+                  ConversionPatternRewriter &rewriter) const override {\n+    rewriter.replaceOpWithNewOp<triton::AtomicCASOp>(\n+        op, typeConverter->convertType(op.getType()), \n+        adaptor.ptr(), adaptor.cmp(), adaptor.val());\n+    return success();\n+  }\n+};\n+\n struct TritonAtomicRMWPattern\n     : public OpConversionPattern<triton::AtomicRMWOp> {\n   using OpConversionPattern<triton::AtomicRMWOp>::OpConversionPattern;"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "file_content_changes": "@@ -105,7 +105,7 @@ void init_triton_ir(py::module &&m) {\n       .value(\"AND\", mlir::triton::RMWOp::AND)\n       .value(\"OR\", mlir::triton::RMWOp::OR)\n       .value(\"XOR\", mlir::triton::RMWOp::XOR)\n-      // .value(\"XCHG\", mlir::triton::RMWOp::Xchg)\n+      .value(\"XCHG\", mlir::triton::RMWOp::XCHG)\n       .value(\"MAX\", mlir::triton::RMWOp::MAX)\n       .value(\"MIN\", mlir::triton::RMWOp::MIN)\n       .value(\"UMIN\", mlir::triton::RMWOp::UMIN)\n@@ -1095,9 +1095,18 @@ void init_triton_ir(py::module &&m) {\n            [](mlir::OpBuilder &self, mlir::Value &ptr, mlir::Value &cmp,\n               mlir::Value &val) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-             auto ptrType = mlir::getElementTypeOrSelf(ptr)\n-                                .cast<mlir::triton::PointerType>();\n-             mlir::Type dstType = ptrType.getPointeeType();\n+             mlir::Type dstType;\n+             if (auto srcTensorType = ptr.getType().dyn_cast<mlir::RankedTensorType>()) {\n+               mlir::Type dstElemType = srcTensorType.getElementType()\n+                                            .cast<mlir::triton::PointerType>()\n+                                            .getPointeeType();\n+               dstType = mlir::RankedTensorType::get(srcTensorType.getShape(),\n+                                                     dstElemType);\n+             } else {\n+               auto ptrType = mlir::getElementTypeOrSelf(ptr)\n+                                  .cast<mlir::triton::PointerType>();\n+               dstType = ptrType.getPointeeType();\n+             }\n              return self.create<mlir::triton::AtomicCASOp>(loc, dstType, ptr,\n                                                            cmp, val);\n            })"}, {"filename": "python/tests/test_core.py", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "file_content_changes": "@@ -700,6 +700,16 @@ def kernel(Z, X, AXIS: tl.constexpr, SHAPE0: tl.constexpr, SHAPE1: tl.constexpr)\n #     serialized_add[(64,)](data, Lock)\n #     triton.testing.assert_almost_equal(data, ref)\n \n+def test_simple_atomic_cas():\n+    # 1. make sure that atomic_cas changes the original value (Lock)\n+    @triton.jit\n+    def change_value(Lock):\n+        tl.atomic_cas(Lock, 0, 1)\n+\n+    Lock = torch.zeros((1,), device='cuda', dtype=torch.int32)\n+    change_value[(1,)](Lock)\n+\n+    assert (Lock[0] == 1)\n \n # # ---------------\n # # test cast"}]