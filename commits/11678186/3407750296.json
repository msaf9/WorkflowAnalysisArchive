[{"filename": "include/triton/Target/LLVMIR/LLVMIRTranslation.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -30,7 +30,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n std::unique_ptr<llvm::Module>\n translateLLVMToLLVMIR(llvm::LLVMContext *llvmContext, mlir::ModuleOp module);\n \n-bool linkLibdevice(llvm::Module &module, llvm::StringRef path);\n+bool linkExternLib(llvm::Module &module, llvm::StringRef path);\n \n } // namespace triton\n } // namespace mlir"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "file_content_changes": "@@ -189,24 +189,8 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n \n   llvm::SMDiagnostic err;\n   for (auto &lib : extern_libs) {\n-    if (\"libdevice\" == lib.first) {\n-      linkLibdevice(*llvmir, lib.first);\n-      continue;\n-    }\n-\n-    auto ext_mod = llvm::parseIRFile(lib.second, err, *llvmContext);\n-    if (!ext_mod) {\n-      llvm::errs() << \"Failed to load extern lib \" << lib.first;\n-      return nullptr;\n-    }\n-    ext_mod->setTargetTriple(llvmir->getTargetTriple());\n-    ext_mod->setDataLayout(llvmir->getDataLayout());\n-\n-    if (llvm::Linker::linkModules(*llvmir, std::move(ext_mod),\n-                                  llvm::Linker::Flags::LinkOnlyNeeded)) {\n-      llvm::errs() << \"Failed to link extern lib \" << lib.first;\n+    if (!linkExternLib(*llvmir, lib.second))\n       return nullptr;\n-    }\n   }\n \n   return llvmir;\n@@ -232,7 +216,7 @@ void addExternalLibs(mlir::ModuleOp &module,\n   return;\n }\n \n-bool linkLibdevice(llvm::Module &module, llvm::StringRef path) {\n+bool linkExternLib(llvm::Module &module, llvm::StringRef path) {\n   llvm::SMDiagnostic err;\n   auto &ctx = module.getContext();\n \n@@ -251,14 +235,6 @@ bool linkLibdevice(llvm::Module &module, llvm::StringRef path) {\n     return false;\n   }\n \n-  llvm::Type *I32 = llvm::Type::getInt32Ty(ctx);\n-  llvm::Metadata *md_four =\n-      llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 4));\n-  llvm::Metadata *md_name = llvm::MDString::get(ctx, \"nvvm-reflect-ftz\");\n-  llvm::Metadata *md_one =\n-      llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 1));\n-  llvm::MDNode *reflect = llvm::MDNode::get(ctx, {md_four, md_name, md_one});\n-  module.addModuleFlag(reflect);\n   return true;\n }\n "}, {"filename": "lib/Target/PTX/PTXTranslation.cpp", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "file_content_changes": "@@ -80,10 +80,25 @@ static std::string llir_to_ptx(llvm::Module *module, int capability, int ptx) {\n                                           .parent_path() /\n                                       \"python\" / \"triton\" / \"language\" /\n                                       \"libdevice.10.bc\";\n-    if (mlir::triton::linkLibdevice(*module, libdevice.string()))\n+    if (!mlir::triton::linkExternLib(*module, libdevice.string()))\n       llvm::errs() << \"link failed for: \" << libdevice.string();\n   }\n \n+  // please check https://llvm.org/docs/NVPTXUsage.html#reflection-parameters\n+  // this will enable fast math path in libdevice\n+  // for example, when enable nvvm-reflect-ftz, sqrt.approx.f32 will change to\n+  // sqrt.approx.ftz.f32\n+  {\n+    auto &ctx = module->getContext();\n+    llvm::Type *I32 = llvm::Type::getInt32Ty(ctx);\n+    llvm::Metadata *md_four =\n+        llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 4));\n+    llvm::Metadata *md_name = llvm::MDString::get(ctx, \"nvvm-reflect-ftz\");\n+    llvm::Metadata *md_one =\n+        llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 1));\n+    llvm::MDNode *reflect = llvm::MDNode::get(ctx, {md_four, md_name, md_one});\n+    module->addModuleFlag(reflect);\n+  }\n   // LLVM version in use may not officially support target hardware\n   int max_nvvm_cc = 75;\n   // int max_nvvm_ptx = 74;"}]