[{"filename": "lib/Analysis/Membar.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -24,7 +24,7 @@ void MembarAnalysis::dfsOperation(Operation *operation,\n     // scf.if only: two regions\n     // scf.for: one region\n     RegionInfo curRegionInfo;\n-    auto traverseRegions = [&]() -> auto{\n+    auto traverseRegions = [&]() -> auto {\n       for (auto &region : operation->getRegions()) {\n         // Copy the parent info as the current info.\n         RegionInfo regionInfo = *parentRegionInfo;"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "file_content_changes": "@@ -18,8 +18,8 @@\n #include \"llvm/IRReader/IRReader.h\"\n #include \"llvm/Linker/Linker.h\"\n #include \"llvm/Support/SourceMgr.h\"\n-#include <filesystem>\n #include <dlfcn.h>\n+#include <filesystem>\n \n namespace mlir {\n namespace triton {\n@@ -123,38 +123,34 @@ static std::map<std::string, std::string> getExternLibs(mlir::ModuleOp module) {\n     // Then native code is in `triton/_C/libtriton.so` and libdevice in\n     // `triton/third_party/cuda/lib/libdevice.10.bc`\n     static const auto this_library_path = [] {\n-        Dl_info fileinfo;\n-        if (dladdr(reinterpret_cast<void*>(&getExternLibs), &fileinfo) == 0) {\n-          return std::filesystem::path();\n-        }\n-        return std::filesystem::path(fileinfo.dli_fname);\n+      Dl_info fileinfo;\n+      if (dladdr(reinterpret_cast<void *>(&getExternLibs), &fileinfo) == 0) {\n+        return std::filesystem::path();\n+      }\n+      return std::filesystem::path(fileinfo.dli_fname);\n     }();\n-    static const auto runtime_path = this_library_path\n-                                         .parent_path()\n-                                         .parent_path() /\n-                                     \"third_party\" / \"cuda\" / \"lib\" /\n-                                     \"libdevice.10.bc\";\n+    static const auto runtime_path =\n+        this_library_path.parent_path().parent_path() / \"third_party\" / \"cuda\" /\n+        \"lib\" / \"libdevice.10.bc\";\n     if (fs::exists(runtime_path)) {\n-        externLibs.try_emplace(libdevice, runtime_path.string());\n+      externLibs.try_emplace(libdevice, runtime_path.string());\n     } else {\n-      // When using the Math Dialect, it is possible that some ops (e.g., log) are\n-      // lowered to a function call. In this case, we need to link libdevice\n+      // When using the Math Dialect, it is possible that some ops (e.g., log)\n+      // are lowered to a function call. In this case, we need to link libdevice\n       // using its default path:\n       // [triton root dir]/python/triton/language/libdevice.10.bc\n       // TODO(Keren): handle external linkage other than libdevice?\n       static const auto this_file_path = std::filesystem::path(__FILE__);\n-      static const auto compiletime_path = this_file_path\n-                                               .parent_path()\n+      static const auto compiletime_path = this_file_path.parent_path()\n                                                .parent_path()\n                                                .parent_path()\n                                                .parent_path() /\n-                                           \"python\" / \"triton\" /\n-                                           \"third_party\" / \"cuda\" / \"lib\" /\n-                                           \"libdevice.10.bc\";\n+                                           \"python\" / \"triton\" / \"third_party\" /\n+                                           \"cuda\" / \"lib\" / \"libdevice.10.bc\";\n       if (!fs::exists(compiletime_path)) {\n         std::string error_msg = \"Can't find libdevice at neither \" +\n-                                 runtime_path.string() + \" nor \" +\n-                                 compiletime_path.string();\n+                                runtime_path.string() + \" nor \" +\n+                                compiletime_path.string();\n         llvm::report_fatal_error(error_msg.c_str());\n       }\n       externLibs.try_emplace(libdevice, compiletime_path.string());"}]