[{"filename": "README.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "file_content_changes": "@@ -38,24 +38,25 @@ pip install -U --pre triton\n ```\n git clone https://github.com/openai/triton.git;\n cd triton/python;\n-pip install cmake; # build time dependency\n+pip install cmake; # build-time dependency\n pip install -e .\n ```\n \n # Changelog\n \n Version 2.0 is out! New features include:\n-- Many, many bugfixes\n+- Many, many bug fixes\n - Performance improvements\n - Backend rewritten to use MLIR\n - Support for kernels that contain back-to-back matmuls (e.g., flash attention)\n \n # Contributing\n \n-Community contributions are more than welcome, whether it be to fix bugs or to add new features. Feel free to open GitHub issues about your contribution ideas, and we will review them. A contributor's guide containing general guidelines is coming soon!\n+Community contributions are more than welcome, whether it be to fix bugs or to add new features. Feel free to open GitHub issues about your contribution ideas, and we will review them. Please do not submit PRs that simply fix simple typos in our documentation -- unless they can lead to confusion.\n \n-If you\u2019re interested in joining our team and working on Triton & GPU kernels, [we\u2019re hiring](https://openai.com/jobs/#acceleration)!\n+Note 1: A more detailed contributor's guide containing general guidelines is coming soon!\n \n+Note 2: If you\u2019re interested in joining our team and working on Triton & GPU kernels, [we\u2019re hiring](https://openai.com/jobs/#acceleration)!\n \n # Compatibility\n "}, {"filename": "cmake/FindLLVM.cmake", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1,4 +1,3 @@\n-\n # - Find LLVM headers and libraries.\n # This module locates LLVM and adapts the llvm-config output for use with\n # CMake."}, {"filename": "docs/getting-started/installation.rst", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "file_content_changes": "@@ -1,10 +1,10 @@\n-==============\n+============\n Installation\n-==============\n+============\n \n----------------------\n+--------------------\n Binary Distributions\n----------------------\n+--------------------\n \n You can install the latest stable release of Triton from pip:\n \n@@ -21,21 +21,21 @@ And the latest nightly release:\n       pip install -U --pre triton\n \n \n---------------\n+-----------\n From Source\n---------------\n+-----------\n \n-+++++++++++++++\n+++++++++++++++\n Python Package\n-+++++++++++++++\n+++++++++++++++\n \n You can install the Python package from source by running the following commands:\n \n .. code-block:: bash\n \n       git clone https://github.com/openai/triton.git;\n       cd triton/python;\n-      pip install cmake; # build time dependency\n+      pip install cmake; # build-time dependency\n       pip install -e .\n \n Note that, if llvm-11 is not present on your system, the setup.py script will download the official LLVM11 static libraries link against that.\n@@ -51,5 +51,5 @@ and the benchmarks\n \n .. code-block:: bash\n       \n-      cd bench/\n+      cd bench\n       python -m run --with-plots --result-dir /tmp/triton-bench"}, {"filename": "docs/index.rst", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "file_content_changes": "@@ -3,6 +3,7 @@ Welcome to Triton's documentation!\n \n Triton is a language and compiler for parallel programming. It aims to provide a Python-based programming environment for productively writing custom DNN compute kernels capable of running at maximal throughput on modern GPU hardware.\n \n+\n Getting Started\n ---------------\n \n@@ -17,8 +18,9 @@ Getting Started\n    getting-started/installation\n    getting-started/tutorials/index\n \n+\n Python API\n--------------------\n+----------\n \n - :doc:`triton <python-api/triton>`\n - :doc:`triton.language <python-api/triton.language>`\n@@ -36,7 +38,7 @@ Python API\n \n    \n Going Further\n-------------------\n+-------------\n \n Check out the following documents to learn more about Triton and how it compares against other DSLs for DNNs:\n "}, {"filename": "docs/programming-guide/chapter-1/introduction.rst", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "file_content_changes": "@@ -1,18 +1,18 @@\n-==============\n+============\n Introduction\n-==============\n+============\n \n---------------\n+-----------\n Motivations\n---------------\n+-----------\n \n-Over the past decade, Deep Neural Networks (DNNs) have emerged as an important class of Machine Learning (ML) models, capable of  achieving state-of-the-art performance across many domains ranging from natural language processing [SUTSKEVER2014]_ to computer vision [REDMON2016]_ to computational neuroscience [LEE2017]_. The strength of these models lies in their hierarchical structure, composed of a sequence of parametric (e.g., convolutional) and non-parametric (e.g., rectified linearity) *layers*. This pattern, though notoriously computationally expensive, also generates a large amount of highly parallelizable work particularly well suited for multi- and many- core processors.\n+Over the past decade, Deep Neural Networks (DNNs) have emerged as an important class of Machine Learning (ML) models, capable of achieving state-of-the-art performance across many domains ranging from natural language processing [SUTSKEVER2014]_ to computer vision [REDMON2016]_ to computational neuroscience [LEE2017]_. The strength of these models lies in their hierarchical structure, composed of a sequence of parametric (e.g., convolutional) and non-parametric (e.g., rectified linearity) *layers*. This pattern, though notoriously computationally expensive, also generates a large amount of highly parallelizable work particularly well suited for multi- and many- core processors.\n \n As a consequence, Graphics Processing Units (GPUs) have become a cheap and accessible resource for exploring and/or deploying novel research ideas in the field. This trend has been accelerated by the release of several frameworks for General-Purpose GPU (GPGPU) computing, such as CUDA and OpenCL, which have made the development of high-performance programs easier. Yet, GPUs remain incredibly challenging to optimize for locality and parallelism, especially for computations that cannot be efficiently implemented using a combination of pre-existing optimized primitives. To make matters worse, GPU architectures are also rapidly evolving and specializing, as evidenced by the addition of tensor cores to NVIDIA (and more recently AMD) micro-architectures.\n \n-This tension between the computational opportunities offered by DNNs and the practical difficulty of GPU programming has created substantial academic and industrial interest for Domain-Specific Languages (DSLs) and compilers. Regrettably, these systems -- whether they be based on  polyhedral machinery (*e.g.*, Tiramisu [BAGHDADI2021]_, Tensor Comprehensions [VASILACHE2018]_) or scheduling languages (*e.g.*, Halide [JRK2013]_, TVM [CHEN2018]_) -- remain less flexible and (for the same algorithm) markedly slower than the best handwritten compute kernels available in libraries like `cuBLAS <https://docs.nvidia.com/cuda/cublas/index.html>`_, `cuDNN <https://docs.nvidia.com/deeplearning/cudnn/api/index.html>`_ or `TensorRT <https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html>`_.\n+This tension between the computational opportunities offered by DNNs and the practical difficulty of GPU programming has created substantial academic and industrial interest for Domain-Specific Languages (DSLs) and compilers. Regrettably, these systems -- whether they be based on polyhedral machinery (e.g., Tiramisu [BAGHDADI2021]_, Tensor Comprehensions [VASILACHE2018]_) or scheduling languages (e.g., Halide [JRK2013]_, TVM [CHEN2018]_) -- remain less flexible and (for the same algorithm) markedly slower than the best handwritten compute kernels available in libraries like `cuBLAS <https://docs.nvidia.com/cuda/cublas/index.html>`_, `cuDNN <https://docs.nvidia.com/deeplearning/cudnn/api/index.html>`_ or `TensorRT <https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html>`_.\n \n-The main premise of this project is the following: programming paradigms based on blocked algorithms [LAM1991]_ can facilitate the construction of high-performance compute kernels for neural networks.  We specifically revisit traditional \"Single Program, Multiple Data\" (SPMD [AUGUIN1983]_) execution models for GPUs, and propose a variant in which programs -- rather than threads -- are blocked. For example, in the case of matrix multiplication, CUDA and Triton differ as follows:\n+The main premise of this project is the following: programming paradigms based on blocked algorithms [LAM1991]_ can facilitate the construction of high-performance compute kernels for neural networks. We specifically revisit traditional \"Single Program, Multiple Data\" (SPMD [AUGUIN1983]_) execution models for GPUs, and propose a variant in which programs -- rather than threads -- are blocked. For example, in the case of matrix multiplication, CUDA and Triton differ as follows:\n \n .. table::\n     :widths: 50 50\n@@ -31,8 +31,8 @@ The main premise of this project is the following: programming paradigms based o\n     |   #pragma parallel                                  |   #pragma parallel                                  |\n     |   for(int n = 0; j < N; n++){                       |   for(int n = 0; n < N; n += NB){                   |\n     |     float acc = 0;                                  |     float acc[MB, NB] = 0;                          |\n-    |     for(int k = 0; k < K;k ++)                      |     for(int k = 0; k < K; k += KB)                  |\n-    |       acc += A[i, k]* B[k, j];                      |       acc +=  A[m:m+MB, k:k+KB]                     |\n+    |     for(int k = 0; k < K; k++)                      |     for(int k = 0; k < K; k += KB)                  |\n+    |       acc += A[i, k] * B[k, j];                     |       acc +=  A[m:m+MB, k:k+KB]                     |\n     |                                                     |             @ B[k:k+KB, n:n+NB];                    |\n     |     C[i, j] = acc;                                  |     C[m:m+MB, n:n+NB] = acc;                        |\n     |   }                                                 |   }                                                 |\n@@ -48,15 +48,17 @@ The main premise of this project is the following: programming paradigms based o\n \n A key benefit of this approach is that it leads to block-structured iteration spaces that offer programmers more flexibility than existing DSLs when implementing sparse operations, all while allowing compilers to aggressively optimize programs for data locality and parallelism.\n \n---------------\n+\n+----------\n Challenges\n---------------\n+----------\n \n The main challenge posed by our proposed paradigm is that of work scheduling, i.e., how the work done by each program instance should be partitioned for efficient execution on modern GPUs. To address this issue, the Triton compiler makes heavy use of *block-level data-flow analysis*, a technique for scheduling iteration blocks statically based on the control- and data-flow structure of the target program. The resulting system actually works surprisingly well: our compiler manages to apply a broad range of interesting optimization automatically (e.g., automatic coalescing, thread swizzling, pre-fetching, automatic vectorization, tensor core-aware instruction selection, shared memory allocation/synchronization, asynchronous copy scheduling). Of course doing all this is not trivial; one of the purposes of this guide is to give you a sense of how it works.\n \n---------------\n+\n+----------\n References\n---------------\n+----------\n \n .. [SUTSKEVER2014] I. Sutskever et al., \"Sequence to Sequence Learning with Neural Networks\", NIPS 2014\n .. [REDMON2016] J. Redmon et al., \"You Only Look Once: Unified, Real-Time Object Detection\", CVPR 2016\n@@ -66,4 +68,4 @@ References\n .. [JRK2013] J. Ragan-Kelley et al., \"Halide: A Language and Compiler for Optimizing Parallelism, Locality, and Recomputation in Image Processing Pipelines\", PLDI 2013\n .. [CHEN2018] T. Chen et al., \"TVM: An Automated End-to-End Optimizing Compiler for Deep Learning\", OSDI 2018\n .. [LAM1991] M. Lam et al., \"The Cache Performance and Optimizations of Blocked Algorithms\", ASPLOS 1991\n-.. [AUGUIN1983] M. Auguin et al., \"Opsila: an advanced SIMD for numerical analysis and signal processing\", EUROMICRO 1983\n\\ No newline at end of file\n+.. [AUGUIN1983] M. Auguin et al., \"Opsila: an advanced SIMD for numerical analysis and signal processing\", EUROMICRO 1983"}, {"filename": "docs/programming-guide/chapter-2/related-work.rst", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "file_content_changes": "@@ -1,18 +1,19 @@\n-==============\n+============\n Related Work\n-==============\n+============\n \n At first sight, Triton may seem like just yet another DSL for DNNs. The purpose of this section is to contextualize Triton and highlight its differences with the two leading approaches in this domain: polyhedral compilation and scheduling languages.\n \n------------------------\n+\n+----------------------\n Polyhedral Compilation\n------------------------\n+----------------------\n \n Traditional compilers typically rely on intermediate representations, such as LLVM-IR [LATTNER2004]_, that encode control flow information using (un)conditional branches. This relatively low-level format makes it difficult to statically analyze the runtime behavior (e.g., cache misses) of input programs, and to  automatically optimize loops accordingly through the use of tiling [WOLFE1989]_, fusion [DARTE1999]_ and interchange [ALLEN1984]_. To solve this issue, polyhedral compilers [ANCOURT1991]_ rely on program representations that have statically predictable control flow, thereby enabling aggressive compile-time program transformations for data locality and parallelism. Though this strategy has been adopted by many languages and compilers for DNNs such as Tiramisu [BAGHDADI2021]_, Tensor Comprehensions [VASILACHE2018]_, Diesel [ELANGO2018]_ and the Affine dialect in MLIR [LATTNER2019]_, it also comes with a number of limitations that will be described later in this section.\n \n-+++++++++++++++++++++++\n+++++++++++++++++++++++\n Program Representation\n-+++++++++++++++++++++++\n+++++++++++++++++++++++\n \n Polyhedral compilation is a vast area of research. In this section we only outline the most basic aspects of this topic, but readers interested in the solid mathematical foundations underneath may refer to the ample literature on linear and integer programming.\n \n@@ -105,19 +106,19 @@ Where :math:`\\Theta_S(\\mathbf{x})` is a p-dimensional vector representing the sl\n \n where :math:`i` and :math:`j` are respectively the slowest and fastest growing loop indices in the nest. If :math:`T_S` is a vector (resp. tensor), then :math:`\\Theta_S` is a said to be one-dimensional (resp. multi-dimensional).\n \n-+++++++++++\n+++++++++++\n Advantages\n-+++++++++++\n+++++++++++\n \n Programs amenable to polyhedral compilation can be aggressively transformed and optimized. Most of these transformations actually boil down to the production of  schedules and iteration domains that enable loop transformations promoting parallelism and spatial/temporal data locality (e.g., fusion, interchange, tiling, parallelization).\n \n Polyhedral compilers can also automatically go through complex verification processes to ensure that the semantics of their input program is preserved throughout this optimization phase. Note that polyhedral optimizers are not incompatible with more standard optimization techniques. In fact, it is not uncommon for these systems to be implemented as a set of LLVM passes that can be run ahead of more traditional compilation techniques [GROSSER2012]_.\n \n All in all, polyhedral machinery is extremely powerful, when applicable. It has been shown to support most common loop transformations, and has indeed achieved performance comparable to state-of-the-art GPU libraries for dense matrix multiplication [ELANGO2018]_. Additionally, it is also fully automatic and doesn't require any hint from programmers apart from source-code in a C-like format. \n \n-++++++++++++\n++++++++++++\n Limitations\n-++++++++++++\n++++++++++++\n \n Unfortunately, polyhedral compilers suffer from two major limitations that have prevented its adoption as a universal method for code generation in neural networks.\n \n@@ -127,9 +128,10 @@ Second, the polyhedral framework is not very generally applicable; SCoPs are rel\n \n On the other hand, blocked program representations advocated by this dissertation are less restricted in scope and can achieve close to peak performance using standard dataflow analysis.\n \n------------------------\n+\n+--------------------\n Scheduling Languages\n------------------------\n+--------------------\n \n Separation of concerns [DIJKSTRA82]_ is a well-known design principle in computer science: programs should be decomposed into modular layers of abstraction that separate the semantics of their algorithms from the details of their implementation. Systems like Halide and TVM push this philosophy one step further, and enforce this separation at the grammatical level through the use of a  **scheduling language**. The benefits of this methodology are particularly visible in the case of matrix multiplication, where, as one can see below, the definition of the algorithm (Line 1-7) is completely disjoint from its implementation (Line 8-16), meaning that both can be maintained, optimized and distributed independently. \n \n@@ -156,17 +158,17 @@ Separation of concerns [DIJKSTRA82]_ is a well-known design principle in compute\n \n The resulting code may however not be completely portable, as schedules can sometimes rely on execution models (e.g., SPMD) or hardware intrinsics (e.g., matrix-multiply-accumulate) that are not widely available. This issue can be mitigated by auto-scheduling mechanisms [MULLAPUDI2016]_.\n \n-+++++++++++\n+++++++++++\n Advantages\n-+++++++++++\n+++++++++++\n \n The main advantage of this approach is that it allows programmers to write an algorithm *only once*, and focus on performance optimization separately. It makes it possible to manually specify optimizations that a polyhedral compiler wouldn't be able to figure out automatically using static data-flow analysis.\n \n Scheduling languages are, without a doubt, one of the most popular approaches for neural network code generation. The most popular system for this purpose is probably TVM, which provides good performance across a wide range of platforms as well as built-in automatic scheduling mechanisms.\n \n-++++++++++++\n++++++++++++\n Limitations\n-++++++++++++\n++++++++++++\n \n This ease-of-development comes at a cost. First of all, existing systems that follow this paradigm tend to be noticeably slower than Triton on modern hardware when applicable (e.g., V100/A100 tensor cores w/ equal tile sizes). I do believe that this is not a fundamental issue of scheduling languages -- in the sense that it could probably be solved with more efforts -- but it could mean that these systems are harder to engineer. More importantly, existing scheduling languages generate loops whose bounds and increments cannot depend on surrounding loop indices without at least imposing severe constraints on possible schedules -- if not breaking the system entirely. This is problematic for sparse computations, whose iteration spaces may be irregular.\n \n@@ -181,7 +183,7 @@ This ease-of-development comes at a cost. First of all, existing systems that fo\n     |   for(int j = 0; j < 4; j++)                        |                                                     |\n     |     float acc = 0;                                  |                                                     |\n     |     for(int k = 0; k < K[i]; k++)                   |                                                     |\n-    |       acc += A[i][col[i,k]]*B[k][j]                 |                                                     |\n+    |       acc += A[i][col[i, k]] * B[k][j]              |                                                     |\n     |     C[i][j] = acc;                                  |                                                     |\n     +-----------------------------------------------------+-----------------------------------------------------+\n \n@@ -190,9 +192,10 @@ This ease-of-development comes at a cost. First of all, existing systems that fo\n \n On the other hand, the block-based program representation that we advocate for through this work allows for block-structured iteration spaces and allows programmers to manually handle load-balancing as they wish.\n \n---------------\n+\n+----------\n References\n---------------\n+----------\n \n .. [LATTNER2004] C. Lattner et al., \"LLVM: a compilation framework for lifelong program analysis transformation\", CGO 2004\n .. [WOLFE1989] M. Wolfe, \"More Iteration Space Tiling\", SC 1989"}, {"filename": "docs/python-api/triton.language.rst", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "file_content_changes": "@@ -1,11 +1,11 @@\n triton.language\n-================\n+===============\n \n .. currentmodule:: triton.language\n \n \n Programming Model\n--------------------\n+-----------------\n \n .. autosummary::\n     :toctree: generated\n@@ -16,7 +16,7 @@ Programming Model\n \n \n Creation Ops\n--------------\n+------------\n \n .. autosummary::\n     :toctree: generated\n@@ -27,7 +27,7 @@ Creation Ops\n \n \n Shape Manipulation Ops\n------------------------\n+----------------------\n \n .. autosummary::\n     :toctree: generated\n@@ -40,16 +40,17 @@ Shape Manipulation Ops\n \n \n Linear Algebra Ops\n--------------------\n+------------------\n \n .. autosummary::\n     :toctree: generated\n     :nosignatures:\n \n     dot\n \n+\n Memory Ops\n---------------------\n+----------\n \n .. autosummary::\n     :toctree: generated\n@@ -62,7 +63,7 @@ Memory Ops\n \n \n Indexing Ops\n---------------\n+------------\n \n .. autosummary::\n     :toctree: generated\n@@ -72,7 +73,7 @@ Indexing Ops\n \n \n Math Ops\n-----------\n+--------\n \n .. autosummary::\n     :toctree: generated\n@@ -88,7 +89,7 @@ Math Ops\n \n \n Reduction Ops\n----------------\n+-------------\n \n .. autosummary::\n     :toctree: generated\n@@ -98,8 +99,9 @@ Reduction Ops\n     min\n     sum\n \n+\n Atomic Ops\n----------------\n+----------\n \n .. autosummary::\n     :toctree: generated\n@@ -112,7 +114,7 @@ Atomic Ops\n \n \n Comparison ops\n----------------\n+--------------\n \n .. autosummary::\n     :toctree: generated\n@@ -124,7 +126,7 @@ Comparison ops\n .. _Random Number Generation:\n \n Random Number Generation\n--------------------------\n+------------------------\n \n .. autosummary::\n     :toctree: generated\n@@ -135,11 +137,12 @@ Random Number Generation\n     rand\n     randn\n \n+\n Compiler Hint Ops\n--------------------\n+-----------------\n \n .. autosummary::\n     :toctree: generated\n     :nosignatures:\n \n-    multiple_of\n\\ No newline at end of file\n+    multiple_of"}, {"filename": "docs/python-api/triton.rst", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1,5 +1,5 @@\n triton\n-========\n+======\n \n .. currentmodule:: triton\n \n@@ -10,4 +10,4 @@ triton\n     jit\n     autotune\n     heuristics\n-    Config\n\\ No newline at end of file\n+    Config"}, {"filename": "docs/python-api/triton.testing.rst", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1,5 +1,5 @@\n triton.testing\n-================\n+==============\n \n .. currentmodule:: triton.testing\n \n@@ -9,4 +9,4 @@ triton.testing\n \n     do_bench\n     Benchmark\n-    perf_report\n\\ No newline at end of file\n+    perf_report"}, {"filename": "include/triton/Analysis/AxisInfo.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "file_content_changes": "@@ -112,7 +112,8 @@ class AxisInfo {\n \n   /// The _divisibility_ information maps the `d`-th\n   /// dimension to the largest power-of-two that\n-  /// divides the first element of all the values along it\n+  /// divides the first element of all groups of\n+  // _contiguity_ values along it\n   /// For example:\n   /// [10, 11, 12, 13, 18, 19, 20, 21]\n   /// [20, 21, 22, 23, 28, 29, 30, 31]\n@@ -123,6 +124,10 @@ class AxisInfo {\n   /// [14, 18, 22, 26]\n   /// [15, 19, 23, 27]\n   //  would have divisibility [4, 1]\n+  //  On the other hand:\n+  //  [0, 1, 2, 0, 4, 5, 6, 7]\n+  //  would have divisibility 1 because\n+  //  _contiguity_=1\n   DimVectorT divisibility;\n \n   /// The _constancy_ information maps the `d`-th"}, {"filename": "include/triton/Conversion/CMakeLists.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "file_content_changes": "@@ -1,4 +1,3 @@\n-\n set(LLVM_TARGET_DEFINITIONS Passes.td)\n mlir_tablegen(Passes.h.inc -gen-pass-decls)\n-add_public_tablegen_target(TritonConversionPassIncGen)\n\\ No newline at end of file\n+add_public_tablegen_target(TritonConversionPassIncGen)"}, {"filename": "include/triton/Dialect/TritonGPU/IR/CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -9,4 +9,3 @@ set(LLVM_TARGET_DEFINITIONS TritonGPUAttrDefs.td)\n mlir_tablegen(TritonGPUAttrDefs.h.inc -gen-attrdef-decls)\n mlir_tablegen(TritonGPUAttrDefs.cpp.inc -gen-attrdef-defs)\n add_public_tablegen_target(TritonGPUAttrDefsIncGen)\n-"}, {"filename": "lib/Analysis/Allocation.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -65,7 +65,7 @@ getScratchConfigForCvtLayout(triton::gpu::ConvertLayoutOp op, unsigned &inVec,\n         return {};\n \n   assert(srcLayout && dstLayout &&\n-         \"Unexpect layout in getScratchConfigForCvtLayout()\");\n+         \"Unexpected layout in getScratchConfigForCvtLayout()\");\n   auto [inOrd, outOrd] = getCvtOrder(srcLayout, dstLayout);\n   unsigned srcContigPerThread = getContigPerThread(srcLayout)[inOrd[0]];\n   unsigned dstContigPerThread = getContigPerThread(dstLayout)[outOrd[0]];"}, {"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "file_content_changes": "@@ -164,16 +164,16 @@ class MakeRangeOpAxisInfoVisitor final\n   }\n };\n \n-class ConstantOpAxisInfoVisitor final\n-    : public AxisInfoVisitorImpl<arith::ConstantOp> {\n+template <typename OpTy>\n+class ConstantOpAxisInfoVisitor final : public AxisInfoVisitorImpl<OpTy> {\n public:\n-  using AxisInfoVisitorImpl<arith::ConstantOp>::AxisInfoVisitorImpl;\n+  using AxisInfoVisitorImpl<OpTy>::AxisInfoVisitorImpl;\n \n   AxisInfo\n-  getAxisInfo(arith::ConstantOp op,\n+  getAxisInfo(OpTy op,\n               ArrayRef<const dataflow::Lattice<AxisInfo> *> operands) override {\n-    auto intAttr = op.getValue().dyn_cast<IntegerAttr>();\n-    auto boolAttr = op.getValue().dyn_cast<BoolAttr>();\n+    auto intAttr = op.getValue().template dyn_cast<IntegerAttr>();\n+    auto boolAttr = op.getValue().template dyn_cast<BoolAttr>();\n     if (intAttr || boolAttr) {\n       int64_t value{};\n       if (intAttr)\n@@ -186,10 +186,10 @@ class ConstantOpAxisInfoVisitor final\n                       /*knownConstantValue=*/{value});\n     }\n     // TODO: generalize to dense attr\n-    auto splatAttr = op.getValue().dyn_cast<SplatElementsAttr>();\n+    auto splatAttr = op.getValue().template dyn_cast<SplatElementsAttr>();\n     if (splatAttr && splatAttr.getElementType().isIntOrIndex()) {\n-      int64_t value = splatAttr.getSplatValue<APInt>().getZExtValue();\n-      TensorType ty = splatAttr.getType().cast<TensorType>();\n+      int64_t value = splatAttr.template getSplatValue<APInt>().getZExtValue();\n+      TensorType ty = splatAttr.getType().template cast<TensorType>();\n       return AxisInfo(\n           /*contiguity=*/AxisInfo::DimVectorT(ty.getRank(), 1),\n           /*divisibility=*/\n@@ -233,7 +233,8 @@ class AddSubOpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n     if (lhs.getConstantValue().has_value() &&\n         rhs.getConstantValue().has_value()) {\n       if constexpr (std::is_same_v<OpTy, arith::AddIOp> ||\n-                    std::is_same_v<OpTy, triton::AddPtrOp>) {\n+                    std::is_same_v<OpTy, triton::AddPtrOp> ||\n+                    std::is_same_v<OpTy, LLVM::AddOp>) {\n         return {lhs.getConstantValue().value() +\n                 rhs.getConstantValue().value()};\n       } else if constexpr (std::is_same_v<OpTy, arith::SubIOp>) {\n@@ -334,14 +335,11 @@ class DivOpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n     if (lhs.getConstantValue().has_value() &&\n         lhs.getConstantValue().value() == 0)\n       return lhs.getDivisibility(dim);\n-    // Case 2: rhs is constant\n-    if (rhs.getConstantValue().has_value()) {\n-      auto lhsDivisibility = lhs.getDivisibility(dim);\n-      auto rhsValue = rhs.getConstantValue().value();\n-      if (lhsDivisibility % rhsValue == 0)\n-        return lhsDivisibility / rhsValue;\n-    }\n-    // Case 3: both are not constant\n+    // Case 2: rhs is 1\n+    if (rhs.getConstantValue().has_value() &&\n+        rhs.getConstantValue().value() == 1)\n+      return lhs.getDivisibility(dim);\n+    // otherwise: return 1\n     return 1;\n   }\n \n@@ -815,11 +813,15 @@ AxisInfoAnalysis::AxisInfoAnalysis(DataFlowSolver &solver)\n                   CastOpAxisInfoVisitor<triton::gpu::ConvertLayoutOp>,\n                   CastOpAxisInfoVisitor<mlir::UnrealizedConversionCastOp>,\n                   CastOpAxisInfoVisitor<triton::BitcastOp>>();\n+  // TODO: Remove rules for LLVM::ConstantOp, LLVM::AddOp\n+  // when scf.for supports integers induction variable\n   visitors.append<MakeRangeOpAxisInfoVisitor>();\n-  visitors.append<ConstantOpAxisInfoVisitor>();\n+  visitors.append<ConstantOpAxisInfoVisitor<arith::ConstantOp>,\n+                  ConstantOpAxisInfoVisitor<LLVM::ConstantOp>>();\n   visitors.append<AddSubOpAxisInfoVisitor<triton::AddPtrOp>,\n                   AddSubOpAxisInfoVisitor<arith::AddIOp>,\n-                  AddSubOpAxisInfoVisitor<arith::SubIOp>>();\n+                  AddSubOpAxisInfoVisitor<arith::SubIOp>,\n+                  AddSubOpAxisInfoVisitor<LLVM::AddOp>>();\n   visitors.append<MulIOpAxisInfoVisitor>();\n   visitors.append<DivOpAxisInfoVisitor<arith::DivSIOp>,\n                   DivOpAxisInfoVisitor<arith::DivUIOp>>();"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -234,9 +234,9 @@ struct ConvertLayoutOpConversion\n     }\n   }\n \n-  // The MMAV1's result is quite different from the exising \"Replica\" structure,\n-  // add a new simple but clear implementation for it to avoid modificating the\n-  // logic of the exising one.\n+  // The MMAV1's result is quite different from the existing \"Replica\"\n+  // structure, add a new simple but clear implementation for it to avoid\n+  // modifying the logic of the existing one.\n   void processReplicaForMMAV1(Location loc, ConversionPatternRewriter &rewriter,\n                               bool stNotRd, RankedTensorType type,\n                               ArrayRef<unsigned> multiDimRepId, unsigned vec,"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1356,7 +1356,7 @@ int DotOpFMAConversionHelper::getNumElemsPerThread(\n   auto shapePerCTA = getShapePerCTA(blockedLayout);\n   auto sizePerThread = getSizePerThread(blockedLayout);\n \n-  // TODO[Superjomn]: we assume the k aixs is fixed for $a and $b here, fix it\n+  // TODO[Superjomn]: we assume the k axis is fixed for $a and $b here, fix it\n   // if not.\n   int K = dotOpLayout.getOpIdx() == 0 ? shape[1] : shape[0];\n   int otherDim = dotOpLayout.getOpIdx() == 1 ? shape[1] : shape[0];"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -332,7 +332,7 @@ class MMA16816SmemLoader {\n };\n \n // This class helps to adapt the existing DotOpConversion to the latest\n-// DotOpOperand layout design. It decouples the exising implementation to two\n+// DotOpOperand layout design. It decouples the existing implementation to two\n // parts:\n // 1. loading the specific operand matrix(for $a, $b, $c) from smem\n // 2. passing the loaded value and perform the mma codegen"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ReduceOpToLLVM.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -434,7 +434,7 @@ struct ReduceOpConversion\n \n     // We could avoid this barrier in some of the layouts, however this is not\n     // the general case.\n-    // TODO: optimize the barrier incase the layouts are accepted.\n+    // TODO: optimize the barrier in case the layouts are accepted.\n     barrier();\n \n     // set output values"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -299,7 +299,7 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n       Value idxRow = idx[outOrder[1]]; // discontiguous dimension\n       Value strideCol = srcStrides[outOrder[0]];\n       Value strideRow = srcStrides[outOrder[1]];\n-      // extract dynamic/static offset for immediate offseting\n+      // extract dynamic/static offset for immediate offsetting\n       unsigned immedateOffCol = 0;\n       if (auto add = dyn_cast_or_null<LLVM::AddOp>(idxCol.getDefiningOp()))\n         if (auto _cst = dyn_cast_or_null<LLVM::ConstantOp>(\n@@ -311,7 +311,7 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n           idxCol = cacheCol[key];\n           immedateOffCol = cst / (outVec * maxPhase) * (outVec * maxPhase);\n         }\n-      // extract dynamic/static offset for immediate offseting\n+      // extract dynamic/static offset for immediate offsetting\n       unsigned immedateOffRow = 0;\n       if (auto add = dyn_cast_or_null<LLVM::AddOp>(idxRow.getDefiningOp()))\n         if (auto _cst = dyn_cast_or_null<LLVM::ConstantOp>(\n@@ -363,7 +363,7 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     auto srcDistributedLayout = srcTy.getEncoding();\n     if (auto mmaLayout = srcDistributedLayout.dyn_cast<MmaEncodingAttr>()) {\n       assert((!mmaLayout.isVolta()) &&\n-             \"ConvertLayout MMAv1->Shared is not suppported yet\");\n+             \"ConvertLayout MMAv1->Shared is not supported yet\");\n     }\n     auto dstSharedLayout =\n         dstTy.getEncoding().cast<triton::gpu::SharedEncodingAttr>();\n@@ -618,7 +618,7 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n \n     SmallVector<Value> multiDimBase(rank);\n     for (unsigned k = 0; k < rank; ++k) {\n-      // Wrap around multiDimWarpId/multiDimThreadId incase\n+      // Wrap around multiDimWarpId/multiDimThreadId in case\n       // shape[k] > shapePerCTA[k]\n       auto maxWarps =\n           ceil<unsigned>(shape[k], sizePerThread[k] * threadsPerWarp[k]);"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "file_content_changes": "@@ -261,7 +261,7 @@ translateLLVMToLLVMIR(llvm::LLVMContext *llvmContext, mlir::ModuleOp module) {\n   }\n \n   auto optPipeline = mlir::makeOptimizingTransformer(\n-      /*optLevel=*/3, /*sizeLevel=*/0,\n+      /*optLevel=*/0, /*sizeLevel=*/0,\n       /*targetMachine=*/nullptr);\n \n   if (auto err = optPipeline(llvmModule.get())) {\n@@ -310,7 +310,6 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n     return nullptr;\n   }\n \n-  // llvm::outs() << module << \"\\n\";\n   auto llvmIR = translateLLVMToLLVMIR(llvmContext, module);\n   if (!llvmIR) {\n     llvm::errs() << \"Translate to LLVM IR failed\";"}, {"filename": "python/examples/copy_strided.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1,4 +1,3 @@\n-\n import triton\n import triton.language as tl\n "}, {"filename": "python/setup.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -83,8 +83,8 @@ def get_thirdparty_packages(triton_cache_path):\n         if p.syspath_var_name in os.environ:\n             package_dir = os.environ[p.syspath_var_name]\n         version_file_path = os.path.join(package_dir, \"version.txt\")\n-        if not os.path.exists(version_file_path) or\\\n-           Path(version_file_path).read_text() != p.url:\n+        if p.syspath_var_name not in os.environ and\\\n+           (not os.path.exists(version_file_path) or Path(version_file_path).read_text() != p.url):\n             try:\n                 shutil.rmtree(package_root_dir)\n             except Exception:"}, {"filename": "python/test/regression/test_performance.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -56,7 +56,7 @@ def nvsmi(attrs):\n     'a100': {\n         (512, 512, 512): {'float16': 0.08, 'float32': 0.13, 'int8': 0.05},\n         (1024, 1024, 1024): {'float16': 0.33, 'float32': 0.35, 'int8': 0.169},\n-        (2048, 2048, 2048): {'float16': 0.64, 'float32': 0.57, 'int8': 0.34},\n+        (2048, 2048, 2048): {'float16': 0.59, 'float32': 0.57, 'int8': 0.34},\n         (4096, 4096, 4096): {'float16': 0.81, 'float32': 0.75, 'int8': 0.46},\n         (8192, 8192, 8192): {'float16': 0.77, 'float32': 0.85, 'int8': 0.51},\n         # tall-skinny"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "file_content_changes": "@@ -295,6 +295,43 @@ def test_floordiv(dtype_x, dtype_y, device='cuda'):\n     _test_binary(dtype_x, dtype_y, expr, numpy_expr, device=device)\n \n \n+def test_unsigned_name_mangling(device='cuda'):\n+    # Test that uint32 and int32 are mangled differently by the compiler\n+    SIZE = 128\n+    # define the kernel / launch-grid\n+\n+    @triton.jit\n+    def kernel(O1, O2, X, Y, SIZE: tl.constexpr):\n+        off = tl.arange(0, SIZE)\n+        x = tl.load(X + off)\n+        y = tl.load(Y + off)\n+        out1 = tl.abs(x)  # uint32 -> nop\n+        out2 = tl.abs(-y)  # int32 -> should have an effect\n+        tl.store(O1 + off, out1)\n+        tl.store(O2 + off, out2)\n+\n+    dtype_x = 'uint32'\n+    dtype_y = 'int32'\n+    # inputs\n+    rs = RandomState(17)\n+    x = numpy_random(SIZE, dtype_str=dtype_x, rs=rs)\n+    y = numpy_random(SIZE, dtype_str=dtype_y, rs=rs)\n+    # reference result\n+    expect = (np.abs(x), np.abs(-y))\n+    # triton result\n+    x_tri = to_triton(x, device=device, dst_type=dtype_x)\n+    y_tri = to_triton(y, device=device, dst_type=dtype_y)\n+    actual = tuple(\n+        to_triton(np.empty_like(e), device=device)\n+        for e in expect\n+    )\n+    kernel[(1, )](actual[0], actual[1], x_tri, y_tri, SIZE=SIZE, num_warps=4)\n+\n+    # Bitwise op, so expect exact equality\n+    assert (expect[0] == to_numpy(actual[0])).all()\n+    assert (expect[1] == to_numpy(actual[1])).all()\n+\n+\n # ---------------\n # test bitwise ops\n # ---------------\n@@ -1140,7 +1177,8 @@ def kernel(X, stride_xm, stride_xn,\n                                            [128, 128, 64, 4],\n                                            [64, 128, 128, 4],\n                                            [32, 128, 64, 2],\n-                                           [128, 128, 64, 2],\n+                                           # triggers nvptx/ptxas bug on V100 currently\n+                                           # [128, 128, 64, 2],\n                                            [64, 128, 128, 2]]\n                           for allow_tf32 in [True]\n                           for col_a in [True, False]\n@@ -1980,7 +2018,7 @@ def kernel(InitI, Bound, CutOff, OutI, OutJ):\n # -----------------------\n # test layout conversions\n # -----------------------\n-# TODO: backend hsould be tested separately\n+# TODO: backend should be tested separately\n \n \n class MmaLayout:"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "file_content_changes": "@@ -57,7 +57,9 @@ def mangle_ty(ty):\n     if ty.is_ptr():\n         return 'P' + mangle_ty(ty.element_ty)\n     if ty.is_int():\n-        return 'i' + str(ty.int_bitwidth)\n+        SIGNED = triton.language.dtype.SIGNEDNESS.SIGNED\n+        prefix = 'i' if ty.int_signedness == SIGNED else 'u'\n+        return prefix + str(ty.int_bitwidth)\n     if ty.is_fp8():\n         return 'fp8'\n     if ty.is_fp16():\n@@ -903,6 +905,22 @@ def visit_Expr(self, node):\n     def visit_NoneType(self, node):\n         return None\n \n+    def visit_JoinedStr(self, node):\n+        values = list(node.values)\n+        for i, value in enumerate(values):\n+            if isinstance(value, ast.Constant):\n+                values[i] = str(value.value)\n+            elif isinstance(value, ast.FormattedValue):\n+                conversion_code = value.conversion\n+                evaluated = self.visit(value.value)\n+                if not isinstance(evaluated, triton.language.constexpr):\n+                    raise NotImplementedError(\"Cannot evaluate f-string containing non-constexpr conversion values,\"\n+                                              \" found conversion of type \" + str(type(evaluated)))\n+                values[i] = (\"{}\" if conversion_code < 0 else \"{!\" + chr(conversion_code) + \"}\").format(evaluated.value)\n+            else:\n+                raise AssertionError(\"encountered unexpected node of type {} in a JoinedStr node\".format(type(value)))\n+        return ''.join(values)\n+\n     def visit(self, node):\n         if node is not None:\n             self.last_node = node\n@@ -996,7 +1014,7 @@ def build_triton_ir(fn, signature, specialization, constants, debug=False):\n         generator.visit(fn.parse())\n     except Exception as e:\n         node = generator.last_node\n-        if node is None or isinstance(e, (NotImplementedError, CompilationError)):\n+        if node is None or isinstance(e, CompilationError):\n             raise e\n         raise CompilationError(fn.src, node) from e\n     ret = generator.module"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "file_content_changes": "@@ -37,8 +37,8 @@ def _to_tensor(x, builder):\n \n \n class dtype:\n-    SINT_TYPES = ['int1', 'int8', 'int16', 'int32', 'int64']\n-    UINT_TYPES = ['uint8', 'uint16', 'uint32', 'uint64']\n+    SINT_TYPES = ['int8', 'int16', 'int32', 'int64']\n+    UINT_TYPES = ['int1', 'uint8', 'uint16', 'uint32', 'uint64']\n     FP_TYPES = ['fp8e4', 'fp8e5', 'fp16', 'bf16', 'fp32', 'fp64']\n     STANDARD_FP_TYPES = ['fp16', 'bf16', 'fp32', 'fp64']\n     OTHER_TYPES = ['void']\n@@ -898,7 +898,7 @@ def load(pointer, mask=None, other=None, cache_modifier=\"\", eviction_policy=\"\",\n     :param other: if mask[idx] is false, return other[idx]\n     :type other: Block, optional\n     :param cache_modifier: changes cache option in nvidia ptx\n-    'type cache_modifier: str, optional\n+    :type cache_modifier: str, optional\n     \"\"\"\n     # mask, other can be constexpr\n     if _constexpr_to_value(mask) is not None:\n@@ -1065,7 +1065,7 @@ def _add_math_1arg_docstr(name: str) -> Callable[[T], T]:\n \n     def _decorator(func: T) -> T:\n         docstr = \"\"\"\n-    Computes the element-wise {name} of :code:`x`\n+    Computes the element-wise {name} of :code:`x`.\n \n     :param x: the input values\n     :type x: Block\n@@ -1275,7 +1275,7 @@ def softmax(x, ieee_rounding=False):\n @triton.jit\n def ravel(x):\n     \"\"\"\n-    Returns a contiguous flattened view of :code:`x`\n+    Returns a contiguous flattened view of :code:`x`.\n \n     :param x: the input tensor\n     :type x: Block"}, {"filename": "python/triton/language/random.py", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -106,7 +106,7 @@ def uint32_to_uniform_float(x):\n def rand(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n     \"\"\"\n     Given a :code:`seed` scalar and an :code:`offset` block,\n-    returns a block of random :code:`float32` in :math:`U(0, 1)`\n+    returns a block of random :code:`float32` in :math:`U(0, 1)`.\n \n     :param seed: The seed for generating random numbers.\n     :param offsets: The offsets to generate random numbers for.\n@@ -120,7 +120,7 @@ def rand(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n def rand4x(seed, offsets, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n     \"\"\"\n     Given a :code:`seed` scalar and an :code:`offsets` block,\n-    returns a 4 blocks of random :code:`float32` in :math:`U(0, 1)`\n+    returns a 4 blocks of random :code:`float32` in :math:`U(0, 1)`.\n \n     :param seed: The seed for generating random numbers.\n     :param offsets: The offsets to generate random numbers for.\n@@ -151,7 +151,7 @@ def pair_uniform_to_normal(u1, u2):\n def randn(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n     \"\"\"\n     Given a :code:`seed` scalar and an :code:`offset` block,\n-    returns a block of random :code:`float32` in :math:`\\\\mathcal{N}(0, 1)`\n+    returns a block of random :code:`float32` in :math:`\\\\mathcal{N}(0, 1)`.\n \n     :param seed: The seed for generating random numbers.\n     :param offsets: The offsets to generate random numbers for.\n@@ -167,7 +167,7 @@ def randn(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n def randn4x(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n     \"\"\"\n     Given a :code:`seed` scalar and an :code:`offset` block,\n-    returns a 4 blocks of random :code:`float32` in :math:`\\\\mathcal{N}(0, 1)`\n+    returns a 4 blocks of random :code:`float32` in :math:`\\\\mathcal{N}(0, 1)`.\n \n     :param seed: The seed for generating random numbers.\n     :param offsets: The offsets to generate random numbers for."}, {"filename": "python/triton/ops/blocksparse/matmul.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -181,8 +181,8 @@ def _dsd_kernel(\n     inc_b = tl.load(pinc)\n     inc_b = tl.multiple_of(inc_b, 8)\n     for k in range(K, 0, -TILE_K):\n-        a = tl.load(pa, mask=True)\n-        b = tl.load(pb, mask=offs_bn[None, :] < DS0)\n+        a = tl.load(pa)\n+        b = tl.load(pb)\n         acc += tl.dot(a, b)\n         pa += inc_a\n         pb += inc_b * stride_bk"}, {"filename": "python/triton/runtime/autotuner.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -165,7 +165,7 @@ def autotune(configs, key, prune_configs_by=None, reset_to_zero=None):\n         @triton.jit\n         def kernel(x_ptr, x_size, **META):\n             BLOCK_SIZE = META['BLOCK_SIZE']\n-    :note: When all the configurations are evaluated, the kernel will run multiple time.\n+    :note: When all the configurations are evaluated, the kernel will run multiple times.\n            This means that whatever value the kernel updates will be updated multiple times.\n            To avoid this undesired behavior, you can use the `reset_to_zero` argument, which\n            resets the value of the provided tensor to `zero` before running any configuration.\n@@ -209,9 +209,9 @@ def heuristics(values):\n         @triton.jit\n         def kernel(x_ptr, x_size, **META):\n             BLOCK_SIZE = META['BLOCK_SIZE'] # smallest power-of-two >= x_size\n-    .param values: a dictionary of meta-parameter names and functions that compute the value of the meta-parameter.\n+    :param values: a dictionary of meta-parameter names and functions that compute the value of the meta-parameter.\n                    each such function takes a list of positional arguments as input.\n-    .type values: dict[str, Callable[[list[Any]], Any]]\n+    :type values: dict[str, Callable[[list[Any]], Any]]\n     \"\"\"\n     def decorator(fn):\n         return Heuristics(fn, fn.arg_names, values)"}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "file_content_changes": "@@ -316,7 +316,9 @@ def __init__(self, fn, version=None, do_not_specialize=None, debug=None):\n         self.annotations = {self.arg_names.index(name): ty for name, ty in fn.__annotations__.items()}\n         self.__annotations__ = fn.__annotations__\n         # index of constexprs\n-        self.constexprs = [self.arg_names.index(ann) for ann in self.__annotations__.keys()]\n+        from triton.language.core import \\\n+            constexpr  # import here rather than at module level due to circular import tangle\n+        self.constexprs = [index for index, ty in self.annotations.items() if isinstance(ty, type) and issubclass(ty, constexpr)]\n         # launcher\n         self.run = self._make_launcher()\n         # re-use docs of wrapped function"}, {"filename": "python/tutorials/01-vector-add.py", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "file_content_changes": "@@ -1,16 +1,18 @@\n \"\"\"\n Vector Addition\n-=================\n-In this tutorial, you will write a simple vector addition using Triton and learn about:\n+===============\n \n+In this tutorial, you will write a simple vector addition using Triton.\n+\n+In doing so, you will learn about:\n - The basic programming model of Triton.\n - The `triton.jit` decorator, which is used to define Triton kernels.\n - The best practices for validating and benchmarking your custom ops against native reference implementations.\n \"\"\"\n \n # %%\n # Compute Kernel\n-# --------------------------\n+# --------------\n \n import torch\n \n@@ -92,9 +94,10 @@ def add(x: torch.Tensor, y: torch.Tensor):\n \n # %%\n # Benchmark\n-# -----------\n+# ---------\n+#\n # We can now benchmark our custom op on vectors of increasing sizes to get a sense of how it does relative to PyTorch.\n-# To make things easier, Triton has a set of built-in utilities that allow us to concisely plot the performance of your custom ops.\n+# To make things easier, Triton has a set of built-in utilities that allow us to concisely plot the performance of our custom ops.\n # for different problem sizes.\n \n "}, {"filename": "python/tutorials/02-fused-softmax.py", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "file_content_changes": "@@ -1,18 +1,20 @@\n \"\"\"\n Fused Softmax\n-=================\n+=============\n+\n In this tutorial, you will write a fused softmax operation that is significantly faster\n than PyTorch's native op for a particular class of matrices: those whose rows can fit in\n the GPU's SRAM.\n-You will learn about:\n \n+In doing so, you will learn about:\n - The benefits of kernel fusion for bandwidth-bound operations.\n - Reduction operators in Triton.\n \"\"\"\n \n # %%\n # Motivations\n-# ------------\n+# -----------\n+#\n # Custom GPU kernels for elementwise additions are educationally valuable but won't get you very far in practice.\n # Let us consider instead the case of a simple (numerically stabilized) softmax operation:\n \n@@ -55,9 +57,11 @@ def naive_softmax(x):\n \n # %%\n # Compute Kernel\n-# ----------------\n+# --------------\n+#\n # Our softmax kernel works as follows: each program loads a row of the input matrix X,\n # normalizes it and writes back the result to the output Y.\n+#\n # Note that one important limitation of Triton is that each block must have a\n # power-of-two number of elements, so we need to internally \"pad\" each row and guard the\n # memory operations properly if we want to handle any possible input shapes:\n@@ -93,6 +97,7 @@ def softmax_kernel(\n # %%\n # We can create a helper function that enqueues the kernel and its (meta-)arguments for any given input tensor.\n \n+\n def softmax(x):\n     n_rows, n_cols = x.shape\n     # The block size is the smallest power of two greater than the number of columns in `x`\n@@ -124,7 +129,7 @@ def softmax(x):\n \n # %%\n # Unit Test\n-# ----------\n+# ---------\n \n # %%\n # We make sure that we test our kernel on a matrix with an irregular number of rows and columns.\n@@ -141,7 +146,8 @@ def softmax(x):\n \n # %%\n # Benchmark\n-# -------------\n+# ---------\n+#\n # Here we will benchmark our operation as a function of the number of columns in the input matrix -- assuming 4096 rows.\n # We will then compare its performance against (1) :code:`torch.softmax` and (2) the :code:`naive_softmax` defined above.\n \n@@ -185,7 +191,6 @@ def benchmark(M, N, provider):\n \n # %%\n # In the above plot, we can see that:\n-#\n #  - Triton is 4x faster than the Torch JIT. This confirms our suspicions that the Torch JIT does not do any fusion here.\n #  - Triton is noticeably faster than :code:`torch.softmax` -- in addition to being **easier to read, understand and maintain**.\n #    Note however that the PyTorch `softmax` operation is more general and will work on tensors of any shape."}, {"filename": "python/tutorials/03-matrix-multiplication.py", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "file_content_changes": "@@ -1,10 +1,10 @@\n \"\"\"\n Matrix Multiplication\n-======================\n+=====================\n In this tutorial, you will write a 25-lines high-performance FP16 matrix multiplication\n kernel that achieves performance on par with cuBLAS.\n-You will specifically learn about:\n \n+In doing so, you will learn about:\n - Block-level matrix multiplications\n - Multi-dimensional pointer arithmetic\n - Program re-ordering for improved L2 cache hit rate\n@@ -13,7 +13,8 @@\n \n # %%\n # Motivations\n-# -------------\n+# -----------\n+#\n # Matrix multiplications are a key building block of most modern high-performance computing systems.\n # They are notoriously hard to optimize, hence their implementation is generally done by\n # hardware vendors themselves as part of so-called \"kernel libraries\" (e.g., cuBLAS).\n@@ -42,15 +43,16 @@\n \n # %%\n # Compute Kernel\n-# ----------------\n+# --------------\n #\n # The above algorithm is, actually, fairly straightforward to implement in Triton.\n # The main difficulty comes from the computation of the memory locations at which blocks\n # of :code:`A` and :code:`B` must be read in the inner loop. For that, we need\n-# multi-dimensional pointer arithmetics.\n+# multi-dimensional pointer arithmetic.\n+#\n #\n-# Pointer Arithmetics\n-# ~~~~~~~~~~~~~~~~~~~~\n+# Pointer Arithmetic\n+# ~~~~~~~~~~~~~~~~~~\n #\n # For a row-major 2D tensor :code:`X`, the memory location of :code:`X[i, j]` is given b\n # y :code:`&X[i, j] = X + i*stride_xi + j*stride_xj`.\n@@ -81,7 +83,7 @@\n #\n #\n # L2 Cache Optimizations\n-# ~~~~~~~~~~~~~~~~~~~~~~~~\n+# ~~~~~~~~~~~~~~~~~~~~~~\n #\n # As mentioned above, each program instance computes a :code:`[BLOCK_SIZE_M, BLOCK_SIZE_N]`\n # block of :code:`C`.\n@@ -137,8 +139,7 @@\n \n # %%\n # Final Result\n-# -------------\n-#\n+# ------------\n \n import torch\n \n@@ -201,7 +202,7 @@ def matmul_kernel(\n     # and accumulate\n     # a_ptrs is a block of [BLOCK_SIZE_M, BLOCK_SIZE_K] pointers\n     # b_ptrs is a block of [BLOCK_SIZE_K, BLOCK_SIZE_n] pointers\n-    # see above `Pointer Arithmetics` section for details\n+    # see above `Pointer Arithmetic` section for details\n     offs_am = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n     offs_bn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n     offs_k = tl.arange(0, BLOCK_SIZE_K)\n@@ -281,7 +282,7 @@ def matmul(a, b, activation=None):\n \n # %%\n # Unit Test\n-# -----------\n+# ---------\n #\n # We can test our custom matrix multiplication operation against a native torch implementation (i.e., cuBLAS)\n \n@@ -299,10 +300,11 @@ def matmul(a, b, activation=None):\n \n # %%\n # Benchmark\n-# --------------\n+# ---------\n #\n # Square Matrix Performance\n # ~~~~~~~~~~~~~~~~~~~~~~~~~~\n+#\n # We can now compare the performance of our kernel against that of cuBLAS. Here we focus on square matrices, but feel free to arrange this script as you wish to benchmark any other matrix shape.\n \n "}, {"filename": "python/tutorials/04-low-memory-dropout.py", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "file_content_changes": "@@ -1,18 +1,20 @@\n \"\"\"\n Low-Memory Dropout\n-=================\n+==================\n \n In this tutorial, you will write a memory-efficient implementation of dropout whose state\n will be composed of a single int32 seed. This differs from more traditional implementations of dropout,\n-whose state is generally composed of a bit mask tensor of the same shape as the input. You will learn about:\n+whose state is generally composed of a bit mask tensor of the same shape as the input.\n \n+In doing so, you will learn about:\n - The limitations of naive implementations of Dropout with PyTorch\n - Parallel pseudo-random number generation in Triton\n \"\"\"\n \n # %%\n # Baseline\n-# -------------\n+# --------\n+#\n # The *dropout* operator was first introduced in [SRIVASTAVA2014]_ as a way to improve the performance\n # of deep neural networks in low-data regime (i.e. regularization).\n #\n@@ -37,12 +39,12 @@\n \n @triton.jit\n def _dropout(\n-        x_ptr,  # pointer to the input\n-        x_keep_ptr,  # pointer to a mask of 0s and 1s\n-        output_ptr,  # pointer to the output\n-        n_elements,  # number of elements in the `x` tensor\n-        p,  # probability that an element of `x` is changed to zero\n-        BLOCK_SIZE: tl.constexpr,\n+    x_ptr,  # pointer to the input\n+    x_keep_ptr,  # pointer to a mask of 0s and 1s\n+    output_ptr,  # pointer to the output\n+    n_elements,  # number of elements in the `x` tensor\n+    p,  # probability that an element of `x` is changed to zero\n+    BLOCK_SIZE: tl.constexpr,\n ):\n     pid = tl.program_id(axis=0)\n     block_start = pid * BLOCK_SIZE\n@@ -81,15 +83,16 @@ def dropout(x, x_keep, p):\n \n # %%\n # Seeded dropout\n-# -------------\n-# Above implementation of dropout works fine, but it can be a bit awkward to deal with. Firstly\n+# --------------\n+#\n+# The above implementation of dropout works fine, but it can be a bit awkward to deal with. Firstly\n # we need to store the dropout mask for backpropagation. Secondly, dropout state management can get\n # very tricky when using recompute/checkpointing (e.g. see all the notes about `preserve_rng_state` in\n # https://pytorch.org/docs/1.9.0/checkpoint.html). In this tutorial we'll describe an alternative implementation\n # that (1) has a smaller memory footprint; (2) requires less data movement; and (3) simplifies the management\n # of persisting randomness across multiple invocations of the kernel.\n #\n-# Pseudorandom number generation in Triton is simple! In this tutorial we will use the\n+# Pseudo-random number generation in Triton is simple! In this tutorial we will use the\n # :code:`triton.language.rand` function which generates a block of uniformly distributed :code:`float32`\n # values in [0, 1), given a seed and a block of :code:`int32` offsets. But if you need it, Triton also provides\n # other :ref:`random number generation strategies <Random Number Generation>`.\n@@ -102,12 +105,12 @@ def dropout(x, x_keep, p):\n \n @triton.jit\n def _seeded_dropout(\n-        x_ptr,\n-        output_ptr,\n-        n_elements,\n-        p,\n-        seed,\n-        BLOCK_SIZE: tl.constexpr,\n+    x_ptr,\n+    output_ptr,\n+    n_elements,\n+    p,\n+    seed,\n+    BLOCK_SIZE: tl.constexpr,\n ):\n     # compute memory offsets of elements handled by this instance\n     pid = tl.program_id(axis=0)\n@@ -153,14 +156,15 @@ def seeded_dropout(x, p, seed):\n \n # %%\n # Exercises\n-# -------------\n+# ---------\n+#\n # 1. Extend the kernel to operate over a matrix and use a vector of seeds - one per row.\n # 2. Add support for striding.\n # 3. (challenge) Implement a kernel for sparse Johnson-Lindenstrauss transform which generates the projection matrix one the fly each time using a seed.\n \n # %%\n # References\n-# --------------\n+# ----------\n #\n # .. [SALMON2011] John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, \"Parallel Random Numbers: As Easy as 1, 2, 3\", 2011\n # .. [SRIVASTAVA2014] Nitish Srivastava and Geoffrey Hinton and Alex Krizhevsky and Ilya Sutskever and Ruslan Salakhutdinov, \"Dropout: A Simple Way to Prevent Neural Networks from Overfitting\", JMLR 2014"}, {"filename": "python/tutorials/05-layer-norm.py", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "file_content_changes": "@@ -3,15 +3,16 @@\n ====================\n In this tutorial, you will write a high-performance layer normalization\n kernel that runs faster than the PyTorch implementation.\n-You will specifically learn about:\n \n-- How to implement backward pass in Triton\n-- How to implement parallel reduction in Triton\n+In doing so, you will learn about:\n+- Implementing backward pass in Triton\n+- Implementing parallel reduction in Triton\n \"\"\"\n \n # %%\n # Motivations\n-# -------------\n+# -----------\n+#\n # The *LayerNorm* operator was first introduced in [BA2016]_ as a way to improve the performance\n # of sequential models (e.g., Transformers) or neural networks with small batch size.\n # It takes a vector :math:`x` as input and produces a vector :math:`y` of the same shape as output.\n@@ -23,7 +24,7 @@\n #    y = \\frac{ x - \\text{E}[x] }{ \\sqrt{\\text{Var}(x) + \\epsilon} } * w + b\n #\n # where :math:`\\epsilon` is a small constant added to the denominator for numerical stability.\n-# Let\u2019s first take a look at the foward pass implementation.\n+# Let\u2019s first take a look at the forward pass implementation.\n \n import torch\n \n@@ -91,7 +92,8 @@ def _layer_norm_fwd_fused(\n \n # %%\n # Backward pass\n-# ---------------------------------\n+# -------------\n+#\n # The backward pass for the layer normalization operator is a bit more involved than the forward pass.\n # Let :math:`\\hat{x}` be the normalized inputs :math:`\\frac{ x - \\text{E}[x] }{ \\sqrt{\\text{Var}(x) + \\epsilon} }` before the linear transformation,\n # the Vector-Jacobian Products (VJP) :math:`\\nabla_{x}` of :math:`x` are given by:\n@@ -218,7 +220,8 @@ def _layer_norm_bwd_dwdb(\n \n # %%\n # Benchmark\n-# ---------------------------------\n+# ---------\n+#\n # We can now compare the performance of our kernel against that of PyTorch.\n # Here we focus on inputs that have Less than 64KB per feature.\n # Specifically, one can set :code:`'mode': 'backward'` to benchmark the backward pass.\n@@ -362,6 +365,6 @@ def bench_layer_norm(M, N, dtype, provider, mode='backward', eps=1e-5, device='c\n \n # %%\n # References\n-# --------------\n+# ----------\n #\n # .. [BA2016] Jimmy Lei Ba and Jamie Ryan Kiros and Geoffrey E. Hinton, \"Layer Normalization\", Arxiv 2016"}, {"filename": "python/tutorials/06-fused-attention.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -1,6 +1,7 @@\n \"\"\"\n Fused Attention\n ===============\n+\n This is a Triton implementation of the Flash Attention algorithm\n (see: Dao et al., https://arxiv.org/pdf/2205.14135v2.pdf; Rabe and Staats https://arxiv.org/pdf/2112.05682v2.pdf)\n \"\"\""}, {"filename": "python/tutorials/README.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,5 +1,5 @@\n Tutorials\n-==================\n+=========\n \n Below is a gallery of tutorials for writing various basic operations with Triton. It is recommended that you read through the tutorials in order, starting with the simplest one.\n "}, {"filename": "test/Analysis/test-alignment.mlir", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "file_content_changes": "@@ -82,7 +82,7 @@ func.func @div() {\n   %3 = arith.divui %1, %0 : tensor<128xi32>\n   // CHECK-NEXT: contiguity = [1], divisibility = [64], constancy = [128], constant_value = 64\n   %4 = arith.constant dense<64> : tensor<128xi32>\n-  // CHECK-NEXT: contiguity = [1], divisibility = [16777216], constancy = [64], constant_value = <none>\n+  // CHECK-NEXT: contiguity = [1], divisibility = [1], constancy = [64], constant_value = <none>\n   %5 = arith.divsi %0, %4 : tensor<128xi32>\n   // CHECK-NEXT: contiguity = [1], divisibility = [1], constancy = [1], constant_value = <none>\n   %6 = arith.divsi %4, %0 : tensor<128xi32>\n@@ -94,11 +94,12 @@ func.func @div() {\n   %9 = arith.divui %0, %8 : tensor<128xi32>\n   // CHECK-NEXT: contiguity = [128], divisibility = [8192], constancy = [1], constant_value = <none>\n   %10 = tt.make_range {end = 8320 : i32, start = 8192 : i32} : tensor<128xi32>\n-  // CHECK-NEXT: contiguity = [1], divisibility = [128], constancy = [64], constant_value = <none>\n+  // CHECK-NEXT: contiguity = [1], divisibility = [1], constancy = [64], constant_value = <none>\n   %11 = arith.divsi %10, %4 : tensor<128xi32>\n   return\n }\n \n+\n // -----\n \n // CHECK-LABEL: @rem\n@@ -179,11 +180,11 @@ func.func @logic() {\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n   // CHECK-NEXT: contiguity = [1], divisibility = [64], constancy = [128], constant_value = 64\n   %1 = arith.constant dense<64> : tensor<128xi32>\n-  // CHECK-NEXT: contiguity = [1], divisibility = [16777216], constancy = [64], constant_value = <none>\n+  // CHECK-NEXT: contiguity = [1], divisibility = [1], constancy = [64], constant_value = <none>\n   %2 = arith.divsi %0, %1 : tensor<128xi32>\n   // CHECK-NEXT: contiguity = [1], divisibility = [8], constancy = [128], constant_value = 8\n   %3 = arith.constant dense<8> : tensor<128xi32>\n-  // CHECK-NEXT: contiguity = [1], divisibility = [134217728], constancy = [8], constant_value = <none>\n+  // CHECK-NEXT: contiguity = [1], divisibility = [1], constancy = [8], constant_value = <none>\n   %4 = arith.divsi %0, %3 : tensor<128xi32>\n   // CHECK-NEXT: contiguity = [1], divisibility = [1], constancy = [1], constant_value = <none>\n   %5 = arith.andi %0, %1 : tensor<128xi32>"}, {"filename": "test/TritonGPU/prefetch.mlir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -62,4 +62,3 @@ func.func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16\n   }\n   return\n }\n-"}, {"filename": "unittest/CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1,4 +1,3 @@\n-\n include (${CMAKE_CURRENT_SOURCE_DIR}/googletest.cmake)\n \n include(GoogleTest)"}]