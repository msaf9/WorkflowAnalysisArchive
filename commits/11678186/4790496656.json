[{"filename": "python/triton/runtime/cache.py", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "file_content_changes": "@@ -1,11 +1,10 @@\n import json\n import os\n+import random\n from abc import ABC, abstractmethod\n from pathlib import Path\n from typing import Dict, Optional\n \n-from filelock import FileLock\n-\n \n def default_cache_dir():\n     return os.path.join(Path.home(), \".triton\", \"cache\")\n@@ -96,12 +95,18 @@ def put(self, data, filename, binary=True) -> str:\n             data = str(data)\n         assert self.lock_path is not None\n         filepath = self._make_path(filename)\n-        with FileLock(self.lock_path):\n-            # use tempfile to be robust against program interruptions\n-            mode = \"wb\" if binary else \"w\"\n-            with open(filepath + \".tmp\", mode) as f:\n-                f.write(data)\n-            os.rename(filepath + \".tmp\", filepath)\n+        # Random ID to avoid any collisions\n+        rnd_id = random.randint(0, 1000000)\n+        # we use the PID incase a bunch of these around so we can see what PID made it\n+        pid = os.getpid()\n+        # use tempfile to be robust against program interruptions\n+        temp_path = f\"{filepath}.tmp.pid_{pid}_{rnd_id}\"\n+        mode = \"wb\" if binary else \"w\"\n+        with open(temp_path, mode) as f:\n+            f.write(data)\n+        # Replace is guaranteed to be atomic on POSIX systems if it succeeds\n+        # so filepath cannot see a partial write\n+        os.replace(temp_path, filepath)\n         return filepath\n \n "}]