[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "file_content_changes": "@@ -890,28 +890,6 @@ class ConvertTritonGPUOpToLLVMPattern\n     return base;\n   }\n \n-  static SharedMemoryObject\n-  getSharedMemoryObjectFromStruct(Location loc, Value llvmStruct,\n-                                  ConversionPatternRewriter &rewriter) {\n-    auto elems = getElementsFromStruct(loc, llvmStruct, rewriter);\n-    auto rank = (elems.size() - 1) / 2;\n-    return SharedMemoryObject(\n-        /*base=*/elems[0],\n-        /*strides=*/{elems.begin() + 1, elems.begin() + 1 + rank},\n-        /*offsets=*/{elems.begin() + 1 + rank, elems.end()});\n-  }\n-\n-  static Value\n-  getStructFromSharedMemoryObject(Location loc,\n-                                  const SharedMemoryObject &smemObj,\n-                                  ConversionPatternRewriter &rewriter) {\n-    auto elems = smemObj.getElems();\n-    auto types = smemObj.getTypes();\n-    auto structTy =\n-        LLVM::LLVMStructType::getLiteral(rewriter.getContext(), types);\n-    return getStructFromElements(loc, elems, rewriter, structTy);\n-  }\n-\n protected:\n   const Allocation *allocation;\n   Value smem;\n@@ -3289,17 +3267,17 @@ class MMA16816SmemLoader {\n     // Physical offset (before swizzling)\n     Value cMatOff = matOff[order[0]];\n     Value sMatOff = matOff[order[1]];\n+    Value cSwizzleMatOff = udiv(cSwizzleOffset, i32_val(cMatShape));\n+    cMatOff = add(cMatOff, cSwizzleMatOff);\n \n     // row offset inside a matrix, each matrix has 8 rows.\n     Value sOffInMat = c;\n \n     SmallVector<Value> offs(numPtrs);\n     Value phase = urem(udiv(sOffInMat, i32_val(perPhase)), i32_val(maxPhase));\n     Value sOff = add(sOffInMat, mul(sMatOff, i32_val(sMatShape)));\n-    Value cSwizzleMatOff = udiv(cSwizzleOffset, i32_val(cMatShape));\n     for (int i = 0; i < numPtrs; ++i) {\n       Value cMatOffI = add(cMatOff, i32_val(i * pLoadStrideInMat));\n-      cMatOffI = add(cMatOffI, cSwizzleMatOff);\n       cMatOffI = xor_(cMatOffI, phase);\n       offs[i] = add(mul(cMatOffI, i32_val(cMatShape)), mul(sOff, sTileStride));\n     }\n@@ -3328,6 +3306,9 @@ class MMA16816SmemLoader {\n \n       Value cMatOff = add(mul(warpOff, i32_val(warpOffStride)),\n                           mul(nkMatArr, i32_val(matArrStride)));\n+      Value cSwizzleMatOff = udiv(cSwizzleOffset, i32_val(cMatShape));\n+      cMatOff = add(cMatOff, cSwizzleMatOff);\n+\n       Value sMatOff = kMatArr;\n       Value sOff = add(sOffInMat, mul(sMatOff, i32_val(sMatShape)));\n       // FIXME: (kOrder == 1?) is really dirty hack\n@@ -4839,13 +4820,12 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   Value offA0 = isARow ? offsetAK : offsetAM;\n   Value offA1 = isARow ? offsetAM : offsetAK;\n   Value phaseA = urem(udiv(offA1, i32_val(perPhaseA)), i32_val(maxPhaseA));\n+  offA0 = add(offA0, cSwizzleOffset);\n   SmallVector<Value> offA(numPtrA);\n-\n-  Value cSwizzleVecOffset = udiv(cSwizzleOffset, i32_val(vecA));\n   for (int i = 0; i < numPtrA; i++) {\n     Value offA0I = add(offA0, i32_val(i * (isARow ? 4 : strideRepM)));\n     offA0I = udiv(offA0I, i32_val(vecA));\n-    offA0I = xor_(add(cSwizzleVecOffset, offA0I), phaseA);\n+    offA0I = xor_(offA0I, phaseA);\n     offA0I = xor_(offA0I, i32_val(vecA));\n     offA[i] = add(mul(offA0I, strideA0), mul(offA1, strideA1));\n   }\n@@ -4956,6 +4936,8 @@ Value DotOpMmaV1ConversionHelper::loadB(\n   Value offB0 = isBRow ? offsetBN : offsetBK;\n   Value offB1 = isBRow ? offsetBK : offsetBN;\n   Value phaseB = urem(udiv(offB1, i32_val(perPhaseB)), i32_val(maxPhaseB));\n+  Value cSwizzleOffset = smemObj.getCSwizzleOffset(order[0]);\n+  offB0 = add(offB0, cSwizzleOffset);\n   SmallVector<Value> offB(numPtrB);\n   for (int i = 0; i < numPtrB; ++i) {\n     Value offB0I = add(offB0, i32_val(i * (isBRow ? strideRepN : 4)));"}, {"filename": "lib/Dialect/Triton/IR/Ops.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -126,7 +126,7 @@ namespace triton {\n \n //-- FpToFpOp --\n bool FpToFpOp::areCastCompatible(::mlir::TypeRange inputs,\n-                               ::mlir::TypeRange outputs) {\n+                                 ::mlir::TypeRange outputs) {\n   if (inputs.size() != 1 || outputs.size() != 1)\n     return false;\n   auto srcEltType = inputs.front();\n@@ -143,8 +143,8 @@ bool FpToFpOp::areCastCompatible(::mlir::TypeRange inputs,\n     std::swap(srcEltType, dstEltType);\n   if (!srcEltType.dyn_cast<mlir::triton::Float8Type>())\n     return false;\n-  return dstEltType.isF16() || dstEltType.isBF16() ||\n-         dstEltType.isF32() || dstEltType.isF64();\n+  return dstEltType.isF16() || dstEltType.isBF16() || dstEltType.isF32() ||\n+         dstEltType.isF64();\n }\n \n //-- StoreOp --"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Coalesce.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -33,9 +33,9 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n     SmallVector<unsigned, 4> sizePerThread(rank, 1);\n     PointerType ptrType = origType.getElementType().cast<PointerType>();\n     auto pointeeType = ptrType.getPointeeType();\n-    unsigned numBits =\n-        pointeeType.isa<triton::Float8Type>() ?\n-        8 : pointeeType.getIntOrFloatBitWidth();\n+    unsigned numBits = pointeeType.isa<triton::Float8Type>()\n+                           ? 8\n+                           : pointeeType.getIntOrFloatBitWidth();\n     unsigned maxMultiple = info.getDivisibility(order[0]);\n     unsigned maxContig = info.getContiguity(order[0]);\n     unsigned alignment = std::min(maxMultiple, maxContig);"}]