[{"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "file_content_changes": "@@ -85,27 +85,25 @@ AxisInfo AxisInfo::getPessimisticValueState(Value value) {\n         }\n       }\n     }\n-  }\n-  else if(Operation* op = value.getDefiningOp()) {\n+  } else if (Operation *op = value.getDefiningOp()) {\n     DimVectorT knownContiguity(rank, 1);\n     DimVectorT knownDivisibility(rank, 1);\n     DimVectorT knownConstancy(rank, 1);\n-    if(Attribute attr = op->getAttr(\"tt.divisibility\")){\n+    if (Attribute attr = op->getAttr(\"tt.divisibility\")) {\n       auto vals = attr.cast<DenseElementsAttr>().getValues<int>();\n       knownDivisibility = DimVectorT(vals.begin(), vals.end());\n     }\n-    if(Attribute attr = op->getAttr(\"tt.contiguity\")){\n+    if (Attribute attr = op->getAttr(\"tt.contiguity\")) {\n       auto vals = attr.cast<DenseElementsAttr>().getValues<int>();\n       knownContiguity = DimVectorT(vals.begin(), vals.end());\n     }\n-    if(Attribute attr = op->getAttr(\"tt.constancy\")){\n+    if (Attribute attr = op->getAttr(\"tt.constancy\")) {\n       auto vals = attr.cast<DenseElementsAttr>().getValues<int>();\n       knownConstancy = DimVectorT(vals.begin(), vals.end());\n     }\n     return AxisInfo(knownContiguity, knownDivisibility, knownConstancy);\n   }\n \n-\n   return AxisInfo(/*knownContiguity=*/DimVectorT(rank, contiHint),\n                   /*knownDivisibility=*/DimVectorT(rank, divHint),\n                   /*knownConstancy=*/DimVectorT(rank, constHint));\n@@ -841,15 +839,15 @@ ChangeResult AxisInfoAnalysis::visitOperation(\n   auto newContiguity = curr.getContiguity();\n   auto newDivisibility = curr.getDivisibility();\n   auto newConstancy = curr.getConstancy();\n-  if(Attribute attr = op->getAttr(\"tt.contiguity\")){\n+  if (Attribute attr = op->getAttr(\"tt.contiguity\")) {\n     auto vals = attr.cast<DenseElementsAttr>().getValues<int>();\n     newContiguity = AxisInfo::DimVectorT(vals.begin(), vals.end());\n   }\n-  if(Attribute attr = op->getAttr(\"tt.divisibility\")){\n+  if (Attribute attr = op->getAttr(\"tt.divisibility\")) {\n     auto vals = attr.cast<DenseElementsAttr>().getValues<int>();\n     newDivisibility = AxisInfo::DimVectorT(vals.begin(), vals.end());\n   }\n-  if(Attribute attr = op->getAttr(\"tt.constancy\")){\n+  if (Attribute attr = op->getAttr(\"tt.constancy\")) {\n     auto vals = attr.cast<DenseElementsAttr>().getValues<int>();\n     newConstancy = AxisInfo::DimVectorT(vals.begin(), vals.end());\n   }"}, {"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -345,8 +345,8 @@ struct TritonStorePattern : public OpConversionPattern<triton::StoreOp> {\n   matchAndRewrite(triton::StoreOp op, OpAdaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n     rewriter.replaceOpWithNewOp<triton::StoreOp>(\n-        op, adaptor.ptr(), adaptor.value(), adaptor.mask(),\n-        adaptor.cache(), adaptor.evict());\n+        op, adaptor.ptr(), adaptor.value(), adaptor.mask(), adaptor.cache(),\n+        adaptor.evict());\n     return success();\n   }\n };"}, {"filename": "lib/Dialect/Triton/IR/Ops.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -152,7 +152,8 @@ void StoreOp::build(::mlir::OpBuilder &builder, ::mlir::OperationState &state,\n                     ::mlir::Value ptr, ::mlir::Value value,\n                     ::mlir::triton::CacheModifier cache,\n                     ::mlir::triton::EvictionPolicy evict) {\n-  return StoreOp::build(builder, state, ptr, value, mlir::Value(), cache, evict);\n+  return StoreOp::build(builder, state, ptr, value, mlir::Value(), cache,\n+                        evict);\n }\n \n //-- LoadOp --"}, {"filename": "lib/Dialect/Triton/Transforms/Combine.cpp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "file_content_changes": "@@ -164,10 +164,9 @@ struct CanonicalizeMaskedStorePattern\n \n     if (splatMask.getSplatValue<IntegerAttr>().getValue() == true) {\n       // mask = splat(1)\n-      rewriter.replaceOpWithNewOp<triton::StoreOp>(storeOp, storeOp.ptr(),\n-                                                   storeOp.value(),\n-                                                   storeOp.cache(),\n-                                                   storeOp.evict());\n+      rewriter.replaceOpWithNewOp<triton::StoreOp>(\n+          storeOp, storeOp.ptr(), storeOp.value(), storeOp.cache(),\n+          storeOp.evict());\n     } else {\n       // mask = splat(0)\n       rewriter.eraseOp(storeOp);"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "file_content_changes": "@@ -155,8 +155,9 @@ class SimplifyConversion : public mlir::RewritePattern {\n     if (!arg)\n       return mlir::failure();\n     // cvt(view) -> view\n-    if(auto view = dyn_cast<triton::ViewOp>(arg)){\n-      rewriter.replaceOpWithNewOp<triton::ViewOp>(op, op->getResult(0).getType(), view.getResult());\n+    if (auto view = dyn_cast<triton::ViewOp>(arg)) {\n+      rewriter.replaceOpWithNewOp<triton::ViewOp>(\n+          op, op->getResult(0).getType(), view.getResult());\n       return mlir::success();\n     }\n     // cvt(alloc_tensor(x), type2) -> alloc_tensor(x, type2)\n@@ -283,7 +284,7 @@ LogicalResult invertEncoding(Attribute targetEncoding, Operation *op,\n       return failure();\n     ret = sliceEncoding.getParent();\n   }\n-  if (auto view = dyn_cast<triton::ViewOp>(op)){\n+  if (auto view = dyn_cast<triton::ViewOp>(op)) {\n     return failure();\n   }\n   return success();\n@@ -296,11 +297,11 @@ inline bool expensiveLoadOrStore(Operation *op, Attribute &targetEncoding) {\n     return false;\n   auto ptr = op->getOperand(0);\n   // Case 2: We assume that `evict_last` loads/stores have high hit rate\n-  if(auto load = dyn_cast<triton::LoadOp>(op))\n-    if(load.evict() == triton::EvictionPolicy::EVICT_LAST)\n+  if (auto load = dyn_cast<triton::LoadOp>(op))\n+    if (load.evict() == triton::EvictionPolicy::EVICT_LAST)\n       return false;\n-  if(auto store = dyn_cast<triton::StoreOp>(op))\n-    if(store.evict() == triton::EvictionPolicy::EVICT_LAST)\n+  if (auto store = dyn_cast<triton::StoreOp>(op))\n+    if (store.evict() == triton::EvictionPolicy::EVICT_LAST)\n       return false;\n   if (auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>()) {\n     auto encoding = tensorTy.getEncoding();\n@@ -382,7 +383,7 @@ LogicalResult simulateBackwardRematerialization(\n         continue;\n       if (auto view = dyn_cast<triton::ViewOp>(opArgI))\n         continue;\n-      \n+\n       // We add one expensive conversion for the current operand\n       numCvts += 1;\n       queue.emplace_back(opArgI, newEncoding);\n@@ -582,20 +583,20 @@ class FoldConvertAndReduce : public mlir::RewritePattern {\n              !isa<triton::gpu::ConvertLayoutOp>(op) && !isa<scf::YieldOp>(op);\n     };\n     mlir::getForwardSlice(cvt.getResult(), &cvtSlices, filter);\n-    if (cvtSlices.empty()){\n+    if (cvtSlices.empty()) {\n       return failure();\n     }\n \n     llvm::MapVector<Value, Attribute> toConvert;\n     for (Operation *op : cvtSlices) {\n       // don't rematerialize anything expensive\n-      if (expensiveToRemat(op, srcEncoding)){\n+      if (expensiveToRemat(op, srcEncoding)) {\n         return failure();\n       }\n       // don't rematerialize non-element-wise\n       if (!op->hasTrait<mlir::OpTrait::SameOperandsAndResultEncoding>() &&\n           !op->hasTrait<mlir::OpTrait::Elementwise>() &&\n-          !isa<triton::StoreOp>(op)){\n+          !isa<triton::StoreOp>(op)) {\n         return failure();\n       }\n       // don't rematerialize if it adds an extra conversion that can't"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -170,7 +170,7 @@ LogicalResult LoopPipeliner::initialize() {\n       auto ptr = loadOp.ptr();\n       unsigned vec = axisInfoAnalysis.getPtrContiguity(ptr);\n       auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>();\n-      if(!tensorTy)\n+      if (!tensorTy)\n         continue;\n       auto ty = tensorTy.getElementType()\n                     .cast<triton::PointerType>()"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "file_content_changes": "@@ -193,9 +193,9 @@ void init_triton_ir(py::module &&m) {\n                auto arg = self.cast<mlir::BlockArgument>();\n                int id = arg.getArgNumber();\n                std::string attrName = name + \"_arg\" + std::to_string(id);\n-               mlir::Block* owner = arg.getOwner();\n-               if(owner->isEntryBlock() && \n-                  !mlir::isa<mlir::FuncOp>(owner->getParentOp())){\n+               mlir::Block *owner = arg.getOwner();\n+               if (owner->isEntryBlock() &&\n+                   !mlir::isa<mlir::FuncOp>(owner->getParentOp())) {\n                  owner->getParentOp()->setAttr(attrName, attr);\n                }\n              }\n@@ -1089,12 +1089,12 @@ void init_triton_ir(py::module &&m) {\n                  loc, ptrs, cacheModifier, evictionPolicy, isVolatile);\n            })\n       .def(\"create_store\",\n-           [](mlir::OpBuilder &self, mlir::Value &ptrs,\n-              mlir::Value &value,\n+           [](mlir::OpBuilder &self, mlir::Value &ptrs, mlir::Value &value,\n               mlir::triton::CacheModifier cacheModifier,\n               mlir::triton::EvictionPolicy evictionPolicy) -> void {\n              auto loc = self.getUnknownLoc();\n-             self.create<mlir::triton::StoreOp>(loc, ptrs, value, cacheModifier, evictionPolicy);\n+             self.create<mlir::triton::StoreOp>(loc, ptrs, value, cacheModifier,\n+                                                evictionPolicy);\n            })\n       .def(\"create_masked_load\",\n            [](mlir::OpBuilder &self, mlir::Value &ptrs, mlir::Value &mask,\n@@ -1109,11 +1109,11 @@ void init_triton_ir(py::module &&m) {\n            })\n       .def(\"create_masked_store\",\n            [](mlir::OpBuilder &self, mlir::Value &ptrs, mlir::Value &val,\n-              mlir::Value &mask,\n-              mlir::triton::CacheModifier cacheModifier,\n+              mlir::Value &mask, mlir::triton::CacheModifier cacheModifier,\n               mlir::triton::EvictionPolicy evictionPolicy) -> void {\n              auto loc = self.getUnknownLoc();\n-             self.create<mlir::triton::StoreOp>(loc, ptrs, val, mask, cacheModifier, evictionPolicy);\n+             self.create<mlir::triton::StoreOp>(loc, ptrs, val, mask,\n+                                                cacheModifier, evictionPolicy);\n            })\n       .def(\"create_view\",\n            [](mlir::OpBuilder &self, mlir::Value &arg,"}, {"filename": "python/triton/third_party/cuda/include/cuda.h", "status": "modified", "additions": 6795, "deletions": 5384, "changes": 12179, "file_content_changes": "N/A"}]