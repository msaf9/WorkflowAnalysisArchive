[{"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -712,5 +712,4 @@ triton::MakeTensorPtrOp getMakeTensorPtrOp(Value v) {\n \n   llvm_unreachable(\"Unable to getMakeTensorPtr()\");\n }\n-\n } // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "file_content_changes": "@@ -153,7 +153,8 @@ struct ConvertLayoutOpConversion\n     }\n     if (auto mmaLayout = layout.dyn_cast<MmaEncodingAttr>()) {\n       auto shapePerCTA = getShapePerCTA(mmaLayout, shape);\n-      auto instrShape = mmaVersionToInstrShapeOfMN(mmaLayout, shapePerCTA);\n+      auto instrShape = mmaVersionToInstrShapeOfMN(\n+          mmaLayout, fixShapePerCTAForMmaV3(rewriter, mmaLayout, shapePerCTA));\n       SmallVector<Value> mmaColIdx(4);\n       SmallVector<Value> mmaRowIdx(2);\n       Value threadId = getThreadId(rewriter, loc);\n@@ -729,7 +730,9 @@ struct ConvertLayoutOpConversion\n                                                          rewriter, srcTy);\n \n       auto srcShapePerCTA = getShapePerCTA(mmaLayout, srcShape);\n-      auto instrShape = mmaVersionToInstrShapeOfMN(mmaLayout, srcShapePerCTA);\n+      auto instrShape = mmaVersionToInstrShapeOfMN(\n+          mmaLayout,\n+          fixShapePerCTAForMmaV3(rewriter, mmaLayout, srcShapePerCTA));\n       auto warpsPerCTA = mmaLayout.getWarpsPerCTA();\n       uint32_t repM =\n           ceil<unsigned>(srcShapePerCTA[0], instrShape[0] * warpsPerCTA[0]);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "file_content_changes": "@@ -771,6 +771,30 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n       return result;\n     }\n   }\n+  SmallVector<int64_t>\n+  fixShapePerCTAForMmaV3(ConversionPatternRewriter &rewriter,\n+                         triton::gpu::MmaEncodingAttr mma,\n+                         ArrayRef<int64_t> currentShape) const {\n+    if (mma.getVersionMajor() < 3 || currentShape[1] > 1)\n+      return {currentShape.begin(), currentShape.end()};\n+    ModuleOp moduleOp =\n+        rewriter.getBlock()->getParentOp()->getParentOfType<ModuleOp>();\n+    std::set<int64_t> ns;\n+    moduleOp.walk([&](Operation *op) {\n+      for (auto result : op->getResults()) {\n+        if (auto type = result.getType().dyn_cast<RankedTensorType>()) {\n+          if (type.getEncoding() == mma) {\n+            auto shapePerCTA = triton::gpu::getShapePerCTA(type.getEncoding(),\n+                                                           type.getShape());\n+            if (shapePerCTA[1] > 1)\n+              ns.insert(shapePerCTA[1]);\n+          }\n+        }\n+      }\n+    });\n+    assert(ns.size() == 1 && \"too many mma encoding with different N size\");\n+    return {currentShape[0], *ns.begin()};\n+  }\n \n private:\n   void restoreInsertionPointIfSet(OpBuilder::InsertPoint *insertPt,\n@@ -1038,7 +1062,8 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     assert(_warpsPerCTA.size() == 2);\n     auto order = triton::gpu::getOrder(mmaLayout);\n     auto shapePerCTA = getShapePerCTA(mmaLayout, shape);\n-    auto instrShape = mmaVersionToInstrShapeOfMN(mmaLayout, shapePerCTA);\n+    auto instrShape = mmaVersionToInstrShapeOfMN(\n+        mmaLayout, fixShapePerCTAForMmaV3(rewriter, mmaLayout, shapePerCTA));\n     SmallVector<Value> warpsPerCTA = {i32_val(_warpsPerCTA[0]),\n                                       i32_val(_warpsPerCTA[1])};\n "}, {"filename": "lib/Dialect/TritonGPU/Transforms/Utility.cpp", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "file_content_changes": "@@ -53,12 +53,6 @@ mmaVersionToInstrShapeImpl(int version, const ArrayRef<int64_t> &shape,\n SmallVector<unsigned, 3>\n mmaVersionToInstrShape(int version, ArrayRef<int64_t> outputShapePerCTA,\n                        RankedTensorType inputType) {\n-  if (version == 3) {\n-    if (outputShapePerCTA[0] % 64 != 0 || outputShapePerCTA[1] % 8 != 0) {\n-      assert(false && \"type not supported\");\n-      return {0, 0, 0};\n-    }\n-  }\n   return mmaVersionToInstrShapeImpl(version, outputShapePerCTA,\n                                     inputType.getElementType());\n }\n@@ -73,9 +67,8 @@ mmaVersionToInstrShapeOfMN(triton::gpu::MmaEncodingAttr mma,\n     eltType = builder.getIntegerType(8);\n   else\n     eltType = builder.getF16Type();\n-  auto instrShape =\n-      mmaVersionToInstrShape(mma.getVersionMajor(), outputShapePerCTA,\n-                             RankedTensorType::get({1, 1}, eltType, mma));\n+  auto instrShape = mmaVersionToInstrShapeImpl(mma.getVersionMajor(),\n+                                               outputShapePerCTA, eltType);\n \n   return {instrShape[0], instrShape[1]};\n }"}]