[{"filename": ".github/workflows/integration-tests.yml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "file_content_changes": "@@ -166,10 +166,12 @@ jobs:\n       - name: Install Triton on ROCM\n         if: ${{ env.BACKEND == 'ROCM'}}\n         run: |\n+          git submodule update --init --recursive\n           cd python\n           python3 -m pip install --upgrade pip\n           python3 -m pip install cmake==3.24\n           python3 -m pip install torch==1.13.1 --index-url https://download.pytorch.org/whl/rocm5.2\n+          export TRITON_CODEGEN_AMD_HIP_BACKEND=1\n           python3 -m pip install --no-build-isolation -vvv '.[tests]'\n \n       - name: Install Triton on XPU\n@@ -191,7 +193,7 @@ jobs:\n         if: ${{ env.BACKEND == 'ROCM'}}\n         run: |\n           cd python/test/unit/language\n-          python3 -m pytest --capture=tee-sys -rfs --verbose \"test_core.py::test_empty_kernel\"\n+          python3 -m pytest --capture=tee-sys -rfs --verbose \"test_core.py\"\n \n       - name: Run python tests on XPU\n         if: ${{ env.BACKEND == 'XPU'}}"}, {"filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -1,3 +1,7 @@\n [submodule \"third_party/intel_xpu_backend\"]\n \tpath = third_party/intel_xpu_backend\n \turl = http://github.com/intel/intel-xpu-backend-for-triton\n+[submodule \"third_party/amd_hip_backend\"]\n+\tpath = third_party/amd_hip_backend\n+\turl = https://github.com/ROCmSoftwarePlatform/triton\n+\tbranch = third_party_backend_2"}, {"filename": "CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -211,7 +211,6 @@ if(TRITON_BUILD_PYTHON_MODULE)\n     TritonGPUTransforms\n     TritonLLVMIR\n     TritonPTX\n-    TritonHSACO\n     ${dialect_libs}\n     ${conversion_libs}\n "}, {"filename": "bin/CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -50,7 +50,6 @@ llvm_update_compile_flags(triton-translate)\n          TritonGPUTransforms\n          TritonLLVMIR\n          TritonPTX\n-         TritonHSACO\n          ${dialect_libs}\n          ${conversion_libs}\n          # tests"}, {"filename": "bin/triton-translate.cpp", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "file_content_changes": "@@ -14,7 +14,6 @@\n #include \"triton/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n-#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n #include \"triton/Target/PTX/PTXTranslation.h\"\n #include \"llvm/IR/LLVMContext.h\"\n@@ -127,16 +126,11 @@ LogicalResult tritonTranslateMain(int argc, char **argv,\n     llvm::errs() << \"Translate to LLVM IR failed\";\n   }\n \n-  if (targetKind == \"llvmir\")\n+  if (targetKind == \"llvmir\") {\n     llvm::outs() << *llvmir << '\\n';\n-  else if (targetKind == \"ptx\")\n+  } else if (targetKind == \"ptx\") {\n     llvm::outs() << ::triton::translateLLVMIRToPTX(*llvmir, SMArch.getValue(),\n                                                    ptxVersion.getValue());\n-  else if (targetKind == \"hsaco\") {\n-    auto [module, hsaco] = ::triton::translateLLVMIRToHSACO(\n-        *llvmir, GCNArch.getValue(), GCNTriple.getValue(),\n-        GCNFeatures.getValue());\n-    llvm::outs() << hsaco;\n   } else {\n     llvm::errs() << \"Error: Unknown target specified: \" << targetKind << \"\\n\";\n     return failure();"}, {"filename": "include/triton/Target/HSACO/HSACOTranslation.h", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "file_content_changes": "@@ -1,21 +0,0 @@\n-#ifndef TRITON_TARGET_HSACOTRANSLATION_H\n-#define TRITON_TARGET_HSACOTRANSLATION_H\n-\n-#include <memory>\n-#include <string>\n-#include <tuple>\n-\n-namespace llvm {\n-class Module;\n-} // namespace llvm\n-\n-namespace triton {\n-\n-// Translate TritonGPU IR to HSACO code.\n-std::tuple<std::string, std::string>\n-translateLLVMIRToHSACO(llvm::Module &module, std::string gfx_arch,\n-                       std::string gfx_triple, std::string gfx_features);\n-\n-} // namespace triton\n-\n-#endif"}, {"filename": "lib/Target/CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1,3 +1,2 @@\n add_subdirectory(LLVMIR)\n add_subdirectory(PTX)\n-add_subdirectory(HSACO)"}, {"filename": "lib/Target/HSACO/CMakeLists.txt", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "file_content_changes": "@@ -1,9 +0,0 @@\n-add_mlir_translation_library(TritonHSACO\n-        HSACOTranslation.cpp\n-\n-        LINK_COMPONENTS\n-        Core\n-\n-        LINK_LIBS PUBLIC\n-        TritonLLVMIR\n-        )"}, {"filename": "lib/Target/HSACO/HSACOTranslation.cpp", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "file_content_changes": "@@ -1,182 +0,0 @@\n-#include \"triton/Target/HSACO/HSACOTranslation.h\"\n-#include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n-#include \"mlir/ExecutionEngine/ExecutionEngine.h\"\n-#include \"mlir/ExecutionEngine/OptUtils.h\"\n-#include \"mlir/IR/BuiltinOps.h\"\n-#include \"mlir/IR/Dialect.h\"\n-#include \"mlir/Pass/Pass.h\"\n-#include \"mlir/Pass/PassManager.h\"\n-#include \"mlir/Support/LogicalResult.h\"\n-#include \"mlir/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.h\"\n-#include \"mlir/Target/LLVMIR/Export.h\"\n-#include \"mlir/Target/LLVMIR/LLVMTranslationInterface.h\"\n-#include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n-#include \"triton/Tools/Sys/GetEnv.hpp\"\n-\n-#include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n-#include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n-#include \"llvm/IR/IRBuilder.h\"\n-#include \"llvm/IR/IRPrintingPasses.h\"\n-#include \"llvm/IR/LegacyPassManager.h\"\n-#include \"llvm/IR/Module.h\"\n-#include \"llvm/IR/Verifier.h\"\n-#include \"llvm/MC/TargetRegistry.h\"\n-#include \"llvm/Support/CodeGen.h\"\n-#include \"llvm/Support/CommandLine.h\"\n-#include \"llvm/Support/SourceMgr.h\"\n-#include \"llvm/Support/TargetSelect.h\"\n-#include \"llvm/Support/raw_ostream.h\"\n-#include \"llvm/Target/TargetMachine.h\"\n-#include \"llvm/Target/TargetOptions.h\"\n-#include \"llvm/Transforms/Scalar.h\"\n-#include \"llvm/Transforms/Utils/Cloning.h\"\n-#include <filesystem>\n-#include <iostream>\n-#include <memory>\n-#include <random>\n-\n-namespace {\n-\n-void init_llvm() {\n-  LLVMInitializeAMDGPUTarget();\n-  LLVMInitializeAMDGPUTargetInfo();\n-  LLVMInitializeAMDGPUTargetMC();\n-  LLVMInitializeAMDGPUAsmParser();\n-  LLVMInitializeAMDGPUAsmPrinter();\n-}\n-\n-std::unique_ptr<llvm::TargetMachine>\n-initialize_module(llvm::Module *module, const std::string &triple,\n-                  const std::string &proc, const std::string &features) {\n-  // verify and store llvm\n-  llvm::legacy::PassManager pm;\n-  pm.add(llvm::createVerifierPass());\n-  pm.run(*module);\n-\n-  module->setTargetTriple(triple);\n-\n-  std::string error;\n-  auto target =\n-      llvm::TargetRegistry::lookupTarget(module->getTargetTriple(), error);\n-  llvm::TargetOptions opt;\n-  opt.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n-  opt.UnsafeFPMath = false;\n-  opt.NoInfsFPMath = false;\n-  opt.NoNaNsFPMath = true;\n-  llvm::TargetMachine *machine = target->createTargetMachine(\n-      module->getTargetTriple(), proc, features, opt, llvm::Reloc::PIC_,\n-      std::nullopt, llvm::CodeGenOpt::Aggressive);\n-\n-  module->setDataLayout(machine->createDataLayout());\n-\n-  for (llvm::Function &f : module->functions())\n-    f.addFnAttr(llvm::Attribute::AlwaysInline);\n-\n-  return std::unique_ptr<llvm::TargetMachine>(machine);\n-}\n-\n-std::string generate_amdgcn_assembly(llvm::Module *module,\n-                                     const std::string &triple,\n-                                     const std::string &proc,\n-                                     const std::string &features) {\n-  auto machine = initialize_module(module, triple, proc, features);\n-  llvm::SmallVector<char, 0> buffer;\n-  llvm::legacy::PassManager pass;\n-  llvm::raw_svector_ostream stream(buffer);\n-\n-  // emit\n-  machine->addPassesToEmitFile(pass, stream, nullptr,\n-                               llvm::CodeGenFileType::CGFT_AssemblyFile);\n-  pass.run(*module);\n-\n-  std::string amdgcn(buffer.begin(), buffer.end());\n-  if (::triton::tools::getBoolEnv(\"AMDGCN_ENABLE_DUMP\")) {\n-    std::cout << \"// -----// AMDGCN Dump //----- //\\n\" << amdgcn << std::endl;\n-  }\n-\n-  return amdgcn;\n-}\n-\n-std::string generate_hsaco(llvm::Module *module, const std::string &triple,\n-                           const std::string &proc,\n-                           const std::string &features) {\n-  auto machine = initialize_module(module, triple, proc, features);\n-\n-  // create unique dir for kernel's binary and hsaco\n-  std::error_code ec;\n-  std::string kernel_name_base = \"amd_triton_kernel\";\n-  std::filesystem::path tmp = std::filesystem::temp_directory_path();\n-  std::filesystem::path kernel_dir_base(kernel_name_base);\n-  llvm::SmallString<256> unique_dir;\n-  ec = llvm::sys::fs::createUniqueDirectory((tmp / kernel_dir_base).string(),\n-                                            unique_dir);\n-  if (ec) {\n-    std::cerr << \"Directory for \" << kernel_name_base\n-              << \" was not created. error code: \" << ec << std::endl;\n-  }\n-  std::filesystem::path kernel_dir(unique_dir.data());\n-  std::string kernel_name = kernel_dir.stem();\n-\n-  // Save GCN ISA binary.\n-  std::filesystem::path isa_binary(kernel_name + \".o\");\n-  std::string isabin_path = (kernel_dir / isa_binary).string();\n-  std::unique_ptr<llvm::raw_fd_ostream> isabin_fs(\n-      new llvm::raw_fd_ostream(isabin_path, ec, llvm::sys::fs::OF_Text));\n-  if (ec) {\n-    std::cerr << isabin_path << \" was not created. error code: \" << ec\n-              << std::endl;\n-  }\n-\n-  // emit\n-  llvm::legacy::PassManager pass;\n-  machine->addPassesToEmitFile(pass, *isabin_fs, nullptr,\n-                               llvm::CGFT_ObjectFile);\n-  pass.run(*module);\n-\n-  // generate HASCO file\n-  std::filesystem::path hsaco(kernel_name + \".hsaco\");\n-  std::string hsaco_path = (kernel_dir / hsaco).string();\n-  std::string error_message;\n-  std::string lld_path = \"/opt/rocm/llvm/bin/ld.lld\";\n-  int lld_result = llvm::sys::ExecuteAndWait(\n-      lld_path,\n-      {lld_path, \"-flavor\", \"gnu\", \"-shared\", \"-o\", hsaco_path, isabin_path},\n-      std::nullopt, {}, 0, 0, &error_message);\n-  if (lld_result) {\n-    std::cout << \"ld.lld execute fail: \" << std::endl;\n-    std::cout << error_message << std::endl;\n-    std::cout << lld_result << std::endl;\n-  }\n-\n-  return hsaco_path;\n-}\n-\n-std::tuple<std::string, std::string>\n-llir_to_amdgcn_and_hsaco(llvm::Module *module, std::string gfx_arch,\n-                         std::string gfx_triple, std::string gfx_features) {\n-\n-  init_llvm();\n-\n-  // verify and store llvm\n-  auto module_obj = llvm::CloneModule(*module);\n-  auto amdgcn =\n-      generate_amdgcn_assembly(module, gfx_triple, gfx_arch, gfx_features);\n-  auto hsaco_path =\n-      generate_hsaco(module_obj.get(), gfx_triple, gfx_arch, gfx_features);\n-\n-  return std::make_tuple(amdgcn, hsaco_path);\n-}\n-\n-} // namespace\n-\n-namespace triton {\n-\n-std::tuple<std::string, std::string>\n-translateLLVMIRToHSACO(llvm::Module &module, std::string gfx_arch,\n-                       std::string gfx_triple, std::string gfx_features) {\n-  auto hsacoCode =\n-      llir_to_amdgcn_and_hsaco(&module, gfx_arch, gfx_triple, gfx_features);\n-  return hsacoCode;\n-}\n-\n-} // namespace triton"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "file_content_changes": "@@ -25,7 +25,6 @@\n #include \"triton/Dialect/Triton/IR/Types.h\"\n #include \"triton/Dialect/Triton/Transforms/Passes.h\"\n #include \"triton/Dialect/TritonGPU/Transforms/Passes.h\"\n-#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n #include \"triton/Target/PTX/PTXTranslation.h\"\n #include \"triton/Tools/Sys/GetEnv.hpp\"\n@@ -216,6 +215,7 @@ void init_triton_ir(py::module &&m) {\n         // we load LLVM because the frontend uses LLVM.undef for\n         // some placeholders\n         self.getOrLoadDialect<mlir::LLVM::LLVMDialect>();\n+        self.getOrLoadDialect<mlir::tensor::TensorDialect>();\n       });\n   // .def(py::init([](){\n   //   mlir::MLIRContext context;\n@@ -1748,24 +1748,6 @@ void init_triton_translation(py::module &m) {\n            const std::vector<std::string> &paths) {\n           ::mlir::triton::addExternalLibs(op, names, paths);\n         });\n-\n-  m.def(\n-      \"translate_llvmir_to_hsaco\",\n-      [](const std::string llvmIR, std::string gfx_arch, std::string gfx_triple,\n-         std::string gfx_features) -> std::tuple<std::string, std::string> {\n-        // create LLVM module from C++\n-        llvm::LLVMContext context;\n-        std::unique_ptr<llvm::MemoryBuffer> buffer =\n-            llvm::MemoryBuffer::getMemBuffer(llvmIR.c_str());\n-        llvm::SMDiagnostic error;\n-        std::unique_ptr<llvm::Module> module =\n-            llvm::parseIR(buffer->getMemBufferRef(), error, context);\n-        // translate module to HSACO\n-        auto hsacoCode = triton::translateLLVMIRToHSACO(\n-            *module, gfx_arch, gfx_triple, gfx_features);\n-        return hsacoCode;\n-      },\n-      ret::take_ownership);\n }\n \n void init_triton(py::module &m) {"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 184, "deletions": 65, "changes": 249, "file_content_changes": "@@ -12,6 +12,7 @@\n import triton\n import triton._C.libtriton.triton as _triton\n import triton.language as tl\n+from triton.common.build import is_hip\n from triton.runtime.jit import JITFunction, TensorWrapper, reinterpret\n \n int_dtypes = ['int8', 'int16', 'int32', 'int64']\n@@ -127,7 +128,10 @@ def __init__(self, version, warps_per_cta):\n         self.warps_per_cta = warps_per_cta\n \n     def __str__(self):\n-        return f\"#triton_gpu.mma<{{versionMajor={self.version[0]}, versionMinor={self.version[1]}, warpsPerCTA={self.warps_per_cta}}}>\"\n+        if is_hip():\n+            return f\"#triton_gpu_rocm.mma<{{versionMajor={self.version[0]}, versionMinor={self.version[1]}, warpsPerCTA={self.warps_per_cta}}}>\"\n+        else:\n+            return f\"#triton_gpu.mma<{{versionMajor={self.version[0]}, versionMinor={self.version[1]}, warpsPerCTA={self.warps_per_cta}}}>\"\n \n \n class BlockedLayout:\n@@ -138,7 +142,10 @@ def __init__(self, size_per_thread, threads_per_warp, warps_per_cta, order):\n         self.order = order\n \n     def __str__(self):\n-        return f\"#triton_gpu.blocked<{{sizePerThread={self.sz_per_thread}, threadsPerWarp={self.threads_per_warp}, warpsPerCTA={self.warps_per_cta}, order={self.order}}}>\"\n+        if is_hip():\n+            return f\"#triton_gpu_rocm.blocked<{{sizePerThread={self.sz_per_thread}, threadsPerWarp={self.threads_per_warp}, warpsPerCTA={self.warps_per_cta}, order={self.order}}}>\"\n+        else:\n+            return f\"#triton_gpu.blocked<{{sizePerThread={self.sz_per_thread}, threadsPerWarp={self.threads_per_warp}, warpsPerCTA={self.warps_per_cta}, order={self.order}}}>\"\n \n \n class SharedLayout:\n@@ -149,7 +156,10 @@ def __init__(self, vec, per_phase, max_phase, order):\n         self.order = str(order)\n \n     def __str__(self):\n-        return f\"#triton_gpu.shared<{{vec={self.vec}, perPhase={self.per_phase}, maxPhase={self.max_phase}, order={self.order}}}>\"\n+        if is_hip():\n+            return f\"#triton_gpu_rocm.shared<{{vec={self.vec}, perPhase={self.per_phase}, maxPhase={self.max_phase}, order={self.order}}}>\"\n+        else:\n+            return f\"#triton_gpu.shared<{{vec={self.vec}, perPhase={self.per_phase}, maxPhase={self.max_phase}, order={self.order}}}>\"\n \n \n @pytest.mark.parametrize(\"dtype_x\", list(dtypes) + [\"bfloat16\"])\n@@ -713,6 +723,8 @@ def test_abs(dtype_x, device):\n \n @pytest.mark.parametrize(\"in_dtype\", [tl.float8e4b15, tl.float8e4, tl.float8e5])\n def test_abs_fp8(in_dtype, device):\n+    if is_hip():\n+        pytest.skip('test_abs_fp8 not supported on HIP.')\n \n     @triton.jit\n     def abs_kernel(X, Z, SIZE: tl.constexpr):\n@@ -916,6 +928,9 @@ def noinline_multi_values_fn(x, y, Z):\n \n @pytest.mark.parametrize(\"mode\", [\"simple\", \"call_graph\", \"shared\", \"dynamic\", \"multi_values\"])\n def test_noinline(mode, device):\n+    if is_hip() and mode == \"shared\":\n+        pytest.skip('test_noinline[\"shared\"] not supported on HIP.')\n+\n     @triton.jit\n     def kernel(X, Y, Z):\n         x = tl.load(X)\n@@ -1001,6 +1016,9 @@ def kernel(X, Z):\n     else:\n         np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01)\n     sem_str = \"acq_rel\" if sem is None else sem\n+    if is_hip():\n+        return\n+\n     assert f\"atom.global.gpu.{sem_str}\" in h.asm[\"ptx\"]\n \n \n@@ -1089,6 +1107,8 @@ def serialized_add(data, Lock, SEM: tl.constexpr):\n     h = serialized_add[(64,)](data, Lock, SEM=sem)\n     sem_str = \"acq_rel\" if sem is None else sem\n     np.testing.assert_allclose(to_numpy(data), to_numpy(ref))\n+    if is_hip():\n+        return\n     assert f\"atom.global.{sem_str}\" in h.asm[\"ptx\"]\n \n \n@@ -1117,6 +1137,9 @@ def test_cast(dtype_x, dtype_z, bitcast, device):\n     check_type_supported(dtype_x, device)\n     check_type_supported(dtype_z, device)\n \n+    if is_hip() and (dtype_z == \"bfloat16\"):\n+        pytest.skip(f'test_cast{(dtype_x, dtype_z)} cast to bfloat16 not supported on HIP.')\n+\n     size = 1024\n     # This is tricky because numpy doesn't have bfloat, and torch doesn't have uints.\n     if dtype_x.startswith('bfloat'):\n@@ -1213,7 +1236,10 @@ def kernel(in_out_ptr):\n \n     for _ in range(1000):\n         x = torch.ones((65536,), device=device, dtype=torch.float32)\n-        kernel[(65536,)](x, num_warps=32)\n+        if is_hip():\n+            kernel[(65536,)](x, num_warps=16)  # threads per Warp for ROCM is 64\n+        else:\n+            kernel[(65536,)](x, num_warps=32)\n         assert torch.all(x == 2)\n \n \n@@ -1309,6 +1335,8 @@ def test_fp8_fpN_roundtrip(in_dtype, out_dtype, device):\n         - conversion tri_fp8 = convert(input=tri_fp16, out=out_dtype) matches the original\n     this is only possible if both conversions are correct\n     \"\"\"\n+    if is_hip():\n+        pytest.skip('test_abs_fp8 not supported on HIP.')\n     check_type_supported(out_dtype, device)\n \n     @triton.jit\n@@ -1524,6 +1552,8 @@ def kernel(X, Z, BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, AXIS: tl.constexp\n \n @pytest.mark.parametrize(\"op, dtype_str, shape, axis, num_warps\", scan_configs)\n def test_scan2d(op, dtype_str, shape, axis, num_warps, device):\n+    if is_hip():\n+        pytest.skip(\"test_scan2d is not supported in HIP\")\n     check_type_supported(dtype_str, device)\n \n     # triton kernel\n@@ -1577,6 +1607,9 @@ def kernel(X, Z, BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, AXIS: tl.constexp\n @pytest.mark.parametrize(\"src_layout\", scan_layouts)\n @pytest.mark.parametrize(\"axis\", [0, 1])\n def test_scan_layouts(M, N, src_layout, axis, device):\n+    if is_hip():\n+        pytest.skip(\"test_scan_layouts is not supported in HIP\")\n+\n     ir = f\"\"\"\n     #blocked = {src_layout}\n     module attributes {{\"triton_gpu.num-warps\" = 4 : i32, \"triton_gpu.threads-per-warp\" = 32 : i32}} {{\n@@ -1640,36 +1673,44 @@ def test_scan_layouts(M, N, src_layout, axis, device):\n @pytest.mark.parametrize(\"src_layout\", layouts)\n @pytest.mark.parametrize(\"axis\", [0, 1])\n def test_reduce_layouts(M, N, src_layout, axis, device):\n+    if is_hip():\n+        pytest.skip(\"test_reduce_layouts is not supported in HIP\")\n+        gpu_dialect = \"triton_gpu_rocm\"\n+        threads_per_warp = 64\n+    else:\n+        gpu_dialect = \"triton_gpu\"\n+        threads_per_warp = 32\n+\n     rdims_2d = f\"1x{N}\" if axis == 0 else f\"{M}x1\"\n     rdims_1d = f\"{N}\" if axis == 0 else f\"{M}\"\n     store_range = \"%7\" if axis == 0 else \"%1\"\n     ir = f\"\"\"\n-    #blocked = #triton_gpu.blocked<{{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}}>\n+    #blocked = #{gpu_dialect}.blocked<{{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}}>\n     #src = {src_layout}\n-    module attributes {{\"triton_gpu.num-warps\" = 4 : i32}} {{\n+    module attributes {{\"{gpu_dialect}.num-warps\" = 4 : i32, \"{gpu_dialect}.threads-per-warp\" = {threads_per_warp} : i32}} {{\n     tt.func public @kernel_0d1d2c3d4c(%arg0: !tt.ptr<i32> {{tt.divisibility = 16 : i32}}, %arg1: i32 {{tt.divisibility = 16 : i32}}, %arg2: !tt.ptr<i32> {{tt.divisibility = 16 : i32}}) {{\n-        %0 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #triton_gpu.slice<{{dim = 1, parent = #blocked}}>>\n-        %1 = tt.expand_dims %0 {{axis = 1 : i32}} : (tensor<{M}xi32, #triton_gpu.slice<{{dim = 1, parent = #blocked}}>>) -> tensor<{M}x1xi32, #blocked>\n+        %0 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #blocked}}>>\n+        %1 = tt.expand_dims %0 {{axis = 1 : i32}} : (tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #blocked}}>>) -> tensor<{M}x1xi32, #blocked>\n         %2 = tt.splat %arg1 : (i32) -> tensor<{M}x1xi32, #blocked>\n         %3 = arith.muli %1, %2 : tensor<{M}x1xi32, #blocked>\n         %4 = tt.splat %arg0 : (!tt.ptr<i32>) -> tensor<{M}x1x!tt.ptr<i32>, #blocked>\n         %5 = tt.addptr %4, %3 : tensor<{M}x1x!tt.ptr<i32>, #blocked>, tensor<{M}x1xi32, #blocked>\n-        %6 = tt.make_range {{end = {N} : i32, start = 0 : i32}} : tensor<{N}xi32, #triton_gpu.slice<{{dim = 0, parent = #blocked}}>>\n-        %7 = tt.expand_dims %6 {{axis = 0 : i32}} : (tensor<{N}xi32, #triton_gpu.slice<{{dim = 0, parent = #blocked}}>>) -> tensor<1x{N}xi32, #blocked>\n+        %6 = tt.make_range {{end = {N} : i32, start = 0 : i32}} : tensor<{N}xi32, #{gpu_dialect}.slice<{{dim = 0, parent = #blocked}}>>\n+        %7 = tt.expand_dims %6 {{axis = 0 : i32}} : (tensor<{N}xi32, #{gpu_dialect}.slice<{{dim = 0, parent = #blocked}}>>) -> tensor<1x{N}xi32, #blocked>\n         %8 = tt.broadcast %5 : (tensor<{M}x1x!tt.ptr<i32>, #blocked>) -> tensor<{M}x{N}x!tt.ptr<i32>, #blocked>\n         %9 = tt.broadcast %7 : (tensor<1x{N}xi32, #blocked>) -> tensor<{M}x{N}xi32, #blocked>\n         %10 = tt.addptr %8, %9 : tensor<{M}x{N}x!tt.ptr<i32>, #blocked>, tensor<{M}x{N}xi32, #blocked>\n         %11 = tt.splat %arg2 : (!tt.ptr<i32>) -> tensor<{rdims_2d}x!tt.ptr<i32>, #blocked>\n         %12 = tt.addptr %11, {store_range} : tensor<{rdims_2d}x!tt.ptr<i32>, #blocked>, tensor<{rdims_2d}xi32, #blocked>\n         %13 = tt.load %10 {{cache = 1 : i32, evict = 1 : i32, isVolatile = false}} : tensor<{M}x{N}xi32, #blocked>\n-        %14 = triton_gpu.convert_layout %13 : (tensor<{M}x{N}xi32, #blocked>) -> tensor<{M}x{N}xi32, #src>\n+        %14 = {gpu_dialect}.convert_layout %13 : (tensor<{M}x{N}xi32, #blocked>) -> tensor<{M}x{N}xi32, #src>\n         %15 = \"tt.reduce\"(%14) ({{\n         ^bb0(%arg3: i32, %arg4: i32):\n           %17 = arith.addi %arg3, %arg4 : i32\n           tt.reduce.return %17 : i32\n-        }}) {{axis = {axis} : i32}} : (tensor<{M}x{N}xi32, #src>) -> tensor<{rdims_1d}xi32, #triton_gpu.slice<{{dim = {axis}, parent = #src}}>>\n-        %18 = triton_gpu.convert_layout %15 : (tensor<{rdims_1d}xi32, #triton_gpu.slice<{{dim = {axis}, parent = #src}}>>) -> tensor<{rdims_1d}xi32, #triton_gpu.slice<{{dim = {axis}, parent = #blocked}}>>\n-        %19 = tt.expand_dims %18 {{axis = {axis} : i32}} : (tensor<{rdims_1d}xi32, #triton_gpu.slice<{{dim = {axis}, parent = #blocked}}>>) -> tensor<{rdims_2d}xi32, #blocked>\n+        }}) {{axis = {axis} : i32}} : (tensor<{M}x{N}xi32, #src>) -> tensor<{rdims_1d}xi32, #{gpu_dialect}.slice<{{dim = {axis}, parent = #src}}>>\n+        %18 = {gpu_dialect}.convert_layout %15 : (tensor<{rdims_1d}xi32, #{gpu_dialect}.slice<{{dim = {axis}, parent = #src}}>>) -> tensor<{rdims_1d}xi32, #{gpu_dialect}.slice<{{dim = {axis}, parent = #blocked}}>>\n+        %19 = tt.expand_dims %18 {{axis = {axis} : i32}} : (tensor<{rdims_1d}xi32, #{gpu_dialect}.slice<{{dim = {axis}, parent = #blocked}}>>) -> tensor<{rdims_2d}xi32, #blocked>\n         tt.store %12, %19 {{cache = 1 : i32, evict = 1 : i32}} : tensor<{rdims_2d}xi32, #blocked>\n         tt.return\n     }}\n@@ -1710,17 +1751,22 @@ def test_reduce_layouts(M, N, src_layout, axis, device):\n @pytest.mark.parametrize(\"M\", [32, 64, 128, 256])\n @pytest.mark.parametrize(\"src_layout\", layouts)\n def test_store_op(M, src_layout, device):\n+    if is_hip():\n+        gpu_dialect = \"triton_gpu_rocm\"\n+    else:\n+        gpu_dialect = \"triton_gpu\"\n+\n     ir = f\"\"\"\n     #src = {src_layout}\n-    module attributes {{\"triton_gpu.num-warps\" = 4 : i32}} {{\n+    module attributes {{\"{gpu_dialect}.num-warps\" = 4 : i32}} {{\n         tt.func public @kernel(%arg0: !tt.ptr<f32> {{tt.divisibility = 16 : i32}}, %arg1: !tt.ptr<f32> {{tt.divisibility = 16 : i32}}) {{\n-            %0 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #triton_gpu.slice<{{dim = 1, parent = #src}}>>\n-            %1 = tt.splat %arg0 : (!tt.ptr<f32>) -> tensor<{M}x!tt.ptr<f32>, #triton_gpu.slice<{{dim = 1, parent = #src}}>>\n-            %2 = tt.addptr %1, %0 : tensor<{M}x!tt.ptr<f32>, #triton_gpu.slice<{{dim = 1, parent = #src}}>>, tensor<{M}xi32, #triton_gpu.slice<{{dim = 1, parent = #src}}>>\n-            %3 = tt.load %2 {{cache = 1 : i32, evict = 1 : i32, isVolatile = false}} : tensor<{M}xf32, #triton_gpu.slice<{{dim = 1, parent = #src}}>>\n-            %4 = tt.expand_dims %3 {{axis = 1 : i32}} : (tensor<{M}xf32, #triton_gpu.slice<{{dim = 1, parent = #src}}>>) -> tensor<{M}x1xf32, #src>\n-            %5 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #triton_gpu.slice<{{dim = 1, parent = #src}}>>\n-            %6 = tt.expand_dims %5 {{axis = 1 : i32}} : (tensor<{M}xi32, #triton_gpu.slice<{{dim = 1, parent = #src}}>>) -> tensor<{M}x1xi32, #src>\n+            %0 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>\n+            %1 = tt.splat %arg0 : (!tt.ptr<f32>) -> tensor<{M}x!tt.ptr<f32>, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>\n+            %2 = tt.addptr %1, %0 : tensor<{M}x!tt.ptr<f32>, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>, tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>\n+            %3 = tt.load %2 {{cache = 1 : i32, evict = 1 : i32, isVolatile = false}} : tensor<{M}xf32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>\n+            %4 = tt.expand_dims %3 {{axis = 1 : i32}} : (tensor<{M}xf32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>) -> tensor<{M}x1xf32, #src>\n+            %5 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>\n+            %6 = tt.expand_dims %5 {{axis = 1 : i32}} : (tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>) -> tensor<{M}x1xi32, #src>\n             %7 = tt.splat %arg1 : (!tt.ptr<f32>) -> tensor<{M}x1x!tt.ptr<f32>, #src>\n             %8 = tt.addptr %7, %6 : tensor<{M}x1x!tt.ptr<f32>, #src>, tensor<{M}x1xi32, #src>\n             tt.store %8, %4 : tensor<{M}x1xf32, #src>\n@@ -1759,20 +1805,25 @@ def test_store_op(M, src_layout, device):\n @pytest.mark.parametrize(\"src_dim\", [0, 1])\n @pytest.mark.parametrize(\"dst_dim\", [0, 1])\n def test_convert1d(M, src_layout, dst_layout, src_dim, dst_dim, device):\n+    if is_hip():\n+        pytest.skip(\"test_convert1d is not supported in HIP\")\n+        gpu_dialect = \"triton_gpu_rocm\"\n+    else:\n+        gpu_dialect = \"triton_gpu\"\n     ir = f\"\"\"\n     #dst = {dst_layout}\n     #src = {src_layout}\n-    module attributes {{\"triton_gpu.num-warps\" = 4 : i32}} {{\n+    module attributes {{\"{gpu_dialect}.num-warps\" = 4 : i32}} {{\n         tt.func public @kernel(%arg0: !tt.ptr<i32> {{tt.divisibility = 16 : i32}}, %arg1: !tt.ptr<i32> {{tt.divisibility = 16 : i32}}) {{\n-            %0 = tt.splat %arg0 : (!tt.ptr<i32>) -> tensor<{M}x!tt.ptr<i32>, #triton_gpu.slice<{{dim = {src_dim}, parent = #src}}>>\n-            %1 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #triton_gpu.slice<{{dim = {src_dim}, parent = #src}}>>\n-            %2 = tt.addptr %0, %1 : tensor<{M}x!tt.ptr<i32>, #triton_gpu.slice<{{dim = {src_dim}, parent = #src}}>>, tensor<{M}xi32, #triton_gpu.slice<{{dim = {src_dim}, parent = #src}}>>\n-            %3 = tt.load %2 {{cache = 1 : i32, evict = 1 : i32, isVolatile = false}} : tensor<{M}xi32, #triton_gpu.slice<{{dim = {src_dim}, parent = #src}}>>\n-            %4 = tt.splat %arg1 : (!tt.ptr<i32>) -> tensor<{M}x!tt.ptr<i32>, #triton_gpu.slice<{{dim = {dst_dim}, parent = #dst}}>>\n-            %5 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #triton_gpu.slice<{{dim = {dst_dim}, parent = #dst}}>>\n-            %6 = tt.addptr %4, %5 : tensor<{M}x!tt.ptr<i32>, #triton_gpu.slice<{{dim = {dst_dim}, parent = #dst}}>>, tensor<{M}xi32, #triton_gpu.slice<{{dim = {dst_dim}, parent = #dst}}>>\n-            %7 = triton_gpu.convert_layout %3 : (tensor<{M}xi32, #triton_gpu.slice<{{dim = {src_dim}, parent = #src}}>>) -> tensor<{M}xi32, #triton_gpu.slice<{{dim = {dst_dim}, parent = #dst}}>>\n-            tt.store %6, %7 : tensor<{M}xi32, #triton_gpu.slice<{{dim = {dst_dim}, parent = #dst}}>>\n+            %0 = tt.splat %arg0 : (!tt.ptr<i32>) -> tensor<{M}x!tt.ptr<i32>, #{gpu_dialect}.slice<{{dim = {src_dim}, parent = #src}}>>\n+            %1 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = {src_dim}, parent = #src}}>>\n+            %2 = tt.addptr %0, %1 : tensor<{M}x!tt.ptr<i32>, #{gpu_dialect}.slice<{{dim = {src_dim}, parent = #src}}>>, tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = {src_dim}, parent = #src}}>>\n+            %3 = tt.load %2 {{cache = 1 : i32, evict = 1 : i32, isVolatile = false}} : tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = {src_dim}, parent = #src}}>>\n+            %4 = tt.splat %arg1 : (!tt.ptr<i32>) -> tensor<{M}x!tt.ptr<i32>, #{gpu_dialect}.slice<{{dim = {dst_dim}, parent = #dst}}>>\n+            %5 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = {dst_dim}, parent = #dst}}>>\n+            %6 = tt.addptr %4, %5 : tensor<{M}x!tt.ptr<i32>, #{gpu_dialect}.slice<{{dim = {dst_dim}, parent = #dst}}>>, tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = {dst_dim}, parent = #dst}}>>\n+            %7 = {gpu_dialect}.convert_layout %3 : (tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = {src_dim}, parent = #src}}>>) -> tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = {dst_dim}, parent = #dst}}>>\n+            tt.store %6, %7 : tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = {dst_dim}, parent = #dst}}>>\n             tt.return\n         }}\n     }}\n@@ -1818,26 +1869,32 @@ def _welford_combine(mean_1, m2_1, weight_1, mean_2, m2_2, weight_2):\n @pytest.mark.parametrize(\"op\", [\"sum\", \"max\"])\n @pytest.mark.parametrize(\"first_axis\", [0, 1])\n def test_chain_reduce(M, N, src_layout, op, device, first_axis):\n+    if is_hip():\n+        gpu_dialect = \"triton_gpu_rocm\"\n+        pytest.skip(\"test_chain_reduce is not supported in HIP\")\n+    else:\n+        gpu_dialect = \"triton_gpu\"\n+\n     op_str = \"\"\n     if op == \"sum\":\n         op_str = f\"\"\"\n         %13 = arith.addi %arg2, %arg3 : i32\n         tt.reduce.return %13 : i32\"\"\"\n     elif op == \"max\":\n         op_str = f\"\"\"\n-        %13 = \"triton_gpu.cmpi\"(%arg2, %arg3) <{{predicate = 4 : i64}}> : (i32, i32) -> i1\n+        %13 = \"{gpu_dialect}.cmpi\"(%arg2, %arg3) <{{predicate = 4 : i64}}> : (i32, i32) -> i1\n         %14 = arith.select %13, %arg2, %arg3 : i32\n         tt.reduce.return %14 : i32\"\"\"\n     ir = f\"\"\"\n     #src = {src_layout}\n-    module attributes {{\"triton_gpu.num-warps\" = 4 : i32}} {{\n+    module attributes {{\"{gpu_dialect}.num-warps\" = 4 : i32}} {{\n     tt.func public @sum_kernel_0d1d(%arg0: !tt.ptr<i32> {{tt.divisibility = 16 : i32}}, %arg1: !tt.ptr<i32> {{tt.divisibility = 16 : i32}}) {{\n         %cst = arith.constant dense<{N}> : tensor<{M}x1xi32, #src>\n-        %0 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #triton_gpu.slice<{{dim = 1, parent = #src}}>>\n-        %1 = tt.expand_dims %0 {{axis = 1 : i32}} : (tensor<{M}xi32, #triton_gpu.slice<{{dim = 1, parent = #src}}>>) -> tensor<{M}x1xi32, #src>\n+        %0 = tt.make_range {{end = {M} : i32, start = 0 : i32}} : tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>\n+        %1 = tt.expand_dims %0 {{axis = 1 : i32}} : (tensor<{M}xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>) -> tensor<{M}x1xi32, #src>\n         %2 = arith.muli %1, %cst : tensor<{M}x1xi32, #src>\n-        %3 = tt.make_range {{end = {N} : i32, start = 0 : i32}} : tensor<{N}xi32, #triton_gpu.slice<{{dim = 0, parent = #src}}>>\n-        %4 = tt.expand_dims %3 {{axis = 0 : i32}} : (tensor<{N}xi32, #triton_gpu.slice<{{dim = 0, parent = #src}}>>) -> tensor<1x{N}xi32, #src>\n+        %3 = tt.make_range {{end = {N} : i32, start = 0 : i32}} : tensor<{N}xi32, #{gpu_dialect}.slice<{{dim = 0, parent = #src}}>>\n+        %4 = tt.expand_dims %3 {{axis = 0 : i32}} : (tensor<{N}xi32, #{gpu_dialect}.slice<{{dim = 0, parent = #src}}>>) -> tensor<1x{N}xi32, #src>\n         %5 = tt.broadcast %2 : (tensor<{M}x1xi32, #src>) -> tensor<{M}x{N}xi32, #src>\n         %6 = tt.broadcast %4 : (tensor<1x{N}xi32, #src>) -> tensor<{M}x{N}xi32, #src>\n         %7 = arith.addi %5, %6 : tensor<{M}x{N}xi32, #src>\n@@ -1847,11 +1904,11 @@ def test_chain_reduce(M, N, src_layout, op, device, first_axis):\n         %11 = \"tt.reduce\"(%10) ({{\n         ^bb0(%arg2: i32, %arg3: i32):\n         {op_str}\n-        }}) {{axis = {first_axis} : i32}} : (tensor<{M}x{N}xi32, #src>) -> tensor<{M if first_axis == 1 else N}xi32, #triton_gpu.slice<{{dim = {first_axis}, parent = #src}}>>\n+        }}) {{axis = {first_axis} : i32}} : (tensor<{M}x{N}xi32, #src>) -> tensor<{M if first_axis == 1 else N}xi32, #{gpu_dialect}.slice<{{dim = {first_axis}, parent = #src}}>>\n         %12 = \"tt.reduce\"(%11) ({{\n         ^bb0(%arg2: i32, %arg3: i32):\n         {op_str}\n-        }}) {{axis = 0 : i32}} : (tensor<{M if first_axis == 1 else N}xi32, #triton_gpu.slice<{{dim = {first_axis}, parent = #src}}>>) -> i32\n+        }}) {{axis = 0 : i32}} : (tensor<{M if first_axis == 1 else N}xi32, #{gpu_dialect}.slice<{{dim = {first_axis}, parent = #src}}>>) -> i32\n         tt.store %arg1, %12 {{cache = 1 : i32, evict = 1 : i32}} : i32\n         tt.return\n     }}\n@@ -1918,6 +1975,8 @@ def var_mean_kernel(X, out_mean, out_var, BLOCK: tl.constexpr):\n                              for perm in [(1, 0)]])\n def test_permute(dtype_str, shape, perm, device):\n     check_type_supported(dtype_str, device)  # bfloat16 on cc < 80 will not be tested\n+    if is_hip():\n+        pytest.skip(f\"test_permute is not supported in HIP\")\n \n     # triton kernel\n     @triton.jit\n@@ -1952,6 +2011,10 @@ def kernel(X, stride_xm, stride_xn,\n     # compare\n     np.testing.assert_allclose(to_numpy(z_tri), z_ref)\n     np.testing.assert_allclose(to_numpy(z_tri_contiguous), z_ref)\n+\n+    if is_hip():\n+        return\n+\n     # parse ptx to make sure ld/st are vectorized\n     ptx = pgm.asm['ptx']\n     assert 'ld.global.v4' in ptx\n@@ -1967,7 +2030,7 @@ def kernel(X, stride_xm, stride_xn,\n \n @pytest.mark.parametrize(\"M, N, K, num_warps, col_a, col_b, epilogue, allow_tf32, in_dtype, out_dtype\",\n                          [(*shape, 4, False, False, epilogue, allow_tf32, in_dtype, out_dtype)\n-                          for shape in [(64, 64, 64), (16, 16, 16)]\n+                          for shape in [(64, 64, 64), (32, 32, 32), (16, 16, 16)]\n                           for epilogue in ['none', 'trans', 'add-matrix', 'add-rows', 'add-cols', 'softmax', 'chain-dot']\n                           for allow_tf32 in [True, False]\n                           for in_dtype, out_dtype in [('float16', 'float16'),\n@@ -1997,6 +2060,17 @@ def test_dot(M, N, K, num_warps, col_a, col_b, epilogue, allow_tf32, in_dtype, o\n     check_cuda_only(device)\n \n     capability = torch.cuda.get_device_capability()\n+\n+    if is_hip():\n+        # set capability to large number to jump over check below\n+        # check are not relevant to amd gpu, left them for smaller diff between test_core.py and test_core_amd.py tests\n+        capability = (100, 100)\n+        if out_dtype is None:\n+            if in_dtype in float_dtypes:\n+                out_dtype = \"float32\"\n+            else:\n+                out_dtype = \"int32\"\n+\n     if capability[0] < 7:\n         pytest.skip(\"Only test tl.dot() on devices with sm >= 70\")\n     if capability[0] < 8:\n@@ -2011,6 +2085,14 @@ def test_dot(M, N, K, num_warps, col_a, col_b, epilogue, allow_tf32, in_dtype, o\n             # TODO: support out_dtype=float16 for tl.dot on V100\n             pytest.skip(\"Only test out_dtype=float16 on devices with sm >=80\")\n \n+    if is_hip():\n+        if (M, N, K) in [(64, 128, 128)]:\n+            pytest.skip(f\"test_dot{(M, N, K)} not supported on HIP: memory out of resource.\")\n+        if (M, N, K, num_warps) in [(128, 256, 32, 8), (128, 128, 64, 4)]:\n+            pytest.skip(f\"test_dot{(M, N, K)} not supported on HIP. Reduce Warp to work\")\n+        if M == 16 or N == 16 or K == 16:\n+            pytest.skip(f\"test_dot{(M, N, K)} segfaults on HIP\")\n+\n     torch.backends.cuda.matmul.allow_tf32 = allow_tf32\n \n     # triton kernel\n@@ -2094,6 +2176,7 @@ def kernel(X, stride_xm, stride_xk,\n         out_dtype = tl.float16\n     else:\n         out_dtype = tl.float32\n+\n     pgm = kernel[(1, 1)](x_tri, x_tri.stride(0), x_tri.stride(1),\n                          y_tri, y_tri.stride(0), y_tri.stride(1),\n                          w_tri, w_tri.stride(0), w_tri.stride(1),\n@@ -2108,7 +2191,7 @@ def kernel(X, stride_xm, stride_xk,\n                          CHAIN_DOT=epilogue == 'chain-dot',\n                          ALLOW_TF32=allow_tf32,\n                          num_warps=num_warps)\n-    if epilogue == 'softmax' and (in_dtype != 'float32' or allow_tf32):\n+    if not is_hip() and epilogue == 'softmax' and (in_dtype != 'float32' or allow_tf32):\n         ptx = pgm.asm[\"ptx\"]\n         start = ptx.find(\"shfl.sync\")\n         end = ptx.find(\"cvt.rn.f16.f32\")\n@@ -2141,9 +2224,12 @@ def kernel(X, stride_xm, stride_xk,\n         # XXX: Somehow there's a larger difference when we use float32\n         np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01, atol=1e-3)\n     elif out_dtype == tl.float16:\n-        np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01, atol=1e-3)\n+        np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01, atol=1e-2)\n     else:\n-        np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01)\n+        # added atol, to loose precision for float16xfloat16->float32 case\n+        np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01, atol=1e-3)\n+    if is_hip():\n+        return\n     # make sure ld/st are vectorized\n     ptx = pgm.asm['ptx']\n     if (K > 16 or N > 16 or M > 16) and (M * N // (num_warps * 32) >= 4):\n@@ -2196,6 +2282,9 @@ def kernel(Z, X, Y,\n     h = kernel[grid](z_tri, x_tri, y_tri, M, N, K, BM, BN, BK)\n     z_ref = np.matmul(x, y)\n     np.testing.assert_allclose(z_ref, to_numpy(z_tri), atol=0.01)\n+\n+    if is_hip():\n+        return\n     assert \"tt.dot\" in h.asm['ttir']\n     assert \"triton_gpu.async_wait {num = 2 : i32}\" in h.asm['ttgir']\n \n@@ -2250,6 +2339,9 @@ def kernel(out_ptr):\n \n @pytest.mark.parametrize(\"dtype_str\", ['float32', 'float16'])\n def test_dot_without_load(dtype_str, device):\n+    if is_hip() and dtype_str == \"float16\":\n+        pytest.skip(\"test_dot_without_load[float16] not supported in HIP\")\n+\n     @triton.jit\n     def _kernel(out):\n         a = GENERATE_TEST_HERE\n@@ -2327,6 +2419,9 @@ def _kernel(in_ptr, out_ptr, in_size: tl.constexpr, out_size: tl.constexpr):\n \n @pytest.mark.parametrize(\"dtype\", [torch.bfloat16, torch.float16, torch.float32])\n def test_masked_load_shared_memory(dtype, device):\n+    if is_hip():\n+        pytest.skip(\"test_masked_load_shared_memory is not supported in HIP\")\n+\n     check_type_supported(dtype, device)  # bfloat16 on cc < 80 will not be tested\n \n     M = 32\n@@ -2386,6 +2481,9 @@ def _kernel(dst, src, CACHE: tl.constexpr):\n         tl.store(dst + offsets, x)\n \n     pgm = _kernel[(1,)](dst, src, CACHE=cache)\n+    if is_hip():\n+        return\n+\n     ptx = pgm.asm['ptx']\n     if cache == '':\n         assert 'ld.global.ca' not in ptx\n@@ -2409,6 +2507,9 @@ def _kernel(dst, src, N, BLOCK_SIZE: tl.constexpr):\n         x = tl.load(src + offsets, mask=offsets < N)\n         tl.store(dst + offsets, x, mask=offsets < N)\n     pgm = _kernel[(1,)](dst, src, N=N, BLOCK_SIZE=src.shape[0])\n+    if is_hip():\n+        return\n+\n     ptx = pgm.asm[\"ptx\"]\n     if N % 16 == 0:\n         assert \"ld.global.v4.b32\" in ptx\n@@ -2432,6 +2533,9 @@ def _kernel(dst, src, off, N, BLOCK_SIZE: tl.constexpr, HINT: tl.constexpr):\n         x = tl.load(src + offsets, mask=offsets < N)\n         tl.store(dst + offsets, x, mask=offsets < N)\n     pgm = _kernel[(1,)](dst, src, off, N=1024, BLOCK_SIZE=src.shape[0], HINT=has_hints)\n+    if is_hip():\n+        return\n+\n     ptx = pgm.asm[\"ptx\"]\n     if has_hints:\n         assert \"ld.global.v4.b32\" in ptx\n@@ -2454,6 +2558,8 @@ def _kernel(dst, src, CACHE: tl.constexpr):\n         x = tl.load(src + offsets)\n         tl.store(dst + offsets, x, cache_modifier=CACHE)\n \n+    if is_hip():\n+        return\n     pgm = _kernel[(1,)](dst, src, CACHE=cache)\n     ptx = pgm.asm['ptx']\n     if cache == '':\n@@ -2605,6 +2711,9 @@ def kernel(VALUE, X):\n @pytest.mark.parametrize(\"is_lhs_constexpr\", [False, True])\n @pytest.mark.parametrize(\"is_rhs_constexpr\", [True, False])\n def test_bin_op_constexpr(op, is_lhs_constexpr, is_rhs_constexpr, device):\n+    if is_hip():\n+        if (is_rhs_constexpr, is_lhs_constexpr, op) in [(False, False, \"<<\"), (False, False, \">>\"), (False, True, \"<<\")]:\n+            pytest.skip(f\"test_bin_op_constexpr[{is_lhs_constexpr}-{is_rhs_constexpr}-{op}] is not supported in HIP\")\n \n     @triton.jit\n     def kernel(Z, X, Y):\n@@ -2773,6 +2882,8 @@ def _kernel(dst):\n                           ('float64', 'math.pow_dtype', tl.math.libdevice_path()),\n                           ('float64', 'math.norm4d', '')])\n def test_math_tensor(dtype_str, expr, lib_path, device):\n+    if is_hip() and expr == \"math.scalbn\":\n+        pytest.skip(\"test_math_tensor[math.scalbn] is not supported in HIP\")\n \n     @triton.jit\n     def kernel(X, Y, BLOCK: tl.constexpr):\n@@ -3142,6 +3253,8 @@ def nested_while(data, countPtr):\n \n \n def test_globaltimer(device):\n+    if is_hip():\n+        pytest.skip(\"test_globaltimer is not supported in HIP\")\n     check_cuda_only(device)\n \n     @triton.jit\n@@ -3162,6 +3275,8 @@ def kernel(Out1, Out2):\n \n \n def test_smid(device):\n+    if is_hip():\n+        pytest.skip(\"test_smid is not supported in HIP\")\n     check_cuda_only(device)\n \n     @triton.jit\n@@ -3207,6 +3322,11 @@ def kernel(Out):\n @pytest.mark.parametrize(\"interm_layout\", intermediate_layouts)\n @pytest.mark.parametrize(\"dst_layout\", layouts)\n def test_convert2d(dtype, shape, src_layout, interm_layout, dst_layout, device):\n+    if is_hip():\n+        pytest.skip(\"test_convert2d is not supported in HIP\")\n+        gpu_dialect = \"triton_gpu_rocm\"\n+    else:\n+        gpu_dialect = \"triton_gpu\"\n     if str(src_layout) == str(dst_layout):\n         pytest.skip()\n     if 'mma' in str(src_layout) and 'mma' in str(dst_layout):\n@@ -3222,40 +3342,39 @@ def test_convert2d(dtype, shape, src_layout, interm_layout, dst_layout, device):\n     \"\"\"\n \n     conversion = f\"\"\"\n-    %12 = triton_gpu.convert_layout %9 : (tensor<128x128xi32, #src>) -> tensor<128x128xi32, #dst>\n-    %13 = triton_gpu.convert_layout %11 : (tensor<128x128xf16, #src>) -> tensor<128x128xf16, #dst>\n+    %12 = {gpu_dialect}.convert_layout %9 : (tensor<128x128xi32, #src>) -> tensor<128x128xi32, #dst>\n+    %13 = {gpu_dialect}.convert_layout %11 : (tensor<128x128xf16, #src>) -> tensor<128x128xf16, #dst>\n     \"\"\" if interm_layout is None else f\"\"\"\n-    %15 = triton_gpu.convert_layout %9 : (tensor<128x128xi32, #src>) -> tensor<128x128xi32, #interm>\n-    %16 = triton_gpu.convert_layout %15 : (tensor<128x128xi32, #interm>) -> tensor<128x128xi32, #src>\n-    %17 = triton_gpu.convert_layout %11 : (tensor<128x128xf16, #src>) -> tensor<128x128xf16, #interm>\n-    %18 = triton_gpu.convert_layout %17 : (tensor<128x128xf16, #interm>) -> tensor<128x128xf16, #src>\n+    %15 = {gpu_dialect}.convert_layout %9 : (tensor<128x128xi32, #src>) -> tensor<128x128xi32, #interm>\n+    %16 = {gpu_dialect}.convert_layout %15 : (tensor<128x128xi32, #interm>) -> tensor<128x128xi32, #src>\n+    %17 = {gpu_dialect}.convert_layout %11 : (tensor<128x128xf16, #src>) -> tensor<128x128xf16, #interm>\n+    %18 = {gpu_dialect}.convert_layout %17 : (tensor<128x128xf16, #interm>) -> tensor<128x128xf16, #src>\n \n-    %12 = triton_gpu.convert_layout %16 : (tensor<128x128xi32, #src>) -> tensor<128x128xi32, #dst>\n-    %13 = triton_gpu.convert_layout %18 : (tensor<128x128xf16, #src>) -> tensor<128x128xf16, #dst>\n+    %12 = {gpu_dialect}.convert_layout %16 : (tensor<128x128xi32, #src>) -> tensor<128x128xi32, #dst>\n+    %13 = {gpu_dialect}.convert_layout %18 : (tensor<128x128xf16, #src>) -> tensor<128x128xf16, #dst>\n     \"\"\"\n \n-    ir = layouts + \"\"\"\n-    module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n-  tt.func public @kernel_0d1d(%arg0: !tt.ptr<f16> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f16> {tt.divisibility = 16 : i32}) {\n+    ir = layouts + f\"\"\"\n+    module attributes {{\"{gpu_dialect}.num-warps\" = 4 : i32}}  {{\n+  tt.func public @kernel_0d1d(%arg0: !tt.ptr<f16> {{tt.divisibility = 16 : i32}}, %arg1: !tt.ptr<f16> {{tt.divisibility = 16 : i32}}) {{\n     %cst = arith.constant dense<128> : tensor<128x1xi32, #src>\n-    %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32, #triton_gpu.slice<{dim = 1, parent = #src}>>\n-    %1 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32, #triton_gpu.slice<{dim = 0, parent = #src}>>\n+    %0 = tt.make_range {{end = 128 : i32, start = 0 : i32}} : tensor<128xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>\n+    %1 = tt.make_range {{end = 128 : i32, start = 0 : i32}} : tensor<128xi32, #{gpu_dialect}.slice<{{dim = 0, parent = #src}}>>\n     %2 = tt.splat %arg0 : (!tt.ptr<f16>) -> tensor<128x128x!tt.ptr<f16>, #src>\n-    %4 = tt.expand_dims %0 {axis = 1 : i32} : (tensor<128xi32, #triton_gpu.slice<{dim = 1, parent = #src}>>) -> tensor<128x1xi32, #src>\n+    %4 = tt.expand_dims %0 {{axis = 1 : i32}} : (tensor<128xi32, #{gpu_dialect}.slice<{{dim = 1, parent = #src}}>>) -> tensor<128x1xi32, #src>\n     %5 = arith.muli %4, %cst : tensor<128x1xi32, #src>\n-    %6 = tt.expand_dims %1 {axis = 0 : i32} : (tensor<128xi32, #triton_gpu.slice<{dim = 0, parent = #src}>>) -> tensor<1x128xi32, #src>\n+    %6 = tt.expand_dims %1 {{axis = 0 : i32}} : (tensor<128xi32, #{gpu_dialect}.slice<{{dim = 0, parent = #src}}>>) -> tensor<1x128xi32, #src>\n     %7 = tt.broadcast %6 : (tensor<1x128xi32, #src>) -> tensor<128x128xi32, #src>\n     %8 = tt.broadcast %5 : (tensor<128x1xi32, #src>) -> tensor<128x128xi32, #src>\n     %9 = arith.addi %8, %7 : tensor<128x128xi32, #src>\n     %10 = tt.addptr %2, %9 : tensor<128x128x!tt.ptr<f16>, #src>, tensor<128x128xi32, #src>\n-    %11 = tt.load %10 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<128x128xf16, #src>\n-    %3 = tt.splat %arg1 : (!tt.ptr<f16>) -> tensor<128x128x!tt.ptr<f16>, #dst>\n-    \"\"\" + conversion + \"\"\"\n-    %14 = tt.addptr %3, %12 : tensor<128x128x!tt.ptr<f16>, #dst>, tensor<128x128xi32, #dst>\n+    %11 = tt.load %10 {{cache = 1 : i32, evict = 1 : i32, isVolatile = false}} : tensor<128x128xf16, #src>\n+    %3 = tt.splat %arg1 : (!tt.ptr<f16>) -> tensor<128x128x!tt.ptr<f16>, #dst>\\\n+    {conversion}%14 = tt.addptr %3, %12 : tensor<128x128x!tt.ptr<f16>, #dst>, tensor<128x128xi32, #dst>\n     tt.store %14, %13 : tensor<128x128xf16, #dst>\n     tt.return\n-  }\n-}\n+  }}\n+}}\n \"\"\"\n \n     x = to_triton(numpy_random(shape, dtype_str=dtype), device=device)"}, {"filename": "python/triton/compiler/code_generator.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -496,7 +496,7 @@ def visit_then_else_blocks(self, node, liveins, then_block, else_block):\n             # check type\n             for defs, block_name in [(then_defs, 'then'), (else_defs, 'else')]:\n                 if name in defs:\n-                    assert defs[name].type == liveins[name].type,\\\n+                    assert defs[name].type == liveins[name].type, \\\n                         f'initial value for `{name}` is of type {liveins[name].type}, '\\\n                         f'but the {block_name} block redefines it as {defs[name].type}'\n             if name in then_defs or name in else_defs:\n@@ -516,7 +516,7 @@ def visit_then_else_blocks(self, node, liveins, then_block, else_block):\n                 continue\n             then_ty = then_defs[name].type\n             else_ty = else_defs[name].type\n-            assert then_ty == else_ty,\\\n+            assert then_ty == else_ty, \\\n                 f'mismatched type for {name} between then block ({then_ty}) '\\\n                 f'and else block ({else_ty})'\n             names.append(name)\n@@ -814,7 +814,7 @@ def visit_For(self, node):\n                 if name in liveins:\n                     assert _is_triton_tensor(self.local_defs[name]), f'{name} is not tensor'\n                     assert _is_triton_tensor(liveins[name])\n-                    assert self.local_defs[name].type == liveins[name].type,\\\n+                    assert self.local_defs[name].type == liveins[name].type, \\\n                         f'Loop-carried variable {name} has initial type {liveins[name].type} '\\\n                         f'but is re-assigned to {self.local_defs[name].type} in loop! '\\\n                         f'Please make sure that the type stays consistent.'"}, {"filename": "python/triton/compiler/compiler.py", "status": "modified", "additions": 42, "deletions": 118, "changes": 160, "file_content_changes": "@@ -5,17 +5,16 @@\n import json\n import os\n import re\n-import subprocess\n import tempfile\n from collections import namedtuple\n from pathlib import Path\n-from typing import Any, Tuple\n+from typing import Any\n \n from .._C.libtriton.triton import (add_external_libs, compile_ptx_to_cubin,\n-                                   get_shared_memory_size, ir,\n-                                   translate_llvmir_to_hsaco, translate_llvmir_to_ptx,\n+                                   get_shared_memory_size, ir, translate_llvmir_to_ptx,\n                                    translate_triton_gpu_to_llvmir)\n from ..common.backend import get_backend, path_to_ptxas\n+from ..common.build import is_hip\n # from ..runtime import driver, jit, JITFunction\n # TODO: runtime.errors\n from ..runtime.autotuner import OutOfResources\n@@ -150,72 +149,6 @@ def ptx_to_cubin(ptx: str, arch: int):\n     return compile_ptx_to_cubin(ptx, ptxas, arch)\n \n \n-# AMDGCN translation\n-\n-def get_amdgcn_bitcode_paths(arch):\n-    gpu_arch_agnostic_bitcode_libraries = [\"opencl.bc\",\n-                                           \"ocml.bc\",\n-                                           \"ockl.bc\",\n-                                           \"oclc_finite_only_off.bc\",\n-                                           \"oclc_daz_opt_off.bc\",\n-                                           \"oclc_correctly_rounded_sqrt_on.bc\",\n-                                           \"oclc_unsafe_math_off.bc\",\n-                                           \"oclc_wavefrontsize64_on.bc\"]\n-\n-    gfx_arch = arch[1]\n-    gfx_arch_id = re.search('gfx(\\\\w+)', gfx_arch).group(1).strip()\n-\n-    gpu_arch_specific_bitcode_library = 'oclc_isa_version_' + gfx_arch_id + \".bc\"\n-    bitcode_path_dir = os.path.join(Path(__file__).parent.resolve(), \"third_party/rocm/lib/bitcode/\")\n-\n-    amdgcn_bitcode_paths = {}\n-    i = 1\n-    for bc_lib in gpu_arch_agnostic_bitcode_libraries:\n-        bc_path = bitcode_path_dir + bc_lib\n-        if os.path.exists(bc_path):\n-            amdgcn_bitcode_paths['library_' + str(i)] = bc_path\n-            i += 1\n-    bc_gfx_path = bitcode_path_dir + gpu_arch_specific_bitcode_library\n-    if os.path.exists(bc_gfx_path):\n-        amdgcn_bitcode_paths['library_' + str(i)] = bc_gfx_path\n-\n-    return amdgcn_bitcode_paths\n-\n-\n-def get_amdgpu_arch_fulldetails():\n-    \"\"\"\n-    get the amdgpu fulll ISA details for compiling:\n-    i.e., arch_triple: amdgcn-amd-amdhsa; arch_name: gfx906; arch_features: sramecc+:xnack-\n-    \"\"\"\n-    try:\n-        # TODO: package rocm.cc with Triton\n-        rocm_path_dir = os.getenv(\"ROCM_PATH\", default=\"/opt/rocm\")\n-        rocminfo = subprocess.check_output(rocm_path_dir + '/bin/rocminfo').decode()\n-        gfx_arch_details = re.search('amd.*', rocminfo).group(0).strip().split('--')\n-        arch_triple = gfx_arch_details[0]\n-        arch_name_features = gfx_arch_details[1].split(':')\n-        arch_name = arch_name_features[0]\n-        arch_features = \"\"\n-\n-        if (len(arch_name_features) == 3):\n-            arch_features = \"+\" + re.search('\\\\w+', arch_name_features[1]).group(0) + \",\"\\\n-                            \"-\" + re.search('\\\\w+', arch_name_features[2]).group(0)\n-        return [arch_triple, arch_name, arch_features]\n-    except BaseException:\n-        return None\n-\n-\n-def llir_to_amdgcn_and_hsaco(mod: Any, gfx_arch: str, gfx_triple: str, gfx_features: str) -> Tuple[str, str]:\n-    '''\n-    Translate TritonGPU module to HSACO code based on full details of gpu architecture.\n-    :param mod: a TritonGPU dialect module\n-    :return:\n-        - AMDGCN code\n-        - Path to HSACO object\n-    '''\n-    return translate_llvmir_to_hsaco(mod, gfx_arch, gfx_triple, gfx_features)\n-\n-\n # ------------------------------------------------------------------------------\n # compiler\n # ------------------------------------------------------------------------------\n@@ -278,8 +211,10 @@ def make_hash(fn, arch, **kwargs):\n     \"ttgir\": mlir_arg_type_pattern,\n     \"ptx\": ptx_arg_type_pattern,\n }\n-\n-ttgir_num_warps_pattern = r'\"triton_gpu.num-warps\"\\s?=\\s?(\\d+)\\s?:'\n+if is_hip():\n+    ttgir_num_warps_pattern = r'\"triton_gpu_rocm.num-warps\"\\s?=\\s?(\\d+)\\s?:'\n+else:\n+    ttgir_num_warps_pattern = r'\"triton_gpu.num-warps\"\\s?=\\s?(\\d+)\\s?:'\n \n \n def _get_jsonable_constants(constants):\n@@ -312,39 +247,18 @@ def _is_cuda(arch):\n \n \n def get_architecture_descriptor(capability):\n-    try:\n-        import torch\n-    except ImportError:\n-        raise ImportError(\"Triton requires PyTorch to be installed\")\n     if capability is None:\n-        if torch.version.hip is None:\n-            device = get_current_device()\n-            capability = get_device_capability(device)\n-            capability = capability[0] * 10 + capability[1]\n-        else:\n-            capability = get_amdgpu_arch_fulldetails()\n+        device = get_current_device()\n+        capability = get_device_capability(device)\n+        capability = capability[0] * 10 + capability[1]\n     return capability\n \n \n-def add_rocm_stages(arch, extern_libs, stages):\n-    extern_libs.update(get_amdgcn_bitcode_paths(arch))\n-\n-    for key in list(extern_libs):\n-        if extern_libs[key] == '' or extern_libs[key] is None:\n-            extern_libs.pop(key)\n-\n-    gfx_arch_full_details = arch\n-    gfx_arch = os.environ.get('MI_GPU_ARCH', gfx_arch_full_details[1])\n-    if gfx_arch is None:\n-        raise RuntimeError('gfx_arch is None (not specified)')\n-    stages[\"amdgcn\"] = (lambda path: Path(path).read_text(),\n-                        lambda src: llir_to_amdgcn_and_hsaco(src, gfx_arch,\n-                                                             gfx_arch_full_details[0],\n-                                                             gfx_arch_full_details[2]))\n-\n-\n-def add_cuda_stages(arch, extern_libs, stages):\n-\n+def add_cuda_stages(arch, context, num_warps, num_stages, extern_libs, stages):\n+    stages[\"ttgir\"] = (lambda path: parse_mlir_module(path, context),\n+                       lambda src: optimize_ttgir(ttir_to_ttgir(src, num_warps), num_stages, arch))\n+    stages[\"llir\"] = (lambda path: Path(path).read_text(),\n+                      lambda src: ttgir_to_llir(src, extern_libs, arch))\n     stages[\"ptx\"] = (lambda path: Path(path).read_text(),\n                      lambda src: llir_to_ptx(src, arch))\n     stages[\"cubin\"] = (lambda path: Path(path).read_bytes(),\n@@ -354,17 +268,24 @@ def add_cuda_stages(arch, extern_libs, stages):\n def compile(fn, **kwargs):\n     # Get device type to decide which backend should be used\n     device_type = kwargs.get(\"device_type\", \"cuda\")\n-    _device_backend = get_backend(device_type)\n+    if is_hip():\n+        device_type = \"hip\"\n \n-    if device_type in [\"cuda\", \"hip\"]:\n+    if device_type == \"cuda\":\n+        _device_backend = get_backend(device_type)\n         arch = get_architecture_descriptor(kwargs.get(\"cc\", None))\n+    elif device_type == \"hip\":\n+        _device_backend = get_backend(device_type)\n+        assert _device_backend\n+        arch = _device_backend.get_architecture_descriptor(**kwargs)\n     else:\n         _device_backend = get_backend(device_type)\n         assert _device_backend\n         arch = _device_backend.get_architecture_descriptor(**kwargs)\n \n     is_cuda = device_type == \"cuda\" and _is_cuda(arch)\n-    is_hip = device_type in [\"cuda\", \"hip\"] and not is_cuda\n+    if is_hip():\n+        is_cuda = False\n     context = ir.context()\n     constants = kwargs.get(\"constants\", dict())\n     num_warps = kwargs.get(\"num_warps\", 4)\n@@ -379,14 +300,14 @@ def compile(fn, **kwargs):\n     stages[\"ast\"] = (lambda path: fn, None)\n     stages[\"ttir\"] = (lambda path: parse_mlir_module(path, context),\n                       lambda src: optimize_ttir(ast_to_ttir(src, signature, configs[0], constants, debug=debug, arch=arch), arch))\n-    stages[\"ttgir\"] = (lambda path: parse_mlir_module(path, context),\n-                       lambda src: optimize_ttgir(ttir_to_ttgir(src, num_warps), num_stages, arch))\n-    stages[\"llir\"] = (lambda path: Path(path).read_text(),\n-                      lambda src: ttgir_to_llir(src, extern_libs, arch))\n     if is_cuda:\n-        add_cuda_stages(arch, extern_libs, stages)\n-    elif is_hip:\n-        add_rocm_stages(arch, extern_libs, stages)\n+        add_cuda_stages(arch, context, num_warps, num_stages, extern_libs, stages)\n+    elif is_hip():\n+        _device_backend.add_stages(arch, extern_libs, stages, context=context, num_warps=num_warps, num_stages=num_stages)\n+    elif device_type == \"xpu\":\n+        stages[\"ttgir\"] = (lambda path: parse_mlir_module(path, context),\n+                           lambda src: optimize_ttgir(ttir_to_ttgir(src, num_warps), num_stages, arch))\n+        _device_backend.add_stages(arch, extern_libs, stages)\n     else:\n         _device_backend.add_stages(arch, extern_libs, stages)\n \n@@ -421,7 +342,7 @@ def compile(fn, **kwargs):\n         first_stage = list(stages.keys()).index(ir_name)\n \n     # cache manager\n-    if is_cuda or is_hip:\n+    if is_cuda:\n         so_path = make_stub(name, signature, constants)\n     else:\n         so_path = _device_backend.make_launcher_stub(name, signature, constants)\n@@ -474,7 +395,7 @@ def compile(fn, **kwargs):\n             path = metadata_group.get(ir_filename)\n             if path is None:\n                 next_module = compile_kernel(module)\n-                if ir == \"amdgcn\":\n+                if ir_name == \"amdgcn\":\n                     extra_file_name = f\"{name}.hsaco_path\"\n                     metadata_group[ir_filename] = fn_cache_manager.put(next_module[0], ir_filename)\n                     metadata_group[extra_file_name] = fn_cache_manager.put(next_module[1], extra_file_name)\n@@ -497,13 +418,16 @@ def compile(fn, **kwargs):\n         else:\n             asm[ir_name] = str(next_module)\n         if ir_name == \"llir\" and \"shared\" not in metadata:\n-            metadata[\"shared\"] = get_shared_memory_size(module)\n+            if is_hip():\n+                metadata[\"shared\"] = _device_backend.get_shared_memory_size(module)\n+            else:\n+                metadata[\"shared\"] = get_shared_memory_size(module)\n         if ir_name == \"ptx\":\n             metadata[\"name\"] = get_kernel_name(next_module, pattern='// .globl')\n         if ir_name == \"amdgcn\":\n             metadata[\"name\"] = get_kernel_name(next_module[0], pattern='.globl')\n             asm[\"hsaco_path\"] = next_module[1]\n-        if not is_cuda and not is_hip:\n+        if not is_cuda and not is_hip():\n             _device_backend.add_meta_info(ir_name, module, next_module, metadata, asm)\n         module = next_module\n     # write-back metadata, if it didn't come from the cache\n@@ -535,7 +459,7 @@ def __init__(self, fn, so_path, metadata, asm):\n         self.num_stages = metadata[\"num_stages\"]\n         self.constants = metadata[\"constants\"]\n         self.device_type = metadata[\"device_type\"]\n-        self.device_backend = get_backend(self.device_type) if self.device_type not in [\"cuda\", \"hip\"] else None\n+        self.device_backend = get_backend(self.device_type) if self.device_type not in [\"cuda\"] else None\n         # initialize asm dict\n         self.asm = asm\n         # binaries are lazily initialized\n@@ -549,7 +473,7 @@ def _init_handles(self):\n         if self.cu_module is not None:\n             return\n \n-        if self.device_type in [\"cuda\", \"hip\"]:\n+        if self.device_type in [\"cuda\"]:\n             device = get_current_device()\n             bin_path = {\n                 driver.HIP: \"hsaco_path\",\n@@ -584,7 +508,7 @@ def __getitem__(self, grid):\n \n         def runner(*args, stream=None):\n             if stream is None:\n-                if self.device_type in [\"cuda\", \"rocm\"]:\n+                if self.device_type in [\"cuda\"]:\n                     stream = get_cuda_stream()\n                 else:\n                     stream = get_backend(self.device_type).get_stream(None)"}, {"filename": "python/triton/compiler/make_launcher.py", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "file_content_changes": "@@ -3,15 +3,10 @@\n import tempfile\n \n from ..common import _build\n+from ..common.build import is_hip\n from ..runtime.cache import get_cache_manager\n from ..runtime.jit import version_key\n \n-\n-def is_hip():\n-    import torch\n-    return torch.version.hip is not None\n-\n-\n # ----- stub --------\n \n "}, {"filename": "python/triton/language/math.py", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "file_content_changes": "@@ -1,17 +1,18 @@\n import functools\n import os\n \n+from ..common.build import is_hip\n from . import core\n \n \n @functools.lru_cache()\n def libdevice_path():\n-    import torch\n     third_party_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"third_party\")\n-    if torch.version.hip is None:\n-        default = os.path.join(third_party_dir, \"cuda\", \"lib\", \"libdevice.10.bc\")\n+    if is_hip():\n+        default = os.path.join(third_party_dir, \"hip\", \"lib\", \"bitcode\", \"cuda2gcn.bc\")\n     else:\n-        default = ''\n+        default = os.path.join(third_party_dir, \"cuda\", \"lib\", \"libdevice.10.bc\")\n+\n     return os.getenv(\"TRITON_LIBDEVICE_PATH\", default)\n \n "}, {"filename": "python/triton/language/semantic.py", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "file_content_changes": "@@ -5,6 +5,7 @@\n from typing import List, Optional, Sequence, Tuple, TypeVar\n \n from .._C.libtriton.triton import ir\n+from ..common.build import is_hip\n from . import core as tl\n \n T = TypeVar('T')\n@@ -1239,6 +1240,19 @@ def atomic_xchg(ptr: tl.tensor,\n # ===----------------------------------------------------------------------===//\n \n \n+def gpu_has_mfma() -> bool:\n+    if not is_hip():\n+        return False\n+    return True  # mfma supported in ['gfx908', 'gfx90a']\n+\n+\n+def mfma_supported(M, N, K, allow_tf32, ret_scalar_ty) -> bool:\n+    if not gpu_has_mfma():\n+        return False\n+    # TODO: Add check for configurations and types.\n+    return True\n+\n+\n def dot(lhs: tl.tensor,\n         rhs: tl.tensor,\n         allow_tf32: bool,\n@@ -1250,7 +1264,7 @@ def dot(lhs: tl.tensor,\n     assert len(rhs.shape) == 2, f\"Second input shape ({rhs.shape}) is not two dimensional!\"\n     assert lhs.shape[1].value == rhs.shape[0].value, f\"First input shape ({lhs.shape}) and second input shape {rhs.shape} are not compatible for matmul (second index of first shape ({lhs.shape[1].value}) must be equal to first index of second shape ({rhs.shape[0].value})\"\n     assert lhs.shape[0].value >= 16 and lhs.shape[1].value >= 16 \\\n-        and rhs.shape[1].value >= 16,\\\n+        and rhs.shape[1].value >= 16, \\\n         f\"All values in both first input shape ({lhs.shape}) and second input shape ({rhs.shape}) must be >= 16!\"\n     if lhs.type.scalar.is_int():\n         assert lhs.type.scalar == tl.int8, \"only int8 supported!\"\n@@ -1267,6 +1281,32 @@ def dot(lhs: tl.tensor,\n \n     M = lhs.type.shape[0]\n     N = rhs.type.shape[1]\n+\n+    # Cast operands of types f16 and i8 for configurations where FMA only supported.\n+    if is_hip() and not mfma_supported(M, N, lhs.type.shape[1], allow_tf32, ret_scalar_ty):\n+        ret_cast_scalar_ty = tl.float32 if lhs.type.scalar.is_int() else ret_scalar_ty\n+        lhs = cast(lhs, ret_cast_scalar_ty, builder)\n+        rhs = cast(rhs, ret_cast_scalar_ty, builder)\n+        if ret_cast_scalar_ty == tl.float16:\n+            _0 = builder.create_splat(builder.get_fp16(0), [M, N])\n+        else:\n+            _0 = builder.create_splat(builder.get_fp32(0), [M, N])\n+        ret_ty = tl.block_type(ret_cast_scalar_ty, [M, N])\n+        ret = tl.tensor(builder.create_dot(lhs.handle, rhs.handle, _0, allow_tf32),\n+                        ret_ty)\n+        return cast(ret, ret_scalar_ty, builder)\n+    if is_hip() and mfma_supported(M, N, lhs.type.shape[1], allow_tf32, ret_scalar_ty) and ret_scalar_ty.primitive_bitwidth < 32:\n+        if lhs.type.scalar.is_int():\n+            ret_dot_scalar_ty = tl.int32\n+            _0 = builder.create_splat(builder.get_int32(0), [M, N])\n+        else:\n+            ret_dot_scalar_ty = tl.float32\n+            _0 = builder.create_splat(builder.get_fp32(0), [M, N])\n+        ret_ty = tl.block_type(ret_dot_scalar_ty, [M, N])\n+        ret = tl.tensor(builder.create_dot(lhs.handle, rhs.handle, _0, allow_tf32),\n+                        ret_ty)\n+        return cast(ret, ret_scalar_ty, builder)\n+\n     _0 = builder.create_splat(_0, [M, N])\n     ret_ty = tl.block_type(ret_scalar_ty, [M, N])\n     return tl.tensor(builder.create_dot(lhs.handle, rhs.handle, _0, allow_tf32),"}, {"filename": "python/triton/ops/blocksparse/matmul.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -395,8 +395,8 @@ def backward(ctx, dc):\n                 a, dc, not ctx.trans_a, ctx.trans_c, ctx.trans_b, ctx.spdims, ctx.block, ctx.db_lut, ctx.db_width,\n             )\n         dout = dc if ctx.has_out else None\n-        return da, db, None, None, None,\\\n-            None, None, None, None,\\\n+        return da, db, None, None, None, \\\n+            None, None, None, None, \\\n             None, None, None, None, None, dout\n \n "}, {"filename": "python/tutorials/06-fused-attention.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -338,7 +338,8 @@ def test_op(Z, H, N_CTX, D_HEAD, causal, dtype=torch.float16):\n \n \n try:\n-    from flash_attn.flash_attn_interface import flash_attn_qkvpacked_func as flash_attn_func\n+    from flash_attn.flash_attn_interface import \\\n+        flash_attn_qkvpacked_func as flash_attn_func\n     FLASH_VER = 2\n except BaseException:\n     try:"}, {"filename": "third_party/amd_hip_backend", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -0,0 +1 @@\n+Subproject commit 453761040578b0916e5e3fbfec181820185f2af9"}]