[{"filename": "python/test/unit/hopper/test_gemm.py", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "file_content_changes": "@@ -211,9 +211,10 @@ def matmul_kernel(\n \n \n @pytest.mark.parametrize('BLOCK_M,BLOCK_N,BLOCK_K,NUM_WARPS,NUM_CTAS,M,N,K,TRANS_A,TRANS_B,TRANS_OUTPUT,epilogue,out_dtype,USE_TMA_STORE,NUM_STAGES,ENABLE_WS',\n-                         [(128, 128, 64, 4, 1, *shape_w_c, 'none', out_dtype, use_tma_store, 3, enable_ws)\n+                         [\n+                             # corner shapes\n+                             (128, 128, 64, 4, 1, *shape_w_c, 'none', out_dtype, use_tma_store, 3, enable_ws)\n                           for shape_w_c in [\n-                             # badcase from cublas-important-layers\n                              [4096, 1, 1024, False, False, True],\n                              [2048, 204, 1000, True, False, True],\n                              [4096, 1, 1024, False, False, False],\n@@ -222,8 +223,9 @@ def matmul_kernel(\n                              for out_dtype in ['float16', 'float32']\n                              for use_tma_store in [False, True]\n                              for enable_ws in [False, True]\n-                         ] + [(*shape_w_c, trans_a, trans_b, trans_output, epilogue, out_dtype, use_tma_store, num_stages, enable_ws)\n-                              # softmax works for one CTA\n+                         ] + [\n+                             # softmax epilogue\n+                             (*shape_w_c, trans_a, trans_b, trans_output, epilogue, out_dtype, use_tma_store, num_stages, enable_ws)\n                               for shape_w_c in [\n                              [64, 64, 16, 4, 1, 64, 64, 64],\n                              [128, 128, 64, 4, 1, None, None, None],\n@@ -234,12 +236,14 @@ def matmul_kernel(\n                              for epilogue in ['softmax']\n                              for out_dtype in ['float16', 'float32']\n                              for use_tma_store in [False, True]\n-                             for trans_a in [False, True]\n-                             for trans_b in [False, True]\n-                             for trans_output in [False, True]\n+                             for trans_a in [False,]\n+                             for trans_b in [True,]\n+                             for trans_output in [False,]\n                              for num_stages in [3]\n                              for enable_ws in [False, True]\n-                         ] + [(*shape_w_c, trans_a, trans_b, trans_output, epilogue, out_dtype, use_tma_store, num_stages, enable_ws)\n+                         ] + [\n+                             # loop over epilogues besides of softmax\n+                             (*shape_w_c, trans_a, trans_b, trans_output, epilogue, out_dtype, use_tma_store, num_stages, enable_ws)\n                               for shape_w_c in [\n                              [64, 64, 16, 4, 1, 128, 128, 64],\n                              *[[256, 64, 16, num_warps, num_ctas, 256, 256, 64] for num_warps in [4, 8] for num_ctas in [1, 2, 4]],\n@@ -259,13 +263,15 @@ def matmul_kernel(\n                              for epilogue in ['none', 'add-matrix', 'add-rows', 'add-cols', 'chain-dot']\n                              for out_dtype in ['float16', 'float32']\n                              for use_tma_store in [False, True]\n-                             for trans_a in [False, True]\n-                             for trans_b in [False, True]\n-                             for trans_output in [False, True]\n+                             for trans_a in [False,]\n+                             for trans_b in [True,]\n+                             for trans_output in [False,]\n                              for num_stages in [3]\n                              for enable_ws in [False, True]\n                              if not (epilogue == 'chain-dot' and (shape_w_c[6] is not None or shape_w_c[1] != shape_w_c[6]))\n-                         ] + [(*shape_w_c, trans_a, trans_b, trans_output, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n+                         ] + [\n+                             # loop over tile shapes and transpose combinations\n+                             (*shape_w_c, trans_a, trans_b, trans_output, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n                               for shape_w_c in [\n                              [64, 64, 32, 4, 1, 128, 256, 64],\n                              [128, 128, 16, 4, 4, 512, 256, 64],\n@@ -280,33 +286,38 @@ def matmul_kernel(\n                              [32, 32, 16, 4, 1, 256, 256, 192],\n                              [16, 32, 64, 4, 4, 512, 256, 64],\n                          ]\n-                             for out_dtype in ['float16', 'float32']\n-                             for use_tma_store in [False, True]\n+                             for out_dtype in ['float32',]\n+                             for use_tma_store in [False,]\n                              for trans_a in [False, True]\n                              for trans_b in [False, True]\n                              for trans_output in [False, True]\n                              for num_stages in [3]\n                              for enable_ws in [False, True]\n-                         ] + [(64, n, 16, 4, 1, 512, 256, 256, False, True, trans_output, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n-                              # loop over instr shapes\n+                         ] + [\n+                             # loop over instr shapes & pipeline stages\n+                             (64, n, 16, 4, 1, 512, 256, 256, False, True, trans_output, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n                               for n in [16, 32, 64, 128, 256]\n-                              for trans_output in [False, True]\n-                              for out_dtype in ['float16', 'float32']\n-                              for use_tma_store in [False, True]\n+                              for trans_output in [False,]\n+                              for out_dtype in ['float32',]\n+                              for use_tma_store in [False,]\n                               for num_stages in [2, 4, 5, 7]\n                               for enable_ws in [False, True]\n-                              ] + [(*shape_w_c, *shape, False, True, trans_output, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n-                                   # irregular shapes\n-                                   for shape_w_c in [\n-                                       [128, 128, 64, 4, 1],\n-                                       [256, 128, 64, 4, 2],\n-                                       [128, 128, 128, 4, 2],\n-                              ]\n-                             for shape in list(itertools.product([*range(512, 4096, 360)], [*range(512, 4096, 360)], [512, 1024]))\n-                             for trans_output in [False, True]\n-                             for out_dtype in ['float16', 'float32']\n+                         ] + [\n+                             # irregular shapes\n+                             (*shape_w_c, *shape, False, True, trans_output, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n+                             for shape_w_c in [\n+                                 [128, 128, 64, 4, 1],\n+                                 [256, 128, 64, 4, 2],\n+                                 [128, 128, 128, 4, 2],\n+                             ]\n+                             for shape in [\n+                                 [512, 360, 1024],\n+                                 [360, 4096, 512],\n+                             ]\n+                             for trans_output in [False,]\n+                             for out_dtype in ['float32',]\n                              for use_tma_store in [False, True]\n-                             for num_stages in [2, 3, 4]\n+                             for num_stages in [3, 4]\n                              for enable_ws in [False, True]\n                          ])\n @pytest.mark.skipif(torch.cuda.get_device_capability()"}, {"filename": "python/test/unit/hopper/test_persistent_warp_specialized_gemm.py", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "file_content_changes": "@@ -696,9 +696,9 @@ def full_static_persistent_matmul_kernel(\n \n @pytest.mark.parametrize('BLOCK_M,BLOCK_N,BLOCK_K,NUM_WARPS,NUM_CTAS,M,N,K,TRANS_A,TRANS_B,epilogue,out_dtype,USE_TMA_STORE,NUM_STAGES,ENABLE_WS',\n                          [\n+                             # corner shapes\n                              (128, 128, 64, 4, 1, *shape_w_c, 'none', out_dtype, use_tma_store, 3, enable_ws)\n                              for shape_w_c in [\n-                                 # bad from cublas-important-layers\n                                  [4096, 1, 1024, False, False],\n                                  [2048, 204, 1000, True, False],\n                                  [16, 524288, 32, False, True],\n@@ -707,6 +707,7 @@ def full_static_persistent_matmul_kernel(\n                              for use_tma_store in [False, True]\n                              for enable_ws in [True]\n                          ] + [\n+                             # softmax epilogue\n                              (*shape_w_c, trans_a, trans_b, epilogue, out_dtype, use_tma_store, num_stages, enable_ws)\n                              # softmax works for one CTA\n                              for shape_w_c in [\n@@ -720,11 +721,12 @@ def full_static_persistent_matmul_kernel(\n                              for epilogue in ['softmax']\n                              for out_dtype in ['float16', 'float32']\n                              for use_tma_store in [False, True]\n-                             for trans_a in [False, True]\n-                             for trans_b in [False, True]\n+                             for trans_a in [False,]\n+                             for trans_b in [True,]\n                              for num_stages in [3]\n                              for enable_ws in [True]\n                          ] + [\n+                             # loop over tile shapes and transpose combinations\n                              (*shape_w_c, trans_a, trans_b, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n                              for shape_w_c in [\n                                  [64, 64, 32, 4, 1, 128, 256, 64],\n@@ -740,13 +742,15 @@ def full_static_persistent_matmul_kernel(\n                                  [32, 32, 16, 4, 1, 256, 256, 192],\n                                  [16, 32, 64, 4, 4, 512, 256, 64],\n                              ]\n-                             for out_dtype in ['float16', 'float32']\n-                             for use_tma_store in [False, True]\n+                             for out_dtype in ['float32',]\n+                             for use_tma_store in [False,]\n                              for trans_a in [False, True]\n                              for trans_b in [False, True]\n                              for num_stages in [3]\n                              for enable_ws in [True]\n-                         ] + [(*shape_w_c, trans_a, trans_b, epilogue, out_dtype, use_tma_store, num_stages, enable_ws)\n+                         ] + [\n+                             # loop over epilogues besides of softmax\n+                             (*shape_w_c, trans_a, trans_b, epilogue, out_dtype, use_tma_store, num_stages, enable_ws)\n                               for shape_w_c in [\n                              [64, 64, 16, 4, 1, 128, 128, 64],\n                              *[[256, 64, 16, num_warps, num_ctas, 256, 256, 64] for num_warps in [4] for num_ctas in [1, 2, 4]],\n@@ -767,31 +771,34 @@ def full_static_persistent_matmul_kernel(\n                              for epilogue in ['none', 'add-matrix', 'add-rows', 'add-cols', 'chain-dot']\n                              for out_dtype in ['float16', 'float32']\n                              for use_tma_store in [False, True]\n-                             for trans_a in [False, True]\n-                             for trans_b in [False, True]\n+                             for trans_a in [False,]\n+                             for trans_b in [True,]\n                              for num_stages in [3]\n                              for enable_ws in [True]\n                              if not (epilogue == 'chain-dot' and (shape_w_c[5] is not None or shape_w_c[0] != shape_w_c[1]))\n                          ] + [\n+                             # loop over instr shapes & pipeline stages\n                              (64, n, 16, 4, 1, 512, 256, 256, False, True, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n-                             # loop over instr shapes\n                              for n in [16, 32, 64, 128, 256]\n-                             for out_dtype in ['float16', 'float32']\n-                             for use_tma_store in [False, True]\n+                             for out_dtype in ['float32']\n+                             for use_tma_store in [False,]\n                              for num_stages in [2, 4, 5, 7]\n                              for enable_ws in [True]\n                          ] + [\n-                             (*shape_w_c, *shape, False, True, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n                              # irregular shapes\n+                             (*shape_w_c, *shape, False, True, 'none', out_dtype, use_tma_store, num_stages, enable_ws)\n                              for shape_w_c in [\n                                  [128, 128, 64, 4, 1],\n                                  [256, 128, 64, 4, 2],\n                                  [128, 128, 128, 4, 2]\n                              ]\n-                             for shape in list(itertools.product([*range(512, 4096, 360)], [*range(512, 4096, 360)], [512, 1024]))\n-                             for out_dtype in ['float16', 'float32']\n+                             for shape in [\n+                                 [512, 360, 1024],\n+                                 [360, 4096, 512],\n+                             ]\n+                             for out_dtype in ['float32']\n                              for use_tma_store in [False, True]\n-                             for num_stages in [2, 3, 4]\n+                             for num_stages in [3, 4]\n                              for enable_ws in [True]\n                          ]\n                          )"}, {"filename": "python/test/unit/operators/test_flash_attention.py", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "file_content_changes": "@@ -5,20 +5,19 @@\n import triton.ops\n \n \n-@pytest.mark.parametrize('Z, H, N_CTX, D_HEAD', [(4, 48, 1024, 16),\n-                                                 (4, 48, 1024, 32),\n+@pytest.mark.parametrize('Z, H, N_CTX, D_HEAD', [\n                                                  (4, 48, 1024, 64),\n-                                                 (4, 48, 1024, 128)])\n-@pytest.mark.parametrize('dtype', [torch.float16, torch.bfloat16])\n-@pytest.mark.parametrize('causal', [True, False])\n-@pytest.mark.parametrize('seq_par', [True, False])\n+                                                 ])\n+@pytest.mark.parametrize('dtype', [torch.float16,])\n+@pytest.mark.parametrize('causal', [True,])\n+@pytest.mark.parametrize('seq_par', [True,])\n def test_op(Z, H, N_CTX, D_HEAD, dtype, causal, seq_par):\n     # with ENABLE_TMA=0 and ENABLE_MMA_V3=0\n     import os\n     enable_mmav3 = os.environ.get('ENABLE_MMA_V3', 'not found').lower()\n     enable_tma = os.environ.get('ENABLE_TMA', 'not found').lower()\n-    if enable_mmav3 in [\"on\", \"true\", \"1\"] and enable_tma in [\"on\", \"true\", \"1\"]:\n-        pytest.skip('Segmentation fault')\n+    # if enable_mmav3 in [\"on\", \"true\", \"1\"] and enable_tma in [\"on\", \"true\", \"1\"]:\n+    #     pytest.skip('Segmentation fault')\n \n     capability = torch.cuda.get_device_capability()\n     if capability[0] < 8:"}]