[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "file_content_changes": "@@ -31,6 +31,13 @@ static Type getI1SameShape(Value v) {\n   return i1Type;\n }\n \n+// pass named attrs (e.g., tt.contiguity) from Triton to Triton\n+static void addNamedAttrs(Operation *op, DictionaryAttr dictAttrs) {\n+  for (const NamedAttribute attr : dictAttrs.getValue())\n+    if (!op->hasAttr(attr.getName()))\n+      op->setAttr(attr.getName(), attr.getValue());\n+}\n+\n #define int_attr(num) builder.getI64IntegerAttr(num)\n \n namespace {\n@@ -70,6 +77,8 @@ class LoopPipeliner {\n   /// Block arguments that loads depend on\n   SetVector<BlockArgument> depArgs;\n \n+  SetVector<BlockArgument> nonImmedidateDepArgs;\n+\n   /// Operations (inside the loop body) that loads depend on\n   SetVector<Operation *> depOps;\n \n@@ -204,6 +213,12 @@ LogicalResult LoopPipeliner::initialize() {\n     for (Value op : loadOp->getOperands())\n       collectDeps(op, numStages - 1, deps);\n     loadDeps[loadOp] = deps;\n+    if (deps.size() > 0 && !isa<BlockArgument>(deps.front())) {\n+      for (auto dep : deps) {\n+        if (auto arg = dyn_cast<BlockArgument>(dep))\n+          nonImmedidateDepArgs.insert(arg);\n+      }\n+    }\n   }\n \n   // Don't pipeline valid loads that depend on other valid loads\n@@ -373,6 +388,7 @@ void LoopPipeliner::emitPrologue() {\n               lookupOrDefault(loadOp.getPtr(), stage), newMask,\n               lookupOrDefault(loadOp.getOther(), stage), loadOp.getCache(),\n               loadOp.getEvict(), loadOp.getIsVolatile());\n+          addNamedAttrs(newOp, op->getAttrDictionary());\n         } else {\n           newOp = builder.clone(*op);\n         }\n@@ -459,9 +475,9 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n   //   (original args)\n   //   (insertSliceAsync buffer at stage numStages - 1) for each load\n   //   (extracted tensor) for each load\n-  //   (depArgs at stage numStages - 1)\n+  //   (depArgs at stage numStages - 1):\n   //   for each dep arg that is not an immediate block argument\n-  //   (depArgs at stage numStages - 2)\n+  //   (depArgs at stage numStages - 2):\n   //   for each dep arg that is an immediate block argument\n   //   (iv at stage numStages - 2)\n   //   (pipeline iteration index)\n@@ -483,19 +499,10 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n   size_t depArgsBeginIdx = newLoopArgs.size();\n   for (BlockArgument depArg : depArgs) {\n     depArgsIdx[depArg] = newLoopArgs.size();\n-    auto users = depArg.getUsers();\n-    bool immediate = false;\n-    for (auto user : users) {\n-      if (loads.contains(user->getResult(0))) {\n-        // Immediate dep arg\n-        immediate = true;\n-        break;\n-      }\n-    }\n-    if (immediate)\n-      newLoopArgs.push_back(valueMapping[depArg][numStages - 2]);\n-    else\n+    if (nonImmedidateDepArgs.contains(depArg)) {\n       newLoopArgs.push_back(valueMapping[depArg][numStages - 1]);\n+    } else\n+      newLoopArgs.push_back(valueMapping[depArg][numStages - 2]);\n   }\n \n   size_t nextIVIdx = newLoopArgs.size();\n@@ -604,6 +611,7 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n             nextMapping.lookupOrDefault(loadOp.getPtr()), newMask,\n             nextMapping.lookupOrDefault(loadOp.getOther()), loadOp.getCache(),\n             loadOp.getEvict(), loadOp.getIsVolatile());\n+        addNamedAttrs(nextOp, op->getAttrDictionary());\n         nextMapping.map(loadOp.getResult(), nextOp->getResult(0));\n       } else {\n         nextOp = builder.clone(*op, nextMapping);"}]