[{"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.cpp", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "file_content_changes": "@@ -1,6 +1,7 @@\n #include \"triton/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.h\"\n \n #include \"mlir/Dialect/Arithmetic/IR/Arithmetic.h\"\n+#include \"mlir/Dialect/ControlFlow/IR/ControlFlowOps.h\"\n #include \"mlir/Dialect/GPU/IR/GPUDialect.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/Dialect/LLVMIR/NVVMDialect.h\"\n@@ -625,29 +626,28 @@ void populateSCFPatterns(TritonGPUTypeConverter &typeConverter,\n \n // CF\n \n-class CFBranchPattern : public OpConversionPattern<BranchOp> {\n+class CFBranchPattern : public OpConversionPattern<cf::BranchOp> {\n public:\n-  using OpConversionPattern<BranchOp>::OpConversionPattern;\n+  using OpConversionPattern<cf::BranchOp>::OpConversionPattern;\n \n   LogicalResult\n-  matchAndRewrite(BranchOp op, BranchOp::Adaptor adaptor,\n+  matchAndRewrite(cf::BranchOp op, cf::BranchOp::Adaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n-    auto converter = getTypeConverter();\n-    auto newOp = rewriter.replaceOpWithNewOp<BranchOp>(op, op.getSuccessor(),\n-                                                       adaptor.getOperands());\n+    auto newOp = rewriter.replaceOpWithNewOp<cf::BranchOp>(\n+        op, op.getSuccessor(), adaptor.getOperands());\n     return success();\n   }\n };\n \n-class CFCondBranchPattern : public OpConversionPattern<CondBranchOp> {\n+class CFCondBranchPattern : public OpConversionPattern<cf::CondBranchOp> {\n public:\n-  using OpConversionPattern<CondBranchOp>::OpConversionPattern;\n+  using OpConversionPattern<cf::CondBranchOp>::OpConversionPattern;\n \n   LogicalResult\n-  matchAndRewrite(CondBranchOp op, CondBranchOp::Adaptor adaptor,\n+  matchAndRewrite(cf::CondBranchOp op, cf::CondBranchOp::Adaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n     auto converter = getTypeConverter();\n-    auto newOp = rewriter.replaceOpWithNewOp<CondBranchOp>(\n+    auto newOp = rewriter.replaceOpWithNewOp<cf::CondBranchOp>(\n         op, adaptor.getCondition(), op.getTrueDest(),\n         adaptor.getTrueDestOperands(), op.getFalseDest(),\n         adaptor.getFalseDestOperands());"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "file_content_changes": "@@ -2,6 +2,7 @@\n #include \"mlir/IR/BlockAndValueMapping.h\"\n #include \"mlir/IR/TypeUtilities.h\"\n #include \"triton/Analysis/AxisInfo.h\"\n+#include \"triton/Analysis/Utility.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n #include \"triton/Dialect/TritonGPU/Transforms/Passes.h\"\n \n@@ -160,15 +161,18 @@ ttg::AllocTensorOp LoopPipeliner::allocateEmptyBuffer(Operation *op,\n LogicalResult LoopPipeliner::initialize() {\n   Block *loop = forOp.getBody();\n \n-  AxisInfoAnalysis axisInfoAnalysis(forOp.getContext());\n-  axisInfoAnalysis.run(forOp->getParentOfType<ModuleOp>());\n+  std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n+  AxisInfoAnalysis *axisInfoAnalysis = solver->load<AxisInfoAnalysis>();\n+  if (failed(solver->initializeAndRun(forOp->getParentOfType<ModuleOp>()))) {\n+    return failure();\n+  }\n \n   // can we use forOp.walk(...) here?\n   SmallVector<triton::LoadOp, 2> allLoads;\n   for (Operation &op : *loop)\n     if (auto loadOp = dyn_cast<triton::LoadOp>(&op)) {\n       auto ptr = loadOp.ptr();\n-      unsigned vec = axisInfoAnalysis.getPtrVectorSize(ptr);\n+      unsigned vec = axisInfoAnalysis->getPtrVectorSize(ptr);\n       auto ty = getElementTypeOrSelf(ptr.getType())\n                     .cast<triton::PointerType>()\n                     .getPointeeType();"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "file_content_changes": "@@ -11,6 +11,7 @@\n #include \"mlir/Parser/Parser.h\"\n #include \"mlir/Support/FileUtilities.h\"\n \n+#include \"mlir/Dialect/ControlFlow/IR/ControlFlowOps.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"triton/Analysis/Allocation.h\"\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h\"\n@@ -655,15 +656,15 @@ void init_triton_ir(py::module &&m) {\n            [](mlir::OpBuilder &self, mlir::Value condition,\n               mlir::Block *trueDest, mlir::Block *falseDest) {\n              auto loc = self.getUnknownLoc();\n-             self.create<mlir::CondBranchOp>(loc, condition, trueDest,\n-                                             falseDest);\n+             self.create<mlir::cf::CondBranchOp>(loc, condition, trueDest,\n+                                                 falseDest);\n              return;\n            })\n       .def(\"create_branch\",\n            [](mlir::OpBuilder &self, mlir::Block *dest,\n               std::vector<mlir::Value> &args) {\n              auto loc = self.getUnknownLoc();\n-             self.create<mlir::BranchOp>(loc, dest, args);\n+             self.create<mlir::cf::BranchOp>(loc, dest, args);\n              return;\n            })\n       // Structured control flow"}]