[{"filename": "python/src/pybind11/attr.h", "status": "modified", "additions": 288, "deletions": 103, "changes": 391, "file_content_changes": "@@ -10,65 +10,113 @@\n \n #pragma once\n \n+#include \"detail/common.h\"\n #include \"cast.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+#include <functional>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n \n /// \\addtogroup annotations\n /// @{\n \n /// Annotation for methods\n-struct is_method { handle class_; is_method(const handle &c) : class_(c) { } };\n+struct is_method {\n+    handle class_;\n+    explicit is_method(const handle &c) : class_(c) {}\n+};\n \n /// Annotation for operators\n-struct is_operator { };\n+struct is_operator {};\n+\n+/// Annotation for classes that cannot be subclassed\n+struct is_final {};\n \n /// Annotation for parent scope\n-struct scope { handle value; scope(const handle &s) : value(s) { } };\n+struct scope {\n+    handle value;\n+    explicit scope(const handle &s) : value(s) {}\n+};\n \n /// Annotation for documentation\n-struct doc { const char *value; doc(const char *value) : value(value) { } };\n+struct doc {\n+    const char *value;\n+    explicit doc(const char *value) : value(value) {}\n+};\n \n /// Annotation for function names\n-struct name { const char *value; name(const char *value) : value(value) { } };\n+struct name {\n+    const char *value;\n+    explicit name(const char *value) : value(value) {}\n+};\n \n /// Annotation indicating that a function is an overload associated with a given \"sibling\"\n-struct sibling { handle value; sibling(const handle &value) : value(value.ptr()) { } };\n+struct sibling {\n+    handle value;\n+    explicit sibling(const handle &value) : value(value.ptr()) {}\n+};\n \n /// Annotation indicating that a class derives from another given type\n-template <typename T> struct base {\n-    PYBIND11_DEPRECATED(\"base<T>() was deprecated in favor of specifying 'T' as a template argument to class_\")\n-    base() { }\n+template <typename T>\n+struct base {\n+\n+    PYBIND11_DEPRECATED(\n+        \"base<T>() was deprecated in favor of specifying 'T' as a template argument to class_\")\n+    base() = default;\n };\n \n /// Keep patient alive while nurse lives\n-template <size_t Nurse, size_t Patient> struct keep_alive { };\n+template <size_t Nurse, size_t Patient>\n+struct keep_alive {};\n \n /// Annotation indicating that a class is involved in a multiple inheritance relationship\n-struct multiple_inheritance { };\n+struct multiple_inheritance {};\n \n /// Annotation which enables dynamic attributes, i.e. adds `__dict__` to a class\n-struct dynamic_attr { };\n+struct dynamic_attr {};\n \n /// Annotation which enables the buffer protocol for a type\n-struct buffer_protocol { };\n+struct buffer_protocol {};\n \n /// Annotation which requests that a special metaclass is created for a type\n struct metaclass {\n     handle value;\n \n     PYBIND11_DEPRECATED(\"py::metaclass() is no longer required. It's turned on by default now.\")\n-    metaclass() {}\n+    metaclass() = default;\n \n     /// Override pybind11's default metaclass\n-    explicit metaclass(handle value) : value(value) { }\n+    explicit metaclass(handle value) : value(value) {}\n+};\n+\n+/// Specifies a custom callback with signature `void (PyHeapTypeObject*)` that\n+/// may be used to customize the Python type.\n+///\n+/// The callback is invoked immediately before `PyType_Ready`.\n+///\n+/// Note: This is an advanced interface, and uses of it may require changes to\n+/// work with later versions of pybind11.  You may wish to consult the\n+/// implementation of `make_new_python_type` in `detail/classes.h` to understand\n+/// the context in which the callback will be run.\n+struct custom_type_setup {\n+    using callback = std::function<void(PyHeapTypeObject *heap_type)>;\n+\n+    explicit custom_type_setup(callback value) : value(std::move(value)) {}\n+\n+    callback value;\n };\n \n /// Annotation that marks a class as local to the module:\n-struct module_local { const bool value; constexpr module_local(bool v = true) : value(v) { } };\n+struct module_local {\n+    const bool value;\n+    constexpr explicit module_local(bool v = true) : value(v) {}\n+};\n \n /// Annotation to mark enums as an arithmetic type\n-struct arithmetic { };\n+struct arithmetic {};\n+\n+/// Mark a function for addition at the beginning of the existing overload chain instead of the end\n+struct prepend {};\n \n /** \\rst\n     A call policy which places one or more guard variables (``Ts...``) around the function call.\n@@ -88,9 +136,13 @@ struct arithmetic { };\n             return foo(args...); // forwarded arguments\n         });\n  \\endrst */\n-template <typename... Ts> struct call_guard;\n+template <typename... Ts>\n+struct call_guard;\n \n-template <> struct call_guard<> { using type = detail::void_type; };\n+template <>\n+struct call_guard<> {\n+    using type = detail::void_type;\n+};\n \n template <typename T>\n struct call_guard<T> {\n@@ -110,13 +162,14 @@ struct call_guard<T, Ts...> {\n \n /// @} annotations\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n /* Forward declarations */\n enum op_id : int;\n enum op_type : int;\n struct undefined_t;\n-template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t> struct op_;\n-inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);\n+template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t>\n+struct op_;\n+void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);\n \n /// Internal data structure which holds metadata about a keyword argument\n struct argument_record {\n@@ -127,14 +180,16 @@ struct argument_record {\n     bool none : 1;     ///< True if None is allowed when loading\n \n     argument_record(const char *name, const char *descr, handle value, bool convert, bool none)\n-        : name(name), descr(descr), value(value), convert(convert), none(none) { }\n+        : name(name), descr(descr), value(value), convert(convert), none(none) {}\n };\n \n-/// Internal data structure which holds metadata about a bound function (signature, overloads, etc.)\n+/// Internal data structure which holds metadata about a bound function (signature, overloads,\n+/// etc.)\n struct function_record {\n     function_record()\n         : is_constructor(false), is_new_style_constructor(false), is_stateless(false),\n-          is_operator(false), has_args(false), has_kwargs(false), is_method(false) { }\n+          is_operator(false), is_method(false), has_args(false), has_kwargs(false),\n+          prepend(false) {}\n \n     /// Function name\n     char *name = nullptr; /* why no C++ strings? They generate heavier code.. */\n@@ -149,13 +204,13 @@ struct function_record {\n     std::vector<argument_record> args;\n \n     /// Pointer to lambda function which converts arguments and performs the actual call\n-    handle (*impl) (function_call &) = nullptr;\n+    handle (*impl)(function_call &) = nullptr;\n \n     /// Storage for the wrapped function pointer and captured data, if any\n-    void *data[3] = { };\n+    void *data[3] = {};\n \n     /// Pointer to custom destructor for 'data' (if needed)\n-    void (*free_data) (function_record *ptr) = nullptr;\n+    void (*free_data)(function_record *ptr) = nullptr;\n \n     /// Return value policy associated with this function\n     return_value_policy policy = return_value_policy::automatic;\n@@ -172,18 +227,28 @@ struct function_record {\n     /// True if this is an operator (__add__), etc.\n     bool is_operator : 1;\n \n+    /// True if this is a method\n+    bool is_method : 1;\n+\n     /// True if the function has a '*args' argument\n     bool has_args : 1;\n \n     /// True if the function has a '**kwargs' argument\n     bool has_kwargs : 1;\n \n-    /// True if this is a method\n-    bool is_method : 1;\n+    /// True if this function is to be inserted at the beginning of the overload resolution chain\n+    bool prepend : 1;\n \n     /// Number of arguments (including py::args and/or py::kwargs, if present)\n     std::uint16_t nargs;\n \n+    /// Number of leading positional arguments, which are terminated by a py::args or py::kwargs\n+    /// argument or by a py::kw_only annotation.\n+    std::uint16_t nargs_pos = 0;\n+\n+    /// Number of leading arguments (counted in `nargs`) that are positional-only\n+    std::uint16_t nargs_pos_only = 0;\n+\n     /// Python method object\n     PyMethodDef *def = nullptr;\n \n@@ -201,7 +266,7 @@ struct function_record {\n struct type_record {\n     PYBIND11_NOINLINE type_record()\n         : multiple_inheritance(false), dynamic_attr(false), buffer_protocol(false),\n-          default_holder(true), module_local(false) { }\n+          default_holder(true), module_local(false), is_final(false) {}\n \n     /// Handle to the parent scope\n     handle scope;\n@@ -239,6 +304,9 @@ struct type_record {\n     /// Custom metaclass (optional)\n     handle metaclass;\n \n+    /// Custom type setup.\n+    custom_type_setup::callback custom_type_setup_callback;\n+\n     /// Multiple inheritance marker\n     bool multiple_inheritance : 1;\n \n@@ -254,148 +322,226 @@ struct type_record {\n     /// Is the class definition local to the module shared object?\n     bool module_local : 1;\n \n-    PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *)) {\n-        auto base_info = detail::get_type_info(base, false);\n+    /// Is the class inheritable from python classes?\n+    bool is_final : 1;\n+\n+    PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *) ) {\n+        auto *base_info = detail::get_type_info(base, false);\n         if (!base_info) {\n             std::string tname(base.name());\n             detail::clean_type_id(tname);\n-            pybind11_fail(\"generic_type: type \\\"\" + std::string(name) +\n-                          \"\\\" referenced unknown base type \\\"\" + tname + \"\\\"\");\n+            pybind11_fail(\"generic_type: type \\\"\" + std::string(name)\n+                          + \"\\\" referenced unknown base type \\\"\" + tname + \"\\\"\");\n         }\n \n         if (default_holder != base_info->default_holder) {\n             std::string tname(base.name());\n             detail::clean_type_id(tname);\n-            pybind11_fail(\"generic_type: type \\\"\" + std::string(name) + \"\\\" \" +\n-                    (default_holder ? \"does not have\" : \"has\") +\n-                    \" a non-default holder type while its base \\\"\" + tname + \"\\\" \" +\n-                    (base_info->default_holder ? \"does not\" : \"does\"));\n+            pybind11_fail(\"generic_type: type \\\"\" + std::string(name) + \"\\\" \"\n+                          + (default_holder ? \"does not have\" : \"has\")\n+                          + \" a non-default holder type while its base \\\"\" + tname + \"\\\" \"\n+                          + (base_info->default_holder ? \"does not\" : \"does\"));\n         }\n \n         bases.append((PyObject *) base_info->type);\n \n-        if (base_info->type->tp_dictoffset != 0)\n-            dynamic_attr = true;\n+#if PY_VERSION_HEX < 0x030B0000\n+        dynamic_attr |= base_info->type->tp_dictoffset != 0;\n+#else\n+        dynamic_attr |= (base_info->type->tp_flags & Py_TPFLAGS_MANAGED_DICT) != 0;\n+#endif\n \n-        if (caster)\n+        if (caster) {\n             base_info->implicit_casts.emplace_back(type, caster);\n+        }\n     }\n };\n \n-inline function_call::function_call(const function_record &f, handle p) :\n-        func(f), parent(p) {\n+inline function_call::function_call(const function_record &f, handle p) : func(f), parent(p) {\n     args.reserve(f.nargs);\n     args_convert.reserve(f.nargs);\n }\n \n /// Tag for a new-style `__init__` defined in `detail/init.h`\n-struct is_new_style_constructor { };\n+struct is_new_style_constructor {};\n \n /**\n  * Partial template specializations to process custom attributes provided to\n  * cpp_function_ and class_. These are either used to initialize the respective\n  * fields in the type_record and function_record data structures or executed at\n  * runtime to deal with custom call policies (e.g. keep_alive).\n  */\n-template <typename T, typename SFINAE = void> struct process_attribute;\n+template <typename T, typename SFINAE = void>\n+struct process_attribute;\n \n-template <typename T> struct process_attribute_default {\n+template <typename T>\n+struct process_attribute_default {\n     /// Default implementation: do nothing\n-    static void init(const T &, function_record *) { }\n-    static void init(const T &, type_record *) { }\n-    static void precall(function_call &) { }\n-    static void postcall(function_call &, handle) { }\n+    static void init(const T &, function_record *) {}\n+    static void init(const T &, type_record *) {}\n+    static void precall(function_call &) {}\n+    static void postcall(function_call &, handle) {}\n };\n \n /// Process an attribute specifying the function's name\n-template <> struct process_attribute<name> : process_attribute_default<name> {\n+template <>\n+struct process_attribute<name> : process_attribute_default<name> {\n     static void init(const name &n, function_record *r) { r->name = const_cast<char *>(n.value); }\n };\n \n /// Process an attribute specifying the function's docstring\n-template <> struct process_attribute<doc> : process_attribute_default<doc> {\n+template <>\n+struct process_attribute<doc> : process_attribute_default<doc> {\n     static void init(const doc &n, function_record *r) { r->doc = const_cast<char *>(n.value); }\n };\n \n /// Process an attribute specifying the function's docstring (provided as a C-style string)\n-template <> struct process_attribute<const char *> : process_attribute_default<const char *> {\n+template <>\n+struct process_attribute<const char *> : process_attribute_default<const char *> {\n     static void init(const char *d, function_record *r) { r->doc = const_cast<char *>(d); }\n     static void init(const char *d, type_record *r) { r->doc = const_cast<char *>(d); }\n };\n-template <> struct process_attribute<char *> : process_attribute<const char *> { };\n+template <>\n+struct process_attribute<char *> : process_attribute<const char *> {};\n \n /// Process an attribute indicating the function's return value policy\n-template <> struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {\n+template <>\n+struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {\n     static void init(const return_value_policy &p, function_record *r) { r->policy = p; }\n };\n \n-/// Process an attribute which indicates that this is an overloaded function associated with a given sibling\n-template <> struct process_attribute<sibling> : process_attribute_default<sibling> {\n+/// Process an attribute which indicates that this is an overloaded function associated with a\n+/// given sibling\n+template <>\n+struct process_attribute<sibling> : process_attribute_default<sibling> {\n     static void init(const sibling &s, function_record *r) { r->sibling = s.value; }\n };\n \n /// Process an attribute which indicates that this function is a method\n-template <> struct process_attribute<is_method> : process_attribute_default<is_method> {\n-    static void init(const is_method &s, function_record *r) { r->is_method = true; r->scope = s.class_; }\n+template <>\n+struct process_attribute<is_method> : process_attribute_default<is_method> {\n+    static void init(const is_method &s, function_record *r) {\n+        r->is_method = true;\n+        r->scope = s.class_;\n+    }\n };\n \n /// Process an attribute which indicates the parent scope of a method\n-template <> struct process_attribute<scope> : process_attribute_default<scope> {\n+template <>\n+struct process_attribute<scope> : process_attribute_default<scope> {\n     static void init(const scope &s, function_record *r) { r->scope = s.value; }\n };\n \n /// Process an attribute which indicates that this function is an operator\n-template <> struct process_attribute<is_operator> : process_attribute_default<is_operator> {\n+template <>\n+struct process_attribute<is_operator> : process_attribute_default<is_operator> {\n     static void init(const is_operator &, function_record *r) { r->is_operator = true; }\n };\n \n-template <> struct process_attribute<is_new_style_constructor> : process_attribute_default<is_new_style_constructor> {\n-    static void init(const is_new_style_constructor &, function_record *r) { r->is_new_style_constructor = true; }\n+template <>\n+struct process_attribute<is_new_style_constructor>\n+    : process_attribute_default<is_new_style_constructor> {\n+    static void init(const is_new_style_constructor &, function_record *r) {\n+        r->is_new_style_constructor = true;\n+    }\n };\n \n+inline void check_kw_only_arg(const arg &a, function_record *r) {\n+    if (r->args.size() > r->nargs_pos && (!a.name || a.name[0] == '\\0')) {\n+        pybind11_fail(\"arg(): cannot specify an unnamed argument after a kw_only() annotation or \"\n+                      \"args() argument\");\n+    }\n+}\n+\n+inline void append_self_arg_if_needed(function_record *r) {\n+    if (r->is_method && r->args.empty()) {\n+        r->args.emplace_back(\"self\", nullptr, handle(), /*convert=*/true, /*none=*/false);\n+    }\n+}\n+\n /// Process a keyword argument attribute (*without* a default value)\n-template <> struct process_attribute<arg> : process_attribute_default<arg> {\n+template <>\n+struct process_attribute<arg> : process_attribute_default<arg> {\n     static void init(const arg &a, function_record *r) {\n-        if (r->is_method && r->args.empty())\n-            r->args.emplace_back(\"self\", nullptr, handle(), true /*convert*/, false /*none not allowed*/);\n+        append_self_arg_if_needed(r);\n         r->args.emplace_back(a.name, nullptr, handle(), !a.flag_noconvert, a.flag_none);\n+\n+        check_kw_only_arg(a, r);\n     }\n };\n \n /// Process a keyword argument attribute (*with* a default value)\n-template <> struct process_attribute<arg_v> : process_attribute_default<arg_v> {\n+template <>\n+struct process_attribute<arg_v> : process_attribute_default<arg_v> {\n     static void init(const arg_v &a, function_record *r) {\n-        if (r->is_method && r->args.empty())\n-            r->args.emplace_back(\"self\", nullptr /*descr*/, handle() /*parent*/, true /*convert*/, false /*none not allowed*/);\n+        if (r->is_method && r->args.empty()) {\n+            r->args.emplace_back(\n+                \"self\", /*descr=*/nullptr, /*parent=*/handle(), /*convert=*/true, /*none=*/false);\n+        }\n \n         if (!a.value) {\n-#if !defined(NDEBUG)\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n             std::string descr(\"'\");\n-            if (a.name) descr += std::string(a.name) + \": \";\n+            if (a.name) {\n+                descr += std::string(a.name) + \": \";\n+            }\n             descr += a.type + \"'\";\n             if (r->is_method) {\n-                if (r->name)\n-                    descr += \" in method '\" + (std::string) str(r->scope) + \".\" + (std::string) r->name + \"'\";\n-                else\n+                if (r->name) {\n+                    descr += \" in method '\" + (std::string) str(r->scope) + \".\"\n+                             + (std::string) r->name + \"'\";\n+                } else {\n                     descr += \" in method of '\" + (std::string) str(r->scope) + \"'\";\n+                }\n             } else if (r->name) {\n                 descr += \" in function '\" + (std::string) r->name + \"'\";\n             }\n-            pybind11_fail(\"arg(): could not convert default argument \"\n-                          + descr + \" into a Python object (type not registered yet?)\");\n+            pybind11_fail(\"arg(): could not convert default argument \" + descr\n+                          + \" into a Python object (type not registered yet?)\");\n #else\n             pybind11_fail(\"arg(): could not convert default argument \"\n                           \"into a Python object (type not registered yet?). \"\n-                          \"Compile in debug mode for more information.\");\n+                          \"#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for \"\n+                          \"more information.\");\n #endif\n         }\n         r->args.emplace_back(a.name, a.descr, a.value.inc_ref(), !a.flag_noconvert, a.flag_none);\n+\n+        check_kw_only_arg(a, r);\n+    }\n+};\n+\n+/// Process a keyword-only-arguments-follow pseudo argument\n+template <>\n+struct process_attribute<kw_only> : process_attribute_default<kw_only> {\n+    static void init(const kw_only &, function_record *r) {\n+        append_self_arg_if_needed(r);\n+        if (r->has_args && r->nargs_pos != static_cast<std::uint16_t>(r->args.size())) {\n+            pybind11_fail(\"Mismatched args() and kw_only(): they must occur at the same relative \"\n+                          \"argument location (or omit kw_only() entirely)\");\n+        }\n+        r->nargs_pos = static_cast<std::uint16_t>(r->args.size());\n+    }\n+};\n+\n+/// Process a positional-only-argument maker\n+template <>\n+struct process_attribute<pos_only> : process_attribute_default<pos_only> {\n+    static void init(const pos_only &, function_record *r) {\n+        append_self_arg_if_needed(r);\n+        r->nargs_pos_only = static_cast<std::uint16_t>(r->args.size());\n+        if (r->nargs_pos_only > r->nargs_pos) {\n+            pybind11_fail(\"pos_only(): cannot follow a py::args() argument\");\n+        }\n+        // It also can't follow a kw_only, but a static_assert in pybind11.h checks that\n     }\n };\n \n-/// Process a parent class attribute.  Single inheritance only (class_ itself already guarantees that)\n+/// Process a parent class attribute.  Single inheritance only (class_ itself already guarantees\n+/// that)\n template <typename T>\n-struct process_attribute<T, enable_if_t<is_pyobject<T>::value>> : process_attribute_default<handle> {\n+struct process_attribute<T, enable_if_t<is_pyobject<T>::value>>\n+    : process_attribute_default<handle> {\n     static void init(const handle &h, type_record *r) { r->bases.append(h); }\n };\n \n@@ -408,14 +554,28 @@ struct process_attribute<base<T>> : process_attribute_default<base<T>> {\n /// Process a multiple inheritance attribute\n template <>\n struct process_attribute<multiple_inheritance> : process_attribute_default<multiple_inheritance> {\n-    static void init(const multiple_inheritance &, type_record *r) { r->multiple_inheritance = true; }\n+    static void init(const multiple_inheritance &, type_record *r) {\n+        r->multiple_inheritance = true;\n+    }\n };\n \n template <>\n struct process_attribute<dynamic_attr> : process_attribute_default<dynamic_attr> {\n     static void init(const dynamic_attr &, type_record *r) { r->dynamic_attr = true; }\n };\n \n+template <>\n+struct process_attribute<custom_type_setup> {\n+    static void init(const custom_type_setup &value, type_record *r) {\n+        r->custom_type_setup_callback = value.value;\n+    }\n+};\n+\n+template <>\n+struct process_attribute<is_final> : process_attribute_default<is_final> {\n+    static void init(const is_final &, type_record *r) { r->is_final = true; }\n+};\n+\n template <>\n struct process_attribute<buffer_protocol> : process_attribute_default<buffer_protocol> {\n     static void init(const buffer_protocol &, type_record *r) { r->buffer_protocol = true; }\n@@ -431,46 +591,70 @@ struct process_attribute<module_local> : process_attribute_default<module_local>\n     static void init(const module_local &l, type_record *r) { r->module_local = l.value; }\n };\n \n+/// Process a 'prepend' attribute, putting this at the beginning of the overload chain\n+template <>\n+struct process_attribute<prepend> : process_attribute_default<prepend> {\n+    static void init(const prepend &, function_record *r) { r->prepend = true; }\n+};\n+\n /// Process an 'arithmetic' attribute for enums (does nothing here)\n template <>\n struct process_attribute<arithmetic> : process_attribute_default<arithmetic> {};\n \n template <typename... Ts>\n-struct process_attribute<call_guard<Ts...>> : process_attribute_default<call_guard<Ts...>> { };\n+struct process_attribute<call_guard<Ts...>> : process_attribute_default<call_guard<Ts...>> {};\n \n /**\n  * Process a keep_alive call policy -- invokes keep_alive_impl during the\n  * pre-call handler if both Nurse, Patient != 0 and use the post-call handler\n  * otherwise\n  */\n-template <size_t Nurse, size_t Patient> struct process_attribute<keep_alive<Nurse, Patient>> : public process_attribute_default<keep_alive<Nurse, Patient>> {\n+template <size_t Nurse, size_t Patient>\n+struct process_attribute<keep_alive<Nurse, Patient>>\n+    : public process_attribute_default<keep_alive<Nurse, Patient>> {\n     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>\n-    static void precall(function_call &call) { keep_alive_impl(Nurse, Patient, call, handle()); }\n+    static void precall(function_call &call) {\n+        keep_alive_impl(Nurse, Patient, call, handle());\n+    }\n     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>\n-    static void postcall(function_call &, handle) { }\n+    static void postcall(function_call &, handle) {}\n     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>\n-    static void precall(function_call &) { }\n+    static void precall(function_call &) {}\n     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>\n-    static void postcall(function_call &call, handle ret) { keep_alive_impl(Nurse, Patient, call, ret); }\n+    static void postcall(function_call &call, handle ret) {\n+        keep_alive_impl(Nurse, Patient, call, ret);\n+    }\n };\n \n /// Recursively iterate over variadic template arguments\n-template <typename... Args> struct process_attributes {\n-    static void init(const Args&... args, function_record *r) {\n-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::init(args, r), 0) ... };\n-        ignore_unused(unused);\n+template <typename... Args>\n+struct process_attributes {\n+    static void init(const Args &...args, function_record *r) {\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(r);\n+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(r);\n+        using expander = int[];\n+        (void) expander{\n+            0, ((void) process_attribute<typename std::decay<Args>::type>::init(args, r), 0)...};\n     }\n-    static void init(const Args&... args, type_record *r) {\n-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::init(args, r), 0) ... };\n-        ignore_unused(unused);\n+    static void init(const Args &...args, type_record *r) {\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(r);\n+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(r);\n+        using expander = int[];\n+        (void) expander{0,\n+                        (process_attribute<typename std::decay<Args>::type>::init(args, r), 0)...};\n     }\n     static void precall(function_call &call) {\n-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::precall(call), 0) ... };\n-        ignore_unused(unused);\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(call);\n+        using expander = int[];\n+        (void) expander{0,\n+                        (process_attribute<typename std::decay<Args>::type>::precall(call), 0)...};\n     }\n     static void postcall(function_call &call, handle fn_ret) {\n-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::postcall(call, fn_ret), 0) ... };\n-        ignore_unused(unused);\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(call, fn_ret);\n+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(fn_ret);\n+        using expander = int[];\n+        (void) expander{\n+            0, (process_attribute<typename std::decay<Args>::type>::postcall(call, fn_ret), 0)...};\n     }\n };\n \n@@ -484,10 +668,11 @@ using extract_guard_t = typename exactly_one_t<is_call_guard, call_guard<>, Extr\n /// Check the number of named arguments at compile time\n template <typename... Extra,\n           size_t named = constexpr_sum(std::is_base_of<arg, Extra>::value...),\n-          size_t self  = constexpr_sum(std::is_same<is_method, Extra>::value...)>\n+          size_t self = constexpr_sum(std::is_same<is_method, Extra>::value...)>\n constexpr bool expected_num_args(size_t nargs, bool has_args, bool has_kwargs) {\n-    return named == 0 || (self + named + has_args + has_kwargs) == nargs;\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(nargs, has_args, has_kwargs);\n+    return named == 0 || (self + named + size_t(has_args) + size_t(has_kwargs)) == nargs;\n }\n \n-NAMESPACE_END(detail)\n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/buffer_info.h", "status": "modified", "additions": 130, "deletions": 45, "changes": 175, "file_content_changes": "@@ -11,98 +11,183 @@\n \n #include \"detail/common.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// Default, C-style strides\n+inline std::vector<ssize_t> c_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {\n+    auto ndim = shape.size();\n+    std::vector<ssize_t> strides(ndim, itemsize);\n+    if (ndim > 0) {\n+        for (size_t i = ndim - 1; i > 0; --i) {\n+            strides[i - 1] = strides[i] * shape[i];\n+        }\n+    }\n+    return strides;\n+}\n+\n+// F-style strides; default when constructing an array_t with `ExtraFlags & f_style`\n+inline std::vector<ssize_t> f_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {\n+    auto ndim = shape.size();\n+    std::vector<ssize_t> strides(ndim, itemsize);\n+    for (size_t i = 1; i < ndim; ++i) {\n+        strides[i] = strides[i - 1] * shape[i - 1];\n+    }\n+    return strides;\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n \n /// Information record describing a Python buffer object\n struct buffer_info {\n     void *ptr = nullptr;          // Pointer to the underlying storage\n     ssize_t itemsize = 0;         // Size of individual items in bytes\n     ssize_t size = 0;             // Total number of entries\n-    std::string format;           // For homogeneous buffers, this should be set to format_descriptor<T>::format()\n+    std::string format;           // For homogeneous buffers, this should be set to\n+                                  // format_descriptor<T>::format()\n     ssize_t ndim = 0;             // Number of dimensions\n     std::vector<ssize_t> shape;   // Shape of the tensor (1 entry per dimension)\n-    std::vector<ssize_t> strides; // Number of entries between adjacent entries (for each per dimension)\n-\n-    buffer_info() { }\n-\n-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,\n-                detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in)\n-    : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),\n-      shape(std::move(shape_in)), strides(std::move(strides_in)) {\n-        if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size())\n+    std::vector<ssize_t> strides; // Number of bytes between adjacent entries\n+                                  // (for each per dimension)\n+    bool readonly = false;        // flag to indicate if the underlying storage may be written to\n+\n+    buffer_info() = default;\n+\n+    buffer_info(void *ptr,\n+                ssize_t itemsize,\n+                const std::string &format,\n+                ssize_t ndim,\n+                detail::any_container<ssize_t> shape_in,\n+                detail::any_container<ssize_t> strides_in,\n+                bool readonly = false)\n+        : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),\n+          shape(std::move(shape_in)), strides(std::move(strides_in)), readonly(readonly) {\n+        if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size()) {\n             pybind11_fail(\"buffer_info: ndim doesn't match shape and/or strides length\");\n-        for (size_t i = 0; i < (size_t) ndim; ++i)\n+        }\n+        for (size_t i = 0; i < (size_t) ndim; ++i) {\n             size *= shape[i];\n+        }\n     }\n \n     template <typename T>\n-    buffer_info(T *ptr, detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in)\n-    : buffer_info(private_ctr_tag(), ptr, sizeof(T), format_descriptor<T>::format(), static_cast<ssize_t>(shape_in->size()), std::move(shape_in), std::move(strides_in)) { }\n+    buffer_info(T *ptr,\n+                detail::any_container<ssize_t> shape_in,\n+                detail::any_container<ssize_t> strides_in,\n+                bool readonly = false)\n+        : buffer_info(private_ctr_tag(),\n+                      ptr,\n+                      sizeof(T),\n+                      format_descriptor<T>::format(),\n+                      static_cast<ssize_t>(shape_in->size()),\n+                      std::move(shape_in),\n+                      std::move(strides_in),\n+                      readonly) {}\n+\n+    buffer_info(void *ptr,\n+                ssize_t itemsize,\n+                const std::string &format,\n+                ssize_t size,\n+                bool readonly = false)\n+        : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}, readonly) {}\n \n-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t size)\n-    : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}) { }\n+    template <typename T>\n+    buffer_info(T *ptr, ssize_t size, bool readonly = false)\n+        : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size, readonly) {}\n \n     template <typename T>\n-    buffer_info(T *ptr, ssize_t size)\n-    : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size) { }\n+    buffer_info(const T *ptr, ssize_t size, bool readonly = true)\n+        : buffer_info(\n+            const_cast<T *>(ptr), sizeof(T), format_descriptor<T>::format(), size, readonly) {}\n \n     explicit buffer_info(Py_buffer *view, bool ownview = true)\n-    : buffer_info(view->buf, view->itemsize, view->format, view->ndim,\n-            {view->shape, view->shape + view->ndim}, {view->strides, view->strides + view->ndim}) {\n-        this->view = view;\n+        : buffer_info(\n+            view->buf,\n+            view->itemsize,\n+            view->format,\n+            view->ndim,\n+            {view->shape, view->shape + view->ndim},\n+            /* Though buffer::request() requests PyBUF_STRIDES, ctypes objects\n+             * ignore this flag and return a view with NULL strides.\n+             * When strides are NULL, build them manually.  */\n+            view->strides\n+                ? std::vector<ssize_t>(view->strides, view->strides + view->ndim)\n+                : detail::c_strides({view->shape, view->shape + view->ndim}, view->itemsize),\n+            (view->readonly != 0)) {\n+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)\n+        this->m_view = view;\n+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)\n         this->ownview = ownview;\n     }\n \n     buffer_info(const buffer_info &) = delete;\n-    buffer_info& operator=(const buffer_info &) = delete;\n+    buffer_info &operator=(const buffer_info &) = delete;\n \n-    buffer_info(buffer_info &&other) {\n-        (*this) = std::move(other);\n-    }\n+    buffer_info(buffer_info &&other) noexcept { (*this) = std::move(other); }\n \n-    buffer_info& operator=(buffer_info &&rhs) {\n+    buffer_info &operator=(buffer_info &&rhs) noexcept {\n         ptr = rhs.ptr;\n         itemsize = rhs.itemsize;\n         size = rhs.size;\n         format = std::move(rhs.format);\n         ndim = rhs.ndim;\n         shape = std::move(rhs.shape);\n         strides = std::move(rhs.strides);\n-        std::swap(view, rhs.view);\n+        std::swap(m_view, rhs.m_view);\n         std::swap(ownview, rhs.ownview);\n+        readonly = rhs.readonly;\n         return *this;\n     }\n \n     ~buffer_info() {\n-        if (view && ownview) { PyBuffer_Release(view); delete view; }\n+        if (m_view && ownview) {\n+            PyBuffer_Release(m_view);\n+            delete m_view;\n+        }\n     }\n \n-private:\n-    struct private_ctr_tag { };\n+    Py_buffer *view() const { return m_view; }\n+    Py_buffer *&view() { return m_view; }\n \n-    buffer_info(private_ctr_tag, void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,\n-                detail::any_container<ssize_t> &&shape_in, detail::any_container<ssize_t> &&strides_in)\n-    : buffer_info(ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in)) { }\n-\n-    Py_buffer *view = nullptr;\n+private:\n+    struct private_ctr_tag {};\n+\n+    buffer_info(private_ctr_tag,\n+                void *ptr,\n+                ssize_t itemsize,\n+                const std::string &format,\n+                ssize_t ndim,\n+                detail::any_container<ssize_t> &&shape_in,\n+                detail::any_container<ssize_t> &&strides_in,\n+                bool readonly)\n+        : buffer_info(\n+            ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in), readonly) {}\n+\n+    Py_buffer *m_view = nullptr;\n     bool ownview = false;\n };\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n-template <typename T, typename SFINAE = void> struct compare_buffer_info {\n-    static bool compare(const buffer_info& b) {\n+template <typename T, typename SFINAE = void>\n+struct compare_buffer_info {\n+    static bool compare(const buffer_info &b) {\n         return b.format == format_descriptor<T>::format() && b.itemsize == (ssize_t) sizeof(T);\n     }\n };\n \n-template <typename T> struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {\n-    static bool compare(const buffer_info& b) {\n-        return (size_t) b.itemsize == sizeof(T) && (b.format == format_descriptor<T>::value ||\n-            ((sizeof(T) == sizeof(long)) && b.format == (std::is_unsigned<T>::value ? \"L\" : \"l\")) ||\n-            ((sizeof(T) == sizeof(size_t)) && b.format == (std::is_unsigned<T>::value ? \"N\" : \"n\")));\n+template <typename T>\n+struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {\n+    static bool compare(const buffer_info &b) {\n+        return (size_t) b.itemsize == sizeof(T)\n+               && (b.format == format_descriptor<T>::value\n+                   || ((sizeof(T) == sizeof(long))\n+                       && b.format == (std::is_unsigned<T>::value ? \"L\" : \"l\"))\n+                   || ((sizeof(T) == sizeof(size_t))\n+                       && b.format == (std::is_unsigned<T>::value ? \"N\" : \"n\")));\n     }\n };\n \n-NAMESPACE_END(detail)\n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/cast.h", "status": "modified", "additions": 873, "deletions": 1336, "changes": 2209, "file_content_changes": "N/A"}, {"filename": "python/src/pybind11/chrono.h", "status": "modified", "additions": 125, "deletions": 62, "changes": 187, "file_content_changes": "@@ -11,62 +11,63 @@\n #pragma once\n \n #include \"pybind11.h\"\n+\n+#include <chrono>\n #include <cmath>\n #include <ctime>\n-#include <chrono>\n #include <datetime.h>\n+#include <mutex>\n \n-// Backport the PyDateTime_DELTA functions from Python3.3 if required\n-#ifndef PyDateTime_DELTA_GET_DAYS\n-#define PyDateTime_DELTA_GET_DAYS(o)         (((PyDateTime_Delta*)o)->days)\n-#endif\n-#ifndef PyDateTime_DELTA_GET_SECONDS\n-#define PyDateTime_DELTA_GET_SECONDS(o)      (((PyDateTime_Delta*)o)->seconds)\n-#endif\n-#ifndef PyDateTime_DELTA_GET_MICROSECONDS\n-#define PyDateTime_DELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta*)o)->microseconds)\n-#endif\n-\n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n-template <typename type> class duration_caster {\n+template <typename type>\n+class duration_caster {\n public:\n-    typedef typename type::rep rep;\n-    typedef typename type::period period;\n+    using rep = typename type::rep;\n+    using period = typename type::period;\n \n-    typedef std::chrono::duration<uint_fast32_t, std::ratio<86400>> days;\n+    // signed 25 bits required by the standard.\n+    using days = std::chrono::duration<int_least32_t, std::ratio<86400>>;\n \n     bool load(handle src, bool) {\n         using namespace std::chrono;\n \n         // Lazy initialise the PyDateTime import\n-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }\n+        if (!PyDateTimeAPI) {\n+            PyDateTime_IMPORT;\n+        }\n \n-        if (!src) return false;\n+        if (!src) {\n+            return false;\n+        }\n         // If invoked with datetime.delta object\n         if (PyDelta_Check(src.ptr())) {\n             value = type(duration_cast<duration<rep, period>>(\n-                  days(PyDateTime_DELTA_GET_DAYS(src.ptr()))\n+                days(PyDateTime_DELTA_GET_DAYS(src.ptr()))\n                 + seconds(PyDateTime_DELTA_GET_SECONDS(src.ptr()))\n                 + microseconds(PyDateTime_DELTA_GET_MICROSECONDS(src.ptr()))));\n             return true;\n         }\n         // If invoked with a float we assume it is seconds and convert\n-        else if (PyFloat_Check(src.ptr())) {\n-            value = type(duration_cast<duration<rep, period>>(duration<double>(PyFloat_AsDouble(src.ptr()))));\n+        if (PyFloat_Check(src.ptr())) {\n+            value = type(duration_cast<duration<rep, period>>(\n+                duration<double>(PyFloat_AsDouble(src.ptr()))));\n             return true;\n         }\n-        else return false;\n+        return false;\n     }\n \n     // If this is a duration just return it back\n-    static const std::chrono::duration<rep, period>& get_duration(const std::chrono::duration<rep, period> &src) {\n+    static const std::chrono::duration<rep, period> &\n+    get_duration(const std::chrono::duration<rep, period> &src) {\n         return src;\n     }\n \n     // If this is a time_point get the time_since_epoch\n-    template <typename Clock> static std::chrono::duration<rep, period> get_duration(const std::chrono::time_point<Clock, std::chrono::duration<rep, period>> &src) {\n+    template <typename Clock>\n+    static std::chrono::duration<rep, period>\n+    get_duration(const std::chrono::time_point<Clock, std::chrono::duration<rep, period>> &src) {\n         return src.time_since_epoch();\n     }\n \n@@ -78,9 +79,12 @@ template <typename type> class duration_caster {\n         auto d = get_duration(src);\n \n         // Lazy initialise the PyDateTime import\n-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }\n+        if (!PyDateTimeAPI) {\n+            PyDateTime_IMPORT;\n+        }\n \n-        // Declare these special duration types so the conversions happen with the correct primitive types (int)\n+        // Declare these special duration types so the conversions happen with the correct\n+        // primitive types (int)\n         using dd_t = duration<int, std::ratio<86400>>;\n         using ss_t = duration<int, std::ratio<1>>;\n         using us_t = duration<int, std::micro>;\n@@ -92,71 +96,130 @@ template <typename type> class duration_caster {\n         return PyDelta_FromDSU(dd.count(), ss.count(), us.count());\n     }\n \n-    PYBIND11_TYPE_CASTER(type, _(\"datetime.timedelta\"));\n+    PYBIND11_TYPE_CASTER(type, const_name(\"datetime.timedelta\"));\n };\n \n+inline std::tm *localtime_thread_safe(const std::time_t *time, std::tm *buf) {\n+#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || defined(_MSC_VER)\n+    if (localtime_s(buf, time))\n+        return nullptr;\n+    return buf;\n+#else\n+    static std::mutex mtx;\n+    std::lock_guard<std::mutex> lock(mtx);\n+    std::tm *tm_ptr = std::localtime(time);\n+    if (tm_ptr != nullptr) {\n+        *buf = *tm_ptr;\n+    }\n+    return tm_ptr;\n+#endif\n+}\n+\n // This is for casting times on the system clock into datetime.datetime instances\n-template <typename Duration> class type_caster<std::chrono::time_point<std::chrono::system_clock, Duration>> {\n+template <typename Duration>\n+class type_caster<std::chrono::time_point<std::chrono::system_clock, Duration>> {\n public:\n-    typedef std::chrono::time_point<std::chrono::system_clock, Duration> type;\n+    using type = std::chrono::time_point<std::chrono::system_clock, Duration>;\n     bool load(handle src, bool) {\n         using namespace std::chrono;\n \n         // Lazy initialise the PyDateTime import\n-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }\n+        if (!PyDateTimeAPI) {\n+            PyDateTime_IMPORT;\n+        }\n+\n+        if (!src) {\n+            return false;\n+        }\n+\n+        std::tm cal;\n+        microseconds msecs;\n \n-        if (!src) return false;\n         if (PyDateTime_Check(src.ptr())) {\n-            std::tm cal;\n-            cal.tm_sec   = PyDateTime_DATE_GET_SECOND(src.ptr());\n-            cal.tm_min   = PyDateTime_DATE_GET_MINUTE(src.ptr());\n-            cal.tm_hour  = PyDateTime_DATE_GET_HOUR(src.ptr());\n-            cal.tm_mday  = PyDateTime_GET_DAY(src.ptr());\n-            cal.tm_mon   = PyDateTime_GET_MONTH(src.ptr()) - 1;\n-            cal.tm_year  = PyDateTime_GET_YEAR(src.ptr()) - 1900;\n+            cal.tm_sec = PyDateTime_DATE_GET_SECOND(src.ptr());\n+            cal.tm_min = PyDateTime_DATE_GET_MINUTE(src.ptr());\n+            cal.tm_hour = PyDateTime_DATE_GET_HOUR(src.ptr());\n+            cal.tm_mday = PyDateTime_GET_DAY(src.ptr());\n+            cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;\n+            cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;\n             cal.tm_isdst = -1;\n-\n-            value = system_clock::from_time_t(std::mktime(&cal)) + microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));\n-            return true;\n+            msecs = microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));\n+        } else if (PyDate_Check(src.ptr())) {\n+            cal.tm_sec = 0;\n+            cal.tm_min = 0;\n+            cal.tm_hour = 0;\n+            cal.tm_mday = PyDateTime_GET_DAY(src.ptr());\n+            cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;\n+            cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;\n+            cal.tm_isdst = -1;\n+            msecs = microseconds(0);\n+        } else if (PyTime_Check(src.ptr())) {\n+            cal.tm_sec = PyDateTime_TIME_GET_SECOND(src.ptr());\n+            cal.tm_min = PyDateTime_TIME_GET_MINUTE(src.ptr());\n+            cal.tm_hour = PyDateTime_TIME_GET_HOUR(src.ptr());\n+            cal.tm_mday = 1;  // This date (day, month, year) = (1, 0, 70)\n+            cal.tm_mon = 0;   // represents 1-Jan-1970, which is the first\n+            cal.tm_year = 70; // earliest available date for Python's datetime\n+            cal.tm_isdst = -1;\n+            msecs = microseconds(PyDateTime_TIME_GET_MICROSECOND(src.ptr()));\n+        } else {\n+            return false;\n         }\n-        else return false;\n+\n+        value = time_point_cast<Duration>(system_clock::from_time_t(std::mktime(&cal)) + msecs);\n+        return true;\n     }\n \n-    static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src, return_value_policy /* policy */, handle /* parent */) {\n+    static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src,\n+                       return_value_policy /* policy */,\n+                       handle /* parent */) {\n         using namespace std::chrono;\n \n         // Lazy initialise the PyDateTime import\n-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }\n-\n-        std::time_t tt = system_clock::to_time_t(src);\n-        // this function uses static memory so it's best to copy it out asap just in case\n-        // otherwise other code that is using localtime may break this (not just python code)\n-        std::tm localtime = *std::localtime(&tt);\n+        if (!PyDateTimeAPI) {\n+            PyDateTime_IMPORT;\n+        }\n \n-        // Declare these special duration types so the conversions happen with the correct primitive types (int)\n+        // Get out microseconds, and make sure they are positive, to avoid bug in eastern\n+        // hemisphere time zones (cfr. https://github.com/pybind/pybind11/issues/2417)\n         using us_t = duration<int, std::micro>;\n+        auto us = duration_cast<us_t>(src.time_since_epoch() % seconds(1));\n+        if (us.count() < 0) {\n+            us += seconds(1);\n+        }\n+\n+        // Subtract microseconds BEFORE `system_clock::to_time_t`, because:\n+        // > If std::time_t has lower precision, it is implementation-defined whether the value is\n+        // rounded or truncated. (https://en.cppreference.com/w/cpp/chrono/system_clock/to_time_t)\n+        std::time_t tt\n+            = system_clock::to_time_t(time_point_cast<system_clock::duration>(src - us));\n \n+        std::tm localtime;\n+        std::tm *localtime_ptr = localtime_thread_safe(&tt, &localtime);\n+        if (!localtime_ptr) {\n+            throw cast_error(\"Unable to represent system_clock in local time\");\n+        }\n         return PyDateTime_FromDateAndTime(localtime.tm_year + 1900,\n                                           localtime.tm_mon + 1,\n                                           localtime.tm_mday,\n                                           localtime.tm_hour,\n                                           localtime.tm_min,\n                                           localtime.tm_sec,\n-                                          (duration_cast<us_t>(src.time_since_epoch() % seconds(1))).count());\n+                                          us.count());\n     }\n-    PYBIND11_TYPE_CASTER(type, _(\"datetime.datetime\"));\n+    PYBIND11_TYPE_CASTER(type, const_name(\"datetime.datetime\"));\n };\n \n // Other clocks that are not the system clock are not measured as datetime.datetime objects\n // since they are not measured on calendar time. So instead we just make them timedeltas\n // Or if they have passed us a time as a float we convert that\n-template <typename Clock, typename Duration> class type_caster<std::chrono::time_point<Clock, Duration>>\n-: public duration_caster<std::chrono::time_point<Clock, Duration>> {\n-};\n+template <typename Clock, typename Duration>\n+class type_caster<std::chrono::time_point<Clock, Duration>>\n+    : public duration_caster<std::chrono::time_point<Clock, Duration>> {};\n \n-template <typename Rep, typename Period> class type_caster<std::chrono::duration<Rep, Period>>\n-: public duration_caster<std::chrono::duration<Rep, Period>> {\n-};\n+template <typename Rep, typename Period>\n+class type_caster<std::chrono::duration<Rep, Period>>\n+    : public duration_caster<std::chrono::duration<Rep, Period>> {};\n \n-NAMESPACE_END(detail)\n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/complex.h", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "file_content_changes": "@@ -10,42 +10,50 @@\n #pragma once\n \n #include \"pybind11.h\"\n+\n #include <complex>\n \n /// glibc defines I as a macro which breaks things, e.g., boost template names\n #ifdef I\n-#  undef I\n+#    undef I\n #endif\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n \n-template <typename T> struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {\n+template <typename T>\n+struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {\n     static constexpr const char c = format_descriptor<T>::c;\n-    static constexpr const char value[3] = { 'Z', c, '\\0' };\n+    static constexpr const char value[3] = {'Z', c, '\\0'};\n     static std::string format() { return std::string(value); }\n };\n \n #ifndef PYBIND11_CPP17\n \n-template <typename T> constexpr const char format_descriptor<\n-    std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];\n+template <typename T>\n+constexpr const char\n+    format_descriptor<std::complex<T>,\n+                      detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];\n \n #endif\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n-template <typename T> struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {\n+template <typename T>\n+struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {\n     static constexpr bool value = true;\n     static constexpr int index = is_fmt_numeric<T>::index + 3;\n };\n \n-template <typename T> class type_caster<std::complex<T>> {\n+template <typename T>\n+class type_caster<std::complex<T>> {\n public:\n     bool load(handle src, bool convert) {\n-        if (!src)\n+        if (!src) {\n             return false;\n-        if (!convert && !PyComplex_Check(src.ptr()))\n+        }\n+        if (!convert && !PyComplex_Check(src.ptr())) {\n             return false;\n+        }\n         Py_complex result = PyComplex_AsCComplex(src.ptr());\n         if (result.real == -1.0 && PyErr_Occurred()) {\n             PyErr_Clear();\n@@ -55,11 +63,12 @@ template <typename T> class type_caster<std::complex<T>> {\n         return true;\n     }\n \n-    static handle cast(const std::complex<T> &src, return_value_policy /* policy */, handle /* parent */) {\n+    static handle\n+    cast(const std::complex<T> &src, return_value_policy /* policy */, handle /* parent */) {\n         return PyComplex_FromDoubles((double) src.real(), (double) src.imag());\n     }\n \n-    PYBIND11_TYPE_CASTER(std::complex<T>, _(\"complex\"));\n+    PYBIND11_TYPE_CASTER(std::complex<T>, const_name(\"complex\"));\n };\n-NAMESPACE_END(detail)\n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/class.h", "status": "modified", "additions": 258, "deletions": 139, "changes": 397, "file_content_changes": "@@ -12,18 +12,31 @@\n #include \"../attr.h\"\n #include \"../options.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n-#if PY_VERSION_HEX >= 0x03030000\n-#  define PYBIND11_BUILTIN_QUALNAME\n-#  define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)\n+#if !defined(PYPY_VERSION)\n+#    define PYBIND11_BUILTIN_QUALNAME\n+#    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)\n #else\n-// In pre-3.3 Python, we still set __qualname__ so that we can produce reliable function type\n-// signatures; in 3.3+ this macro expands to nothing:\n-#  define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj) setattr((PyObject *) obj, \"__qualname__\", nameobj)\n+// In PyPy, we still set __qualname__ so that we can produce reliable function type\n+// signatures; in CPython this macro expands to nothing:\n+#    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)                                             \\\n+        setattr((PyObject *) obj, \"__qualname__\", nameobj)\n #endif\n \n+inline std::string get_fully_qualified_tp_name(PyTypeObject *type) {\n+#if !defined(PYPY_VERSION)\n+    return type->tp_name;\n+#else\n+    auto module_name = handle((PyObject *) type).attr(\"__module__\").cast<std::string>();\n+    if (module_name == PYBIND11_BUILTINS_MODULE)\n+        return type->tp_name;\n+    else\n+        return std::move(module_name) + \".\" + type->tp_name;\n+#endif\n+}\n+\n inline PyTypeObject *type_incref(PyTypeObject *type) {\n     Py_INCREF(type);\n     return type;\n@@ -53,24 +66,26 @@ inline PyTypeObject *make_static_property_type() {\n        issue no Python C API calls which could potentially invoke the\n        garbage collector (the GC will call type_traverse(), which will in\n        turn find the newly constructed type in an invalid state) */\n-    auto heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);\n-    if (!heap_type)\n+    auto *heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);\n+    if (!heap_type) {\n         pybind11_fail(\"make_static_property_type(): error allocating type!\");\n+    }\n \n     heap_type->ht_name = name_obj.inc_ref().ptr();\n-#ifdef PYBIND11_BUILTIN_QUALNAME\n+#    ifdef PYBIND11_BUILTIN_QUALNAME\n     heap_type->ht_qualname = name_obj.inc_ref().ptr();\n-#endif\n+#    endif\n \n-    auto type = &heap_type->ht_type;\n+    auto *type = &heap_type->ht_type;\n     type->tp_name = name;\n     type->tp_base = type_incref(&PyProperty_Type);\n     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n     type->tp_descr_get = pybind11_static_get;\n     type->tp_descr_set = pybind11_static_set;\n \n-    if (PyType_Ready(type) < 0)\n+    if (PyType_Ready(type) < 0) {\n         pybind11_fail(\"make_static_property_type(): failure in PyType_Ready()!\");\n+    }\n \n     setattr((PyObject *) type, \"__module__\", str(\"pybind11_builtins\"));\n     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n@@ -86,15 +101,17 @@ inline PyTypeObject *make_static_property_type() {\n inline PyTypeObject *make_static_property_type() {\n     auto d = dict();\n     PyObject *result = PyRun_String(R\"(\\\n-        class pybind11_static_property(property):\n-            def __get__(self, obj, cls):\n-                return property.__get__(self, cls, cls)\n-\n-            def __set__(self, obj, value):\n-                cls = obj if isinstance(obj, type) else type(obj)\n-                property.__set__(self, cls, value)\n-        )\", Py_file_input, d.ptr(), d.ptr()\n-    );\n+class pybind11_static_property(property):\n+    def __get__(self, obj, cls):\n+        return property.__get__(self, cls, cls)\n+\n+    def __set__(self, obj, value):\n+        cls = obj if isinstance(obj, type) else type(obj)\n+        property.__set__(self, cls, value)\n+)\",\n+                                    Py_file_input,\n+                                    d.ptr(),\n+                                    d.ptr());\n     if (result == nullptr)\n         throw error_already_set();\n     Py_DECREF(result);\n@@ -107,7 +124,7 @@ inline PyTypeObject *make_static_property_type() {\n     By default, Python replaces the `static_property` itself, but for wrapped C++ types\n     we need to call `static_property.__set__()` in order to propagate the new value to\n     the underlying C++ data structure. */\n-extern \"C\" inline int pybind11_meta_setattro(PyObject* obj, PyObject* name, PyObject* value) {\n+extern \"C\" inline int pybind11_meta_setattro(PyObject *obj, PyObject *name, PyObject *value) {\n     // Use `_PyType_Lookup()` instead of `PyObject_GetAttr()` in order to get the raw\n     // descriptor (`property`) instead of calling `tp_descr_get` (`property.__get__()`).\n     PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);\n@@ -116,9 +133,10 @@ extern \"C\" inline int pybind11_meta_setattro(PyObject* obj, PyObject* name, PyOb\n     //   1. `Type.static_prop = value`             --> descr_set: `Type.static_prop.__set__(value)`\n     //   2. `Type.static_prop = other_static_prop` --> setattro:  replace existing `static_prop`\n     //   3. `Type.regular_attribute = value`       --> setattro:  regular attribute assignment\n-    const auto static_prop = (PyObject *) get_internals().static_property_type;\n-    const auto call_descr_set = descr && PyObject_IsInstance(descr, static_prop)\n-                                && !PyObject_IsInstance(value, static_prop);\n+    auto *const static_prop = (PyObject *) get_internals().static_property_type;\n+    const auto call_descr_set = (descr != nullptr) && (value != nullptr)\n+                                && (PyObject_IsInstance(descr, static_prop) != 0)\n+                                && (PyObject_IsInstance(value, static_prop) == 0);\n     if (call_descr_set) {\n         // Call `static_property.__set__()` instead of replacing the `static_property`.\n #if !defined(PYPY_VERSION)\n@@ -137,7 +155,6 @@ extern \"C\" inline int pybind11_meta_setattro(PyObject* obj, PyObject* name, PyOb\n     }\n }\n \n-#if PY_MAJOR_VERSION >= 3\n /**\n  * Python 3's PyInstanceMethod_Type hides itself via its tp_descr_get, which prevents aliasing\n  * methods via cls.attr(\"m2\") = cls.attr(\"m1\"): instead the tp_descr_get returns a plain function,\n@@ -150,44 +167,110 @@ extern \"C\" inline PyObject *pybind11_meta_getattro(PyObject *obj, PyObject *name\n         Py_INCREF(descr);\n         return descr;\n     }\n-    else {\n-        return PyType_Type.tp_getattro(obj, name);\n+    return PyType_Type.tp_getattro(obj, name);\n+}\n+\n+/// metaclass `__call__` function that is used to create all pybind11 objects.\n+extern \"C\" inline PyObject *pybind11_meta_call(PyObject *type, PyObject *args, PyObject *kwargs) {\n+\n+    // use the default metaclass call to create/initialize the object\n+    PyObject *self = PyType_Type.tp_call(type, args, kwargs);\n+    if (self == nullptr) {\n+        return nullptr;\n+    }\n+\n+    // This must be a pybind11 instance\n+    auto *instance = reinterpret_cast<detail::instance *>(self);\n+\n+    // Ensure that the base __init__ function(s) were called\n+    for (const auto &vh : values_and_holders(instance)) {\n+        if (!vh.holder_constructed()) {\n+            PyErr_Format(PyExc_TypeError,\n+                         \"%.200s.__init__() must be called when overriding __init__\",\n+                         get_fully_qualified_tp_name(vh.type->type).c_str());\n+            Py_DECREF(self);\n+            return nullptr;\n+        }\n     }\n+\n+    return self;\n+}\n+\n+/// Cleanup the type-info for a pybind11-registered type.\n+extern \"C\" inline void pybind11_meta_dealloc(PyObject *obj) {\n+    auto *type = (PyTypeObject *) obj;\n+    auto &internals = get_internals();\n+\n+    // A pybind11-registered type will:\n+    // 1) be found in internals.registered_types_py\n+    // 2) have exactly one associated `detail::type_info`\n+    auto found_type = internals.registered_types_py.find(type);\n+    if (found_type != internals.registered_types_py.end() && found_type->second.size() == 1\n+        && found_type->second[0]->type == type) {\n+\n+        auto *tinfo = found_type->second[0];\n+        auto tindex = std::type_index(*tinfo->cpptype);\n+        internals.direct_conversions.erase(tindex);\n+\n+        if (tinfo->module_local) {\n+            get_local_internals().registered_types_cpp.erase(tindex);\n+        } else {\n+            internals.registered_types_cpp.erase(tindex);\n+        }\n+        internals.registered_types_py.erase(tinfo->type);\n+\n+        // Actually just `std::erase_if`, but that's only available in C++20\n+        auto &cache = internals.inactive_override_cache;\n+        for (auto it = cache.begin(), last = cache.end(); it != last;) {\n+            if (it->first == (PyObject *) tinfo->type) {\n+                it = cache.erase(it);\n+            } else {\n+                ++it;\n+            }\n+        }\n+\n+        delete tinfo;\n+    }\n+\n+    PyType_Type.tp_dealloc(obj);\n }\n-#endif\n \n /** This metaclass is assigned by default to all pybind11 types and is required in order\n     for static properties to function correctly. Users may override this using `py::metaclass`.\n     Return value: New reference. */\n-inline PyTypeObject* make_default_metaclass() {\n+inline PyTypeObject *make_default_metaclass() {\n     constexpr auto *name = \"pybind11_type\";\n     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));\n \n     /* Danger zone: from now (and until PyType_Ready), make sure to\n        issue no Python C API calls which could potentially invoke the\n        garbage collector (the GC will call type_traverse(), which will in\n        turn find the newly constructed type in an invalid state) */\n-    auto heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);\n-    if (!heap_type)\n+    auto *heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);\n+    if (!heap_type) {\n         pybind11_fail(\"make_default_metaclass(): error allocating metaclass!\");\n+    }\n \n     heap_type->ht_name = name_obj.inc_ref().ptr();\n #ifdef PYBIND11_BUILTIN_QUALNAME\n     heap_type->ht_qualname = name_obj.inc_ref().ptr();\n #endif\n \n-    auto type = &heap_type->ht_type;\n+    auto *type = &heap_type->ht_type;\n     type->tp_name = name;\n     type->tp_base = type_incref(&PyType_Type);\n     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n \n+    type->tp_call = pybind11_meta_call;\n+\n     type->tp_setattro = pybind11_meta_setattro;\n-#if PY_MAJOR_VERSION >= 3\n     type->tp_getattro = pybind11_meta_getattro;\n-#endif\n \n-    if (PyType_Ready(type) < 0)\n+    type->tp_dealloc = pybind11_meta_dealloc;\n+\n+    if (PyType_Ready(type) < 0) {\n         pybind11_fail(\"make_default_metaclass(): failure in PyType_Ready()!\");\n+    }\n \n     setattr((PyObject *) type, \"__module__\", str(\"pybind11_builtins\"));\n     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n@@ -197,16 +280,20 @@ inline PyTypeObject* make_default_metaclass() {\n \n /// For multiple inheritance types we need to recursively register/deregister base pointers for any\n /// base classes with pointers that are difference from the instance value pointer so that we can\n-/// correctly recognize an offset base class pointer. This calls a function with any offset base ptrs.\n-inline void traverse_offset_bases(void *valueptr, const detail::type_info *tinfo, instance *self,\n-        bool (*f)(void * /*parentptr*/, instance * /*self*/)) {\n+/// correctly recognize an offset base class pointer. This calls a function with any offset base\n+/// ptrs.\n+inline void traverse_offset_bases(void *valueptr,\n+                                  const detail::type_info *tinfo,\n+                                  instance *self,\n+                                  bool (*f)(void * /*parentptr*/, instance * /*self*/)) {\n     for (handle h : reinterpret_borrow<tuple>(tinfo->type->tp_bases)) {\n-        if (auto parent_tinfo = get_type_info((PyTypeObject *) h.ptr())) {\n+        if (auto *parent_tinfo = get_type_info((PyTypeObject *) h.ptr())) {\n             for (auto &c : parent_tinfo->implicit_casts) {\n                 if (c.first == tinfo->cpptype) {\n                     auto *parentptr = c.second(valueptr);\n-                    if (parentptr != valueptr)\n+                    if (parentptr != valueptr) {\n                         f(parentptr, self);\n+                    }\n                     traverse_offset_bases(parentptr, parent_tinfo, self, f);\n                     break;\n                 }\n@@ -223,7 +310,7 @@ inline bool deregister_instance_impl(void *ptr, instance *self) {\n     auto &registered_instances = get_internals().registered_instances;\n     auto range = registered_instances.equal_range(ptr);\n     for (auto it = range.first; it != range.second; ++it) {\n-        if (Py_TYPE(self) == Py_TYPE(it->second)) {\n+        if (self == it->second) {\n             registered_instances.erase(it);\n             return true;\n         }\n@@ -233,36 +320,36 @@ inline bool deregister_instance_impl(void *ptr, instance *self) {\n \n inline void register_instance(instance *self, void *valptr, const type_info *tinfo) {\n     register_instance_impl(valptr, self);\n-    if (!tinfo->simple_ancestors)\n+    if (!tinfo->simple_ancestors) {\n         traverse_offset_bases(valptr, tinfo, self, register_instance_impl);\n+    }\n }\n \n inline bool deregister_instance(instance *self, void *valptr, const type_info *tinfo) {\n     bool ret = deregister_instance_impl(valptr, self);\n-    if (!tinfo->simple_ancestors)\n+    if (!tinfo->simple_ancestors) {\n         traverse_offset_bases(valptr, tinfo, self, deregister_instance_impl);\n+    }\n     return ret;\n }\n \n-/// Instance creation function for all pybind11 types. It allocates the internal instance layout for\n-/// holding C++ objects and holders.  Allocation is done lazily (the first time the instance is cast\n-/// to a reference or pointer), and initialization is done by an `__init__` function.\n+/// Instance creation function for all pybind11 types. It allocates the internal instance layout\n+/// for holding C++ objects and holders.  Allocation is done lazily (the first time the instance is\n+/// cast to a reference or pointer), and initialization is done by an `__init__` function.\n inline PyObject *make_new_instance(PyTypeObject *type) {\n #if defined(PYPY_VERSION)\n-    // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first inherited\n-    // object is a a plain Python type (i.e. not derived from an extension type).  Fix it.\n+    // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first\n+    // inherited object is a plain Python type (i.e. not derived from an extension type).  Fix it.\n     ssize_t instance_size = static_cast<ssize_t>(sizeof(instance));\n     if (type->tp_basicsize < instance_size) {\n         type->tp_basicsize = instance_size;\n     }\n #endif\n     PyObject *self = type->tp_alloc(type, 0);\n-    auto inst = reinterpret_cast<instance *>(self);\n+    auto *inst = reinterpret_cast<instance *>(self);\n     // Allocate the value/holder internals:\n     inst->allocate_layout();\n \n-    inst->owned = true;\n-\n     return self;\n }\n \n@@ -277,26 +364,21 @@ extern \"C\" inline PyObject *pybind11_object_new(PyTypeObject *type, PyObject *,\n /// following default function will be used which simply throws an exception.\n extern \"C\" inline int pybind11_object_init(PyObject *self, PyObject *, PyObject *) {\n     PyTypeObject *type = Py_TYPE(self);\n-    std::string msg;\n-#if defined(PYPY_VERSION)\n-    msg += handle((PyObject *) type).attr(\"__module__\").cast<std::string>() + \".\";\n-#endif\n-    msg += type->tp_name;\n-    msg += \": No constructor defined!\";\n+    std::string msg = get_fully_qualified_tp_name(type) + \": No constructor defined!\";\n     PyErr_SetString(PyExc_TypeError, msg.c_str());\n     return -1;\n }\n \n inline void add_patient(PyObject *nurse, PyObject *patient) {\n     auto &internals = get_internals();\n-    auto instance = reinterpret_cast<detail::instance *>(nurse);\n+    auto *instance = reinterpret_cast<detail::instance *>(nurse);\n     instance->has_patients = true;\n     Py_INCREF(patient);\n     internals.patients[nurse].push_back(patient);\n }\n \n inline void clear_patients(PyObject *self) {\n-    auto instance = reinterpret_cast<detail::instance *>(self);\n+    auto *instance = reinterpret_cast<detail::instance *>(self);\n     auto &internals = get_internals();\n     auto pos = internals.patients.find(self);\n     assert(pos != internals.patients.end());\n@@ -306,59 +388,75 @@ inline void clear_patients(PyObject *self) {\n     auto patients = std::move(pos->second);\n     internals.patients.erase(pos);\n     instance->has_patients = false;\n-    for (PyObject *&patient : patients)\n+    for (PyObject *&patient : patients) {\n         Py_CLEAR(patient);\n+    }\n }\n \n /// Clears all internal data from the instance and removes it from registered instances in\n /// preparation for deallocation.\n inline void clear_instance(PyObject *self) {\n-    auto instance = reinterpret_cast<detail::instance *>(self);\n+    auto *instance = reinterpret_cast<detail::instance *>(self);\n \n     // Deallocate any values/holders, if present:\n     for (auto &v_h : values_and_holders(instance)) {\n         if (v_h) {\n \n             // We have to deregister before we call dealloc because, for virtual MI types, we still\n             // need to be able to get the parent pointers.\n-            if (v_h.instance_registered() && !deregister_instance(instance, v_h.value_ptr(), v_h.type))\n-                pybind11_fail(\"pybind11_object_dealloc(): Tried to deallocate unregistered instance!\");\n+            if (v_h.instance_registered()\n+                && !deregister_instance(instance, v_h.value_ptr(), v_h.type)) {\n+                pybind11_fail(\n+                    \"pybind11_object_dealloc(): Tried to deallocate unregistered instance!\");\n+            }\n \n-            if (instance->owned || v_h.holder_constructed())\n+            if (instance->owned || v_h.holder_constructed()) {\n                 v_h.type->dealloc(v_h);\n+            }\n         }\n     }\n     // Deallocate the value/holder layout internals:\n     instance->deallocate_layout();\n \n-    if (instance->weakrefs)\n+    if (instance->weakrefs) {\n         PyObject_ClearWeakRefs(self);\n+    }\n \n     PyObject **dict_ptr = _PyObject_GetDictPtr(self);\n-    if (dict_ptr)\n+    if (dict_ptr) {\n         Py_CLEAR(*dict_ptr);\n+    }\n \n-    if (instance->has_patients)\n+    if (instance->has_patients) {\n         clear_patients(self);\n+    }\n }\n \n /// Instance destructor function for all pybind11 types. It calls `type_info.dealloc`\n /// to destroy the C++ object itself, while the rest is Python bookkeeping.\n extern \"C\" inline void pybind11_object_dealloc(PyObject *self) {\n     clear_instance(self);\n \n-    auto type = Py_TYPE(self);\n+    auto *type = Py_TYPE(self);\n     type->tp_free(self);\n \n+#if PY_VERSION_HEX < 0x03080000\n     // `type->tp_dealloc != pybind11_object_dealloc` means that we're being called\n     // as part of a derived type's dealloc, in which case we're not allowed to decref\n     // the type here. For cross-module compatibility, we shouldn't compare directly\n     // with `pybind11_object_dealloc`, but with the common one stashed in internals.\n     auto pybind11_object_type = (PyTypeObject *) get_internals().instance_base;\n     if (type->tp_dealloc == pybind11_object_type->tp_dealloc)\n         Py_DECREF(type);\n+#else\n+    // This was not needed before Python 3.8 (Python issue 35810)\n+    // https://github.com/pybind/pybind11/issues/1946\n+    Py_DECREF(type);\n+#endif\n }\n \n+std::string error_string();\n+\n /** Create the type which can be used as a common base for all classes.  This is\n     needed in order to satisfy Python's requirements for multiple inheritance.\n     Return value: New reference. */\n@@ -370,16 +468,17 @@ inline PyObject *make_object_base_type(PyTypeObject *metaclass) {\n        issue no Python C API calls which could potentially invoke the\n        garbage collector (the GC will call type_traverse(), which will in\n        turn find the newly constructed type in an invalid state) */\n-    auto heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);\n-    if (!heap_type)\n+    auto *heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);\n+    if (!heap_type) {\n         pybind11_fail(\"make_object_base_type(): error allocating type!\");\n+    }\n \n     heap_type->ht_name = name_obj.inc_ref().ptr();\n #ifdef PYBIND11_BUILTIN_QUALNAME\n     heap_type->ht_qualname = name_obj.inc_ref().ptr();\n #endif\n \n-    auto type = &heap_type->ht_type;\n+    auto *type = &heap_type->ht_type;\n     type->tp_name = name;\n     type->tp_base = type_incref(&PyBaseObject_Type);\n     type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));\n@@ -392,8 +491,9 @@ inline PyObject *make_object_base_type(PyTypeObject *metaclass) {\n     /* Support weak references (needed for the keep_alive feature) */\n     type->tp_weaklistoffset = offsetof(instance, weakrefs);\n \n-    if (PyType_Ready(type) < 0)\n-        pybind11_fail(\"PyType_Ready failed in make_object_base_type():\" + error_string());\n+    if (PyType_Ready(type) < 0) {\n+        pybind11_fail(\"PyType_Ready failed in make_object_base_type(): \" + error_string());\n+    }\n \n     setattr((PyObject *) type, \"__module__\", str(\"pybind11_builtins\"));\n     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n@@ -405,17 +505,19 @@ inline PyObject *make_object_base_type(PyTypeObject *metaclass) {\n /// dynamic_attr: Support for `d = instance.__dict__`.\n extern \"C\" inline PyObject *pybind11_get_dict(PyObject *self, void *) {\n     PyObject *&dict = *_PyObject_GetDictPtr(self);\n-    if (!dict)\n+    if (!dict) {\n         dict = PyDict_New();\n+    }\n     Py_XINCREF(dict);\n     return dict;\n }\n \n /// dynamic_attr: Support for `instance.__dict__ = dict()`.\n extern \"C\" inline int pybind11_set_dict(PyObject *self, PyObject *new_dict, void *) {\n     if (!PyDict_Check(new_dict)) {\n-        PyErr_Format(PyExc_TypeError, \"__dict__ must be set to a dictionary, not a '%.200s'\",\n-                     Py_TYPE(new_dict)->tp_name);\n+        PyErr_Format(PyExc_TypeError,\n+                     \"__dict__ must be set to a dictionary, not a '%.200s'\",\n+                     get_fully_qualified_tp_name(Py_TYPE(new_dict)).c_str());\n         return -1;\n     }\n     PyObject *&dict = *_PyObject_GetDictPtr(self);\n@@ -429,6 +531,10 @@ extern \"C\" inline int pybind11_set_dict(PyObject *self, PyObject *new_dict, void\n extern \"C\" inline int pybind11_traverse(PyObject *self, visitproc visit, void *arg) {\n     PyObject *&dict = *_PyObject_GetDictPtr(self);\n     Py_VISIT(dict);\n+// https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse\n+#if PY_VERSION_HEX >= 0x03090000\n+    Py_VISIT(Py_TYPE(self));\n+#endif\n     return 0;\n }\n \n@@ -441,22 +547,20 @@ extern \"C\" inline int pybind11_clear(PyObject *self) {\n \n /// Give instances of this type a `__dict__` and opt into garbage collection.\n inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type) {\n-    auto type = &heap_type->ht_type;\n-#if defined(PYPY_VERSION)\n-    pybind11_fail(std::string(type->tp_name) + \": dynamic attributes are \"\n-                                               \"currently not supported in \"\n-                                               \"conjunction with PyPy!\");\n-#endif\n+    auto *type = &heap_type->ht_type;\n     type->tp_flags |= Py_TPFLAGS_HAVE_GC;\n-    type->tp_dictoffset = type->tp_basicsize; // place dict at the end\n-    type->tp_basicsize += (ssize_t)sizeof(PyObject *); // and allocate enough space for it\n+#if PY_VERSION_HEX < 0x030B0000\n+    type->tp_dictoffset = type->tp_basicsize;           // place dict at the end\n+    type->tp_basicsize += (ssize_t) sizeof(PyObject *); // and allocate enough space for it\n+#else\n+    type->tp_flags |= Py_TPFLAGS_MANAGED_DICT;\n+#endif\n     type->tp_traverse = pybind11_traverse;\n     type->tp_clear = pybind11_clear;\n \n     static PyGetSetDef getset[] = {\n-        {const_cast<char*>(\"__dict__\"), pybind11_get_dict, pybind11_set_dict, nullptr, nullptr},\n-        {nullptr, nullptr, nullptr, nullptr, nullptr}\n-    };\n+        {const_cast<char *>(\"__dict__\"), pybind11_get_dict, pybind11_set_dict, nullptr, nullptr},\n+        {nullptr, nullptr, nullptr, nullptr, nullptr}};\n     type->tp_getset = getset;\n }\n \n@@ -466,31 +570,42 @@ extern \"C\" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view, int fla\n     type_info *tinfo = nullptr;\n     for (auto type : reinterpret_borrow<tuple>(Py_TYPE(obj)->tp_mro)) {\n         tinfo = get_type_info((PyTypeObject *) type.ptr());\n-        if (tinfo && tinfo->get_buffer)\n+        if (tinfo && tinfo->get_buffer) {\n             break;\n+        }\n     }\n     if (view == nullptr || !tinfo || !tinfo->get_buffer) {\n-        if (view)\n+        if (view) {\n             view->obj = nullptr;\n+        }\n         PyErr_SetString(PyExc_BufferError, \"pybind11_getbuffer(): Internal error\");\n         return -1;\n     }\n     std::memset(view, 0, sizeof(Py_buffer));\n     buffer_info *info = tinfo->get_buffer(obj, tinfo->get_buffer_data);\n+    if ((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE && info->readonly) {\n+        delete info;\n+        // view->obj = nullptr;  // Was just memset to 0, so not necessary\n+        PyErr_SetString(PyExc_BufferError, \"Writable buffer requested for readonly storage\");\n+        return -1;\n+    }\n     view->obj = obj;\n     view->ndim = 1;\n     view->internal = info;\n     view->buf = info->ptr;\n     view->itemsize = info->itemsize;\n     view->len = view->itemsize;\n-    for (auto s : info->shape)\n+    for (auto s : info->shape) {\n         view->len *= s;\n-    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)\n+    }\n+    view->readonly = static_cast<int>(info->readonly);\n+    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT) {\n         view->format = const_cast<char *>(info->format.c_str());\n+    }\n     if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES) {\n         view->ndim = (int) info->ndim;\n-        view->strides = &info->strides[0];\n-        view->shape = &info->shape[0];\n+        view->strides = info->strides.data();\n+        view->shape = info->shape.data();\n     }\n     Py_INCREF(view->obj);\n     return 0;\n@@ -504,80 +619,75 @@ extern \"C\" inline void pybind11_releasebuffer(PyObject *, Py_buffer *view) {\n /// Give this type a buffer interface.\n inline void enable_buffer_protocol(PyHeapTypeObject *heap_type) {\n     heap_type->ht_type.tp_as_buffer = &heap_type->as_buffer;\n-#if PY_MAJOR_VERSION < 3\n-    heap_type->ht_type.tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;\n-#endif\n \n     heap_type->as_buffer.bf_getbuffer = pybind11_getbuffer;\n     heap_type->as_buffer.bf_releasebuffer = pybind11_releasebuffer;\n }\n \n /** Create a brand new Python type according to the `type_record` specification.\n     Return value: New reference. */\n-inline PyObject* make_new_python_type(const type_record &rec) {\n+inline PyObject *make_new_python_type(const type_record &rec) {\n     auto name = reinterpret_steal<object>(PYBIND11_FROM_STRING(rec.name));\n \n     auto qualname = name;\n     if (rec.scope && !PyModule_Check(rec.scope.ptr()) && hasattr(rec.scope, \"__qualname__\")) {\n-#if PY_MAJOR_VERSION >= 3\n         qualname = reinterpret_steal<object>(\n             PyUnicode_FromFormat(\"%U.%U\", rec.scope.attr(\"__qualname__\").ptr(), name.ptr()));\n-#else\n-        qualname = str(rec.scope.attr(\"__qualname__\").cast<std::string>() + \".\" + rec.name);\n-#endif\n     }\n \n-    object module;\n+    object module_;\n     if (rec.scope) {\n-        if (hasattr(rec.scope, \"__module__\"))\n-            module = rec.scope.attr(\"__module__\");\n-        else if (hasattr(rec.scope, \"__name__\"))\n-            module = rec.scope.attr(\"__name__\");\n+        if (hasattr(rec.scope, \"__module__\")) {\n+            module_ = rec.scope.attr(\"__module__\");\n+        } else if (hasattr(rec.scope, \"__name__\")) {\n+            module_ = rec.scope.attr(\"__name__\");\n+        }\n     }\n \n-    auto full_name = c_str(\n+    const auto *full_name = c_str(\n #if !defined(PYPY_VERSION)\n-        module ? str(module).cast<std::string>() + \".\" + rec.name :\n+        module_ ? str(module_).cast<std::string>() + \".\" + rec.name :\n #endif\n-        rec.name);\n+                rec.name);\n \n     char *tp_doc = nullptr;\n     if (rec.doc && options::show_user_defined_docstrings()) {\n         /* Allocate memory for docstring (using PyObject_MALLOC, since\n            Python will free this later on) */\n-        size_t size = strlen(rec.doc) + 1;\n+        size_t size = std::strlen(rec.doc) + 1;\n         tp_doc = (char *) PyObject_MALLOC(size);\n-        memcpy((void *) tp_doc, rec.doc, size);\n+        std::memcpy((void *) tp_doc, rec.doc, size);\n     }\n \n     auto &internals = get_internals();\n     auto bases = tuple(rec.bases);\n-    auto base = (bases.size() == 0) ? internals.instance_base\n-                                    : bases[0].ptr();\n+    auto *base = (bases.empty()) ? internals.instance_base : bases[0].ptr();\n \n     /* Danger zone: from now (and until PyType_Ready), make sure to\n        issue no Python C API calls which could potentially invoke the\n        garbage collector (the GC will call type_traverse(), which will in\n        turn find the newly constructed type in an invalid state) */\n-    auto metaclass = rec.metaclass.ptr() ? (PyTypeObject *) rec.metaclass.ptr()\n-                                         : internals.default_metaclass;\n+    auto *metaclass\n+        = rec.metaclass.ptr() ? (PyTypeObject *) rec.metaclass.ptr() : internals.default_metaclass;\n \n-    auto heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);\n-    if (!heap_type)\n+    auto *heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);\n+    if (!heap_type) {\n         pybind11_fail(std::string(rec.name) + \": Unable to create type object!\");\n+    }\n \n     heap_type->ht_name = name.release().ptr();\n #ifdef PYBIND11_BUILTIN_QUALNAME\n     heap_type->ht_qualname = qualname.inc_ref().ptr();\n #endif\n \n-    auto type = &heap_type->ht_type;\n+    auto *type = &heap_type->ht_type;\n     type->tp_name = full_name;\n     type->tp_doc = tp_doc;\n-    type->tp_base = type_incref((PyTypeObject *)base);\n+    type->tp_base = type_incref((PyTypeObject *) base);\n     type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));\n-    if (bases.size() > 0)\n+    if (!bases.empty()) {\n         type->tp_bases = bases.release().ptr();\n+    }\n \n     /* Don't inherit base __init__ */\n     type->tp_init = pybind11_object_init;\n@@ -586,38 +696,47 @@ inline PyObject* make_new_python_type(const type_record &rec) {\n     type->tp_as_number = &heap_type->as_number;\n     type->tp_as_sequence = &heap_type->as_sequence;\n     type->tp_as_mapping = &heap_type->as_mapping;\n+    type->tp_as_async = &heap_type->as_async;\n \n     /* Flags */\n-    type->tp_flags |= Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n-#if PY_MAJOR_VERSION < 3\n-    type->tp_flags |= Py_TPFLAGS_CHECKTYPES;\n-#endif\n+    type->tp_flags |= Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE;\n+    if (!rec.is_final) {\n+        type->tp_flags |= Py_TPFLAGS_BASETYPE;\n+    }\n \n-    if (rec.dynamic_attr)\n+    if (rec.dynamic_attr) {\n         enable_dynamic_attributes(heap_type);\n+    }\n \n-    if (rec.buffer_protocol)\n+    if (rec.buffer_protocol) {\n         enable_buffer_protocol(heap_type);\n+    }\n \n-    if (PyType_Ready(type) < 0)\n-        pybind11_fail(std::string(rec.name) + \": PyType_Ready failed (\" + error_string() + \")!\");\n+    if (rec.custom_type_setup_callback) {\n+        rec.custom_type_setup_callback(heap_type);\n+    }\n+\n+    if (PyType_Ready(type) < 0) {\n+        pybind11_fail(std::string(rec.name) + \": PyType_Ready failed: \" + error_string());\n+    }\n \n-    assert(rec.dynamic_attr ? PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC)\n-                            : !PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));\n+    assert(!rec.dynamic_attr || PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));\n \n     /* Register type with the parent scope */\n-    if (rec.scope)\n+    if (rec.scope) {\n         setattr(rec.scope, rec.name, (PyObject *) type);\n-    else\n+    } else {\n         Py_INCREF(type); // Keep it alive forever (reference leak)\n+    }\n \n-    if (module) // Needed by pydoc\n-        setattr((PyObject *) type, \"__module__\", module);\n+    if (module_) { // Needed by pydoc\n+        setattr((PyObject *) type, \"__module__\", module_);\n+    }\n \n     PYBIND11_SET_OLDPY_QUALNAME(type, qualname);\n \n     return (PyObject *) type;\n }\n \n-NAMESPACE_END(detail)\n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/common.h", "status": "modified", "additions": 721, "deletions": 359, "changes": 1080, "file_content_changes": "@@ -9,145 +9,270 @@\n \n #pragma once\n \n-#if !defined(NAMESPACE_BEGIN)\n-#  define NAMESPACE_BEGIN(name) namespace name {\n-#endif\n-#if !defined(NAMESPACE_END)\n-#  define NAMESPACE_END(name) }\n-#endif\n+#define PYBIND11_VERSION_MAJOR 2\n+#define PYBIND11_VERSION_MINOR 10\n+#define PYBIND11_VERSION_PATCH 0\n+\n+// Similar to Python's convention: https://docs.python.org/3/c-api/apiabiversion.html\n+// Additional convention: 0xD = dev\n+#define PYBIND11_VERSION_HEX 0x020A0000\n+\n+#define PYBIND11_NAMESPACE_BEGIN(name) namespace name {\n+#define PYBIND11_NAMESPACE_END(name) }\n \n // Robust support for some features and loading modules compiled against different pybind versions\n-// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute on\n-// the main `pybind11` namespace.\n+// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute\n+// on the main `pybind11` namespace.\n #if !defined(PYBIND11_NAMESPACE)\n-#  ifdef __GNUG__\n-#    define PYBIND11_NAMESPACE pybind11 __attribute__((visibility(\"hidden\")))\n-#  else\n-#    define PYBIND11_NAMESPACE pybind11\n-#  endif\n-#endif\n-\n-#if !(defined(_MSC_VER) && __cplusplus == 199711L) && !defined(__INTEL_COMPILER)\n-#  if __cplusplus >= 201402L\n-#    define PYBIND11_CPP14\n-#    if __cplusplus >= 201703L\n-#      define PYBIND11_CPP17\n+#    ifdef __GNUG__\n+#        define PYBIND11_NAMESPACE pybind11 __attribute__((visibility(\"hidden\")))\n+#    else\n+#        define PYBIND11_NAMESPACE pybind11\n+#    endif\n+#endif\n+\n+#if !(defined(_MSC_VER) && __cplusplus == 199711L)\n+#    if __cplusplus >= 201402L\n+#        define PYBIND11_CPP14\n+#        if __cplusplus >= 201703L\n+#            define PYBIND11_CPP17\n+#            if __cplusplus >= 202002L\n+#                define PYBIND11_CPP20\n+// Please update tests/pybind11_tests.cpp `cpp_std()` when adding a macro here.\n+#            endif\n+#        endif\n #    endif\n-#  endif\n #elif defined(_MSC_VER) && __cplusplus == 199711L\n-// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully implemented)\n-// Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3 or newer\n-#  if _MSVC_LANG >= 201402L\n-#    define PYBIND11_CPP14\n-#    if _MSVC_LANG > 201402L && _MSC_VER >= 1910\n-#      define PYBIND11_CPP17\n+// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully\n+// implemented). Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3\n+// or newer.\n+#    if _MSVC_LANG >= 201402L\n+#        define PYBIND11_CPP14\n+#        if _MSVC_LANG > 201402L\n+#            define PYBIND11_CPP17\n+#            if _MSVC_LANG >= 202002L\n+#                define PYBIND11_CPP20\n+#            endif\n+#        endif\n #    endif\n-#  endif\n #endif\n \n // Compiler version assertions\n #if defined(__INTEL_COMPILER)\n-#  if __INTEL_COMPILER < 1700\n-#    error pybind11 requires Intel C++ compiler v17 or newer\n-#  endif\n+#    if __INTEL_COMPILER < 1800\n+#        error pybind11 requires Intel C++ compiler v18 or newer\n+#    elif __INTEL_COMPILER < 1900 && defined(PYBIND11_CPP14)\n+#        error pybind11 supports only C++11 with Intel C++ compiler v18. Use v19 or newer for C++14.\n+#    endif\n+/* The following pragma cannot be pop'ed:\n+   https://community.intel.com/t5/Intel-C-Compiler/Inline-and-no-inline-warning/td-p/1216764 */\n+#    pragma warning disable 2196 // warning #2196: routine is both \"inline\" and \"noinline\"\n #elif defined(__clang__) && !defined(__apple_build_version__)\n-#  if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)\n-#    error pybind11 requires clang 3.3 or newer\n-#  endif\n+#    if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)\n+#        error pybind11 requires clang 3.3 or newer\n+#    endif\n #elif defined(__clang__)\n // Apple changes clang version macros to its Xcode version; the first Xcode release based on\n // (upstream) clang 3.3 was Xcode 5:\n-#  if __clang_major__ < 5\n-#    error pybind11 requires Xcode/clang 5.0 or newer\n-#  endif\n+#    if __clang_major__ < 5\n+#        error pybind11 requires Xcode/clang 5.0 or newer\n+#    endif\n #elif defined(__GNUG__)\n-#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)\n-#    error pybind11 requires gcc 4.8 or newer\n-#  endif\n+#    if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)\n+#        error pybind11 requires gcc 4.8 or newer\n+#    endif\n #elif defined(_MSC_VER)\n-// Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use of some stl features\n-// (e.g. std::negation) added in 2015u3:\n-#  if _MSC_FULL_VER < 190024210\n-#    error pybind11 requires MSVC 2015 update 3 or newer\n-#  endif\n+#    if _MSC_VER < 1910\n+#        error pybind11 2.10+ requires MSVC 2017 or newer\n+#    endif\n #endif\n \n #if !defined(PYBIND11_EXPORT)\n-#  if defined(WIN32) || defined(_WIN32)\n-#    define PYBIND11_EXPORT __declspec(dllexport)\n-#  else\n-#    define PYBIND11_EXPORT __attribute__ ((visibility(\"default\")))\n-#  endif\n+#    if defined(WIN32) || defined(_WIN32)\n+#        define PYBIND11_EXPORT __declspec(dllexport)\n+#    else\n+#        define PYBIND11_EXPORT __attribute__((visibility(\"default\")))\n+#    endif\n #endif\n \n-#if defined(_MSC_VER)\n-#  define PYBIND11_NOINLINE __declspec(noinline)\n+#if !defined(PYBIND11_EXPORT_EXCEPTION)\n+#    ifdef __MINGW32__\n+// workaround for:\n+// error: 'dllexport' implies default visibility, but xxx has already been declared with a\n+// different visibility\n+#        define PYBIND11_EXPORT_EXCEPTION\n+#    else\n+#        define PYBIND11_EXPORT_EXCEPTION PYBIND11_EXPORT\n+#    endif\n+#endif\n+\n+// For CUDA, GCC7, GCC8:\n+// PYBIND11_NOINLINE_FORCED is incompatible with `-Wattributes -Werror`.\n+// When defining PYBIND11_NOINLINE_FORCED, it is best to also use `-Wno-attributes`.\n+// However, the measured shared-library size saving when using noinline are only\n+// 1.7% for CUDA, -0.2% for GCC7, and 0.0% for GCC8 (using -DCMAKE_BUILD_TYPE=MinSizeRel,\n+// the default under pybind11/tests).\n+#if !defined(PYBIND11_NOINLINE_FORCED)                                                            \\\n+    && (defined(__CUDACC__) || (defined(__GNUC__) && (__GNUC__ == 7 || __GNUC__ == 8)))\n+#    define PYBIND11_NOINLINE_DISABLED\n+#endif\n+\n+// The PYBIND11_NOINLINE macro is for function DEFINITIONS.\n+// In contrast, FORWARD DECLARATIONS should never use this macro:\n+// https://stackoverflow.com/questions/9317473/forward-declaration-of-inline-functions\n+#if defined(PYBIND11_NOINLINE_DISABLED) // Option for maximum portability and experimentation.\n+#    define PYBIND11_NOINLINE inline\n+#elif defined(_MSC_VER)\n+#    define PYBIND11_NOINLINE __declspec(noinline) inline\n #else\n-#  define PYBIND11_NOINLINE __attribute__ ((noinline))\n+#    define PYBIND11_NOINLINE __attribute__((noinline)) inline\n #endif\n \n-#if defined(PYBIND11_CPP14)\n-#  define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]\n+#if defined(__MINGW32__)\n+// For unknown reasons all PYBIND11_DEPRECATED member trigger a warning when declared\n+// whether it is used or not\n+#    define PYBIND11_DEPRECATED(reason)\n+#elif defined(PYBIND11_CPP14)\n+#    define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]\n #else\n-#  define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))\n+#    define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))\n #endif\n \n-#define PYBIND11_VERSION_MAJOR 2\n-#define PYBIND11_VERSION_MINOR 3\n-#define PYBIND11_VERSION_PATCH 0\n+#if defined(PYBIND11_CPP17)\n+#    define PYBIND11_MAYBE_UNUSED [[maybe_unused]]\n+#elif defined(_MSC_VER) && !defined(__clang__)\n+#    define PYBIND11_MAYBE_UNUSED\n+#else\n+#    define PYBIND11_MAYBE_UNUSED __attribute__((__unused__))\n+#endif\n+\n+/* Don't let Python.h #define (v)snprintf as macro because they are implemented\n+   properly in Visual Studio since 2015. */\n+#if defined(_MSC_VER)\n+#    define HAVE_SNPRINTF 1\n+#endif\n \n /// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode\n #if defined(_MSC_VER)\n-#  if (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION < 4)\n-#    define HAVE_ROUND 1\n-#  endif\n-#  pragma warning(push)\n-#  pragma warning(disable: 4510 4610 4512 4005)\n-#  if defined(_DEBUG)\n-#    define PYBIND11_DEBUG_MARKER\n-#    undef _DEBUG\n-#  endif\n+#    pragma warning(push)\n+// C4505: 'PySlice_GetIndicesEx': unreferenced local function has been removed (PyPy only)\n+#    pragma warning(disable : 4505)\n+#    if defined(_DEBUG) && !defined(Py_DEBUG)\n+// Workaround for a VS 2022 issue.\n+// NOTE: This workaround knowingly violates the Python.h include order requirement:\n+// https://docs.python.org/3/c-api/intro.html#include-files\n+// See https://github.com/pybind/pybind11/pull/3497 for full context.\n+#        include <yvals.h>\n+#        if _MSVC_STL_VERSION >= 143\n+#            include <crtdefs.h>\n+#        endif\n+#        define PYBIND11_DEBUG_MARKER\n+#        undef _DEBUG\n+#    endif\n+#endif\n+\n+// https://en.cppreference.com/w/c/chrono/localtime\n+#if defined(__STDC_LIB_EXT1__) && !defined(__STDC_WANT_LIB_EXT1__)\n+#    define __STDC_WANT_LIB_EXT1__\n+#endif\n+\n+#ifdef __has_include\n+// std::optional (but including it in c++14 mode isn't allowed)\n+#    if defined(PYBIND11_CPP17) && __has_include(<optional>)\n+#        define PYBIND11_HAS_OPTIONAL 1\n+#    endif\n+// std::experimental::optional (but not allowed in c++11 mode)\n+#    if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \\\n+                                 !__has_include(<optional>))\n+#        define PYBIND11_HAS_EXP_OPTIONAL 1\n+#    endif\n+// std::variant\n+#    if defined(PYBIND11_CPP17) && __has_include(<variant>)\n+#        define PYBIND11_HAS_VARIANT 1\n+#    endif\n+#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)\n+#    define PYBIND11_HAS_OPTIONAL 1\n+#    define PYBIND11_HAS_VARIANT 1\n+#endif\n+\n+#if defined(PYBIND11_CPP17)\n+#    if defined(__has_include)\n+#        if __has_include(<string_view>)\n+#            define PYBIND11_HAS_STRING_VIEW\n+#        endif\n+#    elif defined(_MSC_VER)\n+#        define PYBIND11_HAS_STRING_VIEW\n+#    endif\n+#endif\n+\n+#if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L\n+#    define PYBIND11_HAS_U8STRING\n #endif\n \n #include <Python.h>\n+#if PY_VERSION_HEX < 0x03060000\n+#    error \"PYTHON < 3.6 IS UNSUPPORTED. pybind11 v2.9 was the last to support Python 2 and 3.5.\"\n+#endif\n #include <frameobject.h>\n #include <pythread.h>\n \n-#if defined(_WIN32) && (defined(min) || defined(max))\n-#  error Macro clash with min and max -- define NOMINMAX when compiling your program on Windows\n+/* Python #defines overrides on all sorts of core functions, which\n+   tends to weak havok in C++ codebases that expect these to work\n+   like regular functions (potentially with several overloads) */\n+#if defined(isalnum)\n+#    undef isalnum\n+#    undef isalpha\n+#    undef islower\n+#    undef isspace\n+#    undef isupper\n+#    undef tolower\n+#    undef toupper\n #endif\n \n-#if defined(isalnum)\n-#  undef isalnum\n-#  undef isalpha\n-#  undef islower\n-#  undef isspace\n-#  undef isupper\n-#  undef tolower\n-#  undef toupper\n+#if defined(copysign)\n+#    undef copysign\n #endif\n \n #if defined(_MSC_VER)\n-#  if defined(PYBIND11_DEBUG_MARKER)\n-#    define _DEBUG\n-#    undef PYBIND11_DEBUG_MARKER\n-#  endif\n-#  pragma warning(pop)\n+#    if defined(PYBIND11_DEBUG_MARKER)\n+#        define _DEBUG\n+#        undef PYBIND11_DEBUG_MARKER\n+#    endif\n+#    pragma warning(pop)\n #endif\n \n #include <cstddef>\n #include <cstring>\n+#include <exception>\n #include <forward_list>\n-#include <vector>\n-#include <string>\n-#include <stdexcept>\n-#include <unordered_set>\n-#include <unordered_map>\n #include <memory>\n-#include <typeindex>\n+#include <stdexcept>\n+#include <string>\n #include <type_traits>\n+#include <typeindex>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+#if defined(__has_include)\n+#    if __has_include(<version>)\n+#        include <version>\n+#    endif\n+#endif\n \n-#if PY_MAJOR_VERSION >= 3 /// Compatibility macros for various Python versions\n+// #define PYBIND11_STR_LEGACY_PERMISSIVE\n+// If DEFINED, pybind11::str can hold PyUnicodeObject or PyBytesObject\n+//             (probably surprising and never documented, but this was the\n+//             legacy behavior until and including v2.6.x). As a side-effect,\n+//             pybind11::isinstance<str>() is true for both pybind11::str and\n+//             pybind11::bytes.\n+// If UNDEFINED, pybind11::str can only hold PyUnicodeObject, and\n+//               pybind11::isinstance<str>() is true only for pybind11::str.\n+//               However, for Python 2 only (!), the pybind11::str caster\n+//               implicitly decoded bytes to PyUnicodeObject. This was to ease\n+//               the transition from the legacy behavior to the non-permissive\n+//               behavior.\n+\n+/// Compatibility macros for Python 2 / Python 3 versions TODO: remove\n #define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)\n #define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check\n #define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION\n@@ -159,115 +284,92 @@\n #define PYBIND11_BYTES_SIZE PyBytes_Size\n #define PYBIND11_LONG_CHECK(o) PyLong_Check(o)\n #define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)\n-#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) o)\n-#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) o)\n+#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) (o))\n+#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) (o))\n #define PYBIND11_BYTES_NAME \"bytes\"\n #define PYBIND11_STRING_NAME \"str\"\n #define PYBIND11_SLICE_OBJECT PyObject\n #define PYBIND11_FROM_STRING PyUnicode_FromString\n #define PYBIND11_STR_TYPE ::pybind11::str\n #define PYBIND11_BOOL_ATTR \"__bool__\"\n #define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)\n-#define PYBIND11_PLUGIN_IMPL(name) \\\n+#define PYBIND11_BUILTINS_MODULE \"builtins\"\n+// Providing a separate declaration to make Clang's -Wmissing-prototypes happy.\n+// See comment for PYBIND11_MODULE below for why this is marked \"maybe unused\".\n+#define PYBIND11_PLUGIN_IMPL(name)                                                                \\\n+    extern \"C\" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT PyObject *PyInit_##name();                   \\\n     extern \"C\" PYBIND11_EXPORT PyObject *PyInit_##name()\n \n-#else\n-#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyMethod_New(ptr, nullptr, class_)\n-#define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check\n-#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION\n-#define PYBIND11_BYTES_CHECK PyString_Check\n-#define PYBIND11_BYTES_FROM_STRING PyString_FromString\n-#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize\n-#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize\n-#define PYBIND11_BYTES_AS_STRING PyString_AsString\n-#define PYBIND11_BYTES_SIZE PyString_Size\n-#define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))\n-#define PYBIND11_LONG_AS_LONGLONG(o) (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))\n-#define PYBIND11_LONG_FROM_SIGNED(o) PyInt_FromSsize_t((ssize_t) o) // Returns long if needed.\n-#define PYBIND11_LONG_FROM_UNSIGNED(o) PyInt_FromSize_t((size_t) o) // Returns long if needed.\n-#define PYBIND11_BYTES_NAME \"str\"\n-#define PYBIND11_STRING_NAME \"unicode\"\n-#define PYBIND11_SLICE_OBJECT PySliceObject\n-#define PYBIND11_FROM_STRING PyString_FromString\n-#define PYBIND11_STR_TYPE ::pybind11::bytes\n-#define PYBIND11_BOOL_ATTR \"__nonzero__\"\n-#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_nonzero)\n-#define PYBIND11_PLUGIN_IMPL(name) \\\n-    static PyObject *pybind11_init_wrapper();               \\\n-    extern \"C\" PYBIND11_EXPORT void init##name() {          \\\n-        (void)pybind11_init_wrapper();                      \\\n-    }                                                       \\\n-    PyObject *pybind11_init_wrapper()\n-#endif\n-\n-#if PY_VERSION_HEX >= 0x03050000 && PY_VERSION_HEX < 0x03050200\n-extern \"C\" {\n-    struct _Py_atomic_address { void *value; };\n-    PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;\n-}\n-#endif\n-\n #define PYBIND11_TRY_NEXT_OVERLOAD ((PyObject *) 1) // special failure return code\n #define PYBIND11_STRINGIFY(x) #x\n #define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)\n #define PYBIND11_CONCAT(first, second) first##second\n-\n-#define PYBIND11_CHECK_PYTHON_VERSION \\\n-    {                                                                          \\\n-        const char *compiled_ver = PYBIND11_TOSTRING(PY_MAJOR_VERSION)         \\\n-            \".\" PYBIND11_TOSTRING(PY_MINOR_VERSION);                           \\\n-        const char *runtime_ver = Py_GetVersion();                             \\\n-        size_t len = std::strlen(compiled_ver);                                \\\n-        if (std::strncmp(runtime_ver, compiled_ver, len) != 0                  \\\n-                || (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {     \\\n-            PyErr_Format(PyExc_ImportError,                                    \\\n-                \"Python version mismatch: module was compiled for Python %s, \" \\\n-                \"but the interpreter version is incompatible: %s.\",            \\\n-                compiled_ver, runtime_ver);                                    \\\n-            return nullptr;                                                    \\\n-        }                                                                      \\\n+#define PYBIND11_ENSURE_INTERNALS_READY pybind11::detail::get_internals();\n+\n+#define PYBIND11_CHECK_PYTHON_VERSION                                                             \\\n+    {                                                                                             \\\n+        const char *compiled_ver                                                                  \\\n+            = PYBIND11_TOSTRING(PY_MAJOR_VERSION) \".\" PYBIND11_TOSTRING(PY_MINOR_VERSION);        \\\n+        const char *runtime_ver = Py_GetVersion();                                                \\\n+        size_t len = std::strlen(compiled_ver);                                                   \\\n+        if (std::strncmp(runtime_ver, compiled_ver, len) != 0                                     \\\n+            || (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {                            \\\n+            PyErr_Format(PyExc_ImportError,                                                       \\\n+                         \"Python version mismatch: module was compiled for Python %s, \"           \\\n+                         \"but the interpreter version is incompatible: %s.\",                      \\\n+                         compiled_ver,                                                            \\\n+                         runtime_ver);                                                            \\\n+            return nullptr;                                                                       \\\n+        }                                                                                         \\\n     }\n \n-#define PYBIND11_CATCH_INIT_EXCEPTIONS \\\n-        catch (pybind11::error_already_set &e) {                               \\\n-            PyErr_SetString(PyExc_ImportError, e.what());                      \\\n-            return nullptr;                                                    \\\n-        } catch (const std::exception &e) {                                    \\\n-            PyErr_SetString(PyExc_ImportError, e.what());                      \\\n-            return nullptr;                                                    \\\n-        }                                                                      \\\n+#define PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \\\n+    catch (pybind11::error_already_set & e) {                                                     \\\n+        pybind11::raise_from(e, PyExc_ImportError, \"initialization failed\");                      \\\n+        return nullptr;                                                                           \\\n+    }                                                                                             \\\n+    catch (const std::exception &e) {                                                             \\\n+        PyErr_SetString(PyExc_ImportError, e.what());                                             \\\n+        return nullptr;                                                                           \\\n+    }\n \n /** \\rst\n     ***Deprecated in favor of PYBIND11_MODULE***\n \n     This macro creates the entry point that will be invoked when the Python interpreter\n-    imports a plugin library. Please create a `module` in the function body and return\n+    imports a plugin library. Please create a `module_` in the function body and return\n     the pointer to its underlying Python object at the end.\n \n     .. code-block:: cpp\n \n         PYBIND11_PLUGIN(example) {\n-            pybind11::module m(\"example\", \"pybind11 example plugin\");\n+            pybind11::module_ m(\"example\", \"pybind11 example plugin\");\n             /// Set up bindings here\n             return m.ptr();\n         }\n \\endrst */\n-#define PYBIND11_PLUGIN(name)                                                  \\\n-    PYBIND11_DEPRECATED(\"PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE\")  \\\n-    static PyObject *pybind11_init();                                          \\\n-    PYBIND11_PLUGIN_IMPL(name) {                                               \\\n-        PYBIND11_CHECK_PYTHON_VERSION                                          \\\n-        try {                                                                  \\\n-            return pybind11_init();                                            \\\n-        } PYBIND11_CATCH_INIT_EXCEPTIONS                                       \\\n-    }                                                                          \\\n+#define PYBIND11_PLUGIN(name)                                                                     \\\n+    PYBIND11_DEPRECATED(\"PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE\")                     \\\n+    static PyObject *pybind11_init();                                                             \\\n+    PYBIND11_PLUGIN_IMPL(name) {                                                                  \\\n+        PYBIND11_CHECK_PYTHON_VERSION                                                             \\\n+        PYBIND11_ENSURE_INTERNALS_READY                                                           \\\n+        try {                                                                                     \\\n+            return pybind11_init();                                                               \\\n+        }                                                                                         \\\n+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \\\n+    }                                                                                             \\\n     PyObject *pybind11_init()\n \n /** \\rst\n     This macro creates the entry point that will be invoked when the Python interpreter\n     imports an extension module. The module name is given as the fist argument and it\n     should not be in quotes. The second macro argument defines a variable of type\n-    `py::module` which can be used to initialize the module.\n+    `py::module_` which can be used to initialize the module.\n+\n+    The entry point is marked as \"maybe unused\" to aid dead-code detection analysis:\n+    since the entry point is typically only looked up at runtime and not referenced\n+    during translation, it would otherwise appear as unused (\"dead\") code.\n \n     .. code-block:: cpp\n \n@@ -280,23 +382,34 @@ extern \"C\" {\n             });\n         }\n \\endrst */\n-#define PYBIND11_MODULE(name, variable)                                        \\\n-    static void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &);     \\\n-    PYBIND11_PLUGIN_IMPL(name) {                                               \\\n-        PYBIND11_CHECK_PYTHON_VERSION                                          \\\n-        auto m = pybind11::module(PYBIND11_TOSTRING(name));                    \\\n-        try {                                                                  \\\n-            PYBIND11_CONCAT(pybind11_init_, name)(m);                          \\\n-            return m.ptr();                                                    \\\n-        } PYBIND11_CATCH_INIT_EXCEPTIONS                                       \\\n-    }                                                                          \\\n-    void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &variable)\n-\n-\n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+#define PYBIND11_MODULE(name, variable)                                                           \\\n+    static ::pybind11::module_::module_def PYBIND11_CONCAT(pybind11_module_def_, name)            \\\n+        PYBIND11_MAYBE_UNUSED;                                                                    \\\n+    PYBIND11_MAYBE_UNUSED                                                                         \\\n+    static void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ &);                     \\\n+    PYBIND11_PLUGIN_IMPL(name) {                                                                  \\\n+        PYBIND11_CHECK_PYTHON_VERSION                                                             \\\n+        PYBIND11_ENSURE_INTERNALS_READY                                                           \\\n+        auto m = ::pybind11::module_::create_extension_module(                                    \\\n+            PYBIND11_TOSTRING(name), nullptr, &PYBIND11_CONCAT(pybind11_module_def_, name));      \\\n+        try {                                                                                     \\\n+            PYBIND11_CONCAT(pybind11_init_, name)(m);                                             \\\n+            return m.ptr();                                                                       \\\n+        }                                                                                         \\\n+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \\\n+    }                                                                                             \\\n+    void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ & (variable))\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n \n using ssize_t = Py_ssize_t;\n-using size_t  = std::size_t;\n+using size_t = std::size_t;\n+\n+template <typename IntType>\n+inline ssize_t ssize_t_cast(const IntType &val) {\n+    static_assert(sizeof(IntType) <= sizeof(ssize_t), \"Implicit narrowing is not permitted.\");\n+    return static_cast<ssize_t>(val);\n+}\n \n /// Approach used to cast a previously unknown C++ instance into a Python object\n enum class return_value_policy : uint8_t {\n@@ -315,7 +428,7 @@ enum class return_value_policy : uint8_t {\n \n     /** Reference an existing object (i.e. do not create a new copy) and take\n         ownership. Python will call the destructor and delete operator when the\n-        object\u2019s reference count reaches zero. Undefined behavior ensues when\n+        object's reference count reaches zero. Undefined behavior ensues when\n         the C++ side does the same.. */\n     take_ownership,\n \n@@ -331,7 +444,7 @@ enum class return_value_policy : uint8_t {\n     move,\n \n     /** Reference an existing object, but do not take ownership. The C++ side\n-        is responsible for managing the object\u2019s lifetime and deallocating it\n+        is responsible for managing the object's lifetime and deallocating it\n         when it is no longer used. Warning: undefined behavior will ensue when\n         the C++ side deletes an object that is still referenced and used by\n         Python. */\n@@ -340,7 +453,7 @@ enum class return_value_policy : uint8_t {\n     /** This policy only applies to methods and properties. It references the\n         object without taking ownership similar to the above\n         return_value_policy::reference policy. In contrast to that policy, the\n-        function or property\u2019s implicit this argument (called the parent) is\n+        function or property's implicit this argument (called the parent) is\n         considered to be the the owner of the return value (the child).\n         pybind11 then couples the lifetime of the parent to the child via a\n         reference relationship that ensures that the parent cannot be garbage\n@@ -350,12 +463,16 @@ enum class return_value_policy : uint8_t {\n     reference_internal\n };\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n-inline static constexpr int log2(size_t n, int k = 0) { return (n <= 1) ? k : log2(n >> 1, k + 1); }\n+inline static constexpr int log2(size_t n, int k = 0) {\n+    return (n <= 1) ? k : log2(n >> 1, k + 1);\n+}\n \n // Returns the size as a multiple of sizeof(void *), rounded up.\n-inline static constexpr size_t size_in_ptrs(size_t s) { return 1 + ((s - 1) >> log2(sizeof(void *))); }\n+inline static constexpr size_t size_in_ptrs(size_t s) {\n+    return 1 + ((s - 1) >> log2(sizeof(void *)));\n+}\n \n /**\n  * The space to allocate for simple layout instance holders (see below) in multiple of the size of\n@@ -365,7 +482,7 @@ inline static constexpr size_t size_in_ptrs(size_t s) { return 1 + ((s - 1) >> l\n  */\n constexpr size_t instance_simple_holder_in_ptrs() {\n     static_assert(sizeof(std::shared_ptr<int>) >= sizeof(std::unique_ptr<int>),\n-            \"pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs\");\n+                  \"pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs\");\n     return size_in_ptrs(sizeof(std::shared_ptr<int>));\n }\n \n@@ -393,21 +510,21 @@ struct instance {\n     /**\n      * An instance has two possible value/holder layouts.\n      *\n-     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a pointer\n-     * and the holder object governing that pointer, i.e. [val1*][holder].  This layout is applied\n-     * whenever there is no python-side multiple inheritance of bound C++ types *and* the type's\n-     * holder will fit in the default space (which is large enough to hold either a std::unique_ptr\n-     * or std::shared_ptr).\n+     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a\n+     * pointer and the holder object governing that pointer, i.e. [val1*][holder].  This layout is\n+     * applied whenever there is no python-side multiple inheritance of bound C++ types *and* the\n+     * type's holder will fit in the default space (which is large enough to hold either a\n+     * std::unique_ptr or std::shared_ptr).\n      *\n-     * Non-simple layout applies when using custom holders that require more space than `shared_ptr`\n-     * (which is typically the size of two pointers), or when multiple inheritance is used on the\n-     * python side.  Non-simple layout allocates the required amount of memory to have multiple\n-     * bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is set to a\n-     * pointer to allocated space of the required space to hold a sequence of value pointers and\n-     * holders followed `status`, a set of bit flags (1 byte each), i.e.\n-     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple of\n-     * `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the\n-     * beginning of the [bb...] block (but not independently allocated).\n+     * Non-simple layout applies when using custom holders that require more space than\n+     * `shared_ptr` (which is typically the size of two pointers), or when multiple inheritance is\n+     * used on the python side.  Non-simple layout allocates the required amount of memory to have\n+     * multiple bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is\n+     * set to a pointer to allocated space of the required space to hold a sequence of value\n+     * pointers and holders followed `status`, a set of bit flags (1 byte each), i.e.\n+     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple\n+     * of `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the beginning of\n+     * the [bb...] block (but not independently allocated).\n      *\n      * Status bits indicate whether the associated holder is constructed (&\n      * status_holder_constructed) and whether the value pointer is registered (&\n@@ -421,7 +538,8 @@ struct instance {\n     /// If true, get_internals().patients has an entry for this object\n     bool has_patients : 1;\n \n-    /// Initializes all of the above type/values/holders data (but not the instance values themselves)\n+    /// Initializes all of the above type/values/holders data (but not the instance values\n+    /// themselves)\n     void allocate_layout();\n \n     /// Destroys/deallocates all of the above\n@@ -430,195 +548,322 @@ struct instance {\n     /// Returns the value_and_holder wrapper for the given type (or the first, if `find_type`\n     /// omitted).  Returns a default-constructed (with `.inst = nullptr`) object on failure if\n     /// `throw_if_missing` is false.\n-    value_and_holder get_value_and_holder(const type_info *find_type = nullptr, bool throw_if_missing = true);\n+    value_and_holder get_value_and_holder(const type_info *find_type = nullptr,\n+                                          bool throw_if_missing = true);\n \n     /// Bit values for the non-simple status flags\n-    static constexpr uint8_t status_holder_constructed  = 1;\n+    static constexpr uint8_t status_holder_constructed = 1;\n     static constexpr uint8_t status_instance_registered = 2;\n };\n \n-static_assert(std::is_standard_layout<instance>::value, \"Internal error: `pybind11::detail::instance` is not standard layout!\");\n+static_assert(std::is_standard_layout<instance>::value,\n+              \"Internal error: `pybind11::detail::instance` is not standard layout!\");\n \n /// from __cpp_future__ import (convenient aliases from C++14/17)\n-#if defined(PYBIND11_CPP14) && (!defined(_MSC_VER) || _MSC_VER >= 1910)\n-using std::enable_if_t;\n+#if defined(PYBIND11_CPP14)\n using std::conditional_t;\n+using std::enable_if_t;\n using std::remove_cv_t;\n using std::remove_reference_t;\n #else\n-template <bool B, typename T = void> using enable_if_t = typename std::enable_if<B, T>::type;\n-template <bool B, typename T, typename F> using conditional_t = typename std::conditional<B, T, F>::type;\n-template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;\n-template <typename T> using remove_reference_t = typename std::remove_reference<T>::type;\n+template <bool B, typename T = void>\n+using enable_if_t = typename std::enable_if<B, T>::type;\n+template <bool B, typename T, typename F>\n+using conditional_t = typename std::conditional<B, T, F>::type;\n+template <typename T>\n+using remove_cv_t = typename std::remove_cv<T>::type;\n+template <typename T>\n+using remove_reference_t = typename std::remove_reference<T>::type;\n+#endif\n+\n+#if defined(PYBIND11_CPP20)\n+using std::remove_cvref;\n+using std::remove_cvref_t;\n+#else\n+template <class T>\n+struct remove_cvref {\n+    using type = remove_cv_t<remove_reference_t<T>>;\n+};\n+template <class T>\n+using remove_cvref_t = typename remove_cvref<T>::type;\n #endif\n \n /// Index sequences\n #if defined(PYBIND11_CPP14)\n using std::index_sequence;\n using std::make_index_sequence;\n #else\n-template<size_t ...> struct index_sequence  { };\n-template<size_t N, size_t ...S> struct make_index_sequence_impl : make_index_sequence_impl <N - 1, N - 1, S...> { };\n-template<size_t ...S> struct make_index_sequence_impl <0, S...> { typedef index_sequence<S...> type; };\n-template<size_t N> using make_index_sequence = typename make_index_sequence_impl<N>::type;\n+template <size_t...>\n+struct index_sequence {};\n+template <size_t N, size_t... S>\n+struct make_index_sequence_impl : make_index_sequence_impl<N - 1, N - 1, S...> {};\n+template <size_t... S>\n+struct make_index_sequence_impl<0, S...> {\n+    using type = index_sequence<S...>;\n+};\n+template <size_t N>\n+using make_index_sequence = typename make_index_sequence_impl<N>::type;\n #endif\n \n /// Make an index sequence of the indices of true arguments\n-template <typename ISeq, size_t, bool...> struct select_indices_impl { using type = ISeq; };\n-template <size_t... IPrev, size_t I, bool B, bool... Bs> struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>\n-    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>, I + 1, Bs...> {};\n-template <bool... Bs> using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;\n+template <typename ISeq, size_t, bool...>\n+struct select_indices_impl {\n+    using type = ISeq;\n+};\n+template <size_t... IPrev, size_t I, bool B, bool... Bs>\n+struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>\n+    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>,\n+                          I + 1,\n+                          Bs...> {};\n+template <bool... Bs>\n+using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;\n \n /// Backports of std::bool_constant and std::negation to accommodate older compilers\n-template <bool B> using bool_constant = std::integral_constant<bool, B>;\n-template <typename T> struct negation : bool_constant<!T::value> { };\n-\n-template <typename...> struct void_t_impl { using type = void; };\n-template <typename... Ts> using void_t = typename void_t_impl<Ts...>::type;\n+template <bool B>\n+using bool_constant = std::integral_constant<bool, B>;\n+template <typename T>\n+struct negation : bool_constant<!T::value> {};\n+\n+// PGI/Intel cannot detect operator delete with the \"compatible\" void_t impl, so\n+// using the new one (C++14 defect, so generally works on newer compilers, even\n+// if not in C++17 mode)\n+#if defined(__PGIC__) || defined(__INTEL_COMPILER)\n+template <typename...>\n+using void_t = void;\n+#else\n+template <typename...>\n+struct void_t_impl {\n+    using type = void;\n+};\n+template <typename... Ts>\n+using void_t = typename void_t_impl<Ts...>::type;\n+#endif\n \n /// Compile-time all/any/none of that check the boolean value of all template types\n #if defined(__cpp_fold_expressions) && !(defined(_MSC_VER) && (_MSC_VER < 1916))\n-template <class... Ts> using all_of = bool_constant<(Ts::value && ...)>;\n-template <class... Ts> using any_of = bool_constant<(Ts::value || ...)>;\n+template <class... Ts>\n+using all_of = bool_constant<(Ts::value && ...)>;\n+template <class... Ts>\n+using any_of = bool_constant<(Ts::value || ...)>;\n #elif !defined(_MSC_VER)\n-template <bool...> struct bools {};\n-template <class... Ts> using all_of = std::is_same<\n-    bools<Ts::value..., true>,\n-    bools<true, Ts::value...>>;\n-template <class... Ts> using any_of = negation<all_of<negation<Ts>...>>;\n+template <bool...>\n+struct bools {};\n+template <class... Ts>\n+using all_of = std::is_same<bools<Ts::value..., true>, bools<true, Ts::value...>>;\n+template <class... Ts>\n+using any_of = negation<all_of<negation<Ts>...>>;\n #else\n // MSVC has trouble with the above, but supports std::conjunction, which we can use instead (albeit\n // at a slight loss of compilation efficiency).\n-template <class... Ts> using all_of = std::conjunction<Ts...>;\n-template <class... Ts> using any_of = std::disjunction<Ts...>;\n+template <class... Ts>\n+using all_of = std::conjunction<Ts...>;\n+template <class... Ts>\n+using any_of = std::disjunction<Ts...>;\n #endif\n-template <class... Ts> using none_of = negation<any_of<Ts...>>;\n+template <class... Ts>\n+using none_of = negation<any_of<Ts...>>;\n \n-template <class T, template<class> class... Predicates> using satisfies_all_of = all_of<Predicates<T>...>;\n-template <class T, template<class> class... Predicates> using satisfies_any_of = any_of<Predicates<T>...>;\n-template <class T, template<class> class... Predicates> using satisfies_none_of = none_of<Predicates<T>...>;\n+template <class T, template <class> class... Predicates>\n+using satisfies_all_of = all_of<Predicates<T>...>;\n+template <class T, template <class> class... Predicates>\n+using satisfies_any_of = any_of<Predicates<T>...>;\n+template <class T, template <class> class... Predicates>\n+using satisfies_none_of = none_of<Predicates<T>...>;\n \n /// Strip the class from a method type\n-template <typename T> struct remove_class { };\n-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...)> { typedef R type(A...); };\n-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...) const> { typedef R type(A...); };\n+template <typename T>\n+struct remove_class {};\n+template <typename C, typename R, typename... A>\n+struct remove_class<R (C::*)(A...)> {\n+    using type = R(A...);\n+};\n+template <typename C, typename R, typename... A>\n+struct remove_class<R (C::*)(A...) const> {\n+    using type = R(A...);\n+};\n \n /// Helper template to strip away type modifiers\n-template <typename T> struct intrinsic_type                       { typedef T type; };\n-template <typename T> struct intrinsic_type<const T>              { typedef typename intrinsic_type<T>::type type; };\n-template <typename T> struct intrinsic_type<T*>                   { typedef typename intrinsic_type<T>::type type; };\n-template <typename T> struct intrinsic_type<T&>                   { typedef typename intrinsic_type<T>::type type; };\n-template <typename T> struct intrinsic_type<T&&>                  { typedef typename intrinsic_type<T>::type type; };\n-template <typename T, size_t N> struct intrinsic_type<const T[N]> { typedef typename intrinsic_type<T>::type type; };\n-template <typename T, size_t N> struct intrinsic_type<T[N]>       { typedef typename intrinsic_type<T>::type type; };\n-template <typename T> using intrinsic_t = typename intrinsic_type<T>::type;\n+template <typename T>\n+struct intrinsic_type {\n+    using type = T;\n+};\n+template <typename T>\n+struct intrinsic_type<const T> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T>\n+struct intrinsic_type<T *> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T>\n+struct intrinsic_type<T &> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T>\n+struct intrinsic_type<T &&> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T, size_t N>\n+struct intrinsic_type<const T[N]> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T, size_t N>\n+struct intrinsic_type<T[N]> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T>\n+using intrinsic_t = typename intrinsic_type<T>::type;\n \n /// Helper type to replace 'void' in some expressions\n-struct void_type { };\n+struct void_type {};\n \n /// Helper template which holds a list of types\n-template <typename...> struct type_list { };\n+template <typename...>\n+struct type_list {};\n \n /// Compile-time integer sum\n #ifdef __cpp_fold_expressions\n-template <typename... Ts> constexpr size_t constexpr_sum(Ts... ns) { return (0 + ... + size_t{ns}); }\n+template <typename... Ts>\n+constexpr size_t constexpr_sum(Ts... ns) {\n+    return (0 + ... + size_t{ns});\n+}\n #else\n constexpr size_t constexpr_sum() { return 0; }\n template <typename T, typename... Ts>\n-constexpr size_t constexpr_sum(T n, Ts... ns) { return size_t{n} + constexpr_sum(ns...); }\n+constexpr size_t constexpr_sum(T n, Ts... ns) {\n+    return size_t{n} + constexpr_sum(ns...);\n+}\n #endif\n \n-NAMESPACE_BEGIN(constexpr_impl)\n+PYBIND11_NAMESPACE_BEGIN(constexpr_impl)\n /// Implementation details for constexpr functions\n constexpr int first(int i) { return i; }\n template <typename T, typename... Ts>\n-constexpr int first(int i, T v, Ts... vs) { return v ? i : first(i + 1, vs...); }\n+constexpr int first(int i, T v, Ts... vs) {\n+    return v ? i : first(i + 1, vs...);\n+}\n \n constexpr int last(int /*i*/, int result) { return result; }\n template <typename T, typename... Ts>\n-constexpr int last(int i, int result, T v, Ts... vs) { return last(i + 1, v ? i : result, vs...); }\n-NAMESPACE_END(constexpr_impl)\n+constexpr int last(int i, int result, T v, Ts... vs) {\n+    return last(i + 1, v ? i : result, vs...);\n+}\n+PYBIND11_NAMESPACE_END(constexpr_impl)\n \n-/// Return the index of the first type in Ts which satisfies Predicate<T>.  Returns sizeof...(Ts) if\n-/// none match.\n-template <template<typename> class Predicate, typename... Ts>\n-constexpr int constexpr_first() { return constexpr_impl::first(0, Predicate<Ts>::value...); }\n+/// Return the index of the first type in Ts which satisfies Predicate<T>.\n+/// Returns sizeof...(Ts) if none match.\n+template <template <typename> class Predicate, typename... Ts>\n+constexpr int constexpr_first() {\n+    return constexpr_impl::first(0, Predicate<Ts>::value...);\n+}\n \n /// Return the index of the last type in Ts which satisfies Predicate<T>, or -1 if none match.\n-template <template<typename> class Predicate, typename... Ts>\n-constexpr int constexpr_last() { return constexpr_impl::last(0, -1, Predicate<Ts>::value...); }\n+template <template <typename> class Predicate, typename... Ts>\n+constexpr int constexpr_last() {\n+    return constexpr_impl::last(0, -1, Predicate<Ts>::value...);\n+}\n \n /// Return the Nth element from the parameter pack\n template <size_t N, typename T, typename... Ts>\n-struct pack_element { using type = typename pack_element<N - 1, Ts...>::type; };\n+struct pack_element {\n+    using type = typename pack_element<N - 1, Ts...>::type;\n+};\n template <typename T, typename... Ts>\n-struct pack_element<0, T, Ts...> { using type = T; };\n+struct pack_element<0, T, Ts...> {\n+    using type = T;\n+};\n \n /// Return the one and only type which matches the predicate, or Default if none match.\n /// If more than one type matches the predicate, fail at compile-time.\n-template <template<typename> class Predicate, typename Default, typename... Ts>\n+template <template <typename> class Predicate, typename Default, typename... Ts>\n struct exactly_one {\n     static constexpr auto found = constexpr_sum(Predicate<Ts>::value...);\n     static_assert(found <= 1, \"Found more than one type matching the predicate\");\n \n     static constexpr auto index = found ? constexpr_first<Predicate, Ts...>() : 0;\n     using type = conditional_t<found, typename pack_element<index, Ts...>::type, Default>;\n };\n-template <template<typename> class P, typename Default>\n-struct exactly_one<P, Default> { using type = Default; };\n+template <template <typename> class P, typename Default>\n+struct exactly_one<P, Default> {\n+    using type = Default;\n+};\n \n-template <template<typename> class Predicate, typename Default, typename... Ts>\n+template <template <typename> class Predicate, typename Default, typename... Ts>\n using exactly_one_t = typename exactly_one<Predicate, Default, Ts...>::type;\n \n /// Defer the evaluation of type T until types Us are instantiated\n-template <typename T, typename... /*Us*/> struct deferred_type { using type = T; };\n-template <typename T, typename... Us> using deferred_t = typename deferred_type<T, Us...>::type;\n+template <typename T, typename... /*Us*/>\n+struct deferred_type {\n+    using type = T;\n+};\n+template <typename T, typename... Us>\n+using deferred_t = typename deferred_type<T, Us...>::type;\n \n /// Like is_base_of, but requires a strict base (i.e. `is_strict_base_of<T, T>::value == false`,\n /// unlike `std::is_base_of`)\n-template <typename Base, typename Derived> using is_strict_base_of = bool_constant<\n-    std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;\n-\n-/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived pointer\n-/// can be converted to a Base pointer)\n-template <typename Base, typename Derived> using is_accessible_base_of = bool_constant<\n-    std::is_base_of<Base, Derived>::value && std::is_convertible<Derived *, Base *>::value>;\n-\n-template <template<typename...> class Base>\n+template <typename Base, typename Derived>\n+using is_strict_base_of\n+    = bool_constant<std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;\n+\n+/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived\n+/// pointer can be converted to a Base pointer) For unions, `is_base_of<T, T>::value` is False, so\n+/// we need to check `is_same` as well.\n+template <typename Base, typename Derived>\n+using is_accessible_base_of\n+    = bool_constant<(std::is_same<Base, Derived>::value || std::is_base_of<Base, Derived>::value)\n+                    && std::is_convertible<Derived *, Base *>::value>;\n+\n+template <template <typename...> class Base>\n struct is_template_base_of_impl {\n-    template <typename... Us> static std::true_type check(Base<Us...> *);\n+    template <typename... Us>\n+    static std::true_type check(Base<Us...> *);\n     static std::false_type check(...);\n };\n \n /// Check if a template is the base of a type. For example:\n /// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U can be anything\n-template <template<typename...> class Base, typename T>\n+template <template <typename...> class Base, typename T>\n+// Sadly, all MSVC versions incl. 2022 need the workaround, even in C++20 mode.\n+// See also: https://github.com/pybind/pybind11/pull/3741\n #if !defined(_MSC_VER)\n-using is_template_base_of = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr));\n-#else // MSVC2015 has trouble with decltype in template aliases\n-struct is_template_base_of : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr)) { };\n+using is_template_base_of\n+    = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr));\n+#else\n+struct is_template_base_of\n+    : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr)) {\n+};\n #endif\n \n /// Check if T is an instantiation of the template `Class`. For example:\n /// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U can be anything.\n-template <template<typename...> class Class, typename T>\n-struct is_instantiation : std::false_type { };\n-template <template<typename...> class Class, typename... Us>\n-struct is_instantiation<Class, Class<Us...>> : std::true_type { };\n+template <template <typename...> class Class, typename T>\n+struct is_instantiation : std::false_type {};\n+template <template <typename...> class Class, typename... Us>\n+struct is_instantiation<Class, Class<Us...>> : std::true_type {};\n \n /// Check if T is std::shared_ptr<U> where U can be anything\n-template <typename T> using is_shared_ptr = is_instantiation<std::shared_ptr, T>;\n+template <typename T>\n+using is_shared_ptr = is_instantiation<std::shared_ptr, T>;\n \n /// Check if T looks like an input iterator\n-template <typename T, typename = void> struct is_input_iterator : std::false_type {};\n+template <typename T, typename = void>\n+struct is_input_iterator : std::false_type {};\n template <typename T>\n-struct is_input_iterator<T, void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>\n+struct is_input_iterator<T,\n+                         void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>\n     : std::true_type {};\n \n-template <typename T> using is_function_pointer = bool_constant<\n-    std::is_pointer<T>::value && std::is_function<typename std::remove_pointer<T>::type>::value>;\n-\n-template <typename F> struct strip_function_object {\n+template <typename T>\n+using is_function_pointer\n+    = bool_constant<std::is_pointer<T>::value\n+                    && std::is_function<typename std::remove_pointer<T>::type>::value>;\n+\n+template <typename F>\n+struct strip_function_object {\n+    // If you are encountering an\n+    // 'error: name followed by \"::\" must be a class or namespace name'\n+    // with the Intel compiler and a noexcept function here,\n+    // try to use noexcept(true) instead of plain noexcept.\n     using type = typename remove_class<decltype(&F::operator())>::type;\n };\n \n@@ -627,168 +872,224 @@ template <typename Function, typename F = remove_reference_t<Function>>\n using function_signature_t = conditional_t<\n     std::is_function<F>::value,\n     F,\n-    typename conditional_t<\n-        std::is_pointer<F>::value || std::is_member_pointer<F>::value,\n-        std::remove_pointer<F>,\n-        strip_function_object<F>\n-    >::type\n->;\n+    typename conditional_t<std::is_pointer<F>::value || std::is_member_pointer<F>::value,\n+                           std::remove_pointer<F>,\n+                           strip_function_object<F>>::type>;\n \n /// Returns true if the type looks like a lambda: that is, isn't a function, pointer or member\n /// pointer.  Note that this can catch all sorts of other things, too; this is intended to be used\n /// in a place where passing a lambda makes sense.\n-template <typename T> using is_lambda = satisfies_none_of<remove_reference_t<T>,\n-        std::is_function, std::is_pointer, std::is_member_pointer>;\n-\n-/// Ignore that a variable is unused in compiler warnings\n-inline void ignore_unused(const int *) { }\n+template <typename T>\n+using is_lambda = satisfies_none_of<remove_reference_t<T>,\n+                                    std::is_function,\n+                                    std::is_pointer,\n+                                    std::is_member_pointer>;\n \n+// [workaround(intel)] Internal error on fold expression\n /// Apply a function over each element of a parameter pack\n-#ifdef __cpp_fold_expressions\n-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)\n+#if defined(__cpp_fold_expressions) && !defined(__INTEL_COMPILER)\n+// Intel compiler produces an internal error on this fold expression (tested with ICC 19.0.2)\n+#    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)\n #else\n using expand_side_effects = bool[];\n-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) pybind11::detail::expand_side_effects{ ((PATTERN), void(), false)..., false }\n+#    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN)                                                 \\\n+        (void) pybind11::detail::expand_side_effects { ((PATTERN), void(), false)..., false }\n #endif\n \n-NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(detail)\n \n+#if defined(_MSC_VER)\n+#    pragma warning(push)\n+#    pragma warning(disable : 4275)\n+//     warning C4275: An exported class was derived from a class that wasn't exported.\n+//     Can be ignored when derived from a STL class.\n+#endif\n /// C++ bindings of builtin Python exceptions\n-class builtin_exception : public std::runtime_error {\n+class PYBIND11_EXPORT_EXCEPTION builtin_exception : public std::runtime_error {\n public:\n     using std::runtime_error::runtime_error;\n     /// Set the error using the Python C API\n     virtual void set_error() const = 0;\n };\n+#if defined(_MSC_VER)\n+#    pragma warning(pop)\n+#endif\n \n-#define PYBIND11_RUNTIME_EXCEPTION(name, type) \\\n-    class name : public builtin_exception { public: \\\n-        using builtin_exception::builtin_exception; \\\n-        name() : name(\"\") { } \\\n-        void set_error() const override { PyErr_SetString(type, what()); } \\\n+#define PYBIND11_RUNTIME_EXCEPTION(name, type)                                                    \\\n+    class PYBIND11_EXPORT_EXCEPTION name : public builtin_exception {                             \\\n+    public:                                                                                       \\\n+        using builtin_exception::builtin_exception;                                               \\\n+        name() : name(\"\") {}                                                                      \\\n+        void set_error() const override { PyErr_SetString(type, what()); }                        \\\n     };\n \n PYBIND11_RUNTIME_EXCEPTION(stop_iteration, PyExc_StopIteration)\n PYBIND11_RUNTIME_EXCEPTION(index_error, PyExc_IndexError)\n PYBIND11_RUNTIME_EXCEPTION(key_error, PyExc_KeyError)\n PYBIND11_RUNTIME_EXCEPTION(value_error, PyExc_ValueError)\n PYBIND11_RUNTIME_EXCEPTION(type_error, PyExc_TypeError)\n-PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or handle::call fail due to a type casting error\n+PYBIND11_RUNTIME_EXCEPTION(buffer_error, PyExc_BufferError)\n+PYBIND11_RUNTIME_EXCEPTION(import_error, PyExc_ImportError)\n+PYBIND11_RUNTIME_EXCEPTION(attribute_error, PyExc_AttributeError)\n+PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or\n+                                                           /// handle::call fail due to a type\n+                                                           /// casting error\n PYBIND11_RUNTIME_EXCEPTION(reference_cast_error, PyExc_RuntimeError) /// Used internally\n \n-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) { throw std::runtime_error(reason); }\n-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const std::string &reason) { throw std::runtime_error(reason); }\n+[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const char *reason) {\n+    assert(!PyErr_Occurred());\n+    throw std::runtime_error(reason);\n+}\n+[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const std::string &reason) {\n+    assert(!PyErr_Occurred());\n+    throw std::runtime_error(reason);\n+}\n \n-template <typename T, typename SFINAE = void> struct format_descriptor { };\n+template <typename T, typename SFINAE = void>\n+struct format_descriptor {};\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n // Returns the index of the given type in the type char array below, and in the list in numpy.h\n // The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;\n // complex float,double,long double.  Note that the long double types only participate when long\n // double is actually longer than double (it isn't under MSVC).\n // NB: not only the string below but also complex.h and numpy.h rely on this order.\n-template <typename T, typename SFINAE = void> struct is_fmt_numeric { static constexpr bool value = false; };\n-template <typename T> struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {\n+template <typename T, typename SFINAE = void>\n+struct is_fmt_numeric {\n+    static constexpr bool value = false;\n+};\n+template <typename T>\n+struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {\n     static constexpr bool value = true;\n-    static constexpr int index = std::is_same<T, bool>::value ? 0 : 1 + (\n-        std::is_integral<T>::value ? detail::log2(sizeof(T))*2 + std::is_unsigned<T>::value : 8 + (\n-        std::is_same<T, double>::value ? 1 : std::is_same<T, long double>::value ? 2 : 0));\n+    static constexpr int index\n+        = std::is_same<T, bool>::value\n+              ? 0\n+              : 1\n+                    + (std::is_integral<T>::value\n+                           ? detail::log2(sizeof(T)) * 2 + std::is_unsigned<T>::value\n+                           : 8\n+                                 + (std::is_same<T, double>::value        ? 1\n+                                    : std::is_same<T, long double>::value ? 2\n+                                                                          : 0));\n };\n-NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(detail)\n \n-template <typename T> struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {\n+template <typename T>\n+struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {\n     static constexpr const char c = \"?bBhHiIqQfdg\"[detail::is_fmt_numeric<T>::index];\n-    static constexpr const char value[2] = { c, '\\0' };\n+    static constexpr const char value[2] = {c, '\\0'};\n     static std::string format() { return std::string(1, c); }\n };\n \n #if !defined(PYBIND11_CPP17)\n \n-template <typename T> constexpr const char format_descriptor<\n-    T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];\n+template <typename T>\n+constexpr const char\n+    format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];\n \n #endif\n \n /// RAII wrapper that temporarily clears any Python error state\n struct error_scope {\n     PyObject *type, *value, *trace;\n     error_scope() { PyErr_Fetch(&type, &value, &trace); }\n+    error_scope(const error_scope &) = delete;\n+    error_scope &operator=(const error_scope &) = delete;\n     ~error_scope() { PyErr_Restore(type, value, trace); }\n };\n \n /// Dummy destructor wrapper that can be used to expose classes with a private destructor\n-struct nodelete { template <typename T> void operator()(T*) { } };\n-\n-// overload_cast requires variable templates: C++14\n-#if defined(PYBIND11_CPP14)\n-#define PYBIND11_OVERLOAD_CAST 1\n+struct nodelete {\n+    template <typename T>\n+    void operator()(T *) {}\n+};\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n template <typename... Args>\n struct overload_cast_impl {\n-    constexpr overload_cast_impl() {} // MSVC 2015 needs this\n-\n     template <typename Return>\n-    constexpr auto operator()(Return (*pf)(Args...)) const noexcept\n-                              -> decltype(pf) { return pf; }\n+    constexpr auto operator()(Return (*pf)(Args...)) const noexcept -> decltype(pf) {\n+        return pf;\n+    }\n \n     template <typename Return, typename Class>\n     constexpr auto operator()(Return (Class::*pmf)(Args...), std::false_type = {}) const noexcept\n-                              -> decltype(pmf) { return pmf; }\n+        -> decltype(pmf) {\n+        return pmf;\n+    }\n \n     template <typename Return, typename Class>\n     constexpr auto operator()(Return (Class::*pmf)(Args...) const, std::true_type) const noexcept\n-                              -> decltype(pmf) { return pmf; }\n+        -> decltype(pmf) {\n+        return pmf;\n+    }\n };\n-NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(detail)\n \n+// overload_cast requires variable templates: C++14\n+#if defined(PYBIND11_CPP14)\n+#    define PYBIND11_OVERLOAD_CAST 1\n /// Syntax sugar for resolving overloaded function pointers:\n ///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)\n ///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)\n template <typename... Args>\n+#    if (defined(_MSC_VER) && _MSC_VER < 1920) /* MSVC 2017 */                                    \\\n+        || (defined(__clang__) && __clang_major__ == 5)\n static constexpr detail::overload_cast_impl<Args...> overload_cast = {};\n-// MSVC 2015 only accepts this particular initialization syntax for this variable template.\n+#    else\n+static constexpr detail::overload_cast_impl<Args...> overload_cast;\n+#    endif\n+#endif\n \n /// Const member function selector for overload_cast\n ///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)\n ///  - sweet:   overload_cast<Arg>(&Class::func, const_)\n static constexpr auto const_ = std::true_type{};\n \n-#else // no overload_cast: providing something that static_assert-fails:\n-template <typename... Args> struct overload_cast {\n+#if !defined(PYBIND11_CPP14) // no overload_cast: providing something that static_assert-fails:\n+template <typename... Args>\n+struct overload_cast {\n     static_assert(detail::deferred_t<std::false_type, Args...>::value,\n                   \"pybind11::overload_cast<...> requires compiling in C++14 mode\");\n };\n #endif // overload_cast\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n // Adaptor for converting arbitrary container arguments into a vector; implicitly convertible from\n // any standard container (or C-style array) supporting std::begin/std::end, any singleton\n // arithmetic type (if T is arithmetic), or explicitly constructible from an iterator pair.\n template <typename T>\n class any_container {\n     std::vector<T> v;\n+\n public:\n     any_container() = default;\n \n     // Can construct from a pair of iterators\n     template <typename It, typename = enable_if_t<is_input_iterator<It>::value>>\n-    any_container(It first, It last) : v(first, last) { }\n-\n-    // Implicit conversion constructor from any arbitrary container type with values convertible to T\n-    template <typename Container, typename = enable_if_t<std::is_convertible<decltype(*std::begin(std::declval<const Container &>())), T>::value>>\n-    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) { }\n-\n-    // initializer_list's aren't deducible, so don't get matched by the above template; we need this\n-    // to explicitly allow implicit conversion from one:\n+    any_container(It first, It last) : v(first, last) {}\n+\n+    // Implicit conversion constructor from any arbitrary container type\n+    // with values convertible to T\n+    template <typename Container,\n+              typename = enable_if_t<\n+                  std::is_convertible<decltype(*std::begin(std::declval<const Container &>())),\n+                                      T>::value>>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) {}\n+\n+    // initializer_list's aren't deducible, so don't get matched by the above template;\n+    // we need this to explicitly allow implicit conversion from one:\n     template <typename TIn, typename = enable_if_t<std::is_convertible<TIn, T>::value>>\n-    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) { }\n+    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) {}\n \n     // Avoid copying if given an rvalue vector of the correct type.\n-    any_container(std::vector<T> &&v) : v(std::move(v)) { }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    any_container(std::vector<T> &&v) : v(std::move(v)) {}\n \n     // Moves the vector out of an rvalue any_container\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n     operator std::vector<T> &&() && { return std::move(v); }\n \n     // Dereferencing obtains a reference to the underlying vector\n@@ -800,8 +1101,69 @@ class any_container {\n     const std::vector<T> *operator->() const { return &v; }\n };\n \n-NAMESPACE_END(detail)\n+// Forward-declaration; see detail/class.h\n+std::string get_fully_qualified_tp_name(PyTypeObject *);\n \n+template <typename T>\n+inline static std::shared_ptr<T>\n+try_get_shared_from_this(std::enable_shared_from_this<T> *holder_value_ptr) {\n+// Pre C++17, this code path exploits undefined behavior, but is known to work on many platforms.\n+// Use at your own risk!\n+// See also https://en.cppreference.com/w/cpp/memory/enable_shared_from_this, and in particular\n+// the `std::shared_ptr<Good> gp1 = not_so_good.getptr();` and `try`-`catch` parts of the example.\n+#if defined(__cpp_lib_enable_shared_from_this) && (!defined(_MSC_VER) || _MSC_VER >= 1912)\n+    return holder_value_ptr->weak_from_this().lock();\n+#else\n+    try {\n+        return holder_value_ptr->shared_from_this();\n+    } catch (const std::bad_weak_ptr &) {\n+        return nullptr;\n+    }\n+#endif\n+}\n+\n+// For silencing \"unused\" compiler warnings in special situations.\n+template <typename... Args>\n+#if defined(_MSC_VER) && _MSC_VER < 1920 // MSVC 2017\n+constexpr\n+#endif\n+    inline void\n+    silence_unused_warnings(Args &&...) {\n+}\n+\n+// MSVC warning C4100: Unreferenced formal parameter\n+#if defined(_MSC_VER) && _MSC_VER <= 1916\n+#    define PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(...)                                         \\\n+        detail::silence_unused_warnings(__VA_ARGS__)\n+#else\n+#    define PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(...)\n+#endif\n \n+// GCC -Wunused-but-set-parameter  All GCC versions (as of July 2021).\n+#if defined(__GNUG__) && !defined(__clang__) && !defined(__INTEL_COMPILER)\n+#    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)                       \\\n+        detail::silence_unused_warnings(__VA_ARGS__)\n+#else\n+#    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)\n+#endif\n+\n+#if defined(_MSC_VER) // All versions (as of July 2021).\n+\n+// warning C4127: Conditional expression is constant\n+constexpr inline bool silence_msvc_c4127(bool cond) { return cond; }\n+\n+#    define PYBIND11_SILENCE_MSVC_C4127(...) ::pybind11::detail::silence_msvc_c4127(__VA_ARGS__)\n+\n+#else\n+#    define PYBIND11_SILENCE_MSVC_C4127(...) __VA_ARGS__\n+#endif\n+\n+// Pybind offers detailed error messages by default for all builts that are debug (through the\n+// negation of ndebug). This can also be manually enabled by users, for any builds, through\n+// defining PYBIND11_DETAILED_ERROR_MESSAGES.\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES) && !defined(NDEBUG)\n+#    define PYBIND11_DETAILED_ERROR_MESSAGES\n+#endif\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/descr.h", "status": "modified", "additions": 87, "deletions": 29, "changes": 116, "file_content_changes": "@@ -11,90 +11,148 @@\n \n #include \"common.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n #if !defined(_MSC_VER)\n-#  define PYBIND11_DESCR_CONSTEXPR static constexpr\n+#    define PYBIND11_DESCR_CONSTEXPR static constexpr\n #else\n-#  define PYBIND11_DESCR_CONSTEXPR const\n+#    define PYBIND11_DESCR_CONSTEXPR const\n #endif\n \n /* Concatenate type signatures at compile time */\n template <size_t N, typename... Ts>\n struct descr {\n-    char text[N + 1];\n+    char text[N + 1]{'\\0'};\n \n-    constexpr descr() : text{'\\0'} { }\n-    constexpr descr(char const (&s)[N+1]) : descr(s, make_index_sequence<N>()) { }\n+    constexpr descr() = default;\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    constexpr descr(char const (&s)[N + 1]) : descr(s, make_index_sequence<N>()) {}\n \n     template <size_t... Is>\n-    constexpr descr(char const (&s)[N+1], index_sequence<Is...>) : text{s[Is]..., '\\0'} { }\n+    constexpr descr(char const (&s)[N + 1], index_sequence<Is...>) : text{s[Is]..., '\\0'} {}\n \n     template <typename... Chars>\n-    constexpr descr(char c, Chars... cs) : text{c, static_cast<char>(cs)..., '\\0'} { }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    constexpr descr(char c, Chars... cs) : text{c, static_cast<char>(cs)..., '\\0'} {}\n \n     static constexpr std::array<const std::type_info *, sizeof...(Ts) + 1> types() {\n         return {{&typeid(Ts)..., nullptr}};\n     }\n };\n \n template <size_t N1, size_t N2, typename... Ts1, typename... Ts2, size_t... Is1, size_t... Is2>\n-constexpr descr<N1 + N2, Ts1..., Ts2...> plus_impl(const descr<N1, Ts1...> &a, const descr<N2, Ts2...> &b,\n-                                                   index_sequence<Is1...>, index_sequence<Is2...>) {\n+constexpr descr<N1 + N2, Ts1..., Ts2...> plus_impl(const descr<N1, Ts1...> &a,\n+                                                   const descr<N2, Ts2...> &b,\n+                                                   index_sequence<Is1...>,\n+                                                   index_sequence<Is2...>) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(b);\n     return {a.text[Is1]..., b.text[Is2]...};\n }\n \n template <size_t N1, size_t N2, typename... Ts1, typename... Ts2>\n-constexpr descr<N1 + N2, Ts1..., Ts2...> operator+(const descr<N1, Ts1...> &a, const descr<N2, Ts2...> &b) {\n+constexpr descr<N1 + N2, Ts1..., Ts2...> operator+(const descr<N1, Ts1...> &a,\n+                                                   const descr<N2, Ts2...> &b) {\n     return plus_impl(a, b, make_index_sequence<N1>(), make_index_sequence<N2>());\n }\n \n template <size_t N>\n-constexpr descr<N - 1> _(char const(&text)[N]) { return descr<N - 1>(text); }\n-constexpr descr<0> _(char const(&)[1]) { return {}; }\n+constexpr descr<N - 1> const_name(char const (&text)[N]) {\n+    return descr<N - 1>(text);\n+}\n+constexpr descr<0> const_name(char const (&)[1]) { return {}; }\n \n-template <size_t Rem, size_t... Digits> struct int_to_str : int_to_str<Rem/10, Rem%10, Digits...> { };\n-template <size_t...Digits> struct int_to_str<0, Digits...> {\n+template <size_t Rem, size_t... Digits>\n+struct int_to_str : int_to_str<Rem / 10, Rem % 10, Digits...> {};\n+template <size_t... Digits>\n+struct int_to_str<0, Digits...> {\n+    // WARNING: This only works with C++17 or higher.\n     static constexpr auto digits = descr<sizeof...(Digits)>(('0' + Digits)...);\n };\n \n // Ternary description (like std::conditional)\n template <bool B, size_t N1, size_t N2>\n-constexpr enable_if_t<B, descr<N1 - 1>> _(char const(&text1)[N1], char const(&)[N2]) {\n-    return _(text1);\n+constexpr enable_if_t<B, descr<N1 - 1>> const_name(char const (&text1)[N1], char const (&)[N2]) {\n+    return const_name(text1);\n }\n template <bool B, size_t N1, size_t N2>\n-constexpr enable_if_t<!B, descr<N2 - 1>> _(char const(&)[N1], char const(&text2)[N2]) {\n-    return _(text2);\n+constexpr enable_if_t<!B, descr<N2 - 1>> const_name(char const (&)[N1], char const (&text2)[N2]) {\n+    return const_name(text2);\n }\n \n template <bool B, typename T1, typename T2>\n-constexpr enable_if_t<B, T1> _(const T1 &d, const T2 &) { return d; }\n+constexpr enable_if_t<B, T1> const_name(const T1 &d, const T2 &) {\n+    return d;\n+}\n template <bool B, typename T1, typename T2>\n-constexpr enable_if_t<!B, T2> _(const T1 &, const T2 &d) { return d; }\n+constexpr enable_if_t<!B, T2> const_name(const T1 &, const T2 &d) {\n+    return d;\n+}\n \n-template <size_t Size> auto constexpr _() -> decltype(int_to_str<Size / 10, Size % 10>::digits) {\n+template <size_t Size>\n+auto constexpr const_name() -> remove_cv_t<decltype(int_to_str<Size / 10, Size % 10>::digits)> {\n     return int_to_str<Size / 10, Size % 10>::digits;\n }\n \n-template <typename Type> constexpr descr<1, Type> _() { return {'%'}; }\n+template <typename Type>\n+constexpr descr<1, Type> const_name() {\n+    return {'%'};\n+}\n+\n+// If \"_\" is defined as a macro, py::detail::_ cannot be provided.\n+// It is therefore best to use py::detail::const_name universally.\n+// This block is for backward compatibility only.\n+// (The const_name code is repeated to avoid introducing a \"_\" #define ourselves.)\n+#ifndef _\n+#    define PYBIND11_DETAIL_UNDERSCORE_BACKWARD_COMPATIBILITY\n+template <size_t N>\n+constexpr descr<N - 1> _(char const (&text)[N]) {\n+    return const_name<N>(text);\n+}\n+template <bool B, size_t N1, size_t N2>\n+constexpr enable_if_t<B, descr<N1 - 1>> _(char const (&text1)[N1], char const (&text2)[N2]) {\n+    return const_name<B, N1, N2>(text1, text2);\n+}\n+template <bool B, size_t N1, size_t N2>\n+constexpr enable_if_t<!B, descr<N2 - 1>> _(char const (&text1)[N1], char const (&text2)[N2]) {\n+    return const_name<B, N1, N2>(text1, text2);\n+}\n+template <bool B, typename T1, typename T2>\n+constexpr enable_if_t<B, T1> _(const T1 &d1, const T2 &d2) {\n+    return const_name<B, T1, T2>(d1, d2);\n+}\n+template <bool B, typename T1, typename T2>\n+constexpr enable_if_t<!B, T2> _(const T1 &d1, const T2 &d2) {\n+    return const_name<B, T1, T2>(d1, d2);\n+}\n+\n+template <size_t Size>\n+auto constexpr _() -> remove_cv_t<decltype(int_to_str<Size / 10, Size % 10>::digits)> {\n+    return const_name<Size>();\n+}\n+template <typename Type>\n+constexpr descr<1, Type> _() {\n+    return const_name<Type>();\n+}\n+#endif // #ifndef _\n \n constexpr descr<0> concat() { return {}; }\n \n template <size_t N, typename... Ts>\n-constexpr descr<N, Ts...> concat(const descr<N, Ts...> &descr) { return descr; }\n+constexpr descr<N, Ts...> concat(const descr<N, Ts...> &descr) {\n+    return descr;\n+}\n \n template <size_t N, typename... Ts, typename... Args>\n constexpr auto concat(const descr<N, Ts...> &d, const Args &...args)\n     -> decltype(std::declval<descr<N + 2, Ts...>>() + concat(args...)) {\n-    return d + _(\", \") + concat(args...);\n+    return d + const_name(\", \") + concat(args...);\n }\n \n template <size_t N, typename... Ts>\n constexpr descr<N + 2, Ts...> type_descr(const descr<N, Ts...> &descr) {\n-    return _(\"{\") + descr + _(\"}\");\n+    return const_name(\"{\") + descr + const_name(\"}\");\n }\n \n-NAMESPACE_END(detail)\n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/init.h", "status": "modified", "additions": 197, "deletions": 104, "changes": 301, "file_content_changes": "@@ -11,8 +11,8 @@\n \n #include \"class.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n template <>\n class type_caster<value_and_holder> {\n@@ -22,26 +22,33 @@ class type_caster<value_and_holder> {\n         return true;\n     }\n \n-    template <typename> using cast_op_type = value_and_holder &;\n-    operator value_and_holder &() { return *value; }\n-    static constexpr auto name = _<value_and_holder>();\n+    template <typename>\n+    using cast_op_type = value_and_holder &;\n+    explicit operator value_and_holder &() { return *value; }\n+    static constexpr auto name = const_name<value_and_holder>();\n \n private:\n     value_and_holder *value = nullptr;\n };\n \n-NAMESPACE_BEGIN(initimpl)\n+PYBIND11_NAMESPACE_BEGIN(initimpl)\n \n inline void no_nullptr(void *ptr) {\n-    if (!ptr) throw type_error(\"pybind11::init(): factory function returned nullptr\");\n+    if (!ptr) {\n+        throw type_error(\"pybind11::init(): factory function returned nullptr\");\n+    }\n }\n \n // Implementing functions for all forms of py::init<...> and py::init(...)\n-template <typename Class> using Cpp = typename Class::type;\n-template <typename Class> using Alias = typename Class::type_alias;\n-template <typename Class> using Holder = typename Class::holder_type;\n+template <typename Class>\n+using Cpp = typename Class::type;\n+template <typename Class>\n+using Alias = typename Class::type_alias;\n+template <typename Class>\n+using Holder = typename Class::holder_type;\n \n-template <typename Class> using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;\n+template <typename Class>\n+using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;\n \n // Takes a Cpp pointer and returns true if it actually is a polymorphic Alias instance.\n template <typename Class, enable_if_t<Class::has_alias, int> = 0>\n@@ -50,17 +57,27 @@ bool is_alias(Cpp<Class> *ptr) {\n }\n // Failing fallback version of the above for a no-alias class (always returns false)\n template <typename /*Class*/>\n-constexpr bool is_alias(void *) { return false; }\n+constexpr bool is_alias(void *) {\n+    return false;\n+}\n \n // Constructs and returns a new object; if the given arguments don't map to a constructor, we fall\n // back to brace aggregate initiailization so that for aggregate initialization can be used with\n // py::init, e.g.  `py::init<int, int>` to initialize a `struct T { int a; int b; }`.  For\n // non-aggregate types, we need to use an ordinary T(...) constructor (invoking as `T{...}` usually\n // works, but will not do the expected thing when `T` has an `initializer_list<T>` constructor).\n-template <typename Class, typename... Args, detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>\n-inline Class *construct_or_initialize(Args &&...args) { return new Class(std::forward<Args>(args)...); }\n-template <typename Class, typename... Args, detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>\n-inline Class *construct_or_initialize(Args &&...args) { return new Class{std::forward<Args>(args)...}; }\n+template <typename Class,\n+          typename... Args,\n+          detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>\n+inline Class *construct_or_initialize(Args &&...args) {\n+    return new Class(std::forward<Args>(args)...);\n+}\n+template <typename Class,\n+          typename... Args,\n+          detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>\n+inline Class *construct_or_initialize(Args &&...args) {\n+    return new Class{std::forward<Args>(args)...};\n+}\n \n // Attempts to constructs an alias using a `Alias(Cpp &&)` constructor.  This allows types with\n // an alias to provide only a single Cpp factory function as long as the Alias can be\n@@ -69,12 +86,14 @@ inline Class *construct_or_initialize(Args &&...args) { return new Class{std::fo\n // inherit all the base class constructors.\n template <typename Class>\n void construct_alias_from_cpp(std::true_type /*is_alias_constructible*/,\n-                              value_and_holder &v_h, Cpp<Class> &&base) {\n+                              value_and_holder &v_h,\n+                              Cpp<Class> &&base) {\n     v_h.value_ptr() = new Alias<Class>(std::move(base));\n }\n template <typename Class>\n [[noreturn]] void construct_alias_from_cpp(std::false_type /*!is_alias_constructible*/,\n-                                           value_and_holder &, Cpp<Class> &&) {\n+                                           value_and_holder &,\n+                                           Cpp<Class> &&) {\n     throw type_error(\"pybind11::init(): unable to convert returned instance to required \"\n                      \"alias class: no `Alias<Class>(Class &&)` constructor available\");\n }\n@@ -84,8 +103,8 @@ template <typename Class>\n template <typename Class>\n void construct(...) {\n     static_assert(!std::is_same<Class, Class>::value /* always false */,\n-            \"pybind11::init(): init function must return a compatible pointer, \"\n-            \"holder, or value\");\n+                  \"pybind11::init(): init function must return a compatible pointer, \"\n+                  \"holder, or value\");\n }\n \n // Pointer return v1: the factory function returns a class pointer for a registered class.\n@@ -94,8 +113,9 @@ void construct(...) {\n // construct an Alias from the returned base instance.\n template <typename Class>\n void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);\n     no_nullptr(ptr);\n-    if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {\n+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias && !is_alias<Class>(ptr)) {\n         // We're going to try to construct an alias by moving the cpp type.  Whether or not\n         // that succeeds, we still need to destroy the original cpp pointer (either the\n         // moved away leftover, if the alias construction works, or the value itself if we\n@@ -105,7 +125,7 @@ void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {\n         // the holder and destruction happens when we leave the C++ scope, and the holder\n         // class gets to handle the destruction however it likes.\n         v_h.value_ptr() = ptr;\n-        v_h.set_instance_registered(true); // To prevent init_instance from registering it\n+        v_h.set_instance_registered(true);          // To prevent init_instance from registering it\n         v_h.type->init_instance(v_h.inst, nullptr); // Set up the holder\n         Holder<Class> temp_holder(std::move(v_h.holder<Holder<Class>>())); // Steal the holder\n         v_h.type->dealloc(v_h); // Destroys the moved-out holder remains, resets value ptr to null\n@@ -128,14 +148,18 @@ void construct(value_and_holder &v_h, Alias<Class> *alias_ptr, bool) {\n \n // Holder return: copy its pointer, and move or copy the returned holder into the new instance's\n // holder.  This also handles types like std::shared_ptr<T> and std::unique_ptr<T> where T is a\n-// derived type (through those holder's implicit conversion from derived class holder constructors).\n+// derived type (through those holder's implicit conversion from derived class holder\n+// constructors).\n template <typename Class>\n void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);\n     auto *ptr = holder_helper<Holder<Class>>::get(holder);\n+    no_nullptr(ptr);\n     // If we need an alias, check that the held pointer is actually an alias instance\n-    if (Class::has_alias && need_alias && !is_alias<Class>(ptr))\n+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias && !is_alias<Class>(ptr)) {\n         throw type_error(\"pybind11::init(): construction failed: returned holder-wrapped instance \"\n                          \"is not an alias instance\");\n+    }\n \n     v_h.value_ptr() = ptr;\n     v_h.type->init_instance(v_h.inst, &holder);\n@@ -147,20 +171,23 @@ void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {\n // need it, we simply move-construct the cpp value into a new instance.\n template <typename Class>\n void construct(value_and_holder &v_h, Cpp<Class> &&result, bool need_alias) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);\n     static_assert(std::is_move_constructible<Cpp<Class>>::value,\n-        \"pybind11::init() return-by-value factory function requires a movable class\");\n-    if (Class::has_alias && need_alias)\n+                  \"pybind11::init() return-by-value factory function requires a movable class\");\n+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias) {\n         construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(result));\n-    else\n+    } else {\n         v_h.value_ptr() = new Cpp<Class>(std::move(result));\n+    }\n }\n \n // return-by-value version 2: returning a value of the alias type itself.  We move-construct an\n // Alias instance (even if no the python-side inheritance is involved).  The is intended for\n // cases where Alias initialization is always desired.\n template <typename Class>\n void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {\n-    static_assert(std::is_move_constructible<Alias<Class>>::value,\n+    static_assert(\n+        std::is_move_constructible<Alias<Class>>::value,\n         \"pybind11::init() return-by-alias-value factory function requires a movable alias class\");\n     v_h.value_ptr() = new Alias<Class>(std::move(result));\n }\n@@ -169,56 +196,85 @@ void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {\n template <typename... Args>\n struct constructor {\n     template <typename Class, typename... Extra, enable_if_t<!Class::has_alias, int> = 0>\n-    static void execute(Class &cl, const Extra&... extra) {\n-        cl.def(\"__init__\", [](value_and_holder &v_h, Args... args) {\n-            v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);\n-        }, is_new_style_constructor(), extra...);\n+    static void execute(Class &cl, const Extra &...extra) {\n+        cl.def(\n+            \"__init__\",\n+            [](value_and_holder &v_h, Args... args) {\n+                v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n     }\n \n-    template <typename Class, typename... Extra,\n-              enable_if_t<Class::has_alias &&\n-                          std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>\n-    static void execute(Class &cl, const Extra&... extra) {\n-        cl.def(\"__init__\", [](value_and_holder &v_h, Args... args) {\n-            if (Py_TYPE(v_h.inst) == v_h.type->type)\n-                v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);\n-            else\n-                v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n-        }, is_new_style_constructor(), extra...);\n+    template <typename Class,\n+              typename... Extra,\n+              enable_if_t<Class::has_alias && std::is_constructible<Cpp<Class>, Args...>::value,\n+                          int> = 0>\n+    static void execute(Class &cl, const Extra &...extra) {\n+        cl.def(\n+            \"__init__\",\n+            [](value_and_holder &v_h, Args... args) {\n+                if (Py_TYPE(v_h.inst) == v_h.type->type) {\n+                    v_h.value_ptr()\n+                        = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);\n+                } else {\n+                    v_h.value_ptr()\n+                        = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n+                }\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n     }\n \n-    template <typename Class, typename... Extra,\n-              enable_if_t<Class::has_alias &&\n-                          !std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>\n-    static void execute(Class &cl, const Extra&... extra) {\n-        cl.def(\"__init__\", [](value_and_holder &v_h, Args... args) {\n-            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n-        }, is_new_style_constructor(), extra...);\n+    template <typename Class,\n+              typename... Extra,\n+              enable_if_t<Class::has_alias && !std::is_constructible<Cpp<Class>, Args...>::value,\n+                          int> = 0>\n+    static void execute(Class &cl, const Extra &...extra) {\n+        cl.def(\n+            \"__init__\",\n+            [](value_and_holder &v_h, Args... args) {\n+                v_h.value_ptr()\n+                    = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n     }\n };\n \n // Implementing class for py::init_alias<...>()\n-template <typename... Args> struct alias_constructor {\n-    template <typename Class, typename... Extra,\n-              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value, int> = 0>\n-    static void execute(Class &cl, const Extra&... extra) {\n-        cl.def(\"__init__\", [](value_and_holder &v_h, Args... args) {\n-            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n-        }, is_new_style_constructor(), extra...);\n+template <typename... Args>\n+struct alias_constructor {\n+    template <typename Class,\n+              typename... Extra,\n+              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value,\n+                          int> = 0>\n+    static void execute(Class &cl, const Extra &...extra) {\n+        cl.def(\n+            \"__init__\",\n+            [](value_and_holder &v_h, Args... args) {\n+                v_h.value_ptr()\n+                    = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n     }\n };\n \n // Implementation class for py::init(Func) and py::init(Func, AliasFunc)\n-template <typename CFunc, typename AFunc = void_type (*)(),\n-          typename = function_signature_t<CFunc>, typename = function_signature_t<AFunc>>\n+template <typename CFunc,\n+          typename AFunc = void_type (*)(),\n+          typename = function_signature_t<CFunc>,\n+          typename = function_signature_t<AFunc>>\n struct factory;\n \n // Specialization for py::init(Func)\n template <typename Func, typename Return, typename... Args>\n struct factory<Func, void_type (*)(), Return(Args...)> {\n     remove_reference_t<Func> class_factory;\n \n-    factory(Func &&f) : class_factory(std::forward<Func>(f)) { }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    factory(Func &&f) : class_factory(std::forward<Func>(f)) {}\n \n     // The given class either has no alias or has no separate alias factory;\n     // this always constructs the class itself.  If the class is registered with an alias\n@@ -227,22 +283,32 @@ struct factory<Func, void_type (*)(), Return(Args...)> {\n     // instance, or the alias needs to be constructible from a `Class &&` argument.\n     template <typename Class, typename... Extra>\n     void execute(Class &cl, const Extra &...extra) && {\n-        #if defined(PYBIND11_CPP14)\n-        cl.def(\"__init__\", [func = std::move(class_factory)]\n-        #else\n+#if defined(PYBIND11_CPP14)\n+        cl.def(\n+            \"__init__\",\n+            [func = std::move(class_factory)]\n+#else\n         auto &func = class_factory;\n-        cl.def(\"__init__\", [func]\n-        #endif\n-        (value_and_holder &v_h, Args... args) {\n-            construct<Class>(v_h, func(std::forward<Args>(args)...),\n-                             Py_TYPE(v_h.inst) != v_h.type->type);\n-        }, is_new_style_constructor(), extra...);\n+        cl.def(\n+            \"__init__\",\n+            [func]\n+#endif\n+            (value_and_holder &v_h, Args... args) {\n+                construct<Class>(\n+                    v_h, func(std::forward<Args>(args)...), Py_TYPE(v_h.inst) != v_h.type->type);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n     }\n };\n \n // Specialization for py::init(Func, AliasFunc)\n-template <typename CFunc, typename AFunc,\n-          typename CReturn, typename... CArgs, typename AReturn, typename... AArgs>\n+template <typename CFunc,\n+          typename AFunc,\n+          typename CReturn,\n+          typename... CArgs,\n+          typename AReturn,\n+          typename... AArgs>\n struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {\n     static_assert(sizeof...(CArgs) == sizeof...(AArgs),\n                   \"pybind11::init(class_factory, alias_factory): class and alias factories \"\n@@ -255,29 +321,37 @@ struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {\n     remove_reference_t<AFunc> alias_factory;\n \n     factory(CFunc &&c, AFunc &&a)\n-        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) { }\n+        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) {}\n \n     // The class factory is called when the `self` type passed to `__init__` is the direct\n     // class (i.e. not inherited), the alias factory when `self` is a Python-side subtype.\n     template <typename Class, typename... Extra>\n-    void execute(Class &cl, const Extra&... extra) && {\n-        static_assert(Class::has_alias, \"The two-argument version of `py::init()` can \"\n-                                        \"only be used if the class has an alias\");\n-        #if defined(PYBIND11_CPP14)\n-        cl.def(\"__init__\", [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]\n-        #else\n+    void execute(Class &cl, const Extra &...extra) && {\n+        static_assert(Class::has_alias,\n+                      \"The two-argument version of `py::init()` can \"\n+                      \"only be used if the class has an alias\");\n+#if defined(PYBIND11_CPP14)\n+        cl.def(\n+            \"__init__\",\n+            [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]\n+#else\n         auto &class_func = class_factory;\n         auto &alias_func = alias_factory;\n-        cl.def(\"__init__\", [class_func, alias_func]\n-        #endif\n-        (value_and_holder &v_h, CArgs... args) {\n-            if (Py_TYPE(v_h.inst) == v_h.type->type)\n-                // If the instance type equals the registered type we don't have inheritance, so\n-                // don't need the alias and can construct using the class function:\n-                construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);\n-            else\n-                construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);\n-        }, is_new_style_constructor(), extra...);\n+        cl.def(\n+            \"__init__\",\n+            [class_func, alias_func]\n+#endif\n+            (value_and_holder &v_h, CArgs... args) {\n+                if (Py_TYPE(v_h.inst) == v_h.type->type) {\n+                    // If the instance type equals the registered type we don't have inheritance,\n+                    // so don't need the alias and can construct using the class function:\n+                    construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);\n+                } else {\n+                    construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);\n+                }\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n     }\n };\n \n@@ -288,20 +362,34 @@ void setstate(value_and_holder &v_h, T &&result, bool need_alias) {\n }\n \n /// Set both the C++ and Python states\n-template <typename Class, typename T, typename O,\n+template <typename Class,\n+          typename T,\n+          typename O,\n           enable_if_t<std::is_convertible<O, handle>::value, int> = 0>\n void setstate(value_and_holder &v_h, std::pair<T, O> &&result, bool need_alias) {\n     construct<Class>(v_h, std::move(result.first), need_alias);\n-    setattr((PyObject *) v_h.inst, \"__dict__\", result.second);\n+    auto d = handle(result.second);\n+    if (PyDict_Check(d.ptr()) && PyDict_Size(d.ptr()) == 0) {\n+        // Skipping setattr below, to not force use of py::dynamic_attr() for Class unnecessarily.\n+        // See PR #2972 for details.\n+        return;\n+    }\n+    setattr((PyObject *) v_h.inst, \"__dict__\", d);\n }\n \n /// Implementation for py::pickle(GetState, SetState)\n-template <typename Get, typename Set,\n-          typename = function_signature_t<Get>, typename = function_signature_t<Set>>\n+template <typename Get,\n+          typename Set,\n+          typename = function_signature_t<Get>,\n+          typename = function_signature_t<Set>>\n struct pickle_factory;\n \n-template <typename Get, typename Set,\n-          typename RetState, typename Self, typename NewInstance, typename ArgState>\n+template <typename Get,\n+          typename Set,\n+          typename RetState,\n+          typename Self,\n+          typename NewInstance,\n+          typename ArgState>\n struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {\n     static_assert(std::is_same<intrinsic_t<RetState>, intrinsic_t<ArgState>>::value,\n                   \"The type returned by `__getstate__` must be the same \"\n@@ -310,26 +398,31 @@ struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {\n     remove_reference_t<Get> get;\n     remove_reference_t<Set> set;\n \n-    pickle_factory(Get get, Set set)\n-        : get(std::forward<Get>(get)), set(std::forward<Set>(set)) { }\n+    pickle_factory(Get get, Set set) : get(std::forward<Get>(get)), set(std::forward<Set>(set)) {}\n \n     template <typename Class, typename... Extra>\n     void execute(Class &cl, const Extra &...extra) && {\n         cl.def(\"__getstate__\", std::move(get));\n \n #if defined(PYBIND11_CPP14)\n-        cl.def(\"__setstate__\", [func = std::move(set)]\n+        cl.def(\n+            \"__setstate__\",\n+            [func = std::move(set)]\n #else\n         auto &func = set;\n-        cl.def(\"__setstate__\", [func]\n+        cl.def(\n+            \"__setstate__\",\n+            [func]\n #endif\n-        (value_and_holder &v_h, ArgState state) {\n-            setstate<Class>(v_h, func(std::forward<ArgState>(state)),\n-                            Py_TYPE(v_h.inst) != v_h.type->type);\n-        }, is_new_style_constructor(), extra...);\n+            (value_and_holder &v_h, ArgState state) {\n+                setstate<Class>(\n+                    v_h, func(std::forward<ArgState>(state)), Py_TYPE(v_h.inst) != v_h.type->type);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n     }\n };\n \n-NAMESPACE_END(initimpl)\n-NAMESPACE_END(detail)\n-NAMESPACE_END(pybind11)\n+PYBIND11_NAMESPACE_END(initimpl)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/internals.h", "status": "modified", "additions": 372, "deletions": 103, "changes": 475, "file_content_changes": "@@ -11,8 +11,32 @@\n \n #include \"../pytypes.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+#include <exception>\n+\n+/// Tracks the `internals` and `type_info` ABI version independent of the main library version.\n+///\n+/// Some portions of the code use an ABI that is conditional depending on this\n+/// version number.  That allows ABI-breaking changes to be \"pre-implemented\".\n+/// Once the default version number is incremented, the conditional logic that\n+/// no longer applies can be removed.  Additionally, users that need not\n+/// maintain ABI compatibility can increase the version number in order to take\n+/// advantage of any functionality/efficiency improvements that depend on the\n+/// newer ABI.\n+///\n+/// WARNING: If you choose to manually increase the ABI version, note that\n+/// pybind11 may not be tested as thoroughly with a non-default ABI version, and\n+/// further ABI-incompatible changes may be made before the ABI is officially\n+/// changed to the new version.\n+#ifndef PYBIND11_INTERNALS_VERSION\n+#    define PYBIND11_INTERNALS_VERSION 4\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+using ExceptionTranslator = void (*)(std::exception_ptr);\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n // Forward declarations\n inline PyTypeObject *make_static_property_type();\n inline PyTypeObject *make_default_metaclass();\n@@ -21,28 +45,59 @@ inline PyObject *make_object_base_type(PyTypeObject *metaclass);\n // The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new\n // Thread Specific Storage (TSS) API.\n #if PY_VERSION_HEX >= 0x03070000\n-#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr\n-#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n-#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))\n-#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n+// Avoid unnecessary allocation of `Py_tss_t`, since we cannot use\n+// `Py_LIMITED_API` anyway.\n+#    if PYBIND11_INTERNALS_VERSION > 4\n+#        define PYBIND11_TLS_KEY_REF Py_tss_t &\n+#        ifdef __GNUC__\n+// Clang on macOS warns due to `Py_tss_NEEDS_INIT` not specifying an initializer\n+// for every field.\n+#            define PYBIND11_TLS_KEY_INIT(var)                                                    \\\n+                _Pragma(\"GCC diagnostic push\")                                         /**/       \\\n+                    _Pragma(\"GCC diagnostic ignored \\\"-Wmissing-field-initializers\\\"\") /**/       \\\n+                    Py_tss_t var                                                                  \\\n+                    = Py_tss_NEEDS_INIT;                                                          \\\n+                _Pragma(\"GCC diagnostic pop\")\n+#        else\n+#            define PYBIND11_TLS_KEY_INIT(var) Py_tss_t var = Py_tss_NEEDS_INIT;\n+#        endif\n+#        define PYBIND11_TLS_KEY_CREATE(var) (PyThread_tss_create(&(var)) == 0)\n+#        define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get(&(key))\n+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set(&(key), (value))\n+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set(&(key), nullptr)\n+#        define PYBIND11_TLS_FREE(key) PyThread_tss_delete(&(key))\n+#    else\n+#        define PYBIND11_TLS_KEY_REF Py_tss_t *\n+#        define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr;\n+#        define PYBIND11_TLS_KEY_CREATE(var)                                                      \\\n+            (((var) = PyThread_tss_alloc()) != nullptr && (PyThread_tss_create((var)) == 0))\n+#        define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))\n+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n+#        define PYBIND11_TLS_FREE(key) PyThread_tss_free(key)\n+#    endif\n #else\n-    // Usually an int but a long on Cygwin64 with Python 3.x\n-#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0\n+// Usually an int but a long on Cygwin64 with Python 3.x\n+#    define PYBIND11_TLS_KEY_REF decltype(PyThread_create_key())\n+#    define PYBIND11_TLS_KEY_INIT(var) PYBIND11_TLS_KEY_REF var = 0;\n+#    define PYBIND11_TLS_KEY_CREATE(var) (((var) = PyThread_create_key()) != -1)\n #    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n-#    if PY_MAJOR_VERSION < 3\n-#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n-             PyThread_delete_key_value(key)\n-#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n-             do {                                                            \\\n-                 PyThread_delete_key_value((key));                           \\\n-                 PyThread_set_key_value((key), (value));                     \\\n-             } while (false)\n+#    if defined(PYPY_VERSION)\n+// On CPython < 3.4 and on PyPy, `PyThread_set_key_value` strangely does not set\n+// the value if it has already been set.  Instead, it must first be deleted and\n+// then set again.\n+inline void tls_replace_value(PYBIND11_TLS_KEY_REF key, void *value) {\n+    PyThread_delete_key_value(key);\n+    PyThread_set_key_value(key, value);\n+}\n+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_delete_key_value(key)\n+#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                                            \\\n+            ::pybind11::detail::tls_replace_value((key), (value))\n #    else\n-#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n-             PyThread_set_key_value((key), nullptr)\n-#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n-             PyThread_set_key_value((key), (value))\n+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_set_key_value((key), nullptr)\n+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_set_key_value((key), (value))\n #    endif\n+#    define PYBIND11_TLS_FREE(key) (void) key\n #endif\n \n // Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly\n@@ -64,8 +119,9 @@ struct type_hash {\n     size_t operator()(const std::type_index &t) const {\n         size_t hash = 5381;\n         const char *ptr = t.name();\n-        while (auto c = static_cast<unsigned char>(*ptr++))\n+        while (auto c = static_cast<unsigned char>(*ptr++)) {\n             hash = (hash * 33) ^ c;\n+        }\n         return hash;\n     }\n };\n@@ -80,10 +136,10 @@ struct type_equal_to {\n template <typename value_type>\n using type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n \n-struct overload_hash {\n-    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {\n+struct override_hash {\n+    inline size_t operator()(const std::pair<const PyObject *, const char *> &v) const {\n         size_t value = std::hash<const void *>()(v.first);\n-        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);\n+        value ^= std::hash<const void *>()(v.second) + 0x9e3779b9 + (value << 6) + (value >> 2);\n         return value;\n     }\n };\n@@ -92,22 +148,46 @@ struct overload_hash {\n /// Whenever binary incompatible changes are made to this structure,\n /// `PYBIND11_INTERNALS_VERSION` must be incremented.\n struct internals {\n-    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information\n-    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)\n-    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*\n-    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;\n+    // std::type_index -> pybind11's type information\n+    type_map<type_info *> registered_types_cpp;\n+    // PyTypeObject* -> base type_info(s)\n+    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py;\n+    std::unordered_multimap<const void *, instance *> registered_instances; // void * -> instance*\n+    std::unordered_set<std::pair<const PyObject *, const char *>, override_hash>\n+        inactive_override_cache;\n     type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n     std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n-    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;\n-    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions\n-    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`\n-    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()\n+    std::forward_list<ExceptionTranslator> registered_exception_translators;\n+    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across\n+                                                         // extensions\n+#if PYBIND11_INTERNALS_VERSION == 4\n+    std::vector<PyObject *> unused_loader_patient_stack_remove_at_v5;\n+#endif\n+    std::forward_list<std::string> static_strings; // Stores the std::strings backing\n+                                                   // detail::c_str()\n     PyTypeObject *static_property_type;\n     PyTypeObject *default_metaclass;\n     PyObject *instance_base;\n #if defined(WITH_THREAD)\n-    PYBIND11_TLS_KEY_INIT(tstate);\n+    PYBIND11_TLS_KEY_INIT(tstate)\n+#    if PYBIND11_INTERNALS_VERSION > 4\n+    PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)\n+#    endif // PYBIND11_INTERNALS_VERSION > 4\n     PyInterpreterState *istate = nullptr;\n+    ~internals() {\n+#    if PYBIND11_INTERNALS_VERSION > 4\n+        PYBIND11_TLS_FREE(loader_life_support_tls_key);\n+#    endif // PYBIND11_INTERNALS_VERSION > 4\n+\n+        // This destructor is called *after* Py_Finalize() in finalize_interpreter().\n+        // That *SHOULD BE* fine. The following details what happens when PyThread_tss_free is\n+        // called. PYBIND11_TLS_FREE is PyThread_tss_free on python 3.7+. On older python, it does\n+        // nothing. PyThread_tss_free calls PyThread_tss_delete and PyMem_RawFree.\n+        // PyThread_tss_delete just calls TlsFree (on Windows) or pthread_key_delete (on *NIX).\n+        // Neither of those have anything to do with CPython internals. PyMem_RawFree *requires*\n+        // that the `tstate` be allocated with the CPython allocator.\n+        PYBIND11_TLS_FREE(tstate);\n+    }\n #endif\n };\n \n@@ -120,14 +200,16 @@ struct type_info {\n     void *(*operator_new)(size_t);\n     void (*init_instance)(instance *, const void *);\n     void (*dealloc)(value_and_holder &v_h);\n-    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;\n-    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;\n+    std::vector<PyObject *(*) (PyObject *, PyTypeObject *)> implicit_conversions;\n+    std::vector<std::pair<const std::type_info *, void *(*) (void *)>> implicit_casts;\n     std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n     buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n     void *get_buffer_data = nullptr;\n     void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n     /* A simple type never occurs as a (direct or indirect) parent\n-     * of a class that makes use of multiple inheritance */\n+     * of a class that makes use of multiple inheritance.\n+     * A type can be simple even if it has non-simple ancestors as long as it has no descendants.\n+     */\n     bool simple_type : 1;\n     /* True if there is no multiple inheritance in this type's inheritance tree */\n     bool simple_ancestors : 1;\n@@ -137,26 +219,73 @@ struct type_info {\n     bool module_local : 1;\n };\n \n-/// Tracks the `internals` and `type_info` ABI version independent of the main library version\n-#define PYBIND11_INTERNALS_VERSION 3\n-\n-#if defined(_DEBUG)\n-#   define PYBIND11_BUILD_TYPE \"_debug\"\n+/// On MSVC, debug and release builds are not ABI-compatible!\n+#if defined(_MSC_VER) && defined(_DEBUG)\n+#    define PYBIND11_BUILD_TYPE \"_debug\"\n #else\n-#   define PYBIND11_BUILD_TYPE \"\"\n+#    define PYBIND11_BUILD_TYPE \"\"\n #endif\n \n-#if defined(WITH_THREAD)\n-#  define PYBIND11_INTERNALS_KIND \"\"\n-#else\n-#  define PYBIND11_INTERNALS_KIND \"_without_thread\"\n+/// Let's assume that different compilers are ABI-incompatible.\n+/// A user can manually set this string if they know their\n+/// compiler is compatible.\n+#ifndef PYBIND11_COMPILER_TYPE\n+#    if defined(_MSC_VER)\n+#        define PYBIND11_COMPILER_TYPE \"_msvc\"\n+#    elif defined(__INTEL_COMPILER)\n+#        define PYBIND11_COMPILER_TYPE \"_icc\"\n+#    elif defined(__clang__)\n+#        define PYBIND11_COMPILER_TYPE \"_clang\"\n+#    elif defined(__PGI)\n+#        define PYBIND11_COMPILER_TYPE \"_pgi\"\n+#    elif defined(__MINGW32__)\n+#        define PYBIND11_COMPILER_TYPE \"_mingw\"\n+#    elif defined(__CYGWIN__)\n+#        define PYBIND11_COMPILER_TYPE \"_gcc_cygwin\"\n+#    elif defined(__GNUC__)\n+#        define PYBIND11_COMPILER_TYPE \"_gcc\"\n+#    else\n+#        define PYBIND11_COMPILER_TYPE \"_unknown\"\n+#    endif\n+#endif\n+\n+/// Also standard libs\n+#ifndef PYBIND11_STDLIB\n+#    if defined(_LIBCPP_VERSION)\n+#        define PYBIND11_STDLIB \"_libcpp\"\n+#    elif defined(__GLIBCXX__) || defined(__GLIBCPP__)\n+#        define PYBIND11_STDLIB \"_libstdcpp\"\n+#    else\n+#        define PYBIND11_STDLIB \"\"\n+#    endif\n+#endif\n+\n+/// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.\n+#ifndef PYBIND11_BUILD_ABI\n+#    if defined(__GXX_ABI_VERSION)\n+#        define PYBIND11_BUILD_ABI \"_cxxabi\" PYBIND11_TOSTRING(__GXX_ABI_VERSION)\n+#    else\n+#        define PYBIND11_BUILD_ABI \"\"\n+#    endif\n+#endif\n+\n+#ifndef PYBIND11_INTERNALS_KIND\n+#    if defined(WITH_THREAD)\n+#        define PYBIND11_INTERNALS_KIND \"\"\n+#    else\n+#        define PYBIND11_INTERNALS_KIND \"_without_thread\"\n+#    endif\n #endif\n \n-#define PYBIND11_INTERNALS_ID \"__pybind11_internals_v\" \\\n-    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n+#define PYBIND11_INTERNALS_ID                                                                     \\\n+    \"__pybind11_internals_v\" PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION)                        \\\n+        PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI         \\\n+            PYBIND11_BUILD_TYPE \"__\"\n \n-#define PYBIND11_MODULE_LOCAL_ID \"__pybind11_module_local_v\" \\\n-    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n+#define PYBIND11_MODULE_LOCAL_ID                                                                  \\\n+    \"__pybind11_module_local_v\" PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION)                     \\\n+        PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI         \\\n+            PYBIND11_BUILD_TYPE \"__\"\n \n /// Each module locally stores a pointer to the `internals` data. The data\n /// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\n@@ -165,13 +294,130 @@ inline internals **&get_internals_pp() {\n     return internals_pp;\n }\n \n+// forward decl\n+inline void translate_exception(std::exception_ptr);\n+\n+template <class T,\n+          enable_if_t<std::is_same<std::nested_exception, remove_cvref_t<T>>::value, int> = 0>\n+bool handle_nested_exception(const T &exc, const std::exception_ptr &p) {\n+    std::exception_ptr nested = exc.nested_ptr();\n+    if (nested != nullptr && nested != p) {\n+        translate_exception(nested);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+template <class T,\n+          enable_if_t<!std::is_same<std::nested_exception, remove_cvref_t<T>>::value, int> = 0>\n+bool handle_nested_exception(const T &exc, const std::exception_ptr &p) {\n+    if (const auto *nep = dynamic_cast<const std::nested_exception *>(std::addressof(exc))) {\n+        return handle_nested_exception(*nep, p);\n+    }\n+    return false;\n+}\n+\n+inline bool raise_err(PyObject *exc_type, const char *msg) {\n+    if (PyErr_Occurred()) {\n+        raise_from(exc_type, msg);\n+        return true;\n+    }\n+    PyErr_SetString(exc_type, msg);\n+    return false;\n+}\n+\n+inline void translate_exception(std::exception_ptr p) {\n+    if (!p) {\n+        return;\n+    }\n+    try {\n+        std::rethrow_exception(p);\n+    } catch (error_already_set &e) {\n+        handle_nested_exception(e, p);\n+        e.restore();\n+        return;\n+    } catch (const builtin_exception &e) {\n+        // Could not use template since it's an abstract class.\n+        if (const auto *nep = dynamic_cast<const std::nested_exception *>(std::addressof(e))) {\n+            handle_nested_exception(*nep, p);\n+        }\n+        e.set_error();\n+        return;\n+    } catch (const std::bad_alloc &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_MemoryError, e.what());\n+        return;\n+    } catch (const std::domain_error &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_ValueError, e.what());\n+        return;\n+    } catch (const std::invalid_argument &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_ValueError, e.what());\n+        return;\n+    } catch (const std::length_error &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_ValueError, e.what());\n+        return;\n+    } catch (const std::out_of_range &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_IndexError, e.what());\n+        return;\n+    } catch (const std::range_error &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_ValueError, e.what());\n+        return;\n+    } catch (const std::overflow_error &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_OverflowError, e.what());\n+        return;\n+    } catch (const std::exception &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_RuntimeError, e.what());\n+        return;\n+    } catch (const std::nested_exception &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_RuntimeError, \"Caught an unknown nested exception!\");\n+        return;\n+    } catch (...) {\n+        raise_err(PyExc_RuntimeError, \"Caught an unknown exception!\");\n+        return;\n+    }\n+}\n+\n+#if !defined(__GLIBCXX__)\n+inline void translate_local_exception(std::exception_ptr p) {\n+    try {\n+        if (p) {\n+            std::rethrow_exception(p);\n+        }\n+    } catch (error_already_set &e) {\n+        e.restore();\n+        return;\n+    } catch (const builtin_exception &e) {\n+        e.set_error();\n+        return;\n+    }\n+}\n+#endif\n+\n /// Return a reference to the current `internals` data\n-PYBIND11_NOINLINE inline internals &get_internals() {\n+PYBIND11_NOINLINE internals &get_internals() {\n     auto **&internals_pp = get_internals_pp();\n-    if (internals_pp && *internals_pp)\n+    if (internals_pp && *internals_pp) {\n         return **internals_pp;\n+    }\n+\n+    // Ensure that the GIL is held since we will need to make Python calls.\n+    // Cannot use py::gil_scoped_acquire here since that constructor calls get_internals.\n+    struct gil_scoped_acquire_local {\n+        gil_scoped_acquire_local() : state(PyGILState_Ensure()) {}\n+        ~gil_scoped_acquire_local() { PyGILState_Release(state); }\n+        const PyGILState_STATE state;\n+    } gil;\n+    error_scope err_scope;\n \n-    constexpr auto *id = PYBIND11_INTERNALS_ID;\n+    PYBIND11_STR_TYPE id(PYBIND11_INTERNALS_ID);\n     auto builtins = handle(PyEval_GetBuiltins());\n     if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n         internals_pp = static_cast<internals **>(capsule(builtins[id]));\n@@ -181,69 +427,92 @@ PYBIND11_NOINLINE inline internals &get_internals() {\n         // initial exception translator, below, so add another for our local exception classes.\n         //\n         // libstdc++ doesn't require this (types there are identified only by name)\n+        // libc++ with CPython doesn't require this (types are explicitly exported)\n+        // libc++ with PyPy still need it, awaiting further investigation\n #if !defined(__GLIBCXX__)\n-        (*internals_pp)->registered_exception_translators.push_front(\n-            [](std::exception_ptr p) -> void {\n-                try {\n-                    if (p) std::rethrow_exception(p);\n-                } catch (error_already_set &e)       { e.restore();   return;\n-                } catch (const builtin_exception &e) { e.set_error(); return;\n-                }\n-            }\n-        );\n+        (*internals_pp)->registered_exception_translators.push_front(&translate_local_exception);\n #endif\n     } else {\n-        if (!internals_pp) internals_pp = new internals*();\n+        if (!internals_pp) {\n+            internals_pp = new internals *();\n+        }\n         auto *&internals_ptr = *internals_pp;\n         internals_ptr = new internals();\n #if defined(WITH_THREAD)\n-        #if PY_VERSION_HEX < 0x03090000\n+\n+#    if PY_VERSION_HEX < 0x03090000\n         PyEval_InitThreads();\n-        #endif\n+#    endif\n         PyThreadState *tstate = PyThreadState_Get();\n-        #if PY_VERSION_HEX >= 0x03070000\n-            internals_ptr->tstate = PyThread_tss_alloc();\n-            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))\n-                pybind11_fail(\"get_internals: could not successfully initialize the TSS key!\");\n-            PyThread_tss_set(internals_ptr->tstate, tstate);\n-        #else\n-            internals_ptr->tstate = PyThread_create_key();\n-            if (internals_ptr->tstate == -1)\n-                pybind11_fail(\"get_internals: could not successfully initialize the TLS key!\");\n-            PyThread_set_key_value(internals_ptr->tstate, tstate);\n-        #endif\n+        if (!PYBIND11_TLS_KEY_CREATE(internals_ptr->tstate)) {\n+            pybind11_fail(\"get_internals: could not successfully initialize the tstate TSS key!\");\n+        }\n+        PYBIND11_TLS_REPLACE_VALUE(internals_ptr->tstate, tstate);\n+\n+#    if PYBIND11_INTERNALS_VERSION > 4\n+        if (!PYBIND11_TLS_KEY_CREATE(internals_ptr->loader_life_support_tls_key)) {\n+            pybind11_fail(\"get_internals: could not successfully initialize the \"\n+                          \"loader_life_support TSS key!\");\n+        }\n+#    endif\n         internals_ptr->istate = tstate->interp;\n #endif\n         builtins[id] = capsule(internals_pp);\n-        internals_ptr->registered_exception_translators.push_front(\n-            [](std::exception_ptr p) -> void {\n-                try {\n-                    if (p) std::rethrow_exception(p);\n-                } catch (error_already_set &e)           { e.restore();                                    return;\n-                } catch (const builtin_exception &e)     { e.set_error();                                  return;\n-                } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;\n-                } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n-                } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n-                } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n-                } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;\n-                } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n-                } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;\n-                } catch (...) {\n-                    PyErr_SetString(PyExc_RuntimeError, \"Caught an unknown exception!\");\n-                    return;\n-                }\n-            }\n-        );\n+        internals_ptr->registered_exception_translators.push_front(&translate_exception);\n         internals_ptr->static_property_type = make_static_property_type();\n         internals_ptr->default_metaclass = make_default_metaclass();\n         internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);\n     }\n     return **internals_pp;\n }\n \n-/// Works like `internals.registered_types_cpp`, but for module-local registered types:\n-inline type_map<type_info *> &registered_local_types_cpp() {\n-    static type_map<type_info *> locals{};\n+// the internals struct (above) is shared between all the modules. local_internals are only\n+// for a single module. Any changes made to internals may require an update to\n+// PYBIND11_INTERNALS_VERSION, breaking backwards compatibility. local_internals is, by design,\n+// restricted to a single module. Whether a module has local internals or not should not\n+// impact any other modules, because the only things accessing the local internals is the\n+// module that contains them.\n+struct local_internals {\n+    type_map<type_info *> registered_types_cpp;\n+    std::forward_list<ExceptionTranslator> registered_exception_translators;\n+#if defined(WITH_THREAD) && PYBIND11_INTERNALS_VERSION == 4\n+\n+    // For ABI compatibility, we can't store the loader_life_support TLS key in\n+    // the `internals` struct directly.  Instead, we store it in `shared_data` and\n+    // cache a copy in `local_internals`.  If we allocated a separate TLS key for\n+    // each instance of `local_internals`, we could end up allocating hundreds of\n+    // TLS keys if hundreds of different pybind11 modules are loaded (which is a\n+    // plausible number).\n+    PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)\n+\n+    // Holds the shared TLS key for the loader_life_support stack.\n+    struct shared_loader_life_support_data {\n+        PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)\n+        shared_loader_life_support_data() {\n+            if (!PYBIND11_TLS_KEY_CREATE(loader_life_support_tls_key)) {\n+                pybind11_fail(\"local_internals: could not successfully initialize the \"\n+                              \"loader_life_support TLS key!\");\n+            }\n+        }\n+        // We can't help but leak the TLS key, because Python never unloads extension modules.\n+    };\n+\n+    local_internals() {\n+        auto &internals = get_internals();\n+        // Get or create the `loader_life_support_stack_key`.\n+        auto &ptr = internals.shared_data[\"_life_support\"];\n+        if (!ptr) {\n+            ptr = new shared_loader_life_support_data;\n+        }\n+        loader_life_support_tls_key\n+            = static_cast<shared_loader_life_support_data *>(ptr)->loader_life_support_tls_key;\n+    }\n+#endif //  defined(WITH_THREAD) && PYBIND11_INTERNALS_VERSION == 4\n+};\n+\n+/// Works like `get_internals`, but for things which are locally registered.\n+inline local_internals &get_local_internals() {\n+    static local_internals locals;\n     return locals;\n }\n \n@@ -258,27 +527,27 @@ const char *c_str(Args &&...args) {\n     return strings.front().c_str();\n }\n \n-NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(detail)\n \n /// Returns a named pointer that is shared among all extension modules (using the same\n /// pybind11 version) running in the current interpreter. Names starting with underscores\n /// are reserved for internal usage. Returns `nullptr` if no matching entry was found.\n-inline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n+PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n     auto &internals = detail::get_internals();\n     auto it = internals.shared_data.find(name);\n     return it != internals.shared_data.end() ? it->second : nullptr;\n }\n \n /// Set the shared data that can be later recovered by `get_shared_data()`.\n-inline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n+PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n     detail::get_internals().shared_data[name] = data;\n     return data;\n }\n \n /// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if\n /// such entry exists. Otherwise, a new object of default-constructible type `T` is\n /// added to the shared data under the given name and a reference to it is returned.\n-template<typename T>\n+template <typename T>\n T &get_or_create_shared_data(const std::string &name) {\n     auto &internals = detail::get_internals();\n     auto it = internals.shared_data.find(name);\n@@ -290,4 +559,4 @@ T &get_or_create_shared_data(const std::string &name) {\n     return *ptr;\n }\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/type_caster_base.h", "status": "added", "additions": 1010, "deletions": 0, "changes": 1010, "file_content_changes": "@@ -0,0 +1,1010 @@\n+/*\n+    pybind11/detail/type_caster_base.h (originally first part of pybind11/cast.h)\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"../pytypes.h\"\n+#include \"common.h\"\n+#include \"descr.h\"\n+#include \"internals.h\"\n+#include \"typeid.h\"\n+\n+#include <cstdint>\n+#include <iterator>\n+#include <new>\n+#include <string>\n+#include <type_traits>\n+#include <typeindex>\n+#include <typeinfo>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/// A life support system for temporary objects created by `type_caster::load()`.\n+/// Adding a patient will keep it alive up until the enclosing function returns.\n+class loader_life_support {\n+private:\n+    loader_life_support *parent = nullptr;\n+    std::unordered_set<PyObject *> keep_alive;\n+\n+#if defined(WITH_THREAD)\n+    // Store stack pointer in thread-local storage.\n+    static PYBIND11_TLS_KEY_REF get_stack_tls_key() {\n+#    if PYBIND11_INTERNALS_VERSION == 4\n+        return get_local_internals().loader_life_support_tls_key;\n+#    else\n+        return get_internals().loader_life_support_tls_key;\n+#    endif\n+    }\n+    static loader_life_support *get_stack_top() {\n+        return static_cast<loader_life_support *>(PYBIND11_TLS_GET_VALUE(get_stack_tls_key()));\n+    }\n+    static void set_stack_top(loader_life_support *value) {\n+        PYBIND11_TLS_REPLACE_VALUE(get_stack_tls_key(), value);\n+    }\n+#else\n+    // Use single global variable for stack.\n+    static loader_life_support **get_stack_pp() {\n+        static loader_life_support *global_stack = nullptr;\n+        return global_stack;\n+    }\n+    static loader_life_support *get_stack_top() { return *get_stack_pp(); }\n+    static void set_stack_top(loader_life_support *value) { *get_stack_pp() = value; }\n+#endif\n+\n+public:\n+    /// A new patient frame is created when a function is entered\n+    loader_life_support() : parent{get_stack_top()} { set_stack_top(this); }\n+\n+    /// ... and destroyed after it returns\n+    ~loader_life_support() {\n+        if (get_stack_top() != this) {\n+            pybind11_fail(\"loader_life_support: internal error\");\n+        }\n+        set_stack_top(parent);\n+        for (auto *item : keep_alive) {\n+            Py_DECREF(item);\n+        }\n+    }\n+\n+    /// This can only be used inside a pybind11-bound function, either by `argument_loader`\n+    /// at argument preparation time or by `py::cast()` at execution time.\n+    PYBIND11_NOINLINE static void add_patient(handle h) {\n+        loader_life_support *frame = get_stack_top();\n+        if (!frame) {\n+            // NOTE: It would be nice to include the stack frames here, as this indicates\n+            // use of pybind11::cast<> outside the normal call framework, finding such\n+            // a location is challenging. Developers could consider printing out\n+            // stack frame addresses here using something like __builtin_frame_address(0)\n+            throw cast_error(\"When called outside a bound function, py::cast() cannot \"\n+                             \"do Python -> C++ conversions which require the creation \"\n+                             \"of temporary values\");\n+        }\n+\n+        if (frame->keep_alive.insert(h.ptr()).second) {\n+            Py_INCREF(h.ptr());\n+        }\n+    }\n+};\n+\n+// Gets the cache entry for the given type, creating it if necessary.  The return value is the pair\n+// returned by emplace, i.e. an iterator for the entry and a bool set to `true` if the entry was\n+// just created.\n+inline std::pair<decltype(internals::registered_types_py)::iterator, bool>\n+all_type_info_get_cache(PyTypeObject *type);\n+\n+// Populates a just-created cache entry.\n+PYBIND11_NOINLINE void all_type_info_populate(PyTypeObject *t, std::vector<type_info *> &bases) {\n+    std::vector<PyTypeObject *> check;\n+    for (handle parent : reinterpret_borrow<tuple>(t->tp_bases)) {\n+        check.push_back((PyTypeObject *) parent.ptr());\n+    }\n+\n+    auto const &type_dict = get_internals().registered_types_py;\n+    for (size_t i = 0; i < check.size(); i++) {\n+        auto *type = check[i];\n+        // Ignore Python2 old-style class super type:\n+        if (!PyType_Check((PyObject *) type)) {\n+            continue;\n+        }\n+\n+        // Check `type` in the current set of registered python types:\n+        auto it = type_dict.find(type);\n+        if (it != type_dict.end()) {\n+            // We found a cache entry for it, so it's either pybind-registered or has pre-computed\n+            // pybind bases, but we have to make sure we haven't already seen the type(s) before:\n+            // we want to follow Python/virtual C++ rules that there should only be one instance of\n+            // a common base.\n+            for (auto *tinfo : it->second) {\n+                // NB: Could use a second set here, rather than doing a linear search, but since\n+                // having a large number of immediate pybind11-registered types seems fairly\n+                // unlikely, that probably isn't worthwhile.\n+                bool found = false;\n+                for (auto *known : bases) {\n+                    if (known == tinfo) {\n+                        found = true;\n+                        break;\n+                    }\n+                }\n+                if (!found) {\n+                    bases.push_back(tinfo);\n+                }\n+            }\n+        } else if (type->tp_bases) {\n+            // It's some python type, so keep follow its bases classes to look for one or more\n+            // registered types\n+            if (i + 1 == check.size()) {\n+                // When we're at the end, we can pop off the current element to avoid growing\n+                // `check` when adding just one base (which is typical--i.e. when there is no\n+                // multiple inheritance)\n+                check.pop_back();\n+                i--;\n+            }\n+            for (handle parent : reinterpret_borrow<tuple>(type->tp_bases)) {\n+                check.push_back((PyTypeObject *) parent.ptr());\n+            }\n+        }\n+    }\n+}\n+\n+/**\n+ * Extracts vector of type_info pointers of pybind-registered roots of the given Python type.  Will\n+ * be just 1 pybind type for the Python type of a pybind-registered class, or for any Python-side\n+ * derived class that uses single inheritance.  Will contain as many types as required for a Python\n+ * class that uses multiple inheritance to inherit (directly or indirectly) from multiple\n+ * pybind-registered classes.  Will be empty if neither the type nor any base classes are\n+ * pybind-registered.\n+ *\n+ * The value is cached for the lifetime of the Python type.\n+ */\n+inline const std::vector<detail::type_info *> &all_type_info(PyTypeObject *type) {\n+    auto ins = all_type_info_get_cache(type);\n+    if (ins.second) {\n+        // New cache entry: populate it\n+        all_type_info_populate(type, ins.first->second);\n+    }\n+\n+    return ins.first->second;\n+}\n+\n+/**\n+ * Gets a single pybind11 type info for a python type.  Returns nullptr if neither the type nor any\n+ * ancestors are pybind11-registered.  Throws an exception if there are multiple bases--use\n+ * `all_type_info` instead if you want to support multiple bases.\n+ */\n+PYBIND11_NOINLINE detail::type_info *get_type_info(PyTypeObject *type) {\n+    const auto &bases = all_type_info(type);\n+    if (bases.empty()) {\n+        return nullptr;\n+    }\n+    if (bases.size() > 1) {\n+        pybind11_fail(\n+            \"pybind11::detail::get_type_info: type has multiple pybind11-registered bases\");\n+    }\n+    return bases.front();\n+}\n+\n+inline detail::type_info *get_local_type_info(const std::type_index &tp) {\n+    auto &locals = get_local_internals().registered_types_cpp;\n+    auto it = locals.find(tp);\n+    if (it != locals.end()) {\n+        return it->second;\n+    }\n+    return nullptr;\n+}\n+\n+inline detail::type_info *get_global_type_info(const std::type_index &tp) {\n+    auto &types = get_internals().registered_types_cpp;\n+    auto it = types.find(tp);\n+    if (it != types.end()) {\n+        return it->second;\n+    }\n+    return nullptr;\n+}\n+\n+/// Return the type info for a given C++ type; on lookup failure can either throw or return\n+/// nullptr.\n+PYBIND11_NOINLINE detail::type_info *get_type_info(const std::type_index &tp,\n+                                                   bool throw_if_missing = false) {\n+    if (auto *ltype = get_local_type_info(tp)) {\n+        return ltype;\n+    }\n+    if (auto *gtype = get_global_type_info(tp)) {\n+        return gtype;\n+    }\n+\n+    if (throw_if_missing) {\n+        std::string tname = tp.name();\n+        detail::clean_type_id(tname);\n+        pybind11_fail(\"pybind11::detail::get_type_info: unable to find type info for \\\"\"\n+                      + std::move(tname) + '\"');\n+    }\n+    return nullptr;\n+}\n+\n+PYBIND11_NOINLINE handle get_type_handle(const std::type_info &tp, bool throw_if_missing) {\n+    detail::type_info *type_info = get_type_info(tp, throw_if_missing);\n+    return handle(type_info ? ((PyObject *) type_info->type) : nullptr);\n+}\n+\n+// Searches the inheritance graph for a registered Python instance, using all_type_info().\n+PYBIND11_NOINLINE handle find_registered_python_instance(void *src,\n+                                                         const detail::type_info *tinfo) {\n+    auto it_instances = get_internals().registered_instances.equal_range(src);\n+    for (auto it_i = it_instances.first; it_i != it_instances.second; ++it_i) {\n+        for (auto *instance_type : detail::all_type_info(Py_TYPE(it_i->second))) {\n+            if (instance_type && same_type(*instance_type->cpptype, *tinfo->cpptype)) {\n+                return handle((PyObject *) it_i->second).inc_ref();\n+            }\n+        }\n+    }\n+    return handle();\n+}\n+\n+struct value_and_holder {\n+    instance *inst = nullptr;\n+    size_t index = 0u;\n+    const detail::type_info *type = nullptr;\n+    void **vh = nullptr;\n+\n+    // Main constructor for a found value/holder:\n+    value_and_holder(instance *i, const detail::type_info *type, size_t vpos, size_t index)\n+        : inst{i}, index{index}, type{type}, vh{inst->simple_layout\n+                                                    ? inst->simple_value_holder\n+                                                    : &inst->nonsimple.values_and_holders[vpos]} {}\n+\n+    // Default constructor (used to signal a value-and-holder not found by get_value_and_holder())\n+    value_and_holder() = default;\n+\n+    // Used for past-the-end iterator\n+    explicit value_and_holder(size_t index) : index{index} {}\n+\n+    template <typename V = void>\n+    V *&value_ptr() const {\n+        return reinterpret_cast<V *&>(vh[0]);\n+    }\n+    // True if this `value_and_holder` has a non-null value pointer\n+    explicit operator bool() const { return value_ptr() != nullptr; }\n+\n+    template <typename H>\n+    H &holder() const {\n+        return reinterpret_cast<H &>(vh[1]);\n+    }\n+    bool holder_constructed() const {\n+        return inst->simple_layout\n+                   ? inst->simple_holder_constructed\n+                   : (inst->nonsimple.status[index] & instance::status_holder_constructed) != 0u;\n+    }\n+    // NOLINTNEXTLINE(readability-make-member-function-const)\n+    void set_holder_constructed(bool v = true) {\n+        if (inst->simple_layout) {\n+            inst->simple_holder_constructed = v;\n+        } else if (v) {\n+            inst->nonsimple.status[index] |= instance::status_holder_constructed;\n+        } else {\n+            inst->nonsimple.status[index] &= (std::uint8_t) ~instance::status_holder_constructed;\n+        }\n+    }\n+    bool instance_registered() const {\n+        return inst->simple_layout\n+                   ? inst->simple_instance_registered\n+                   : ((inst->nonsimple.status[index] & instance::status_instance_registered) != 0);\n+    }\n+    // NOLINTNEXTLINE(readability-make-member-function-const)\n+    void set_instance_registered(bool v = true) {\n+        if (inst->simple_layout) {\n+            inst->simple_instance_registered = v;\n+        } else if (v) {\n+            inst->nonsimple.status[index] |= instance::status_instance_registered;\n+        } else {\n+            inst->nonsimple.status[index] &= (std::uint8_t) ~instance::status_instance_registered;\n+        }\n+    }\n+};\n+\n+// Container for accessing and iterating over an instance's values/holders\n+struct values_and_holders {\n+private:\n+    instance *inst;\n+    using type_vec = std::vector<detail::type_info *>;\n+    const type_vec &tinfo;\n+\n+public:\n+    explicit values_and_holders(instance *inst)\n+        : inst{inst}, tinfo(all_type_info(Py_TYPE(inst))) {}\n+\n+    struct iterator {\n+    private:\n+        instance *inst = nullptr;\n+        const type_vec *types = nullptr;\n+        value_and_holder curr;\n+        friend struct values_and_holders;\n+        iterator(instance *inst, const type_vec *tinfo)\n+            : inst{inst}, types{tinfo},\n+              curr(inst /* instance */,\n+                   types->empty() ? nullptr : (*types)[0] /* type info */,\n+                   0, /* vpos: (non-simple types only): the first vptr comes first */\n+                   0 /* index */) {}\n+        // Past-the-end iterator:\n+        explicit iterator(size_t end) : curr(end) {}\n+\n+    public:\n+        bool operator==(const iterator &other) const { return curr.index == other.curr.index; }\n+        bool operator!=(const iterator &other) const { return curr.index != other.curr.index; }\n+        iterator &operator++() {\n+            if (!inst->simple_layout) {\n+                curr.vh += 1 + (*types)[curr.index]->holder_size_in_ptrs;\n+            }\n+            ++curr.index;\n+            curr.type = curr.index < types->size() ? (*types)[curr.index] : nullptr;\n+            return *this;\n+        }\n+        value_and_holder &operator*() { return curr; }\n+        value_and_holder *operator->() { return &curr; }\n+    };\n+\n+    iterator begin() { return iterator(inst, &tinfo); }\n+    iterator end() { return iterator(tinfo.size()); }\n+\n+    iterator find(const type_info *find_type) {\n+        auto it = begin(), endit = end();\n+        while (it != endit && it->type != find_type) {\n+            ++it;\n+        }\n+        return it;\n+    }\n+\n+    size_t size() { return tinfo.size(); }\n+};\n+\n+/**\n+ * Extracts C++ value and holder pointer references from an instance (which may contain multiple\n+ * values/holders for python-side multiple inheritance) that match the given type.  Throws an error\n+ * if the given type (or ValueType, if omitted) is not a pybind11 base of the given instance.  If\n+ * `find_type` is omitted (or explicitly specified as nullptr) the first value/holder are returned,\n+ * regardless of type (and the resulting .type will be nullptr).\n+ *\n+ * The returned object should be short-lived: in particular, it must not outlive the called-upon\n+ * instance.\n+ */\n+PYBIND11_NOINLINE value_and_holder\n+instance::get_value_and_holder(const type_info *find_type /*= nullptr default in common.h*/,\n+                               bool throw_if_missing /*= true in common.h*/) {\n+    // Optimize common case:\n+    if (!find_type || Py_TYPE(this) == find_type->type) {\n+        return value_and_holder(this, find_type, 0, 0);\n+    }\n+\n+    detail::values_and_holders vhs(this);\n+    auto it = vhs.find(find_type);\n+    if (it != vhs.end()) {\n+        return *it;\n+    }\n+\n+    if (!throw_if_missing) {\n+        return value_and_holder();\n+    }\n+\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+    pybind11_fail(\"pybind11::detail::instance::get_value_and_holder: `\"\n+                  + get_fully_qualified_tp_name(find_type->type)\n+                  + \"' is not a pybind11 base of the given `\"\n+                  + get_fully_qualified_tp_name(Py_TYPE(this)) + \"' instance\");\n+#else\n+    pybind11_fail(\n+        \"pybind11::detail::instance::get_value_and_holder: \"\n+        \"type is not a pybind11 base of the given instance \"\n+        \"(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for type details)\");\n+#endif\n+}\n+\n+PYBIND11_NOINLINE void instance::allocate_layout() {\n+    const auto &tinfo = all_type_info(Py_TYPE(this));\n+\n+    const size_t n_types = tinfo.size();\n+\n+    if (n_types == 0) {\n+        pybind11_fail(\n+            \"instance allocation failed: new instance has no pybind11-registered base types\");\n+    }\n+\n+    simple_layout\n+        = n_types == 1 && tinfo.front()->holder_size_in_ptrs <= instance_simple_holder_in_ptrs();\n+\n+    // Simple path: no python-side multiple inheritance, and a small-enough holder\n+    if (simple_layout) {\n+        simple_value_holder[0] = nullptr;\n+        simple_holder_constructed = false;\n+        simple_instance_registered = false;\n+    } else { // multiple base types or a too-large holder\n+        // Allocate space to hold: [v1*][h1][v2*][h2]...[bb...] where [vN*] is a value pointer,\n+        // [hN] is the (uninitialized) holder instance for value N, and [bb...] is a set of bool\n+        // values that tracks whether each associated holder has been initialized.  Each [block] is\n+        // padded, if necessary, to an integer multiple of sizeof(void *).\n+        size_t space = 0;\n+        for (auto *t : tinfo) {\n+            space += 1;                      // value pointer\n+            space += t->holder_size_in_ptrs; // holder instance\n+        }\n+        size_t flags_at = space;\n+        space += size_in_ptrs(n_types); // status bytes (holder_constructed and\n+                                        // instance_registered)\n+\n+        // Allocate space for flags, values, and holders, and initialize it to 0 (flags and values,\n+        // in particular, need to be 0).  Use Python's memory allocation\n+        // functions: Python is using pymalloc, which is designed to be\n+        // efficient for small allocations like the one we're doing here;\n+        // for larger allocations they are just wrappers around malloc.\n+        // TODO: is this still true for pure Python 3.6?\n+        nonsimple.values_and_holders = (void **) PyMem_Calloc(space, sizeof(void *));\n+        if (!nonsimple.values_and_holders) {\n+            throw std::bad_alloc();\n+        }\n+        nonsimple.status\n+            = reinterpret_cast<std::uint8_t *>(&nonsimple.values_and_holders[flags_at]);\n+    }\n+    owned = true;\n+}\n+\n+// NOLINTNEXTLINE(readability-make-member-function-const)\n+PYBIND11_NOINLINE void instance::deallocate_layout() {\n+    if (!simple_layout) {\n+        PyMem_Free(nonsimple.values_and_holders);\n+    }\n+}\n+\n+PYBIND11_NOINLINE bool isinstance_generic(handle obj, const std::type_info &tp) {\n+    handle type = detail::get_type_handle(tp, false);\n+    if (!type) {\n+        return false;\n+    }\n+    return isinstance(obj, type);\n+}\n+\n+PYBIND11_NOINLINE handle get_object_handle(const void *ptr, const detail::type_info *type) {\n+    auto &instances = get_internals().registered_instances;\n+    auto range = instances.equal_range(ptr);\n+    for (auto it = range.first; it != range.second; ++it) {\n+        for (const auto &vh : values_and_holders(it->second)) {\n+            if (vh.type == type) {\n+                return handle((PyObject *) it->second);\n+            }\n+        }\n+    }\n+    return handle();\n+}\n+\n+inline PyThreadState *get_thread_state_unchecked() {\n+#if defined(PYPY_VERSION)\n+    return PyThreadState_GET();\n+#else\n+    return _PyThreadState_UncheckedGet();\n+#endif\n+}\n+\n+// Forward declarations\n+void keep_alive_impl(handle nurse, handle patient);\n+inline PyObject *make_new_instance(PyTypeObject *type);\n+\n+class type_caster_generic {\n+public:\n+    PYBIND11_NOINLINE explicit type_caster_generic(const std::type_info &type_info)\n+        : typeinfo(get_type_info(type_info)), cpptype(&type_info) {}\n+\n+    explicit type_caster_generic(const type_info *typeinfo)\n+        : typeinfo(typeinfo), cpptype(typeinfo ? typeinfo->cpptype : nullptr) {}\n+\n+    bool load(handle src, bool convert) { return load_impl<type_caster_generic>(src, convert); }\n+\n+    PYBIND11_NOINLINE static handle cast(const void *_src,\n+                                         return_value_policy policy,\n+                                         handle parent,\n+                                         const detail::type_info *tinfo,\n+                                         void *(*copy_constructor)(const void *),\n+                                         void *(*move_constructor)(const void *),\n+                                         const void *existing_holder = nullptr) {\n+        if (!tinfo) { // no type info: error will be set already\n+            return handle();\n+        }\n+\n+        void *src = const_cast<void *>(_src);\n+        if (src == nullptr) {\n+            return none().release();\n+        }\n+\n+        if (handle registered_inst = find_registered_python_instance(src, tinfo)) {\n+            return registered_inst;\n+        }\n+\n+        auto inst = reinterpret_steal<object>(make_new_instance(tinfo->type));\n+        auto *wrapper = reinterpret_cast<instance *>(inst.ptr());\n+        wrapper->owned = false;\n+        void *&valueptr = values_and_holders(wrapper).begin()->value_ptr();\n+\n+        switch (policy) {\n+            case return_value_policy::automatic:\n+            case return_value_policy::take_ownership:\n+                valueptr = src;\n+                wrapper->owned = true;\n+                break;\n+\n+            case return_value_policy::automatic_reference:\n+            case return_value_policy::reference:\n+                valueptr = src;\n+                wrapper->owned = false;\n+                break;\n+\n+            case return_value_policy::copy:\n+                if (copy_constructor) {\n+                    valueptr = copy_constructor(src);\n+                } else {\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+                    std::string type_name(tinfo->cpptype->name());\n+                    detail::clean_type_id(type_name);\n+                    throw cast_error(\"return_value_policy = copy, but type \" + type_name\n+                                     + \" is non-copyable!\");\n+#else\n+                    throw cast_error(\"return_value_policy = copy, but type is \"\n+                                     \"non-copyable! (#define PYBIND11_DETAILED_ERROR_MESSAGES or \"\n+                                     \"compile in debug mode for details)\");\n+#endif\n+                }\n+                wrapper->owned = true;\n+                break;\n+\n+            case return_value_policy::move:\n+                if (move_constructor) {\n+                    valueptr = move_constructor(src);\n+                } else if (copy_constructor) {\n+                    valueptr = copy_constructor(src);\n+                } else {\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+                    std::string type_name(tinfo->cpptype->name());\n+                    detail::clean_type_id(type_name);\n+                    throw cast_error(\"return_value_policy = move, but type \" + type_name\n+                                     + \" is neither movable nor copyable!\");\n+#else\n+                    throw cast_error(\"return_value_policy = move, but type is neither \"\n+                                     \"movable nor copyable! \"\n+                                     \"(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in \"\n+                                     \"debug mode for details)\");\n+#endif\n+                }\n+                wrapper->owned = true;\n+                break;\n+\n+            case return_value_policy::reference_internal:\n+                valueptr = src;\n+                wrapper->owned = false;\n+                keep_alive_impl(inst, parent);\n+                break;\n+\n+            default:\n+                throw cast_error(\"unhandled return_value_policy: should not happen!\");\n+        }\n+\n+        tinfo->init_instance(wrapper, existing_holder);\n+\n+        return inst.release();\n+    }\n+\n+    // Base methods for generic caster; there are overridden in copyable_holder_caster\n+    void load_value(value_and_holder &&v_h) {\n+        auto *&vptr = v_h.value_ptr();\n+        // Lazy allocation for unallocated values:\n+        if (vptr == nullptr) {\n+            const auto *type = v_h.type ? v_h.type : typeinfo;\n+            if (type->operator_new) {\n+                vptr = type->operator_new(type->type_size);\n+            } else {\n+#if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)\n+                if (type->type_align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {\n+                    vptr = ::operator new(type->type_size, std::align_val_t(type->type_align));\n+                } else {\n+                    vptr = ::operator new(type->type_size);\n+                }\n+#else\n+                vptr = ::operator new(type->type_size);\n+#endif\n+            }\n+        }\n+        value = vptr;\n+    }\n+    bool try_implicit_casts(handle src, bool convert) {\n+        for (const auto &cast : typeinfo->implicit_casts) {\n+            type_caster_generic sub_caster(*cast.first);\n+            if (sub_caster.load(src, convert)) {\n+                value = cast.second(sub_caster.value);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    bool try_direct_conversions(handle src) {\n+        for (auto &converter : *typeinfo->direct_conversions) {\n+            if (converter(src.ptr(), value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    void check_holder_compat() {}\n+\n+    PYBIND11_NOINLINE static void *local_load(PyObject *src, const type_info *ti) {\n+        auto caster = type_caster_generic(ti);\n+        if (caster.load(src, false)) {\n+            return caster.value;\n+        }\n+        return nullptr;\n+    }\n+\n+    /// Try to load with foreign typeinfo, if available. Used when there is no\n+    /// native typeinfo, or when the native one wasn't able to produce a value.\n+    PYBIND11_NOINLINE bool try_load_foreign_module_local(handle src) {\n+        constexpr auto *local_key = PYBIND11_MODULE_LOCAL_ID;\n+        const auto pytype = type::handle_of(src);\n+        if (!hasattr(pytype, local_key)) {\n+            return false;\n+        }\n+\n+        type_info *foreign_typeinfo = reinterpret_borrow<capsule>(getattr(pytype, local_key));\n+        // Only consider this foreign loader if actually foreign and is a loader of the correct cpp\n+        // type\n+        if (foreign_typeinfo->module_local_load == &local_load\n+            || (cpptype && !same_type(*cpptype, *foreign_typeinfo->cpptype))) {\n+            return false;\n+        }\n+\n+        if (auto *result = foreign_typeinfo->module_local_load(src.ptr(), foreign_typeinfo)) {\n+            value = result;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    // Implementation of `load`; this takes the type of `this` so that it can dispatch the relevant\n+    // bits of code between here and copyable_holder_caster where the two classes need different\n+    // logic (without having to resort to virtual inheritance).\n+    template <typename ThisT>\n+    PYBIND11_NOINLINE bool load_impl(handle src, bool convert) {\n+        if (!src) {\n+            return false;\n+        }\n+        if (!typeinfo) {\n+            return try_load_foreign_module_local(src);\n+        }\n+\n+        auto &this_ = static_cast<ThisT &>(*this);\n+        this_.check_holder_compat();\n+\n+        PyTypeObject *srctype = Py_TYPE(src.ptr());\n+\n+        // Case 1: If src is an exact type match for the target type then we can reinterpret_cast\n+        // the instance's value pointer to the target type:\n+        if (srctype == typeinfo->type) {\n+            this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());\n+            return true;\n+        }\n+        // Case 2: We have a derived class\n+        if (PyType_IsSubtype(srctype, typeinfo->type)) {\n+            const auto &bases = all_type_info(srctype);\n+            bool no_cpp_mi = typeinfo->simple_type;\n+\n+            // Case 2a: the python type is a Python-inherited derived class that inherits from just\n+            // one simple (no MI) pybind11 class, or is an exact match, so the C++ instance is of\n+            // the right type and we can use reinterpret_cast.\n+            // (This is essentially the same as case 2b, but because not using multiple inheritance\n+            // is extremely common, we handle it specially to avoid the loop iterator and type\n+            // pointer lookup overhead)\n+            if (bases.size() == 1 && (no_cpp_mi || bases.front()->type == typeinfo->type)) {\n+                this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());\n+                return true;\n+            }\n+            // Case 2b: the python type inherits from multiple C++ bases.  Check the bases to see\n+            // if we can find an exact match (or, for a simple C++ type, an inherited match); if\n+            // so, we can safely reinterpret_cast to the relevant pointer.\n+            if (bases.size() > 1) {\n+                for (auto *base : bases) {\n+                    if (no_cpp_mi ? PyType_IsSubtype(base->type, typeinfo->type)\n+                                  : base->type == typeinfo->type) {\n+                        this_.load_value(\n+                            reinterpret_cast<instance *>(src.ptr())->get_value_and_holder(base));\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            // Case 2c: C++ multiple inheritance is involved and we couldn't find an exact type\n+            // match in the registered bases, above, so try implicit casting (needed for proper C++\n+            // casting when MI is involved).\n+            if (this_.try_implicit_casts(src, convert)) {\n+                return true;\n+            }\n+        }\n+\n+        // Perform an implicit conversion\n+        if (convert) {\n+            for (const auto &converter : typeinfo->implicit_conversions) {\n+                auto temp = reinterpret_steal<object>(converter(src.ptr(), typeinfo->type));\n+                if (load_impl<ThisT>(temp, false)) {\n+                    loader_life_support::add_patient(temp);\n+                    return true;\n+                }\n+            }\n+            if (this_.try_direct_conversions(src)) {\n+                return true;\n+            }\n+        }\n+\n+        // Failed to match local typeinfo. Try again with global.\n+        if (typeinfo->module_local) {\n+            if (auto *gtype = get_global_type_info(*typeinfo->cpptype)) {\n+                typeinfo = gtype;\n+                return load(src, false);\n+            }\n+        }\n+\n+        // Global typeinfo has precedence over foreign module_local\n+        if (try_load_foreign_module_local(src)) {\n+            return true;\n+        }\n+\n+        // Custom converters didn't take None, now we convert None to nullptr.\n+        if (src.is_none()) {\n+            // Defer accepting None to other overloads (if we aren't in convert mode):\n+            if (!convert) {\n+                return false;\n+            }\n+            value = nullptr;\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    // Called to do type lookup and wrap the pointer and type in a pair when a dynamic_cast\n+    // isn't needed or can't be used.  If the type is unknown, sets the error and returns a pair\n+    // with .second = nullptr.  (p.first = nullptr is not an error: it becomes None).\n+    PYBIND11_NOINLINE static std::pair<const void *, const type_info *>\n+    src_and_type(const void *src,\n+                 const std::type_info &cast_type,\n+                 const std::type_info *rtti_type = nullptr) {\n+        if (auto *tpi = get_type_info(cast_type)) {\n+            return {src, const_cast<const type_info *>(tpi)};\n+        }\n+\n+        // Not found, set error:\n+        std::string tname = rtti_type ? rtti_type->name() : cast_type.name();\n+        detail::clean_type_id(tname);\n+        std::string msg = \"Unregistered type : \" + tname;\n+        PyErr_SetString(PyExc_TypeError, msg.c_str());\n+        return {nullptr, nullptr};\n+    }\n+\n+    const type_info *typeinfo = nullptr;\n+    const std::type_info *cpptype = nullptr;\n+    void *value = nullptr;\n+};\n+\n+/**\n+ * Determine suitable casting operator for pointer-or-lvalue-casting type casters.  The type caster\n+ * needs to provide `operator T*()` and `operator T&()` operators.\n+ *\n+ * If the type supports moving the value away via an `operator T&&() &&` method, it should use\n+ * `movable_cast_op_type` instead.\n+ */\n+template <typename T>\n+using cast_op_type = conditional_t<std::is_pointer<remove_reference_t<T>>::value,\n+                                   typename std::add_pointer<intrinsic_t<T>>::type,\n+                                   typename std::add_lvalue_reference<intrinsic_t<T>>::type>;\n+\n+/**\n+ * Determine suitable casting operator for a type caster with a movable value.  Such a type caster\n+ * needs to provide `operator T*()`, `operator T&()`, and `operator T&&() &&`.  The latter will be\n+ * called in appropriate contexts where the value can be moved rather than copied.\n+ *\n+ * These operator are automatically provided when using the PYBIND11_TYPE_CASTER macro.\n+ */\n+template <typename T>\n+using movable_cast_op_type\n+    = conditional_t<std::is_pointer<typename std::remove_reference<T>::type>::value,\n+                    typename std::add_pointer<intrinsic_t<T>>::type,\n+                    conditional_t<std::is_rvalue_reference<T>::value,\n+                                  typename std::add_rvalue_reference<intrinsic_t<T>>::type,\n+                                  typename std::add_lvalue_reference<intrinsic_t<T>>::type>>;\n+\n+// std::is_copy_constructible isn't quite enough: it lets std::vector<T> (and similar) through when\n+// T is non-copyable, but code containing such a copy constructor fails to actually compile.\n+template <typename T, typename SFINAE = void>\n+struct is_copy_constructible : std::is_copy_constructible<T> {};\n+\n+// Specialization for types that appear to be copy constructible but also look like stl containers\n+// (we specifically check for: has `value_type` and `reference` with `reference = value_type&`): if\n+// so, copy constructability depends on whether the value_type is copy constructible.\n+template <typename Container>\n+struct is_copy_constructible<\n+    Container,\n+    enable_if_t<\n+        all_of<std::is_copy_constructible<Container>,\n+               std::is_same<typename Container::value_type &, typename Container::reference>,\n+               // Avoid infinite recursion\n+               negation<std::is_same<Container, typename Container::value_type>>>::value>>\n+    : is_copy_constructible<typename Container::value_type> {};\n+\n+// Likewise for std::pair\n+// (after C++17 it is mandatory that the copy constructor not exist when the two types aren't\n+// themselves copy constructible, but this can not be relied upon when T1 or T2 are themselves\n+// containers).\n+template <typename T1, typename T2>\n+struct is_copy_constructible<std::pair<T1, T2>>\n+    : all_of<is_copy_constructible<T1>, is_copy_constructible<T2>> {};\n+\n+// The same problems arise with std::is_copy_assignable, so we use the same workaround.\n+template <typename T, typename SFINAE = void>\n+struct is_copy_assignable : std::is_copy_assignable<T> {};\n+template <typename Container>\n+struct is_copy_assignable<Container,\n+                          enable_if_t<all_of<std::is_copy_assignable<Container>,\n+                                             std::is_same<typename Container::value_type &,\n+                                                          typename Container::reference>>::value>>\n+    : is_copy_assignable<typename Container::value_type> {};\n+template <typename T1, typename T2>\n+struct is_copy_assignable<std::pair<T1, T2>>\n+    : all_of<is_copy_assignable<T1>, is_copy_assignable<T2>> {};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+// polymorphic_type_hook<itype>::get(src, tinfo) determines whether the object pointed\n+// to by `src` actually is an instance of some class derived from `itype`.\n+// If so, it sets `tinfo` to point to the std::type_info representing that derived\n+// type, and returns a pointer to the start of the most-derived object of that type\n+// (in which `src` is a subobject; this will be the same address as `src` in most\n+// single inheritance cases). If not, or if `src` is nullptr, it simply returns `src`\n+// and leaves `tinfo` at its default value of nullptr.\n+//\n+// The default polymorphic_type_hook just returns src. A specialization for polymorphic\n+// types determines the runtime type of the passed object and adjusts the this-pointer\n+// appropriately via dynamic_cast<void*>. This is what enables a C++ Animal* to appear\n+// to Python as a Dog (if Dog inherits from Animal, Animal is polymorphic, Dog is\n+// registered with pybind11, and this Animal is in fact a Dog).\n+//\n+// You may specialize polymorphic_type_hook yourself for types that want to appear\n+// polymorphic to Python but do not use C++ RTTI. (This is a not uncommon pattern\n+// in performance-sensitive applications, used most notably in LLVM.)\n+//\n+// polymorphic_type_hook_base allows users to specialize polymorphic_type_hook with\n+// std::enable_if. User provided specializations will always have higher priority than\n+// the default implementation and specialization provided in polymorphic_type_hook_base.\n+template <typename itype, typename SFINAE = void>\n+struct polymorphic_type_hook_base {\n+    static const void *get(const itype *src, const std::type_info *&) { return src; }\n+};\n+template <typename itype>\n+struct polymorphic_type_hook_base<itype, detail::enable_if_t<std::is_polymorphic<itype>::value>> {\n+    static const void *get(const itype *src, const std::type_info *&type) {\n+        type = src ? &typeid(*src) : nullptr;\n+        return dynamic_cast<const void *>(src);\n+    }\n+};\n+template <typename itype, typename SFINAE = void>\n+struct polymorphic_type_hook : public polymorphic_type_hook_base<itype> {};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/// Generic type caster for objects stored on the heap\n+template <typename type>\n+class type_caster_base : public type_caster_generic {\n+    using itype = intrinsic_t<type>;\n+\n+public:\n+    static constexpr auto name = const_name<type>();\n+\n+    type_caster_base() : type_caster_base(typeid(type)) {}\n+    explicit type_caster_base(const std::type_info &info) : type_caster_generic(info) {}\n+\n+    static handle cast(const itype &src, return_value_policy policy, handle parent) {\n+        if (policy == return_value_policy::automatic\n+            || policy == return_value_policy::automatic_reference) {\n+            policy = return_value_policy::copy;\n+        }\n+        return cast(&src, policy, parent);\n+    }\n+\n+    static handle cast(itype &&src, return_value_policy, handle parent) {\n+        return cast(&src, return_value_policy::move, parent);\n+    }\n+\n+    // Returns a (pointer, type_info) pair taking care of necessary type lookup for a\n+    // polymorphic type (using RTTI by default, but can be overridden by specializing\n+    // polymorphic_type_hook). If the instance isn't derived, returns the base version.\n+    static std::pair<const void *, const type_info *> src_and_type(const itype *src) {\n+        const auto &cast_type = typeid(itype);\n+        const std::type_info *instance_type = nullptr;\n+        const void *vsrc = polymorphic_type_hook<itype>::get(src, instance_type);\n+        if (instance_type && !same_type(cast_type, *instance_type)) {\n+            // This is a base pointer to a derived type. If the derived type is registered\n+            // with pybind11, we want to make the full derived object available.\n+            // In the typical case where itype is polymorphic, we get the correct\n+            // derived pointer (which may be != base pointer) by a dynamic_cast to\n+            // most derived type. If itype is not polymorphic, we won't get here\n+            // except via a user-provided specialization of polymorphic_type_hook,\n+            // and the user has promised that no this-pointer adjustment is\n+            // required in that case, so it's OK to use static_cast.\n+            if (const auto *tpi = get_type_info(*instance_type)) {\n+                return {vsrc, tpi};\n+            }\n+        }\n+        // Otherwise we have either a nullptr, an `itype` pointer, or an unknown derived pointer,\n+        // so don't do a cast\n+        return type_caster_generic::src_and_type(src, cast_type, instance_type);\n+    }\n+\n+    static handle cast(const itype *src, return_value_policy policy, handle parent) {\n+        auto st = src_and_type(src);\n+        return type_caster_generic::cast(st.first,\n+                                         policy,\n+                                         parent,\n+                                         st.second,\n+                                         make_copy_constructor(src),\n+                                         make_move_constructor(src));\n+    }\n+\n+    static handle cast_holder(const itype *src, const void *holder) {\n+        auto st = src_and_type(src);\n+        return type_caster_generic::cast(st.first,\n+                                         return_value_policy::take_ownership,\n+                                         {},\n+                                         st.second,\n+                                         nullptr,\n+                                         nullptr,\n+                                         holder);\n+    }\n+\n+    template <typename T>\n+    using cast_op_type = detail::cast_op_type<T>;\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator itype *() { return (type *) value; }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator itype &() {\n+        if (!value) {\n+            throw reference_cast_error();\n+        }\n+        return *((itype *) value);\n+    }\n+\n+protected:\n+    using Constructor = void *(*) (const void *);\n+\n+    /* Only enabled when the types are {copy,move}-constructible *and* when the type\n+       does not have a private operator new implementation. A comma operator is used in the\n+       decltype argument to apply SFINAE to the public copy/move constructors.*/\n+    template <typename T, typename = enable_if_t<is_copy_constructible<T>::value>>\n+    static auto make_copy_constructor(const T *)\n+        -> decltype(new T(std::declval<const T>()), Constructor{}) {\n+        return [](const void *arg) -> void * { return new T(*reinterpret_cast<const T *>(arg)); };\n+    }\n+\n+    template <typename T, typename = enable_if_t<std::is_move_constructible<T>::value>>\n+    static auto make_move_constructor(const T *)\n+        -> decltype(new T(std::declval<T &&>()), Constructor{}) {\n+        return [](const void *arg) -> void * {\n+            return new T(std::move(*const_cast<T *>(reinterpret_cast<const T *>(arg))));\n+        };\n+    }\n+\n+    static Constructor make_copy_constructor(...) { return nullptr; }\n+    static Constructor make_move_constructor(...) { return nullptr; }\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/typeid.h", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "file_content_changes": "@@ -13,43 +13,53 @@\n #include <cstdlib>\n \n #if defined(__GNUG__)\n-#include <cxxabi.h>\n+#    include <cxxabi.h>\n #endif\n \n #include \"common.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n /// Erase all occurrences of a substring\n inline void erase_all(std::string &string, const std::string &search) {\n     for (size_t pos = 0;;) {\n         pos = string.find(search, pos);\n-        if (pos == std::string::npos) break;\n+        if (pos == std::string::npos) {\n+            break;\n+        }\n         string.erase(pos, search.length());\n     }\n }\n \n-PYBIND11_NOINLINE inline void clean_type_id(std::string &name) {\n+PYBIND11_NOINLINE void clean_type_id(std::string &name) {\n #if defined(__GNUG__)\n     int status = 0;\n-    std::unique_ptr<char, void (*)(void *)> res {\n-        abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free };\n-    if (status == 0)\n+    std::unique_ptr<char, void (*)(void *)> res{\n+        abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free};\n+    if (status == 0) {\n         name = res.get();\n+    }\n #else\n     detail::erase_all(name, \"class \");\n     detail::erase_all(name, \"struct \");\n     detail::erase_all(name, \"enum \");\n #endif\n     detail::erase_all(name, \"pybind11::\");\n }\n-NAMESPACE_END(detail)\n \n-/// Return a string representation of a C++ type\n-template <typename T> static std::string type_id() {\n-    std::string name(typeid(T).name());\n+inline std::string clean_type_id(const char *typeid_name) {\n+    std::string name(typeid_name);\n     detail::clean_type_id(name);\n     return name;\n }\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+\n+/// Return a string representation of a C++ type\n+template <typename T>\n+static std::string type_id() {\n+    return detail::clean_type_id(typeid(T).name());\n+}\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/eigen.h", "status": "modified", "additions": 331, "deletions": 230, "changes": 561, "file_content_changes": "@@ -9,218 +9,261 @@\n \n #pragma once\n \n-#include \"numpy.h\"\n+/* HINT: To suppress warnings originating from the Eigen headers, use -isystem.\n+   See also:\n+       https://stackoverflow.com/questions/2579576/i-dir-vs-isystem-dir\n+       https://stackoverflow.com/questions/1741816/isystem-for-ms-visual-studio-c-compiler\n+*/\n \n-#if defined(__INTEL_COMPILER)\n-#  pragma warning(disable: 1682) // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)\n-#elif defined(__GNUG__) || defined(__clang__)\n-#  pragma GCC diagnostic push\n-#  pragma GCC diagnostic ignored \"-Wconversion\"\n-#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n-#  ifdef __clang__\n-//   Eigen generates a bunch of implicit-copy-constructor-is-deprecated warnings with -Wdeprecated\n-//   under Clang, so disable that warning here:\n-#    pragma GCC diagnostic ignored \"-Wdeprecated\"\n-#  endif\n-#  if __GNUC__ >= 7\n-#    pragma GCC diagnostic ignored \"-Wint-in-bool-context\"\n-#  endif\n-#endif\n+#include \"numpy.h\"\n \n+// The C4127 suppression was introduced for Eigen 3.4.0. In theory we could\n+// make it version specific, or even remove it later, but considering that\n+// 1. C4127 is generally far more distracting than useful for modern template code, and\n+// 2. we definitely want to ignore any MSVC warnings originating from Eigen code,\n+//    it is probably best to keep this around indefinitely.\n #if defined(_MSC_VER)\n-#  pragma warning(push)\n-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant\n-#  pragma warning(disable: 4996) // warning C4996: std::unary_negate is deprecated in C++17\n+#    pragma warning(push)\n+#    pragma warning(disable : 4127) // C4127: conditional expression is constant\n+#    pragma warning(disable : 5054) // https://github.com/pybind/pybind11/pull/3741\n+//       C5054: operator '&': deprecated between enumerations of different types\n #endif\n \n #include <Eigen/Core>\n #include <Eigen/SparseCore>\n \n+#if defined(_MSC_VER)\n+#    pragma warning(pop)\n+#endif\n+\n // Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit\n // move constructors that break things.  We could detect this an explicitly copy, but an extra copy\n // of matrices seems highly undesirable.\n-static_assert(EIGEN_VERSION_AT_LEAST(3,2,7), \"Eigen support in pybind11 requires Eigen >= 3.2.7\");\n+static_assert(EIGEN_VERSION_AT_LEAST(3, 2, 7),\n+              \"Eigen support in pybind11 requires Eigen >= 3.2.7\");\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n \n // Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:\n using EigenDStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;\n-template <typename MatrixType> using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;\n-template <typename MatrixType> using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;\n+template <typename MatrixType>\n+using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;\n+template <typename MatrixType>\n+using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n-#if EIGEN_VERSION_AT_LEAST(3,3,0)\n+#if EIGEN_VERSION_AT_LEAST(3, 3, 0)\n using EigenIndex = Eigen::Index;\n+template <typename Scalar, int Flags, typename StorageIndex>\n+using EigenMapSparseMatrix = Eigen::Map<Eigen::SparseMatrix<Scalar, Flags, StorageIndex>>;\n #else\n using EigenIndex = EIGEN_DEFAULT_DENSE_INDEX_TYPE;\n+template <typename Scalar, int Flags, typename StorageIndex>\n+using EigenMapSparseMatrix = Eigen::MappedSparseMatrix<Scalar, Flags, StorageIndex>;\n #endif\n \n // Matches Eigen::Map, Eigen::Ref, blocks, etc:\n-template <typename T> using is_eigen_dense_map = all_of<is_template_base_of<Eigen::DenseBase, T>, std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;\n-template <typename T> using is_eigen_mutable_map = std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;\n-template <typename T> using is_eigen_dense_plain = all_of<negation<is_eigen_dense_map<T>>, is_template_base_of<Eigen::PlainObjectBase, T>>;\n-template <typename T> using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;\n+template <typename T>\n+using is_eigen_dense_map = all_of<is_template_base_of<Eigen::DenseBase, T>,\n+                                  std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;\n+template <typename T>\n+using is_eigen_mutable_map = std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;\n+template <typename T>\n+using is_eigen_dense_plain\n+    = all_of<negation<is_eigen_dense_map<T>>, is_template_base_of<Eigen::PlainObjectBase, T>>;\n+template <typename T>\n+using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;\n // Test for objects inheriting from EigenBase<Derived> that aren't captured by the above.  This\n // basically covers anything that can be assigned to a dense matrix but that don't have a typical\n // matrix data layout that can be copied from their .data().  For example, DiagonalMatrix and\n // SelfAdjointView fall into this category.\n-template <typename T> using is_eigen_other = all_of<\n-    is_template_base_of<Eigen::EigenBase, T>,\n-    negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>, is_eigen_sparse<T>>>\n->;\n+template <typename T>\n+using is_eigen_other\n+    = all_of<is_template_base_of<Eigen::EigenBase, T>,\n+             negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>, is_eigen_sparse<T>>>>;\n \n // Captures numpy/eigen conformability status (returned by EigenProps::conformable()):\n-template <bool EigenRowMajor> struct EigenConformable {\n+template <bool EigenRowMajor>\n+struct EigenConformable {\n     bool conformable = false;\n     EigenIndex rows = 0, cols = 0;\n-    EigenDStride stride{0, 0};      // Only valid if negativestrides is false!\n-    bool negativestrides = false;   // If true, do not use stride!\n+    EigenDStride stride{0, 0};    // Only valid if negativestrides is false!\n+    bool negativestrides = false; // If true, do not use stride!\n \n+    // NOLINTNEXTLINE(google-explicit-constructor)\n     EigenConformable(bool fits = false) : conformable{fits} {}\n     // Matrix type:\n-    EigenConformable(EigenIndex r, EigenIndex c,\n-            EigenIndex rstride, EigenIndex cstride) :\n-        conformable{true}, rows{r}, cols{c} {\n-        // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity. http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747\n-        if (rstride < 0 || cstride < 0) {\n-            negativestrides = true;\n-        } else {\n-            stride = {EigenRowMajor ? rstride : cstride /* outer stride */,\n-                      EigenRowMajor ? cstride : rstride /* inner stride */ };\n-        }\n-    }\n+    EigenConformable(EigenIndex r, EigenIndex c, EigenIndex rstride, EigenIndex cstride)\n+        : conformable{true}, rows{r}, cols{c},\n+          // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity.\n+          // http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747\n+          stride{EigenRowMajor ? (rstride > 0 ? rstride : 0)\n+                               : (cstride > 0 ? cstride : 0) /* outer stride */,\n+                 EigenRowMajor ? (cstride > 0 ? cstride : 0)\n+                               : (rstride > 0 ? rstride : 0) /* inner stride */},\n+          negativestrides{rstride < 0 || cstride < 0} {}\n     // Vector type:\n     EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)\n-        : EigenConformable(r, c, r == 1 ? c*stride : stride, c == 1 ? r : r*stride) {}\n+        : EigenConformable(r, c, r == 1 ? c * stride : stride, c == 1 ? r : r * stride) {}\n \n-    template <typename props> bool stride_compatible() const {\n+    template <typename props>\n+    bool stride_compatible() const {\n         // To have compatible strides, we need (on both dimensions) one of fully dynamic strides,\n-        // matching strides, or a dimension size of 1 (in which case the stride value is irrelevant)\n-        return\n-            !negativestrides &&\n-            (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner() ||\n-                (EigenRowMajor ? cols : rows) == 1) &&\n-            (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer() ||\n-                (EigenRowMajor ? rows : cols) == 1);\n+        // matching strides, or a dimension size of 1 (in which case the stride value is\n+        // irrelevant). Alternatively, if any dimension size is 0, the strides are not relevant\n+        // (and numpy \u2265 1.23 sets the strides to 0 in that case, so we need to check explicitly).\n+        if (negativestrides) {\n+            return false;\n+        }\n+        if (rows == 0 || cols == 0) {\n+            return true;\n+        }\n+        return (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner()\n+                || (EigenRowMajor ? cols : rows) == 1)\n+               && (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer()\n+                   || (EigenRowMajor ? rows : cols) == 1);\n     }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n     operator bool() const { return conformable; }\n };\n \n-template <typename Type> struct eigen_extract_stride { using type = Type; };\n+template <typename Type>\n+struct eigen_extract_stride {\n+    using type = Type;\n+};\n template <typename PlainObjectType, int MapOptions, typename StrideType>\n-struct eigen_extract_stride<Eigen::Map<PlainObjectType, MapOptions, StrideType>> { using type = StrideType; };\n+struct eigen_extract_stride<Eigen::Map<PlainObjectType, MapOptions, StrideType>> {\n+    using type = StrideType;\n+};\n template <typename PlainObjectType, int Options, typename StrideType>\n-struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> { using type = StrideType; };\n+struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> {\n+    using type = StrideType;\n+};\n \n // Helper struct for extracting information from an Eigen type\n-template <typename Type_> struct EigenProps {\n+template <typename Type_>\n+struct EigenProps {\n     using Type = Type_;\n     using Scalar = typename Type::Scalar;\n     using StrideType = typename eigen_extract_stride<Type>::type;\n-    static constexpr EigenIndex\n-        rows = Type::RowsAtCompileTime,\n-        cols = Type::ColsAtCompileTime,\n-        size = Type::SizeAtCompileTime;\n-    static constexpr bool\n-        row_major = Type::IsRowMajor,\n-        vector = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1\n-        fixed_rows = rows != Eigen::Dynamic,\n-        fixed_cols = cols != Eigen::Dynamic,\n-        fixed = size != Eigen::Dynamic, // Fully-fixed size\n-        dynamic = !fixed_rows && !fixed_cols; // Fully-dynamic size\n-\n-    template <EigenIndex i, EigenIndex ifzero> using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;\n-    static constexpr EigenIndex inner_stride = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,\n-                                outer_stride = if_zero<StrideType::OuterStrideAtCompileTime,\n-                                                       vector ? size : row_major ? cols : rows>::value;\n-    static constexpr bool dynamic_stride = inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;\n-    static constexpr bool requires_row_major = !dynamic_stride && !vector && (row_major ? inner_stride : outer_stride) == 1;\n-    static constexpr bool requires_col_major = !dynamic_stride && !vector && (row_major ? outer_stride : inner_stride) == 1;\n+    static constexpr EigenIndex rows = Type::RowsAtCompileTime, cols = Type::ColsAtCompileTime,\n+                                size = Type::SizeAtCompileTime;\n+    static constexpr bool row_major = Type::IsRowMajor,\n+                          vector\n+                          = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1\n+        fixed_rows = rows != Eigen::Dynamic, fixed_cols = cols != Eigen::Dynamic,\n+                          fixed = size != Eigen::Dynamic, // Fully-fixed size\n+        dynamic = !fixed_rows && !fixed_cols;             // Fully-dynamic size\n+\n+    template <EigenIndex i, EigenIndex ifzero>\n+    using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;\n+    static constexpr EigenIndex inner_stride\n+        = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,\n+        outer_stride = if_zero < StrideType::OuterStrideAtCompileTime,\n+        vector      ? size\n+        : row_major ? cols\n+                    : rows > ::value;\n+    static constexpr bool dynamic_stride\n+        = inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;\n+    static constexpr bool requires_row_major\n+        = !dynamic_stride && !vector && (row_major ? inner_stride : outer_stride) == 1;\n+    static constexpr bool requires_col_major\n+        = !dynamic_stride && !vector && (row_major ? outer_stride : inner_stride) == 1;\n \n     // Takes an input array and determines whether we can make it fit into the Eigen type.  If\n     // the array is a vector, we attempt to fit it into either an Eigen 1xN or Nx1 vector\n     // (preferring the latter if it will fit in either, i.e. for a fully dynamic matrix type).\n     static EigenConformable<row_major> conformable(const array &a) {\n         const auto dims = a.ndim();\n-        if (dims < 1 || dims > 2)\n+        if (dims < 1 || dims > 2) {\n             return false;\n+        }\n \n         if (dims == 2) { // Matrix type: require exact match (or dynamic)\n \n-            EigenIndex\n-                np_rows = a.shape(0),\n-                np_cols = a.shape(1),\n-                np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),\n-                np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));\n-            if ((fixed_rows && np_rows != rows) || (fixed_cols && np_cols != cols))\n+            EigenIndex np_rows = a.shape(0), np_cols = a.shape(1),\n+                       np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),\n+                       np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));\n+            if ((PYBIND11_SILENCE_MSVC_C4127(fixed_rows) && np_rows != rows)\n+                || (PYBIND11_SILENCE_MSVC_C4127(fixed_cols) && np_cols != cols)) {\n                 return false;\n+            }\n \n             return {np_rows, np_cols, np_rstride, np_cstride};\n         }\n \n-        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but whichever\n-        // is used, we want the (single) numpy stride value.\n+        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but\n+        // whichever is used, we want the (single) numpy stride value.\n         const EigenIndex n = a.shape(0),\n-              stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));\n+                         stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));\n \n         if (vector) { // Eigen type is a compile-time vector\n-            if (fixed && size != n)\n+            if (PYBIND11_SILENCE_MSVC_C4127(fixed) && size != n) {\n                 return false; // Vector size mismatch\n+            }\n             return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};\n         }\n-        else if (fixed) {\n+        if (fixed) {\n             // The type has a fixed size, but is not a vector: abort\n             return false;\n         }\n-        else if (fixed_cols) {\n+        if (fixed_cols) {\n             // Since this isn't a vector, cols must be != 1.  We allow this only if it exactly\n             // equals the number of elements (rows is Dynamic, and so 1 row is allowed).\n-            if (cols != n) return false;\n+            if (cols != n) {\n+                return false;\n+            }\n             return {1, n, stride};\n+        } // Otherwise it's either fully dynamic, or column dynamic; both become a column vector\n+        if (PYBIND11_SILENCE_MSVC_C4127(fixed_rows) && rows != n) {\n+            return false;\n         }\n-        else {\n-            // Otherwise it's either fully dynamic, or column dynamic; both become a column vector\n-            if (fixed_rows && rows != n) return false;\n-            return {n, 1, stride};\n-        }\n+        return {n, 1, stride};\n     }\n \n-    static constexpr bool show_writeable = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;\n+    static constexpr bool show_writeable\n+        = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;\n     static constexpr bool show_order = is_eigen_dense_map<Type>::value;\n     static constexpr bool show_c_contiguous = show_order && requires_row_major;\n-    static constexpr bool show_f_contiguous = !show_c_contiguous && show_order && requires_col_major;\n-\n-    static constexpr auto descriptor =\n-        _(\"numpy.ndarray[\") + npy_format_descriptor<Scalar>::name +\n-        _(\"[\")  + _<fixed_rows>(_<(size_t) rows>(), _(\"m\")) +\n-        _(\", \") + _<fixed_cols>(_<(size_t) cols>(), _(\"n\")) +\n-        _(\"]\") +\n-        // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to be\n-        // satisfied: writeable=True (for a mutable reference), and, depending on the map's stride\n-        // options, possibly f_contiguous or c_contiguous.  We include them in the descriptor output\n-        // to provide some hint as to why a TypeError is occurring (otherwise it can be confusing to\n-        // see that a function accepts a 'numpy.ndarray[float64[3,2]]' and an error message that you\n-        // *gave* a numpy.ndarray of the right type and dimensions.\n-        _<show_writeable>(\", flags.writeable\", \"\") +\n-        _<show_c_contiguous>(\", flags.c_contiguous\", \"\") +\n-        _<show_f_contiguous>(\", flags.f_contiguous\", \"\") +\n-        _(\"]\");\n+    static constexpr bool show_f_contiguous\n+        = !show_c_contiguous && show_order && requires_col_major;\n+\n+    static constexpr auto descriptor\n+        = const_name(\"numpy.ndarray[\") + npy_format_descriptor<Scalar>::name + const_name(\"[\")\n+          + const_name<fixed_rows>(const_name<(size_t) rows>(), const_name(\"m\")) + const_name(\", \")\n+          + const_name<fixed_cols>(const_name<(size_t) cols>(), const_name(\"n\")) + const_name(\"]\")\n+          +\n+          // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to\n+          // be satisfied: writeable=True (for a mutable reference), and, depending on the map's\n+          // stride options, possibly f_contiguous or c_contiguous.  We include them in the\n+          // descriptor output to provide some hint as to why a TypeError is occurring (otherwise\n+          // it can be confusing to see that a function accepts a 'numpy.ndarray[float64[3,2]]' and\n+          // an error message that you *gave* a numpy.ndarray of the right type and dimensions.\n+          const_name<show_writeable>(\", flags.writeable\", \"\")\n+          + const_name<show_c_contiguous>(\", flags.c_contiguous\", \"\")\n+          + const_name<show_f_contiguous>(\", flags.f_contiguous\", \"\") + const_name(\"]\");\n };\n \n // Casts an Eigen type to numpy array.  If given a base, the numpy array references the src data,\n // otherwise it'll make a copy.  writeable lets you turn off the writeable flag for the array.\n-template <typename props> handle eigen_array_cast(typename props::Type const &src, handle base = handle(), bool writeable = true) {\n+template <typename props>\n+handle\n+eigen_array_cast(typename props::Type const &src, handle base = handle(), bool writeable = true) {\n     constexpr ssize_t elem_size = sizeof(typename props::Scalar);\n     array a;\n-    if (props::vector)\n-        a = array({ src.size() }, { elem_size * src.innerStride() }, src.data(), base);\n-    else\n-        a = array({ src.rows(), src.cols() }, { elem_size * src.rowStride(), elem_size * src.colStride() },\n-                  src.data(), base);\n+    if (props::vector) {\n+        a = array({src.size()}, {elem_size * src.innerStride()}, src.data(), base);\n+    } else {\n+        a = array({src.rows(), src.cols()},\n+                  {elem_size * src.rowStride(), elem_size * src.colStride()},\n+                  src.data(),\n+                  base);\n+    }\n \n-    if (!writeable)\n+    if (!writeable) {\n         array_proxy(a.ptr())->flags &= ~detail::npy_api::NPY_ARRAY_WRITEABLE_;\n+    }\n \n     return a.release();\n }\n@@ -236,10 +279,10 @@ handle eigen_ref_array(Type &src, handle parent = none()) {\n     return eigen_array_cast<props>(src, parent, !std::is_const<Type>::value);\n }\n \n-// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a numpy\n-// array that references the encapsulated data with a python-side reference to the capsule to tie\n-// its destruction to that of any dependent python objects.  Const-ness is determined by whether or\n-// not the Type of the pointer given is const.\n+// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a\n+// numpy array that references the encapsulated data with a python-side reference to the capsule to\n+// tie its destruction to that of any dependent python objects.  Const-ness is determined by\n+// whether or not the Type of the pointer given is const.\n template <typename props, typename Type, typename = enable_if_t<is_eigen_dense_plain<Type>::value>>\n handle eigen_encapsulate(Type *src) {\n     capsule base(src, [](void *o) { delete static_cast<Type *>(o); });\n@@ -248,35 +291,42 @@ handle eigen_encapsulate(Type *src) {\n \n // Type caster for regular, dense matrix types (e.g. MatrixXd), but not maps/refs/etc. of dense\n // types.\n-template<typename Type>\n+template <typename Type>\n struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {\n     using Scalar = typename Type::Scalar;\n     using props = EigenProps<Type>;\n \n     bool load(handle src, bool convert) {\n         // If we're in no-convert mode, only load if given an array of the correct type\n-        if (!convert && !isinstance<array_t<Scalar>>(src))\n+        if (!convert && !isinstance<array_t<Scalar>>(src)) {\n             return false;\n+        }\n \n         // Coerce into an array, but don't do type conversion yet; the copy below handles it.\n         auto buf = array::ensure(src);\n \n-        if (!buf)\n+        if (!buf) {\n             return false;\n+        }\n \n         auto dims = buf.ndim();\n-        if (dims < 1 || dims > 2)\n+        if (dims < 1 || dims > 2) {\n             return false;\n+        }\n \n         auto fits = props::conformable(buf);\n-        if (!fits)\n+        if (!fits) {\n             return false;\n+        }\n \n         // Allocate the new type, then build a numpy reference into it\n         value = Type(fits.rows, fits.cols);\n         auto ref = reinterpret_steal<array>(eigen_ref_array<props>(value));\n-        if (dims == 1) ref = ref.squeeze();\n-        else if (ref.ndim() == 1) buf = buf.squeeze();\n+        if (dims == 1) {\n+            ref = ref.squeeze();\n+        } else if (ref.ndim() == 1) {\n+            buf = buf.squeeze();\n+        }\n \n         int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());\n \n@@ -289,7 +339,6 @@ struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {\n     }\n \n private:\n-\n     // Cast implementation\n     template <typename CType>\n     static handle cast_impl(CType *src, return_value_policy policy, handle parent) {\n@@ -312,7 +361,6 @@ struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {\n     }\n \n public:\n-\n     // Normal returned non-reference, non-const value:\n     static handle cast(Type &&src, return_value_policy /* policy */, handle parent) {\n         return cast_impl(&src, return_value_policy::move, parent);\n@@ -323,14 +371,18 @@ struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {\n     }\n     // lvalue reference return; default (automatic) becomes copy\n     static handle cast(Type &src, return_value_policy policy, handle parent) {\n-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)\n+        if (policy == return_value_policy::automatic\n+            || policy == return_value_policy::automatic_reference) {\n             policy = return_value_policy::copy;\n+        }\n         return cast_impl(&src, policy, parent);\n     }\n     // const lvalue reference return; default (automatic) becomes copy\n     static handle cast(const Type &src, return_value_policy policy, handle parent) {\n-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)\n+        if (policy == return_value_policy::automatic\n+            || policy == return_value_policy::automatic_reference) {\n             policy = return_value_policy::copy;\n+        }\n         return cast(&src, policy, parent);\n     }\n     // non-const pointer return\n@@ -344,28 +396,32 @@ struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {\n \n     static constexpr auto name = props::descriptor;\n \n-    operator Type*() { return &value; }\n-    operator Type&() { return value; }\n-    operator Type&&() && { return std::move(value); }\n-    template <typename T> using cast_op_type = movable_cast_op_type<T>;\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type *() { return &value; }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type &() { return value; }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type &&() && { return std::move(value); }\n+    template <typename T>\n+    using cast_op_type = movable_cast_op_type<T>;\n \n private:\n     Type value;\n };\n \n // Base class for casting reference/map/block/etc. objects back to python.\n-template <typename MapType> struct eigen_map_caster {\n+template <typename MapType>\n+struct eigen_map_caster {\n private:\n     using props = EigenProps<MapType>;\n \n public:\n-\n     // Directly referencing a ref/map's data is a bit dangerous (whatever the map/ref points to has\n-    // to stay around), but we'll allow it under the assumption that you know what you're doing (and\n-    // have an appropriate keep_alive in place).  We return a numpy array pointing directly at the\n-    // ref's data (The numpy array ends up read-only if the ref was to a const matrix type.) Note\n-    // that this means you need to ensure you don't destroy the object in some other way (e.g. with\n-    // an appropriate keep_alive, or with a reference to a statically allocated matrix).\n+    // to stay around), but we'll allow it under the assumption that you know what you're doing\n+    // (and have an appropriate keep_alive in place).  We return a numpy array pointing directly at\n+    // the ref's data (The numpy array ends up read-only if the ref was to a const matrix type.)\n+    // Note that this means you need to ensure you don't destroy the object in some other way (e.g.\n+    // with an appropriate keep_alive, or with a reference to a statically allocated matrix).\n     static handle cast(const MapType &src, return_value_policy policy, handle parent) {\n         switch (policy) {\n             case return_value_policy::copy:\n@@ -389,60 +445,69 @@ template <typename MapType> struct eigen_map_caster {\n     // you end up here if you try anyway.\n     bool load(handle, bool) = delete;\n     operator MapType() = delete;\n-    template <typename> using cast_op_type = MapType;\n+    template <typename>\n+    using cast_op_type = MapType;\n };\n \n // We can return any map-like object (but can only load Refs, specialized next):\n-template <typename Type> struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>>\n-    : eigen_map_caster<Type> {};\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>> : eigen_map_caster<Type> {};\n \n // Loader for Ref<...> arguments.  See the documentation for info on how to make this work without\n // copying (it requires some extra effort in many cases).\n template <typename PlainObjectType, typename StrideType>\n struct type_caster<\n     Eigen::Ref<PlainObjectType, 0, StrideType>,\n-    enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>\n-> : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {\n+    enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>>\n+    : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {\n private:\n     using Type = Eigen::Ref<PlainObjectType, 0, StrideType>;\n     using props = EigenProps<Type>;\n     using Scalar = typename props::Scalar;\n     using MapType = Eigen::Map<PlainObjectType, 0, StrideType>;\n-    using Array = array_t<Scalar, array::forcecast |\n-                ((props::row_major ? props::inner_stride : props::outer_stride) == 1 ? array::c_style :\n-                 (props::row_major ? props::outer_stride : props::inner_stride) == 1 ? array::f_style : 0)>;\n+    using Array\n+        = array_t<Scalar,\n+                  array::forcecast\n+                      | ((props::row_major ? props::inner_stride : props::outer_stride) == 1\n+                             ? array::c_style\n+                         : (props::row_major ? props::outer_stride : props::inner_stride) == 1\n+                             ? array::f_style\n+                             : 0)>;\n     static constexpr bool need_writeable = is_eigen_mutable_map<Type>::value;\n     // Delay construction (these have no default constructor)\n     std::unique_ptr<MapType> map;\n     std::unique_ptr<Type> ref;\n     // Our array.  When possible, this is just a numpy array pointing to the source data, but\n-    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an incompatible\n-    // layout, or is an array of a type that needs to be converted).  Using a numpy temporary\n-    // (rather than an Eigen temporary) saves an extra copy when we need both type conversion and\n-    // storage order conversion.  (Note that we refuse to use this temporary copy when loading an\n-    // argument for a Ref<M> with M non-const, i.e. a read-write reference).\n+    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an\n+    // incompatible layout, or is an array of a type that needs to be converted).  Using a numpy\n+    // temporary (rather than an Eigen temporary) saves an extra copy when we need both type\n+    // conversion and storage order conversion.  (Note that we refuse to use this temporary copy\n+    // when loading an argument for a Ref<M> with M non-const, i.e. a read-write reference).\n     Array copy_or_ref;\n+\n public:\n     bool load(handle src, bool convert) {\n-        // First check whether what we have is already an array of the right type.  If not, we can't\n-        // avoid a copy (because the copy is also going to do type conversion).\n+        // First check whether what we have is already an array of the right type.  If not, we\n+        // can't avoid a copy (because the copy is also going to do type conversion).\n         bool need_copy = !isinstance<Array>(src);\n \n         EigenConformable<props::row_major> fits;\n         if (!need_copy) {\n             // We don't need a converting copy, but we also need to check whether the strides are\n             // compatible with the Ref's stride requirements\n-            Array aref = reinterpret_borrow<Array>(src);\n+            auto aref = reinterpret_borrow<Array>(src);\n \n             if (aref && (!need_writeable || aref.writeable())) {\n                 fits = props::conformable(aref);\n-                if (!fits) return false; // Incompatible dimensions\n-                if (!fits.template stride_compatible<props>())\n+                if (!fits) {\n+                    return false; // Incompatible dimensions\n+                }\n+                if (!fits.template stride_compatible<props>()) {\n                     need_copy = true;\n-                else\n+                } else {\n                     copy_or_ref = std::move(aref);\n-            }\n-            else {\n+                }\n+            } else {\n                 need_copy = true;\n             }\n         }\n@@ -451,64 +516,93 @@ struct type_caster<\n             // We need to copy: If we need a mutable reference, or we're not supposed to convert\n             // (either because we're in the no-convert overload pass, or because we're explicitly\n             // instructed not to copy (via `py::arg().noconvert()`) we have to fail loading.\n-            if (!convert || need_writeable) return false;\n+            if (!convert || need_writeable) {\n+                return false;\n+            }\n \n             Array copy = Array::ensure(src);\n-            if (!copy) return false;\n+            if (!copy) {\n+                return false;\n+            }\n             fits = props::conformable(copy);\n-            if (!fits || !fits.template stride_compatible<props>())\n+            if (!fits || !fits.template stride_compatible<props>()) {\n                 return false;\n+            }\n             copy_or_ref = std::move(copy);\n             loader_life_support::add_patient(copy_or_ref);\n         }\n \n         ref.reset();\n-        map.reset(new MapType(data(copy_or_ref), fits.rows, fits.cols, make_stride(fits.stride.outer(), fits.stride.inner())));\n+        map.reset(new MapType(data(copy_or_ref),\n+                              fits.rows,\n+                              fits.cols,\n+                              make_stride(fits.stride.outer(), fits.stride.inner())));\n         ref.reset(new Type(*map));\n \n         return true;\n     }\n \n-    operator Type*() { return ref.get(); }\n-    operator Type&() { return *ref; }\n-    template <typename _T> using cast_op_type = pybind11::detail::cast_op_type<_T>;\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type *() { return ref.get(); }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type &() { return *ref; }\n+    template <typename _T>\n+    using cast_op_type = pybind11::detail::cast_op_type<_T>;\n \n private:\n     template <typename T = Type, enable_if_t<is_eigen_mutable_map<T>::value, int> = 0>\n-    Scalar *data(Array &a) { return a.mutable_data(); }\n+    Scalar *data(Array &a) {\n+        return a.mutable_data();\n+    }\n \n     template <typename T = Type, enable_if_t<!is_eigen_mutable_map<T>::value, int> = 0>\n-    const Scalar *data(Array &a) { return a.data(); }\n+    const Scalar *data(Array &a) {\n+        return a.data();\n+    }\n \n     // Attempt to figure out a constructor of `Stride` that will work.\n     // If both strides are fixed, use a default constructor:\n-    template <typename S> using stride_ctor_default = bool_constant<\n-        S::InnerStrideAtCompileTime != Eigen::Dynamic && S::OuterStrideAtCompileTime != Eigen::Dynamic &&\n-        std::is_default_constructible<S>::value>;\n+    template <typename S>\n+    using stride_ctor_default = bool_constant<S::InnerStrideAtCompileTime != Eigen::Dynamic\n+                                              && S::OuterStrideAtCompileTime != Eigen::Dynamic\n+                                              && std::is_default_constructible<S>::value>;\n     // Otherwise, if there is a two-index constructor, assume it is (outer,inner) like\n     // Eigen::Stride, and use it:\n-    template <typename S> using stride_ctor_dual = bool_constant<\n-        !stride_ctor_default<S>::value && std::is_constructible<S, EigenIndex, EigenIndex>::value>;\n+    template <typename S>\n+    using stride_ctor_dual\n+        = bool_constant<!stride_ctor_default<S>::value\n+                        && std::is_constructible<S, EigenIndex, EigenIndex>::value>;\n     // Otherwise, if there is a one-index constructor, and just one of the strides is dynamic, use\n     // it (passing whichever stride is dynamic).\n-    template <typename S> using stride_ctor_outer = bool_constant<\n-        !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&\n-        S::OuterStrideAtCompileTime == Eigen::Dynamic && S::InnerStrideAtCompileTime != Eigen::Dynamic &&\n-        std::is_constructible<S, EigenIndex>::value>;\n-    template <typename S> using stride_ctor_inner = bool_constant<\n-        !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&\n-        S::InnerStrideAtCompileTime == Eigen::Dynamic && S::OuterStrideAtCompileTime != Eigen::Dynamic &&\n-        std::is_constructible<S, EigenIndex>::value>;\n+    template <typename S>\n+    using stride_ctor_outer\n+        = bool_constant<!any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value\n+                        && S::OuterStrideAtCompileTime == Eigen::Dynamic\n+                        && S::InnerStrideAtCompileTime != Eigen::Dynamic\n+                        && std::is_constructible<S, EigenIndex>::value>;\n+    template <typename S>\n+    using stride_ctor_inner\n+        = bool_constant<!any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value\n+                        && S::InnerStrideAtCompileTime == Eigen::Dynamic\n+                        && S::OuterStrideAtCompileTime != Eigen::Dynamic\n+                        && std::is_constructible<S, EigenIndex>::value>;\n \n     template <typename S = StrideType, enable_if_t<stride_ctor_default<S>::value, int> = 0>\n-    static S make_stride(EigenIndex, EigenIndex) { return S(); }\n+    static S make_stride(EigenIndex, EigenIndex) {\n+        return S();\n+    }\n     template <typename S = StrideType, enable_if_t<stride_ctor_dual<S>::value, int> = 0>\n-    static S make_stride(EigenIndex outer, EigenIndex inner) { return S(outer, inner); }\n+    static S make_stride(EigenIndex outer, EigenIndex inner) {\n+        return S(outer, inner);\n+    }\n     template <typename S = StrideType, enable_if_t<stride_ctor_outer<S>::value, int> = 0>\n-    static S make_stride(EigenIndex outer, EigenIndex) { return S(outer); }\n+    static S make_stride(EigenIndex outer, EigenIndex) {\n+        return S(outer);\n+    }\n     template <typename S = StrideType, enable_if_t<stride_ctor_inner<S>::value, int> = 0>\n-    static S make_stride(EigenIndex, EigenIndex inner) { return S(inner); }\n-\n+    static S make_stride(EigenIndex, EigenIndex inner) {\n+        return S(inner);\n+    }\n };\n \n // type_caster for special matrix types (e.g. DiagonalMatrix), which are EigenBase, but not\n@@ -518,14 +612,18 @@ struct type_caster<\n template <typename Type>\n struct type_caster<Type, enable_if_t<is_eigen_other<Type>::value>> {\n protected:\n-    using Matrix = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;\n+    using Matrix\n+        = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;\n     using props = EigenProps<Matrix>;\n+\n public:\n     static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {\n         handle h = eigen_encapsulate<props>(new Matrix(src));\n         return h;\n     }\n-    static handle cast(const Type *src, return_value_policy policy, handle parent) { return cast(*src, policy, parent); }\n+    static handle cast(const Type *src, return_value_policy policy, handle parent) {\n+        return cast(*src, policy, parent);\n+    }\n \n     static constexpr auto name = props::descriptor;\n \n@@ -534,26 +632,27 @@ struct type_caster<Type, enable_if_t<is_eigen_other<Type>::value>> {\n     // you end up here if you try anyway.\n     bool load(handle, bool) = delete;\n     operator Type() = delete;\n-    template <typename> using cast_op_type = Type;\n+    template <typename>\n+    using cast_op_type = Type;\n };\n \n-template<typename Type>\n+template <typename Type>\n struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {\n-    typedef typename Type::Scalar Scalar;\n-    typedef remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())> StorageIndex;\n-    typedef typename Type::Index Index;\n+    using Scalar = typename Type::Scalar;\n+    using StorageIndex = remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())>;\n+    using Index = typename Type::Index;\n     static constexpr bool rowMajor = Type::IsRowMajor;\n \n     bool load(handle src, bool) {\n-        if (!src)\n+        if (!src) {\n             return false;\n+        }\n \n         auto obj = reinterpret_borrow<object>(src);\n-        object sparse_module = module::import(\"scipy.sparse\");\n-        object matrix_type = sparse_module.attr(\n-            rowMajor ? \"csr_matrix\" : \"csc_matrix\");\n+        object sparse_module = module_::import(\"scipy.sparse\");\n+        object matrix_type = sparse_module.attr(rowMajor ? \"csr_matrix\" : \"csc_matrix\");\n \n-        if (!obj.get_type().is(matrix_type)) {\n+        if (!type::handle_of(obj).is(matrix_type)) {\n             try {\n                 obj = matrix_type(obj);\n             } catch (const error_already_set &) {\n@@ -567,41 +666,43 @@ struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {\n         auto shape = pybind11::tuple((pybind11::object) obj.attr(\"shape\"));\n         auto nnz = obj.attr(\"nnz\").cast<Index>();\n \n-        if (!values || !innerIndices || !outerIndices)\n+        if (!values || !innerIndices || !outerIndices) {\n             return false;\n+        }\n \n-        value = Eigen::MappedSparseMatrix<Scalar, Type::Flags, StorageIndex>(\n-            shape[0].cast<Index>(), shape[1].cast<Index>(), nnz,\n-            outerIndices.mutable_data(), innerIndices.mutable_data(), values.mutable_data());\n+        value = EigenMapSparseMatrix<Scalar,\n+                                     Type::Flags &(Eigen::RowMajor | Eigen::ColMajor),\n+                                     StorageIndex>(shape[0].cast<Index>(),\n+                                                   shape[1].cast<Index>(),\n+                                                   std::move(nnz),\n+                                                   outerIndices.mutable_data(),\n+                                                   innerIndices.mutable_data(),\n+                                                   values.mutable_data());\n \n         return true;\n     }\n \n     static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {\n-        const_cast<Type&>(src).makeCompressed();\n+        const_cast<Type &>(src).makeCompressed();\n \n-        object matrix_type = module::import(\"scipy.sparse\").attr(\n-            rowMajor ? \"csr_matrix\" : \"csc_matrix\");\n+        object matrix_type\n+            = module_::import(\"scipy.sparse\").attr(rowMajor ? \"csr_matrix\" : \"csc_matrix\");\n \n         array data(src.nonZeros(), src.valuePtr());\n         array outerIndices((rowMajor ? src.rows() : src.cols()) + 1, src.outerIndexPtr());\n         array innerIndices(src.nonZeros(), src.innerIndexPtr());\n \n-        return matrix_type(\n-            std::make_tuple(data, innerIndices, outerIndices),\n-            std::make_pair(src.rows(), src.cols())\n-        ).release();\n+        return matrix_type(pybind11::make_tuple(\n+                               std::move(data), std::move(innerIndices), std::move(outerIndices)),\n+                           pybind11::make_tuple(src.rows(), src.cols()))\n+            .release();\n     }\n \n-    PYBIND11_TYPE_CASTER(Type, _<(Type::IsRowMajor) != 0>(\"scipy.sparse.csr_matrix[\", \"scipy.sparse.csc_matrix[\")\n-            + npy_format_descriptor<Scalar>::name + _(\"]\"));\n+    PYBIND11_TYPE_CASTER(Type,\n+                         const_name<(Type::IsRowMajor) != 0>(\"scipy.sparse.csr_matrix[\",\n+                                                             \"scipy.sparse.csc_matrix[\")\n+                             + npy_format_descriptor<Scalar>::name + const_name(\"]\"));\n };\n \n-NAMESPACE_END(detail)\n-NAMESPACE_END(PYBIND11_NAMESPACE)\n-\n-#if defined(__GNUG__) || defined(__clang__)\n-#  pragma GCC diagnostic pop\n-#elif defined(_MSC_VER)\n-#  pragma warning(pop)\n-#endif\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/embed.h", "status": "modified", "additions": 132, "deletions": 55, "changes": 187, "file_content_changes": "@@ -12,21 +12,16 @@\n #include \"pybind11.h\"\n #include \"eval.h\"\n \n+#include <memory>\n+#include <vector>\n+\n #if defined(PYPY_VERSION)\n-#  error Embedding the interpreter is not supported with PyPy\n+#    error Embedding the interpreter is not supported with PyPy\n #endif\n \n-#if PY_MAJOR_VERSION >= 3\n-#  define PYBIND11_EMBEDDED_MODULE_IMPL(name)            \\\n-      extern \"C\" PyObject *pybind11_init_impl_##name() { \\\n-          return pybind11_init_wrapper_##name();         \\\n-      }\n-#else\n-#  define PYBIND11_EMBEDDED_MODULE_IMPL(name)            \\\n-      extern \"C\" void pybind11_init_impl_##name() {      \\\n-          pybind11_init_wrapper_##name();                \\\n-      }\n-#endif\n+#define PYBIND11_EMBEDDED_MODULE_IMPL(name)                                                       \\\n+    extern \"C\" PyObject *pybind11_init_impl_##name();                                             \\\n+    extern \"C\" PyObject *pybind11_init_impl_##name() { return pybind11_init_wrapper_##name(); }\n \n /** \\rst\n     Add a new module to the table of builtins for the interpreter. Must be\n@@ -43,70 +38,141 @@\n             });\n         }\n  \\endrst */\n-#define PYBIND11_EMBEDDED_MODULE(name, variable)                              \\\n-    static void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &);    \\\n-    static PyObject PYBIND11_CONCAT(*pybind11_init_wrapper_, name)() {        \\\n-        auto m = pybind11::module(PYBIND11_TOSTRING(name));                   \\\n-        try {                                                                 \\\n-            PYBIND11_CONCAT(pybind11_init_, name)(m);                         \\\n-            return m.ptr();                                                   \\\n-        } catch (pybind11::error_already_set &e) {                            \\\n-            PyErr_SetString(PyExc_ImportError, e.what());                     \\\n-            return nullptr;                                                   \\\n-        } catch (const std::exception &e) {                                   \\\n-            PyErr_SetString(PyExc_ImportError, e.what());                     \\\n-            return nullptr;                                                   \\\n-        }                                                                     \\\n-    }                                                                         \\\n-    PYBIND11_EMBEDDED_MODULE_IMPL(name)                                       \\\n-    pybind11::detail::embedded_module name(PYBIND11_TOSTRING(name),           \\\n-                               PYBIND11_CONCAT(pybind11_init_impl_, name));   \\\n-    void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &variable)\n-\n-\n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+#define PYBIND11_EMBEDDED_MODULE(name, variable)                                                  \\\n+    static ::pybind11::module_::module_def PYBIND11_CONCAT(pybind11_module_def_, name);           \\\n+    static void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ &);                     \\\n+    static PyObject PYBIND11_CONCAT(*pybind11_init_wrapper_, name)() {                            \\\n+        auto m = ::pybind11::module_::create_extension_module(                                    \\\n+            PYBIND11_TOSTRING(name), nullptr, &PYBIND11_CONCAT(pybind11_module_def_, name));      \\\n+        try {                                                                                     \\\n+            PYBIND11_CONCAT(pybind11_init_, name)(m);                                             \\\n+            return m.ptr();                                                                       \\\n+        }                                                                                         \\\n+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \\\n+    }                                                                                             \\\n+    PYBIND11_EMBEDDED_MODULE_IMPL(name)                                                           \\\n+    ::pybind11::detail::embedded_module PYBIND11_CONCAT(pybind11_module_, name)(                  \\\n+        PYBIND11_TOSTRING(name), PYBIND11_CONCAT(pybind11_init_impl_, name));                     \\\n+    void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_                                \\\n+                                               & variable) // NOLINT(bugprone-macro-parentheses)\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n /// Python 2.7/3.x compatible version of `PyImport_AppendInittab` and error checks.\n struct embedded_module {\n-#if PY_MAJOR_VERSION >= 3\n-    using init_t = PyObject *(*)();\n-#else\n-    using init_t = void (*)();\n-#endif\n+    using init_t = PyObject *(*) ();\n     embedded_module(const char *name, init_t init) {\n-        if (Py_IsInitialized())\n+        if (Py_IsInitialized() != 0) {\n             pybind11_fail(\"Can't add new modules after the interpreter has been initialized\");\n+        }\n \n         auto result = PyImport_AppendInittab(name, init);\n-        if (result == -1)\n+        if (result == -1) {\n             pybind11_fail(\"Insufficient memory to add a new module\");\n+        }\n     }\n };\n \n-NAMESPACE_END(detail)\n+struct wide_char_arg_deleter {\n+    void operator()(wchar_t *ptr) const {\n+        // API docs: https://docs.python.org/3/c-api/sys.html#c.Py_DecodeLocale\n+        PyMem_RawFree(ptr);\n+    }\n+};\n+\n+inline wchar_t *widen_chars(const char *safe_arg) {\n+    wchar_t *widened_arg = Py_DecodeLocale(safe_arg, nullptr);\n+    return widened_arg;\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n \n /** \\rst\n     Initialize the Python interpreter. No other pybind11 or CPython API functions can be\n     called before this is done; with the exception of `PYBIND11_EMBEDDED_MODULE`. The\n-    optional parameter can be used to skip the registration of signal handlers (see the\n-    `Python documentation`_ for details). Calling this function again after the interpreter\n-    has already been initialized is a fatal error.\n+    optional `init_signal_handlers` parameter can be used to skip the registration of\n+    signal handlers (see the `Python documentation`_ for details). Calling this function\n+    again after the interpreter has already been initialized is a fatal error.\n \n     If initializing the Python interpreter fails, then the program is terminated.  (This\n     is controlled by the CPython runtime and is an exception to pybind11's normal behavior\n     of throwing exceptions on errors.)\n \n+    The remaining optional parameters, `argc`, `argv`, and `add_program_dir_to_path` are\n+    used to populate ``sys.argv`` and ``sys.path``.\n+    See the |PySys_SetArgvEx documentation|_ for details.\n+\n     .. _Python documentation: https://docs.python.org/3/c-api/init.html#c.Py_InitializeEx\n+    .. |PySys_SetArgvEx documentation| replace:: ``PySys_SetArgvEx`` documentation\n+    .. _PySys_SetArgvEx documentation: https://docs.python.org/3/c-api/init.html#c.PySys_SetArgvEx\n  \\endrst */\n-inline void initialize_interpreter(bool init_signal_handlers = true) {\n-    if (Py_IsInitialized())\n+inline void initialize_interpreter(bool init_signal_handlers = true,\n+                                   int argc = 0,\n+                                   const char *const *argv = nullptr,\n+                                   bool add_program_dir_to_path = true) {\n+    if (Py_IsInitialized() != 0) {\n         pybind11_fail(\"The interpreter is already running\");\n+    }\n+\n+#if PY_VERSION_HEX < 0x030B0000\n \n     Py_InitializeEx(init_signal_handlers ? 1 : 0);\n \n-    // Make .py files in the working directory available by default\n-    module::import(\"sys\").attr(\"path\").cast<list>().append(\".\");\n+    // Before it was special-cased in python 3.8, passing an empty or null argv\n+    // caused a segfault, so we have to reimplement the special case ourselves.\n+    bool special_case = (argv == nullptr || argc <= 0);\n+\n+    const char *const empty_argv[]{\"\\0\"};\n+    const char *const *safe_argv = special_case ? empty_argv : argv;\n+    if (special_case) {\n+        argc = 1;\n+    }\n+\n+    auto argv_size = static_cast<size_t>(argc);\n+    // SetArgv* on python 3 takes wchar_t, so we have to convert.\n+    std::unique_ptr<wchar_t *[]> widened_argv(new wchar_t *[argv_size]);\n+    std::vector<std::unique_ptr<wchar_t[], detail::wide_char_arg_deleter>> widened_argv_entries;\n+    widened_argv_entries.reserve(argv_size);\n+    for (size_t ii = 0; ii < argv_size; ++ii) {\n+        widened_argv_entries.emplace_back(detail::widen_chars(safe_argv[ii]));\n+        if (!widened_argv_entries.back()) {\n+            // A null here indicates a character-encoding failure or the python\n+            // interpreter out of memory. Give up.\n+            return;\n+        }\n+        widened_argv[ii] = widened_argv_entries.back().get();\n+    }\n+\n+    auto *pysys_argv = widened_argv.get();\n+\n+    PySys_SetArgvEx(argc, pysys_argv, static_cast<int>(add_program_dir_to_path));\n+#else\n+    PyConfig config;\n+    PyConfig_InitIsolatedConfig(&config);\n+    config.install_signal_handlers = init_signal_handlers ? 1 : 0;\n+\n+    PyStatus status = PyConfig_SetBytesArgv(&config, argc, const_cast<char *const *>(argv));\n+    if (PyStatus_Exception(status)) {\n+        // A failure here indicates a character-encoding failure or the python\n+        // interpreter out of memory. Give up.\n+        PyConfig_Clear(&config);\n+        throw std::runtime_error(PyStatus_IsError(status) ? status.err_msg\n+                                                          : \"Failed to prepare CPython\");\n+    }\n+    status = Py_InitializeFromConfig(&config);\n+    PyConfig_Clear(&config);\n+    if (PyStatus_Exception(status)) {\n+        throw std::runtime_error(PyStatus_IsError(status) ? status.err_msg\n+                                                          : \"Failed to init CPython\");\n+    }\n+    if (add_program_dir_to_path) {\n+        PyRun_SimpleString(\"import sys, os.path; \"\n+                           \"sys.path.insert(0, \"\n+                           \"os.path.abspath(os.path.dirname(sys.argv[0])) \"\n+                           \"if sys.argv and os.path.exists(sys.argv[0]) else '')\");\n+    }\n+#endif\n }\n \n /** \\rst\n@@ -153,8 +219,13 @@ inline void finalize_interpreter() {\n     // during destruction), so we get the pointer-pointer here and check it after Py_Finalize().\n     detail::internals **internals_ptr_ptr = detail::get_internals_pp();\n     // It could also be stashed in builtins, so look there too:\n-    if (builtins.contains(id) && isinstance<capsule>(builtins[id]))\n+    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n         internals_ptr_ptr = capsule(builtins[id]);\n+    }\n+    // Local internals contains data managed by the current interpreter, so we must clear them to\n+    // avoid undefined behaviors when initializing another interpreter\n+    detail::get_local_internals().registered_types_cpp.clear();\n+    detail::get_local_internals().registered_exception_translators.clear();\n \n     Py_Finalize();\n \n@@ -168,6 +239,8 @@ inline void finalize_interpreter() {\n     Scope guard version of `initialize_interpreter` and `finalize_interpreter`.\n     This a move-only guard and only a single instance can exist.\n \n+    See `initialize_interpreter` for a discussion of its constructor arguments.\n+\n     .. code-block:: cpp\n \n         #include <pybind11/embed.h>\n@@ -179,8 +252,11 @@ inline void finalize_interpreter() {\n  \\endrst */\n class scoped_interpreter {\n public:\n-    scoped_interpreter(bool init_signal_handlers = true) {\n-        initialize_interpreter(init_signal_handlers);\n+    explicit scoped_interpreter(bool init_signal_handlers = true,\n+                                int argc = 0,\n+                                const char *const *argv = nullptr,\n+                                bool add_program_dir_to_path = true) {\n+        initialize_interpreter(init_signal_handlers, argc, argv, add_program_dir_to_path);\n     }\n \n     scoped_interpreter(const scoped_interpreter &) = delete;\n@@ -189,12 +265,13 @@ class scoped_interpreter {\n     scoped_interpreter &operator=(scoped_interpreter &&) = delete;\n \n     ~scoped_interpreter() {\n-        if (is_valid)\n+        if (is_valid) {\n             finalize_interpreter();\n+        }\n     }\n \n private:\n     bool is_valid = true;\n };\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/eval.h", "status": "modified", "additions": 84, "deletions": 45, "changes": 129, "file_content_changes": "@@ -1,5 +1,5 @@\n /*\n-    pybind11/exec.h: Support for evaluating Python expressions and statements\n+    pybind11/eval.h: Support for evaluating Python expressions and statements\n     from strings and files\n \n     Copyright (c) 2016 Klemens Morgenstern <klemens.morgenstern@ed-chemnitz.de> and\n@@ -13,7 +13,25 @@\n \n #include \"pybind11.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+#include <utility>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+inline void ensure_builtins_in_globals(object &global) {\n+#if defined(PYPY_VERSION) || PY_VERSION_HEX < 0x03080000\n+    // Running exec and eval adds `builtins` module under `__builtins__` key to\n+    // globals if not yet present.  Python 3.8 made PyRun_String behave\n+    // similarly. Let's also do that for older versions, for consistency. This\n+    // was missing from PyPy3.8 7.3.7.\n+    if (!global.contains(\"__builtins__\"))\n+        global[\"__builtins__\"] = module_::import(PYBIND11_BUILTINS_MODULE);\n+#else\n+    (void) global;\n+#endif\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n \n enum eval_mode {\n     /// Evaluate a string containing an isolated expression\n@@ -27,91 +45,112 @@ enum eval_mode {\n };\n \n template <eval_mode mode = eval_expr>\n-object eval(str expr, object global = globals(), object local = object()) {\n-    if (!local)\n+object eval(const str &expr, object global = globals(), object local = object()) {\n+    if (!local) {\n         local = global;\n+    }\n+\n+    detail::ensure_builtins_in_globals(global);\n \n     /* PyRun_String does not accept a PyObject / encoding specifier,\n        this seems to be the only alternative */\n     std::string buffer = \"# -*- coding: utf-8 -*-\\n\" + (std::string) expr;\n \n-    int start;\n+    int start = 0;\n     switch (mode) {\n-        case eval_expr:             start = Py_eval_input;   break;\n-        case eval_single_statement: start = Py_single_input; break;\n-        case eval_statements:       start = Py_file_input;   break;\n-        default: pybind11_fail(\"invalid evaluation mode\");\n+        case eval_expr:\n+            start = Py_eval_input;\n+            break;\n+        case eval_single_statement:\n+            start = Py_single_input;\n+            break;\n+        case eval_statements:\n+            start = Py_file_input;\n+            break;\n+        default:\n+            pybind11_fail(\"invalid evaluation mode\");\n     }\n \n     PyObject *result = PyRun_String(buffer.c_str(), start, global.ptr(), local.ptr());\n-    if (!result)\n+    if (!result) {\n         throw error_already_set();\n+    }\n     return reinterpret_steal<object>(result);\n }\n \n template <eval_mode mode = eval_expr, size_t N>\n object eval(const char (&s)[N], object global = globals(), object local = object()) {\n     /* Support raw string literals by removing common leading whitespace */\n-    auto expr = (s[0] == '\\n') ? str(module::import(\"textwrap\").attr(\"dedent\")(s))\n-                               : str(s);\n-    return eval<mode>(expr, global, local);\n+    auto expr = (s[0] == '\\n') ? str(module_::import(\"textwrap\").attr(\"dedent\")(s)) : str(s);\n+    return eval<mode>(expr, std::move(global), std::move(local));\n }\n \n-inline void exec(str expr, object global = globals(), object local = object()) {\n-    eval<eval_statements>(expr, global, local);\n+inline void exec(const str &expr, object global = globals(), object local = object()) {\n+    eval<eval_statements>(expr, std::move(global), std::move(local));\n }\n \n template <size_t N>\n void exec(const char (&s)[N], object global = globals(), object local = object()) {\n-    eval<eval_statements>(s, global, local);\n+    eval<eval_statements>(s, std::move(global), std::move(local));\n }\n \n+#if defined(PYPY_VERSION)\n+template <eval_mode mode = eval_statements>\n+object eval_file(str, object, object) {\n+    pybind11_fail(\"eval_file not supported in PyPy3. Use eval\");\n+}\n+template <eval_mode mode = eval_statements>\n+object eval_file(str, object) {\n+    pybind11_fail(\"eval_file not supported in PyPy3. Use eval\");\n+}\n+template <eval_mode mode = eval_statements>\n+object eval_file(str) {\n+    pybind11_fail(\"eval_file not supported in PyPy3. Use eval\");\n+}\n+#else\n template <eval_mode mode = eval_statements>\n object eval_file(str fname, object global = globals(), object local = object()) {\n-    if (!local)\n+    if (!local) {\n         local = global;\n+    }\n \n-    int start;\n+    detail::ensure_builtins_in_globals(global);\n+\n+    int start = 0;\n     switch (mode) {\n-        case eval_expr:             start = Py_eval_input;   break;\n-        case eval_single_statement: start = Py_single_input; break;\n-        case eval_statements:       start = Py_file_input;   break;\n-        default: pybind11_fail(\"invalid evaluation mode\");\n+        case eval_expr:\n+            start = Py_eval_input;\n+            break;\n+        case eval_single_statement:\n+            start = Py_single_input;\n+            break;\n+        case eval_statements:\n+            start = Py_file_input;\n+            break;\n+        default:\n+            pybind11_fail(\"invalid evaluation mode\");\n     }\n \n     int closeFile = 1;\n     std::string fname_str = (std::string) fname;\n-#if PY_VERSION_HEX >= 0x03040000\n     FILE *f = _Py_fopen_obj(fname.ptr(), \"r\");\n-#elif PY_VERSION_HEX >= 0x03000000\n-    FILE *f = _Py_fopen(fname.ptr(), \"r\");\n-#else\n-    /* No unicode support in open() :( */\n-    auto fobj = reinterpret_steal<object>(PyFile_FromString(\n-        const_cast<char *>(fname_str.c_str()),\n-        const_cast<char*>(\"r\")));\n-    FILE *f = nullptr;\n-    if (fobj)\n-        f = PyFile_AsFile(fobj.ptr());\n-    closeFile = 0;\n-#endif\n     if (!f) {\n         PyErr_Clear();\n         pybind11_fail(\"File \\\"\" + fname_str + \"\\\" could not be opened!\");\n     }\n \n-#if PY_VERSION_HEX < 0x03000000 && defined(PYPY_VERSION)\n-    PyObject *result = PyRun_File(f, fname_str.c_str(), start, global.ptr(),\n-                                  local.ptr());\n-    (void) closeFile;\n-#else\n-    PyObject *result = PyRun_FileEx(f, fname_str.c_str(), start, global.ptr(),\n-                                    local.ptr(), closeFile);\n-#endif\n+    if (!global.contains(\"__file__\")) {\n+        global[\"__file__\"] = std::move(fname);\n+    }\n \n-    if (!result)\n+    PyObject *result\n+        = PyRun_FileEx(f, fname_str.c_str(), start, global.ptr(), local.ptr(), closeFile);\n+\n+    if (!result) {\n         throw error_already_set();\n+    }\n     return reinterpret_steal<object>(result);\n }\n+#endif\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/functional.h", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "file_content_changes": "@@ -10,27 +10,31 @@\n #pragma once\n \n #include \"pybind11.h\"\n+\n #include <functional>\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n template <typename Return, typename... Args>\n struct type_caster<std::function<Return(Args...)>> {\n     using type = std::function<Return(Args...)>;\n     using retval_type = conditional_t<std::is_same<Return, void>::value, void_type, Return>;\n-    using function_type = Return (*) (Args...);\n+    using function_type = Return (*)(Args...);\n \n public:\n     bool load(handle src, bool convert) {\n         if (src.is_none()) {\n             // Defer accepting None to other overloads (if we aren't in convert mode):\n-            if (!convert) return false;\n+            if (!convert) {\n+                return false;\n+            }\n             return true;\n         }\n \n-        if (!isinstance<function>(src))\n+        if (!isinstance<function>(src)) {\n             return false;\n+        }\n \n         auto func = reinterpret_borrow<function>(src);\n \n@@ -43,66 +47,84 @@ struct type_caster<std::function<Return(Args...)>> {\n            captured variables), in which case the roundtrip can be avoided.\n          */\n         if (auto cfunc = func.cpp_function()) {\n-            auto c = reinterpret_borrow<capsule>(PyCFunction_GET_SELF(cfunc.ptr()));\n-            auto rec = (function_record *) c;\n-\n-            if (rec && rec->is_stateless &&\n-                    same_type(typeid(function_type), *reinterpret_cast<const std::type_info *>(rec->data[1]))) {\n-                struct capture { function_type f; };\n-                value = ((capture *) &rec->data)->f;\n-                return true;\n+            auto *cfunc_self = PyCFunction_GET_SELF(cfunc.ptr());\n+            if (isinstance<capsule>(cfunc_self)) {\n+                auto c = reinterpret_borrow<capsule>(cfunc_self);\n+                auto *rec = (function_record *) c;\n+\n+                while (rec != nullptr) {\n+                    if (rec->is_stateless\n+                        && same_type(typeid(function_type),\n+                                     *reinterpret_cast<const std::type_info *>(rec->data[1]))) {\n+                        struct capture {\n+                            function_type f;\n+                        };\n+                        value = ((capture *) &rec->data)->f;\n+                        return true;\n+                    }\n+                    rec = rec->next;\n+                }\n             }\n+            // PYPY segfaults here when passing builtin function like sum.\n+            // Raising an fail exception here works to prevent the segfault, but only on gcc.\n+            // See PR #1413 for full details\n         }\n \n         // ensure GIL is held during functor destruction\n         struct func_handle {\n             function f;\n-            func_handle(function&& f_) : f(std::move(f_)) {}\n-            func_handle(const func_handle&) = default;\n+#if !(defined(_MSC_VER) && _MSC_VER == 1916 && defined(PYBIND11_CPP17))\n+            // This triggers a syntax error under very special conditions (very weird indeed).\n+            explicit\n+#endif\n+                func_handle(function &&f_) noexcept\n+                : f(std::move(f_)) {\n+            }\n+            func_handle(const func_handle &f_) { operator=(f_); }\n+            func_handle &operator=(const func_handle &f_) {\n+                gil_scoped_acquire acq;\n+                f = f_.f;\n+                return *this;\n+            }\n             ~func_handle() {\n                 gil_scoped_acquire acq;\n                 function kill_f(std::move(f));\n             }\n         };\n \n-        // value = [hfunc = func_handle(std::move(func))](Args... args) -> Return {\n-        //     gil_scoped_acquire acq;\n-        //     object retval(hfunc.f(std::forward<Args>(args)...));\n-        //     /* Visual studio 2015 parser issue: need parentheses around this expression */\n-        //     return (retval.template cast<Return>());\n-        // };\n-\n+        // to emulate 'move initialization capture' in C++11\n         struct func_wrapper {\n             func_handle hfunc;\n-            func_wrapper(func_handle&& hf): hfunc(std::move(hf)) {}\n+            explicit func_wrapper(func_handle &&hf) noexcept : hfunc(std::move(hf)) {}\n             Return operator()(Args... args) const {\n                 gil_scoped_acquire acq;\n-                object retval(hfunc.f(std::forward<Args>(args)...));\n-                /* Visual studio 2015 parser issue: need parentheses around this expression */\n-                return (retval.template cast<Return>());\n+                // casts the returned object as a rvalue to the return type\n+                return hfunc.f(std::forward<Args>(args)...).template cast<Return>();\n             }\n         };\n \n         value = func_wrapper(func_handle(std::move(func)));\n-\n         return true;\n     }\n \n     template <typename Func>\n     static handle cast(Func &&f_, return_value_policy policy, handle /* parent */) {\n-        if (!f_)\n+        if (!f_) {\n             return none().inc_ref();\n+        }\n \n         auto result = f_.template target<function_type>();\n-        if (result)\n+        if (result) {\n             return cpp_function(*result, policy).release();\n-        else\n-            return cpp_function(std::forward<Func>(f_), policy).release();\n+        }\n+        return cpp_function(std::forward<Func>(f_), policy).release();\n     }\n \n-    PYBIND11_TYPE_CASTER(type, _(\"Callable[[\") + concat(make_caster<Args>::name...) + _(\"], \")\n-                               + make_caster<retval_type>::name + _(\"]\"));\n+    PYBIND11_TYPE_CASTER(type,\n+                         const_name(\"Callable[[\") + concat(make_caster<Args>::name...)\n+                             + const_name(\"], \") + make_caster<retval_type>::name\n+                             + const_name(\"]\"));\n };\n \n-NAMESPACE_END(detail)\n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/gil.h", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "file_content_changes": "@@ -0,0 +1,202 @@\n+/*\n+    pybind11/gil.h: RAII helpers for managing the GIL\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+#include \"detail/internals.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// forward declarations\n+PyThreadState *get_thread_state_unchecked();\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+#if defined(WITH_THREAD) && !defined(PYPY_VERSION)\n+\n+/* The functions below essentially reproduce the PyGILState_* API using a RAII\n+ * pattern, but there are a few important differences:\n+ *\n+ * 1. When acquiring the GIL from an non-main thread during the finalization\n+ *    phase, the GILState API blindly terminates the calling thread, which\n+ *    is often not what is wanted. This API does not do this.\n+ *\n+ * 2. The gil_scoped_release function can optionally cut the relationship\n+ *    of a PyThreadState and its associated thread, which allows moving it to\n+ *    another thread (this is a fairly rare/advanced use case).\n+ *\n+ * 3. The reference count of an acquired thread state can be controlled. This\n+ *    can be handy to prevent cases where callbacks issued from an external\n+ *    thread would otherwise constantly construct and destroy thread state data\n+ *    structures.\n+ *\n+ * See the Python bindings of NanoGUI (http://github.com/wjakob/nanogui) for an\n+ * example which uses features 2 and 3 to migrate the Python thread of\n+ * execution to another thread (to run the event loop on the original thread,\n+ * in this case).\n+ */\n+\n+class gil_scoped_acquire {\n+public:\n+    PYBIND11_NOINLINE gil_scoped_acquire() {\n+        auto &internals = detail::get_internals();\n+        tstate = (PyThreadState *) PYBIND11_TLS_GET_VALUE(internals.tstate);\n+\n+        if (!tstate) {\n+            /* Check if the GIL was acquired using the PyGILState_* API instead (e.g. if\n+               calling from a Python thread). Since we use a different key, this ensures\n+               we don't create a new thread state and deadlock in PyEval_AcquireThread\n+               below. Note we don't save this state with internals.tstate, since we don't\n+               create it we would fail to clear it (its reference count should be > 0). */\n+            tstate = PyGILState_GetThisThreadState();\n+        }\n+\n+        if (!tstate) {\n+            tstate = PyThreadState_New(internals.istate);\n+#    if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            if (!tstate) {\n+                pybind11_fail(\"scoped_acquire: could not create thread state!\");\n+            }\n+#    endif\n+            tstate->gilstate_counter = 0;\n+            PYBIND11_TLS_REPLACE_VALUE(internals.tstate, tstate);\n+        } else {\n+            release = detail::get_thread_state_unchecked() != tstate;\n+        }\n+\n+        if (release) {\n+            PyEval_AcquireThread(tstate);\n+        }\n+\n+        inc_ref();\n+    }\n+\n+    void inc_ref() { ++tstate->gilstate_counter; }\n+\n+    PYBIND11_NOINLINE void dec_ref() {\n+        --tstate->gilstate_counter;\n+#    if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+        if (detail::get_thread_state_unchecked() != tstate) {\n+            pybind11_fail(\"scoped_acquire::dec_ref(): thread state must be current!\");\n+        }\n+        if (tstate->gilstate_counter < 0) {\n+            pybind11_fail(\"scoped_acquire::dec_ref(): reference count underflow!\");\n+        }\n+#    endif\n+        if (tstate->gilstate_counter == 0) {\n+#    if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            if (!release) {\n+                pybind11_fail(\"scoped_acquire::dec_ref(): internal error!\");\n+            }\n+#    endif\n+            PyThreadState_Clear(tstate);\n+            if (active) {\n+                PyThreadState_DeleteCurrent();\n+            }\n+            PYBIND11_TLS_DELETE_VALUE(detail::get_internals().tstate);\n+            release = false;\n+        }\n+    }\n+\n+    /// This method will disable the PyThreadState_DeleteCurrent call and the\n+    /// GIL won't be acquired. This method should be used if the interpreter\n+    /// could be shutting down when this is called, as thread deletion is not\n+    /// allowed during shutdown. Check _Py_IsFinalizing() on Python 3.7+, and\n+    /// protect subsequent code.\n+    PYBIND11_NOINLINE void disarm() { active = false; }\n+\n+    PYBIND11_NOINLINE ~gil_scoped_acquire() {\n+        dec_ref();\n+        if (release) {\n+            PyEval_SaveThread();\n+        }\n+    }\n+\n+private:\n+    PyThreadState *tstate = nullptr;\n+    bool release = true;\n+    bool active = true;\n+};\n+\n+class gil_scoped_release {\n+public:\n+    explicit gil_scoped_release(bool disassoc = false) : disassoc(disassoc) {\n+        // `get_internals()` must be called here unconditionally in order to initialize\n+        // `internals.tstate` for subsequent `gil_scoped_acquire` calls. Otherwise, an\n+        // initialization race could occur as multiple threads try `gil_scoped_acquire`.\n+        auto &internals = detail::get_internals();\n+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)\n+        tstate = PyEval_SaveThread();\n+        if (disassoc) {\n+            // Python >= 3.7 can remove this, it's an int before 3.7\n+            // NOLINTNEXTLINE(readability-qualified-auto)\n+            auto key = internals.tstate;\n+            PYBIND11_TLS_DELETE_VALUE(key);\n+        }\n+    }\n+\n+    /// This method will disable the PyThreadState_DeleteCurrent call and the\n+    /// GIL won't be acquired. This method should be used if the interpreter\n+    /// could be shutting down when this is called, as thread deletion is not\n+    /// allowed during shutdown. Check _Py_IsFinalizing() on Python 3.7+, and\n+    /// protect subsequent code.\n+    PYBIND11_NOINLINE void disarm() { active = false; }\n+\n+    ~gil_scoped_release() {\n+        if (!tstate) {\n+            return;\n+        }\n+        // `PyEval_RestoreThread()` should not be called if runtime is finalizing\n+        if (active) {\n+            PyEval_RestoreThread(tstate);\n+        }\n+        if (disassoc) {\n+            // Python >= 3.7 can remove this, it's an int before 3.7\n+            // NOLINTNEXTLINE(readability-qualified-auto)\n+            auto key = detail::get_internals().tstate;\n+            PYBIND11_TLS_REPLACE_VALUE(key, tstate);\n+        }\n+    }\n+\n+private:\n+    PyThreadState *tstate;\n+    bool disassoc;\n+    bool active = true;\n+};\n+#elif defined(PYPY_VERSION)\n+class gil_scoped_acquire {\n+    PyGILState_STATE state;\n+\n+public:\n+    gil_scoped_acquire() { state = PyGILState_Ensure(); }\n+    ~gil_scoped_acquire() { PyGILState_Release(state); }\n+    void disarm() {}\n+};\n+\n+class gil_scoped_release {\n+    PyThreadState *state;\n+\n+public:\n+    gil_scoped_release() { state = PyEval_SaveThread(); }\n+    ~gil_scoped_release() { PyEval_RestoreThread(state); }\n+    void disarm() {}\n+};\n+#else\n+class gil_scoped_acquire {\n+    void disarm() {}\n+};\n+class gil_scoped_release {\n+    void disarm() {}\n+};\n+#endif\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/iostream.h", "status": "modified", "additions": 105, "deletions": 47, "changes": 152, "file_content_changes": "@@ -5,20 +5,34 @@\n \n     All rights reserved. Use of this source code is governed by a\n     BSD-style license that can be found in the LICENSE file.\n+\n+    WARNING: The implementation in this file is NOT thread safe. Multiple\n+    threads writing to a redirected ostream concurrently cause data races\n+    and potentially buffer overflows. Therefore it is currently a requirement\n+    that all (possibly) concurrent redirected ostream writes are protected by\n+    a mutex.\n+    #HelpAppreciated: Work on iostream.h thread safety.\n+    For more background see the discussions under\n+    https://github.com/pybind/pybind11/pull/2982 and\n+    https://github.com/pybind/pybind11/pull/2995.\n */\n \n #pragma once\n \n #include \"pybind11.h\"\n \n-#include <streambuf>\n+#include <algorithm>\n+#include <cstring>\n+#include <iostream>\n+#include <iterator>\n+#include <memory>\n #include <ostream>\n+#include <streambuf>\n #include <string>\n-#include <memory>\n-#include <iostream>\n+#include <utility>\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n // Buffer that writes to Python instead of C++\n class pythonbuf : public std::streambuf {\n@@ -30,48 +44,92 @@ class pythonbuf : public std::streambuf {\n     object pywrite;\n     object pyflush;\n \n-    int overflow(int c) {\n+    int overflow(int c) override {\n         if (!traits_type::eq_int_type(c, traits_type::eof())) {\n             *pptr() = traits_type::to_char_type(c);\n             pbump(1);\n         }\n         return sync() == 0 ? traits_type::not_eof(c) : traits_type::eof();\n     }\n \n-    int sync() {\n-        if (pbase() != pptr()) {\n-            // This subtraction cannot be negative, so dropping the sign\n-            str line(pbase(), static_cast<size_t>(pptr() - pbase()));\n+    // Computes how many bytes at the end of the buffer are part of an\n+    // incomplete sequence of UTF-8 bytes.\n+    // Precondition: pbase() < pptr()\n+    size_t utf8_remainder() const {\n+        const auto rbase = std::reverse_iterator<char *>(pbase());\n+        const auto rpptr = std::reverse_iterator<char *>(pptr());\n+        auto is_ascii = [](char c) { return (static_cast<unsigned char>(c) & 0x80) == 0x00; };\n+        auto is_leading = [](char c) { return (static_cast<unsigned char>(c) & 0xC0) == 0xC0; };\n+        auto is_leading_2b = [](char c) { return static_cast<unsigned char>(c) <= 0xDF; };\n+        auto is_leading_3b = [](char c) { return static_cast<unsigned char>(c) <= 0xEF; };\n+        // If the last character is ASCII, there are no incomplete code points\n+        if (is_ascii(*rpptr)) {\n+            return 0;\n+        }\n+        // Otherwise, work back from the end of the buffer and find the first\n+        // UTF-8 leading byte\n+        const auto rpend = rbase - rpptr >= 3 ? rpptr + 3 : rbase;\n+        const auto leading = std::find_if(rpptr, rpend, is_leading);\n+        if (leading == rbase) {\n+            return 0;\n+        }\n+        const auto dist = static_cast<size_t>(leading - rpptr);\n+        size_t remainder = 0;\n+\n+        if (dist == 0) {\n+            remainder = 1; // 1-byte code point is impossible\n+        } else if (dist == 1) {\n+            remainder = is_leading_2b(*leading) ? 0 : dist + 1;\n+        } else if (dist == 2) {\n+            remainder = is_leading_3b(*leading) ? 0 : dist + 1;\n+        }\n+        // else if (dist >= 3), at least 4 bytes before encountering an UTF-8\n+        // leading byte, either no remainder or invalid UTF-8.\n+        // Invalid UTF-8 will cause an exception later when converting\n+        // to a Python string, so that's not handled here.\n+        return remainder;\n+    }\n \n-            {\n-                gil_scoped_acquire tmp;\n-                pywrite(line);\n+    // This function must be non-virtual to be called in a destructor.\n+    int _sync() {\n+        if (pbase() != pptr()) { // If buffer is not empty\n+            gil_scoped_acquire tmp;\n+            // This subtraction cannot be negative, so dropping the sign.\n+            auto size = static_cast<size_t>(pptr() - pbase());\n+            size_t remainder = utf8_remainder();\n+\n+            if (size > remainder) {\n+                str line(pbase(), size - remainder);\n+                pywrite(std::move(line));\n                 pyflush();\n             }\n \n+            // Copy the remainder at the end of the buffer to the beginning:\n+            if (remainder > 0) {\n+                std::memmove(pbase(), pptr() - remainder, remainder);\n+            }\n             setp(pbase(), epptr());\n+            pbump(static_cast<int>(remainder));\n         }\n         return 0;\n     }\n \n-public:\n+    int sync() override { return _sync(); }\n \n-    pythonbuf(object pyostream, size_t buffer_size = 1024)\n-        : buf_size(buffer_size),\n-          d_buffer(new char[buf_size]),\n-          pywrite(pyostream.attr(\"write\")),\n+public:\n+    explicit pythonbuf(const object &pyostream, size_t buffer_size = 1024)\n+        : buf_size(buffer_size), d_buffer(new char[buf_size]), pywrite(pyostream.attr(\"write\")),\n           pyflush(pyostream.attr(\"flush\")) {\n         setp(d_buffer.get(), d_buffer.get() + buf_size - 1);\n     }\n \n+    pythonbuf(pythonbuf &&) = default;\n+\n     /// Sync before destroy\n-    ~pythonbuf() {\n-        sync();\n-    }\n+    ~pythonbuf() override { _sync(); }\n };\n \n-NAMESPACE_END(detail)\n-\n+PYBIND11_NAMESPACE_END(detail)\n \n /** \\rst\n     This a move-only guard that redirects output.\n@@ -93,8 +151,9 @@ NAMESPACE_END(detail)\n     .. code-block:: cpp\n \n         {\n-            py::scoped_ostream_redirect output{std::cerr, py::module::import(\"sys\").attr(\"stderr\")};\n-            std::cerr << \"Hello, World!\";\n+            py::scoped_ostream_redirect output{\n+                std::cerr, py::module::import(\"sys\").attr(\"stderr\")};\n+            std::cout << \"Hello, World!\";\n         }\n  \\endrst */\n class scoped_ostream_redirect {\n@@ -104,24 +163,21 @@ class scoped_ostream_redirect {\n     detail::pythonbuf buffer;\n \n public:\n-    scoped_ostream_redirect(\n-            std::ostream &costream = std::cout,\n-            object pyostream = module::import(\"sys\").attr(\"stdout\"))\n+    explicit scoped_ostream_redirect(std::ostream &costream = std::cout,\n+                                     const object &pyostream\n+                                     = module_::import(\"sys\").attr(\"stdout\"))\n         : costream(costream), buffer(pyostream) {\n         old = costream.rdbuf(&buffer);\n     }\n \n-    ~scoped_ostream_redirect() {\n-        costream.rdbuf(old);\n-    }\n+    ~scoped_ostream_redirect() { costream.rdbuf(old); }\n \n     scoped_ostream_redirect(const scoped_ostream_redirect &) = delete;\n     scoped_ostream_redirect(scoped_ostream_redirect &&other) = default;\n     scoped_ostream_redirect &operator=(const scoped_ostream_redirect &) = delete;\n     scoped_ostream_redirect &operator=(scoped_ostream_redirect &&) = delete;\n };\n \n-\n /** \\rst\n     Like `scoped_ostream_redirect`, but redirects cerr by default. This class\n     is provided primary to make ``py::call_guard`` easier to make.\n@@ -135,14 +191,13 @@ class scoped_ostream_redirect {\n \\endrst */\n class scoped_estream_redirect : public scoped_ostream_redirect {\n public:\n-    scoped_estream_redirect(\n-            std::ostream &costream = std::cerr,\n-            object pyostream = module::import(\"sys\").attr(\"stderr\"))\n-        : scoped_ostream_redirect(costream,pyostream) {}\n+    explicit scoped_estream_redirect(std::ostream &costream = std::cerr,\n+                                     const object &pyostream\n+                                     = module_::import(\"sys\").attr(\"stderr\"))\n+        : scoped_ostream_redirect(costream, pyostream) {}\n };\n \n-\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n // Class to redirect output as a context manager. C++ backend.\n class OstreamRedirect {\n@@ -152,14 +207,16 @@ class OstreamRedirect {\n     std::unique_ptr<scoped_estream_redirect> redirect_stderr;\n \n public:\n-    OstreamRedirect(bool do_stdout = true, bool do_stderr = true)\n+    explicit OstreamRedirect(bool do_stdout = true, bool do_stderr = true)\n         : do_stdout_(do_stdout), do_stderr_(do_stderr) {}\n \n     void enter() {\n-        if (do_stdout_)\n+        if (do_stdout_) {\n             redirect_stdout.reset(new scoped_ostream_redirect());\n-        if (do_stderr_)\n+        }\n+        if (do_stderr_) {\n             redirect_stderr.reset(new scoped_estream_redirect());\n+        }\n     }\n \n     void exit() {\n@@ -168,7 +225,7 @@ class OstreamRedirect {\n     }\n };\n \n-NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(detail)\n \n /** \\rst\n     This is a helper function to add a C++ redirect context manager to Python\n@@ -197,11 +254,12 @@ NAMESPACE_END(detail)\n             m.noisy_function_with_error_printing()\n \n  \\endrst */\n-inline class_<detail::OstreamRedirect> add_ostream_redirect(module m, std::string name = \"ostream_redirect\") {\n-    return class_<detail::OstreamRedirect>(m, name.c_str(), module_local())\n-        .def(init<bool,bool>(), arg(\"stdout\")=true, arg(\"stderr\")=true)\n+inline class_<detail::OstreamRedirect>\n+add_ostream_redirect(module_ m, const std::string &name = \"ostream_redirect\") {\n+    return class_<detail::OstreamRedirect>(std::move(m), name.c_str(), module_local())\n+        .def(init<bool, bool>(), arg(\"stdout\") = true, arg(\"stderr\") = true)\n         .def(\"__enter__\", &detail::OstreamRedirect::enter)\n-        .def(\"__exit__\", [](detail::OstreamRedirect &self_, args) { self_.exit(); });\n+        .def(\"__exit__\", [](detail::OstreamRedirect &self_, const args &) { self_.exit(); });\n }\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/numpy.h", "status": "modified", "additions": 941, "deletions": 567, "changes": 1508, "file_content_changes": "N/A"}, {"filename": "python/src/pybind11/operators.h", "status": "modified", "additions": 146, "deletions": 113, "changes": 259, "file_content_changes": "@@ -11,24 +11,55 @@\n \n #include \"pybind11.h\"\n \n-#if defined(__clang__) && !defined(__INTEL_COMPILER)\n-#  pragma clang diagnostic ignored \"-Wunsequenced\" // multiple unsequenced modifications to 'self' (when using def(py::self OP Type()))\n-#elif defined(_MSC_VER)\n-#  pragma warning(push)\n-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant\n-#endif\n-\n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n /// Enumeration with all supported operator types\n enum op_id : int {\n-    op_add, op_sub, op_mul, op_div, op_mod, op_divmod, op_pow, op_lshift,\n-    op_rshift, op_and, op_xor, op_or, op_neg, op_pos, op_abs, op_invert,\n-    op_int, op_long, op_float, op_str, op_cmp, op_gt, op_ge, op_lt, op_le,\n-    op_eq, op_ne, op_iadd, op_isub, op_imul, op_idiv, op_imod, op_ilshift,\n-    op_irshift, op_iand, op_ixor, op_ior, op_complex, op_bool, op_nonzero,\n-    op_repr, op_truediv, op_itruediv, op_hash\n+    op_add,\n+    op_sub,\n+    op_mul,\n+    op_div,\n+    op_mod,\n+    op_divmod,\n+    op_pow,\n+    op_lshift,\n+    op_rshift,\n+    op_and,\n+    op_xor,\n+    op_or,\n+    op_neg,\n+    op_pos,\n+    op_abs,\n+    op_invert,\n+    op_int,\n+    op_long,\n+    op_float,\n+    op_str,\n+    op_cmp,\n+    op_gt,\n+    op_ge,\n+    op_lt,\n+    op_le,\n+    op_eq,\n+    op_ne,\n+    op_iadd,\n+    op_isub,\n+    op_imul,\n+    op_idiv,\n+    op_imod,\n+    op_ilshift,\n+    op_irshift,\n+    op_iand,\n+    op_ixor,\n+    op_ior,\n+    op_complex,\n+    op_bool,\n+    op_nonzero,\n+    op_repr,\n+    op_truediv,\n+    op_itruediv,\n+    op_hash\n };\n \n enum op_type : int {\n@@ -37,132 +68,134 @@ enum op_type : int {\n     op_u  /* unary operator */\n };\n \n-struct self_t { };\n+struct self_t {};\n static const self_t self = self_t();\n \n /// Type for an unused type slot\n-struct undefined_t { };\n+struct undefined_t {};\n \n /// Don't warn about an unused variable\n inline self_t __self() { return self; }\n \n /// base template of operator implementations\n-template <op_id, op_type, typename B, typename L, typename R> struct op_impl { };\n+template <op_id, op_type, typename B, typename L, typename R>\n+struct op_impl {};\n \n /// Operator implementation generator\n-template <op_id id, op_type ot, typename L, typename R> struct op_ {\n-    template <typename Class, typename... Extra> void execute(Class &cl, const Extra&... extra) const {\n+template <op_id id, op_type ot, typename L, typename R>\n+struct op_ {\n+    template <typename Class, typename... Extra>\n+    void execute(Class &cl, const Extra &...extra) const {\n         using Base = typename Class::type;\n         using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;\n         using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;\n         using op = op_impl<id, ot, Base, L_type, R_type>;\n         cl.def(op::name(), &op::execute, is_operator(), extra...);\n-        #if PY_MAJOR_VERSION < 3\n-        if (id == op_truediv || id == op_itruediv)\n-            cl.def(id == op_itruediv ? \"__idiv__\" : ot == op_l ? \"__div__\" : \"__rdiv__\",\n-                    &op::execute, is_operator(), extra...);\n-        #endif\n     }\n-    template <typename Class, typename... Extra> void execute_cast(Class &cl, const Extra&... extra) const {\n+    template <typename Class, typename... Extra>\n+    void execute_cast(Class &cl, const Extra &...extra) const {\n         using Base = typename Class::type;\n         using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;\n         using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;\n         using op = op_impl<id, ot, Base, L_type, R_type>;\n         cl.def(op::name(), &op::execute_cast, is_operator(), extra...);\n-        #if PY_MAJOR_VERSION < 3\n-        if (id == op_truediv || id == op_itruediv)\n-            cl.def(id == op_itruediv ? \"__idiv__\" : ot == op_l ? \"__div__\" : \"__rdiv__\",\n-                    &op::execute, is_operator(), extra...);\n-        #endif\n     }\n };\n \n-#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                    \\\n-template <typename B, typename L, typename R> struct op_impl<op_##id, op_l, B, L, R> { \\\n-    static char const* name() { return \"__\" #id \"__\"; }                                \\\n-    static auto execute(const L &l, const R &r) -> decltype(expr) { return (expr); }   \\\n-    static B execute_cast(const L &l, const R &r) { return B(expr); }                  \\\n-};                                                                                     \\\n-template <typename B, typename L, typename R> struct op_impl<op_##id, op_r, B, L, R> { \\\n-    static char const* name() { return \"__\" #rid \"__\"; }                               \\\n-    static auto execute(const R &r, const L &l) -> decltype(expr) { return (expr); }   \\\n-    static B execute_cast(const R &r, const L &l) { return B(expr); }                  \\\n-};                                                                                     \\\n-inline op_<op_##id, op_l, self_t, self_t> op(const self_t &, const self_t &) {         \\\n-    return op_<op_##id, op_l, self_t, self_t>();                                       \\\n-}                                                                                      \\\n-template <typename T> op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {    \\\n-    return op_<op_##id, op_l, self_t, T>();                                            \\\n-}                                                                                      \\\n-template <typename T> op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {    \\\n-    return op_<op_##id, op_r, T, self_t>();                                            \\\n-}\n-\n-#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                        \\\n-template <typename B, typename L, typename R> struct op_impl<op_##id, op_l, B, L, R> { \\\n-    static char const* name() { return \"__\" #id \"__\"; }                                \\\n-    static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }           \\\n-    static B execute_cast(L &l, const R &r) { return B(expr); }                        \\\n-};                                                                                     \\\n-template <typename T> op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {    \\\n-    return op_<op_##id, op_l, self_t, T>();                                            \\\n-}\n-\n-#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                          \\\n-template <typename B, typename L> struct op_impl<op_##id, op_u, B, L, undefined_t> {   \\\n-    static char const* name() { return \"__\" #id \"__\"; }                                \\\n-    static auto execute(const L &l) -> decltype(expr) { return expr; }                 \\\n-    static B execute_cast(const L &l) { return B(expr); }                              \\\n-};                                                                                     \\\n-inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {                    \\\n-    return op_<op_##id, op_u, self_t, undefined_t>();                                  \\\n-}\n-\n-PYBIND11_BINARY_OPERATOR(sub,       rsub,         operator-,    l - r)\n-PYBIND11_BINARY_OPERATOR(add,       radd,         operator+,    l + r)\n-PYBIND11_BINARY_OPERATOR(mul,       rmul,         operator*,    l * r)\n-PYBIND11_BINARY_OPERATOR(truediv,   rtruediv,     operator/,    l / r)\n-PYBIND11_BINARY_OPERATOR(mod,       rmod,         operator%,    l % r)\n-PYBIND11_BINARY_OPERATOR(lshift,    rlshift,      operator<<,   l << r)\n-PYBIND11_BINARY_OPERATOR(rshift,    rrshift,      operator>>,   l >> r)\n-PYBIND11_BINARY_OPERATOR(and,       rand,         operator&,    l & r)\n-PYBIND11_BINARY_OPERATOR(xor,       rxor,         operator^,    l ^ r)\n-PYBIND11_BINARY_OPERATOR(eq,        eq,           operator==,   l == r)\n-PYBIND11_BINARY_OPERATOR(ne,        ne,           operator!=,   l != r)\n-PYBIND11_BINARY_OPERATOR(or,        ror,          operator|,    l | r)\n-PYBIND11_BINARY_OPERATOR(gt,        lt,           operator>,    l > r)\n-PYBIND11_BINARY_OPERATOR(ge,        le,           operator>=,   l >= r)\n-PYBIND11_BINARY_OPERATOR(lt,        gt,           operator<,    l < r)\n-PYBIND11_BINARY_OPERATOR(le,        ge,           operator<=,   l <= r)\n-//PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,  r))\n-PYBIND11_INPLACE_OPERATOR(iadd,     operator+=,   l += r)\n-PYBIND11_INPLACE_OPERATOR(isub,     operator-=,   l -= r)\n-PYBIND11_INPLACE_OPERATOR(imul,     operator*=,   l *= r)\n-PYBIND11_INPLACE_OPERATOR(itruediv, operator/=,   l /= r)\n-PYBIND11_INPLACE_OPERATOR(imod,     operator%=,   l %= r)\n-PYBIND11_INPLACE_OPERATOR(ilshift,  operator<<=,  l <<= r)\n-PYBIND11_INPLACE_OPERATOR(irshift,  operator>>=,  l >>= r)\n-PYBIND11_INPLACE_OPERATOR(iand,     operator&=,   l &= r)\n-PYBIND11_INPLACE_OPERATOR(ixor,     operator^=,   l ^= r)\n-PYBIND11_INPLACE_OPERATOR(ior,      operator|=,   l |= r)\n-PYBIND11_UNARY_OPERATOR(neg,        operator-,    -l)\n-PYBIND11_UNARY_OPERATOR(pos,        operator+,    +l)\n-PYBIND11_UNARY_OPERATOR(abs,        abs,          std::abs(l))\n-PYBIND11_UNARY_OPERATOR(hash,       hash,         std::hash<L>()(l))\n-PYBIND11_UNARY_OPERATOR(invert,     operator~,    (~l))\n-PYBIND11_UNARY_OPERATOR(bool,       operator!,    !!l)\n-PYBIND11_UNARY_OPERATOR(int,        int_,         (int) l)\n-PYBIND11_UNARY_OPERATOR(float,      float_,       (double) l)\n+#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                               \\\n+    template <typename B, typename L, typename R>                                                 \\\n+    struct op_impl<op_##id, op_l, B, L, R> {                                                      \\\n+        static char const *name() { return \"__\" #id \"__\"; }                                       \\\n+        static auto execute(const L &l, const R &r) -> decltype(expr) { return (expr); }          \\\n+        static B execute_cast(const L &l, const R &r) { return B(expr); }                         \\\n+    };                                                                                            \\\n+    template <typename B, typename L, typename R>                                                 \\\n+    struct op_impl<op_##id, op_r, B, L, R> {                                                      \\\n+        static char const *name() { return \"__\" #rid \"__\"; }                                      \\\n+        static auto execute(const R &r, const L &l) -> decltype(expr) { return (expr); }          \\\n+        static B execute_cast(const R &r, const L &l) { return B(expr); }                         \\\n+    };                                                                                            \\\n+    inline op_<op_##id, op_l, self_t, self_t> op(const self_t &, const self_t &) {                \\\n+        return op_<op_##id, op_l, self_t, self_t>();                                              \\\n+    }                                                                                             \\\n+    template <typename T>                                                                         \\\n+    op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                                 \\\n+        return op_<op_##id, op_l, self_t, T>();                                                   \\\n+    }                                                                                             \\\n+    template <typename T>                                                                         \\\n+    op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {                                 \\\n+        return op_<op_##id, op_r, T, self_t>();                                                   \\\n+    }\n+\n+#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                                   \\\n+    template <typename B, typename L, typename R>                                                 \\\n+    struct op_impl<op_##id, op_l, B, L, R> {                                                      \\\n+        static char const *name() { return \"__\" #id \"__\"; }                                       \\\n+        static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }                  \\\n+        static B execute_cast(L &l, const R &r) { return B(expr); }                               \\\n+    };                                                                                            \\\n+    template <typename T>                                                                         \\\n+    op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                                 \\\n+        return op_<op_##id, op_l, self_t, T>();                                                   \\\n+    }\n+\n+#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                                     \\\n+    template <typename B, typename L>                                                             \\\n+    struct op_impl<op_##id, op_u, B, L, undefined_t> {                                            \\\n+        static char const *name() { return \"__\" #id \"__\"; }                                       \\\n+        static auto execute(const L &l) -> decltype(expr) { return expr; }                        \\\n+        static B execute_cast(const L &l) { return B(expr); }                                     \\\n+    };                                                                                            \\\n+    inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {                           \\\n+        return op_<op_##id, op_u, self_t, undefined_t>();                                         \\\n+    }\n+\n+PYBIND11_BINARY_OPERATOR(sub, rsub, operator-, l - r)\n+PYBIND11_BINARY_OPERATOR(add, radd, operator+, l + r)\n+PYBIND11_BINARY_OPERATOR(mul, rmul, operator*, l *r)\n+PYBIND11_BINARY_OPERATOR(truediv, rtruediv, operator/, l / r)\n+PYBIND11_BINARY_OPERATOR(mod, rmod, operator%, l % r)\n+PYBIND11_BINARY_OPERATOR(lshift, rlshift, operator<<, l << r)\n+PYBIND11_BINARY_OPERATOR(rshift, rrshift, operator>>, l >> r)\n+PYBIND11_BINARY_OPERATOR(and, rand, operator&, l &r)\n+PYBIND11_BINARY_OPERATOR(xor, rxor, operator^, l ^ r)\n+PYBIND11_BINARY_OPERATOR(eq, eq, operator==, l == r)\n+PYBIND11_BINARY_OPERATOR(ne, ne, operator!=, l != r)\n+PYBIND11_BINARY_OPERATOR(or, ror, operator|, l | r)\n+PYBIND11_BINARY_OPERATOR(gt, lt, operator>, l > r)\n+PYBIND11_BINARY_OPERATOR(ge, le, operator>=, l >= r)\n+PYBIND11_BINARY_OPERATOR(lt, gt, operator<, l < r)\n+PYBIND11_BINARY_OPERATOR(le, ge, operator<=, l <= r)\n+// PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,  r))\n+PYBIND11_INPLACE_OPERATOR(iadd, operator+=, l += r)\n+PYBIND11_INPLACE_OPERATOR(isub, operator-=, l -= r)\n+PYBIND11_INPLACE_OPERATOR(imul, operator*=, l *= r)\n+PYBIND11_INPLACE_OPERATOR(itruediv, operator/=, l /= r)\n+PYBIND11_INPLACE_OPERATOR(imod, operator%=, l %= r)\n+PYBIND11_INPLACE_OPERATOR(ilshift, operator<<=, l <<= r)\n+PYBIND11_INPLACE_OPERATOR(irshift, operator>>=, l >>= r)\n+PYBIND11_INPLACE_OPERATOR(iand, operator&=, l &= r)\n+PYBIND11_INPLACE_OPERATOR(ixor, operator^=, l ^= r)\n+PYBIND11_INPLACE_OPERATOR(ior, operator|=, l |= r)\n+PYBIND11_UNARY_OPERATOR(neg, operator-, -l)\n+PYBIND11_UNARY_OPERATOR(pos, operator+, +l)\n+// WARNING: This usage of `abs` should only be done for existing STL overloads.\n+// Adding overloads directly in to the `std::` namespace is advised against:\n+// https://en.cppreference.com/w/cpp/language/extending_std\n+PYBIND11_UNARY_OPERATOR(abs, abs, std::abs(l))\n+PYBIND11_UNARY_OPERATOR(hash, hash, std::hash<L>()(l))\n+PYBIND11_UNARY_OPERATOR(invert, operator~, (~l))\n+PYBIND11_UNARY_OPERATOR(bool, operator!, !!l)\n+PYBIND11_UNARY_OPERATOR(int, int_, (int) l)\n+PYBIND11_UNARY_OPERATOR(float, float_, (double) l)\n \n #undef PYBIND11_BINARY_OPERATOR\n #undef PYBIND11_INPLACE_OPERATOR\n #undef PYBIND11_UNARY_OPERATOR\n-NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(detail)\n \n using detail::self;\n+// Add named operators so that they are accessible via `py::`.\n+using detail::hash;\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n-\n-#if defined(_MSC_VER)\n-#  pragma warning(pop)\n-#endif\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/options.h", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "file_content_changes": "@@ -11,47 +11,58 @@\n \n #include \"detail/common.h\"\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n \n class options {\n public:\n-\n     // Default RAII constructor, which leaves settings as they currently are.\n     options() : previous_state(global_state()) {}\n \n     // Class is non-copyable.\n-    options(const options&) = delete;\n-    options& operator=(const options&) = delete;\n+    options(const options &) = delete;\n+    options &operator=(const options &) = delete;\n \n     // Destructor, which restores settings that were in effect before.\n-    ~options() {\n-        global_state() = previous_state;\n-    }\n+    ~options() { global_state() = previous_state; }\n \n     // Setter methods (affect the global state):\n \n-    options& disable_user_defined_docstrings() & { global_state().show_user_defined_docstrings = false; return *this; }\n+    options &disable_user_defined_docstrings() & {\n+        global_state().show_user_defined_docstrings = false;\n+        return *this;\n+    }\n \n-    options& enable_user_defined_docstrings() & { global_state().show_user_defined_docstrings = true; return *this; }\n+    options &enable_user_defined_docstrings() & {\n+        global_state().show_user_defined_docstrings = true;\n+        return *this;\n+    }\n \n-    options& disable_function_signatures() & { global_state().show_function_signatures = false; return *this; }\n+    options &disable_function_signatures() & {\n+        global_state().show_function_signatures = false;\n+        return *this;\n+    }\n \n-    options& enable_function_signatures() & { global_state().show_function_signatures = true; return *this; }\n+    options &enable_function_signatures() & {\n+        global_state().show_function_signatures = true;\n+        return *this;\n+    }\n \n     // Getter methods (return the global state):\n \n-    static bool show_user_defined_docstrings() { return global_state().show_user_defined_docstrings; }\n+    static bool show_user_defined_docstrings() {\n+        return global_state().show_user_defined_docstrings;\n+    }\n \n     static bool show_function_signatures() { return global_state().show_function_signatures; }\n \n     // This type is not meant to be allocated on the heap.\n-    void* operator new(size_t) = delete;\n+    void *operator new(size_t) = delete;\n \n private:\n-\n     struct state {\n-        bool show_user_defined_docstrings = true;  //< Include user-supplied texts in docstrings.\n-        bool show_function_signatures = true;      //< Include auto-generated function signatures in docstrings.\n+        bool show_user_defined_docstrings = true; //< Include user-supplied texts in docstrings.\n+        bool show_function_signatures = true;     //< Include auto-generated function signatures\n+                                                  //  in docstrings.\n     };\n \n     static state &global_state() {\n@@ -62,4 +73,4 @@ class options {\n     state previous_state;\n };\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/pybind11.h", "status": "modified", "additions": 1639, "deletions": 937, "changes": 2576, "file_content_changes": "N/A"}, {"filename": "python/src/pybind11/pytypes.h", "status": "modified", "additions": 1375, "deletions": 454, "changes": 1829, "file_content_changes": "N/A"}, {"filename": "python/src/pybind11/stl.h", "status": "modified", "additions": 165, "deletions": 126, "changes": 291, "file_content_changes": "@@ -10,52 +10,37 @@\n #pragma once\n \n #include \"pybind11.h\"\n-#include <set>\n-#include <unordered_set>\n+#include \"detail/common.h\"\n+\n+#include <deque>\n+#include <list>\n #include <map>\n+#include <ostream>\n+#include <set>\n #include <unordered_map>\n-#include <iostream>\n-#include <list>\n-#include <deque>\n+#include <unordered_set>\n #include <valarray>\n \n-#if defined(_MSC_VER)\n-#pragma warning(push)\n-#pragma warning(disable: 4127) // warning C4127: Conditional expression is constant\n-#endif\n-\n-#ifdef __has_include\n-// std::optional (but including it in c++14 mode isn't allowed)\n-#  if defined(PYBIND11_CPP17) && __has_include(<optional>)\n+// See `detail/common.h` for implementation of these guards.\n+#if defined(PYBIND11_HAS_OPTIONAL)\n #    include <optional>\n-#    define PYBIND11_HAS_OPTIONAL 1\n-#  endif\n-// std::experimental::optional (but not allowed in c++11 mode)\n-#  if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \\\n-                                 !__has_include(<optional>))\n+#elif defined(PYBIND11_HAS_EXP_OPTIONAL)\n #    include <experimental/optional>\n-#    define PYBIND11_HAS_EXP_OPTIONAL 1\n-#  endif\n-// std::variant\n-#  if defined(PYBIND11_CPP17) && __has_include(<variant>)\n+#endif\n+\n+#if defined(PYBIND11_HAS_VARIANT)\n #    include <variant>\n-#    define PYBIND11_HAS_VARIANT 1\n-#  endif\n-#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)\n-#  include <optional>\n-#  include <variant>\n-#  define PYBIND11_HAS_OPTIONAL 1\n-#  define PYBIND11_HAS_VARIANT 1\n #endif\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n /// Extracts an const lvalue reference or rvalue reference for U based on the type of T (e.g. for\n /// forwarding a container element).  Typically used indirect via forwarded_type(), below.\n template <typename T, typename U>\n-using forwarded_type = conditional_t<\n-    std::is_lvalue_reference<T>::value, remove_reference_t<U> &, remove_reference_t<U> &&>;\n+using forwarded_type = conditional_t<std::is_lvalue_reference<T>::value,\n+                                     remove_reference_t<U> &,\n+                                     remove_reference_t<U> &&>;\n \n /// Forwards a value U as rvalue or lvalue according to whether T is rvalue or lvalue; typically\n /// used for forwarding a container's elements.\n@@ -64,55 +49,63 @@ forwarded_type<T, U> forward_like(U &&u) {\n     return std::forward<detail::forwarded_type<T, U>>(std::forward<U>(u));\n }\n \n-template <typename Type, typename Key> struct set_caster {\n+template <typename Type, typename Key>\n+struct set_caster {\n     using type = Type;\n     using key_conv = make_caster<Key>;\n \n     bool load(handle src, bool convert) {\n-        if (!isinstance<pybind11::set>(src))\n+        if (!isinstance<anyset>(src)) {\n             return false;\n-        auto s = reinterpret_borrow<pybind11::set>(src);\n+        }\n+        auto s = reinterpret_borrow<anyset>(src);\n         value.clear();\n         for (auto entry : s) {\n             key_conv conv;\n-            if (!conv.load(entry, convert))\n+            if (!conv.load(entry, convert)) {\n                 return false;\n+            }\n             value.insert(cast_op<Key &&>(std::move(conv)));\n         }\n         return true;\n     }\n \n     template <typename T>\n     static handle cast(T &&src, return_value_policy policy, handle parent) {\n-        if (!std::is_lvalue_reference<T>::value)\n+        if (!std::is_lvalue_reference<T>::value) {\n             policy = return_value_policy_override<Key>::policy(policy);\n+        }\n         pybind11::set s;\n         for (auto &&value : src) {\n-            auto value_ = reinterpret_steal<object>(key_conv::cast(forward_like<T>(value), policy, parent));\n-            if (!value_ || !s.add(value_))\n+            auto value_ = reinterpret_steal<object>(\n+                key_conv::cast(forward_like<T>(value), policy, parent));\n+            if (!value_ || !s.add(std::move(value_))) {\n                 return handle();\n+            }\n         }\n         return s.release();\n     }\n \n-    PYBIND11_TYPE_CASTER(type, _(\"Set[\") + key_conv::name + _(\"]\"));\n+    PYBIND11_TYPE_CASTER(type, const_name(\"Set[\") + key_conv::name + const_name(\"]\"));\n };\n \n-template <typename Type, typename Key, typename Value> struct map_caster {\n-    using key_conv   = make_caster<Key>;\n+template <typename Type, typename Key, typename Value>\n+struct map_caster {\n+    using key_conv = make_caster<Key>;\n     using value_conv = make_caster<Value>;\n \n     bool load(handle src, bool convert) {\n-        if (!isinstance<dict>(src))\n+        if (!isinstance<dict>(src)) {\n             return false;\n+        }\n         auto d = reinterpret_borrow<dict>(src);\n         value.clear();\n         for (auto it : d) {\n             key_conv kconv;\n             value_conv vconv;\n-            if (!kconv.load(it.first.ptr(), convert) ||\n-                !vconv.load(it.second.ptr(), convert))\n+            if (!kconv.load(it.first.ptr(), convert) || !vconv.load(it.second.ptr(), convert)) {\n                 return false;\n+            }\n             value.emplace(cast_op<Key &&>(std::move(kconv)), cast_op<Value &&>(std::move(vconv)));\n         }\n         return true;\n@@ -128,78 +121,94 @@ template <typename Type, typename Key, typename Value> struct map_caster {\n             policy_value = return_value_policy_override<Value>::policy(policy_value);\n         }\n         for (auto &&kv : src) {\n-            auto key = reinterpret_steal<object>(key_conv::cast(forward_like<T>(kv.first), policy_key, parent));\n-            auto value = reinterpret_steal<object>(value_conv::cast(forward_like<T>(kv.second), policy_value, parent));\n-            if (!key || !value)\n+            auto key = reinterpret_steal<object>(\n+                key_conv::cast(forward_like<T>(kv.first), policy_key, parent));\n+            auto value = reinterpret_steal<object>(\n+                value_conv::cast(forward_like<T>(kv.second), policy_value, parent));\n+            if (!key || !value) {\n                 return handle();\n-            d[key] = value;\n+            }\n+            d[std::move(key)] = std::move(value);\n         }\n         return d.release();\n     }\n \n-    PYBIND11_TYPE_CASTER(Type, _(\"Dict[\") + key_conv::name + _(\", \") + value_conv::name + _(\"]\"));\n+    PYBIND11_TYPE_CASTER(Type,\n+                         const_name(\"Dict[\") + key_conv::name + const_name(\", \") + value_conv::name\n+                             + const_name(\"]\"));\n };\n \n-template <typename Type, typename Value> struct list_caster {\n+template <typename Type, typename Value>\n+struct list_caster {\n     using value_conv = make_caster<Value>;\n \n     bool load(handle src, bool convert) {\n-        if (!isinstance<sequence>(src) || isinstance<str>(src))\n+        if (!isinstance<sequence>(src) || isinstance<bytes>(src) || isinstance<str>(src)) {\n             return false;\n+        }\n         auto s = reinterpret_borrow<sequence>(src);\n         value.clear();\n         reserve_maybe(s, &value);\n         for (auto it : s) {\n             value_conv conv;\n-            if (!conv.load(it, convert))\n+            if (!conv.load(it, convert)) {\n                 return false;\n+            }\n             value.push_back(cast_op<Value &&>(std::move(conv)));\n         }\n         return true;\n     }\n \n private:\n-    template <typename T = Type,\n-              enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)), void>::value, int> = 0>\n-    void reserve_maybe(sequence s, Type *) { value.reserve(s.size()); }\n-    void reserve_maybe(sequence, void *) { }\n+    template <\n+        typename T = Type,\n+        enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)), void>::value, int> = 0>\n+    void reserve_maybe(const sequence &s, Type *) {\n+        value.reserve(s.size());\n+    }\n+    void reserve_maybe(const sequence &, void *) {}\n \n public:\n     template <typename T>\n     static handle cast(T &&src, return_value_policy policy, handle parent) {\n-        if (!std::is_lvalue_reference<T>::value)\n+        if (!std::is_lvalue_reference<T>::value) {\n             policy = return_value_policy_override<Value>::policy(policy);\n+        }\n         list l(src.size());\n-        size_t index = 0;\n+        ssize_t index = 0;\n         for (auto &&value : src) {\n-            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));\n-            if (!value_)\n+            auto value_ = reinterpret_steal<object>(\n+                value_conv::cast(forward_like<T>(value), policy, parent));\n+            if (!value_) {\n                 return handle();\n-            PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference\n+            }\n+            PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference\n         }\n         return l.release();\n     }\n \n-    PYBIND11_TYPE_CASTER(Type, _(\"List[\") + value_conv::name + _(\"]\"));\n+    PYBIND11_TYPE_CASTER(Type, const_name(\"List[\") + value_conv::name + const_name(\"]\"));\n };\n \n-template <typename Type, typename Alloc> struct type_caster<std::vector<Type, Alloc>>\n- : list_caster<std::vector<Type, Alloc>, Type> { };\n+template <typename Type, typename Alloc>\n+struct type_caster<std::vector<Type, Alloc>> : list_caster<std::vector<Type, Alloc>, Type> {};\n \n-template <typename Type, typename Alloc> struct type_caster<std::deque<Type, Alloc>>\n- : list_caster<std::deque<Type, Alloc>, Type> { };\n+template <typename Type, typename Alloc>\n+struct type_caster<std::deque<Type, Alloc>> : list_caster<std::deque<Type, Alloc>, Type> {};\n \n-template <typename Type, typename Alloc> struct type_caster<std::list<Type, Alloc>>\n- : list_caster<std::list<Type, Alloc>, Type> { };\n+template <typename Type, typename Alloc>\n+struct type_caster<std::list<Type, Alloc>> : list_caster<std::list<Type, Alloc>, Type> {};\n \n-template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0> struct array_caster {\n+template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0>\n+struct array_caster {\n     using value_conv = make_caster<Value>;\n \n private:\n     template <bool R = Resizable>\n     bool require_size(enable_if_t<R, size_t> size) {\n-        if (value.size() != size)\n+        if (value.size() != size) {\n             value.resize(size);\n+        }\n         return true;\n     }\n     template <bool R = Resizable>\n@@ -209,16 +218,19 @@ template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0> s\n \n public:\n     bool load(handle src, bool convert) {\n-        if (!isinstance<sequence>(src))\n+        if (!isinstance<sequence>(src)) {\n             return false;\n+        }\n         auto l = reinterpret_borrow<sequence>(src);\n-        if (!require_size(l.size()))\n+        if (!require_size(l.size())) {\n             return false;\n+        }\n         size_t ctr = 0;\n         for (auto it : l) {\n             value_conv conv;\n-            if (!conv.load(it, convert))\n+            if (!conv.load(it, convert)) {\n                 return false;\n+            }\n             value[ctr++] = cast_op<Value &&>(std::move(conv));\n         }\n         return true;\n@@ -227,79 +239,99 @@ template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0> s\n     template <typename T>\n     static handle cast(T &&src, return_value_policy policy, handle parent) {\n         list l(src.size());\n-        size_t index = 0;\n+        ssize_t index = 0;\n         for (auto &&value : src) {\n-            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));\n-            if (!value_)\n+            auto value_ = reinterpret_steal<object>(\n+                value_conv::cast(forward_like<T>(value), policy, parent));\n+            if (!value_) {\n                 return handle();\n-            PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference\n+            }\n+            PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference\n         }\n         return l.release();\n     }\n \n-    PYBIND11_TYPE_CASTER(ArrayType, _(\"List[\") + value_conv::name + _<Resizable>(_(\"\"), _(\"[\") + _<Size>() + _(\"]\")) + _(\"]\"));\n+    PYBIND11_TYPE_CASTER(ArrayType,\n+                         const_name(\"List[\") + value_conv::name\n+                             + const_name<Resizable>(const_name(\"\"),\n+                                                     const_name(\"[\") + const_name<Size>()\n+                                                         + const_name(\"]\"))\n+                             + const_name(\"]\"));\n };\n \n-template <typename Type, size_t Size> struct type_caster<std::array<Type, Size>>\n- : array_caster<std::array<Type, Size>, Type, false, Size> { };\n+template <typename Type, size_t Size>\n+struct type_caster<std::array<Type, Size>>\n+    : array_caster<std::array<Type, Size>, Type, false, Size> {};\n \n-template <typename Type> struct type_caster<std::valarray<Type>>\n- : array_caster<std::valarray<Type>, Type, true> { };\n+template <typename Type>\n+struct type_caster<std::valarray<Type>> : array_caster<std::valarray<Type>, Type, true> {};\n \n-template <typename Key, typename Compare, typename Alloc> struct type_caster<std::set<Key, Compare, Alloc>>\n-  : set_caster<std::set<Key, Compare, Alloc>, Key> { };\n+template <typename Key, typename Compare, typename Alloc>\n+struct type_caster<std::set<Key, Compare, Alloc>>\n+    : set_caster<std::set<Key, Compare, Alloc>, Key> {};\n \n-template <typename Key, typename Hash, typename Equal, typename Alloc> struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>\n-  : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> { };\n+template <typename Key, typename Hash, typename Equal, typename Alloc>\n+struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>\n+    : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> {};\n \n-template <typename Key, typename Value, typename Compare, typename Alloc> struct type_caster<std::map<Key, Value, Compare, Alloc>>\n-  : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> { };\n+template <typename Key, typename Value, typename Compare, typename Alloc>\n+struct type_caster<std::map<Key, Value, Compare, Alloc>>\n+    : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> {};\n \n-template <typename Key, typename Value, typename Hash, typename Equal, typename Alloc> struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>\n-  : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key, Value> { };\n+template <typename Key, typename Value, typename Hash, typename Equal, typename Alloc>\n+struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>\n+    : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key, Value> {};\n \n // This type caster is intended to be used for std::optional and std::experimental::optional\n-template<typename T> struct optional_caster {\n-    using value_conv = make_caster<typename T::value_type>;\n+template <typename Type, typename Value = typename Type::value_type>\n+struct optional_caster {\n+    using value_conv = make_caster<Value>;\n \n-    template <typename T_>\n-    static handle cast(T_ &&src, return_value_policy policy, handle parent) {\n-        if (!src)\n+    template <typename T>\n+    static handle cast(T &&src, return_value_policy policy, handle parent) {\n+        if (!src) {\n             return none().inc_ref();\n-        policy = return_value_policy_override<typename T::value_type>::policy(policy);\n-        return value_conv::cast(*std::forward<T_>(src), policy, parent);\n+        }\n+        if (!std::is_lvalue_reference<T>::value) {\n+            policy = return_value_policy_override<Value>::policy(policy);\n+        }\n+        return value_conv::cast(*std::forward<T>(src), policy, parent);\n     }\n \n     bool load(handle src, bool convert) {\n         if (!src) {\n             return false;\n-        } else if (src.is_none()) {\n-            return true;  // default-constructed value is already empty\n+        }\n+        if (src.is_none()) {\n+            return true; // default-constructed value is already empty\n         }\n         value_conv inner_caster;\n-        if (!inner_caster.load(src, convert))\n+        if (!inner_caster.load(src, convert)) {\n             return false;\n+        }\n \n-        value.emplace(cast_op<typename T::value_type &&>(std::move(inner_caster)));\n+        value.emplace(cast_op<Value &&>(std::move(inner_caster)));\n         return true;\n     }\n \n-    PYBIND11_TYPE_CASTER(T, _(\"Optional[\") + value_conv::name + _(\"]\"));\n+    PYBIND11_TYPE_CASTER(Type, const_name(\"Optional[\") + value_conv::name + const_name(\"]\"));\n };\n \n-#if PYBIND11_HAS_OPTIONAL\n-template<typename T> struct type_caster<std::optional<T>>\n-    : public optional_caster<std::optional<T>> {};\n+#if defined(PYBIND11_HAS_OPTIONAL)\n+template <typename T>\n+struct type_caster<std::optional<T>> : public optional_caster<std::optional<T>> {};\n \n-template<> struct type_caster<std::nullopt_t>\n-    : public void_caster<std::nullopt_t> {};\n+template <>\n+struct type_caster<std::nullopt_t> : public void_caster<std::nullopt_t> {};\n #endif\n \n-#if PYBIND11_HAS_EXP_OPTIONAL\n-template<typename T> struct type_caster<std::experimental::optional<T>>\n+#if defined(PYBIND11_HAS_EXP_OPTIONAL)\n+template <typename T>\n+struct type_caster<std::experimental::optional<T>>\n     : public optional_caster<std::experimental::optional<T>> {};\n \n-template<> struct type_caster<std::experimental::nullopt_t>\n+template <>\n+struct type_caster<std::experimental::nullopt_t>\n     : public void_caster<std::experimental::nullopt_t> {};\n #endif\n \n@@ -320,7 +352,7 @@ struct variant_caster_visitor {\n /// `namespace::variant` types which provide a `namespace::visit()` function are handled here\n /// automatically using argument-dependent lookup. Users can provide specializations for other\n /// variant-like classes, e.g. `boost::variant` and `boost::apply_visitor`.\n-template <template<typename...> class Variant>\n+template <template <typename...> class Variant>\n struct visit_helper {\n     template <typename... Args>\n     static auto call(Args &&...args) -> decltype(visit(std::forward<Args>(args)...)) {\n@@ -329,17 +361,18 @@ struct visit_helper {\n };\n \n /// Generic variant caster\n-template <typename Variant> struct variant_caster;\n+template <typename Variant>\n+struct variant_caster;\n \n-template <template<typename...> class V, typename... Ts>\n+template <template <typename...> class V, typename... Ts>\n struct variant_caster<V<Ts...>> {\n     static_assert(sizeof...(Ts) > 0, \"Variant must consist of at least one alternative.\");\n \n     template <typename U, typename... Us>\n     bool load_alternative(handle src, bool convert, type_list<U, Us...>) {\n         auto caster = make_caster<U>();\n         if (caster.load(src, convert)) {\n-            value = cast_op<U>(caster);\n+            value = cast_op<U>(std::move(caster));\n             return true;\n         }\n         return load_alternative(src, convert, type_list<Us...>{});\n@@ -352,8 +385,9 @@ struct variant_caster<V<Ts...>> {\n         // E.g. `py::int_(1).cast<variant<double, int>>()` needs to fill the `int`\n         // slot of the variant. Without two-pass loading `double` would be filled\n         // because it appears first and a conversion is possible.\n-        if (convert && load_alternative(src, false, type_list<Ts...>{}))\n+        if (convert && load_alternative(src, false, type_list<Ts...>{})) {\n             return true;\n+        }\n         return load_alternative(src, convert, type_list<Ts...>{});\n     }\n \n@@ -364,23 +398,28 @@ struct variant_caster<V<Ts...>> {\n     }\n \n     using Type = V<Ts...>;\n-    PYBIND11_TYPE_CASTER(Type, _(\"Union[\") + detail::concat(make_caster<Ts>::name...) + _(\"]\"));\n+    PYBIND11_TYPE_CASTER(Type,\n+                         const_name(\"Union[\") + detail::concat(make_caster<Ts>::name...)\n+                             + const_name(\"]\"));\n };\n \n-#if PYBIND11_HAS_VARIANT\n+#if defined(PYBIND11_HAS_VARIANT)\n template <typename... Ts>\n-struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> { };\n+struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> {};\n+\n+template <>\n+struct type_caster<std::monostate> : public void_caster<std::monostate> {};\n #endif\n \n-NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(detail)\n \n inline std::ostream &operator<<(std::ostream &os, const handle &obj) {\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+    os << str(obj).cast<std::string_view>();\n+#else\n     os << (std::string) str(obj);\n+#endif\n     return os;\n }\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n-\n-#if defined(_MSC_VER)\n-#pragma warning(pop)\n-#endif\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/stl/filesystem.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "file_content_changes": "@@ -0,0 +1,116 @@\n+// Copyright (c) 2021 The Pybind Development Team.\n+// All rights reserved. Use of this source code is governed by a\n+// BSD-style license that can be found in the LICENSE file.\n+\n+#pragma once\n+\n+#include \"../pybind11.h\"\n+#include \"../detail/common.h\"\n+#include \"../detail/descr.h\"\n+#include \"../cast.h\"\n+#include \"../pytypes.h\"\n+\n+#include <string>\n+\n+#ifdef __has_include\n+#    if defined(PYBIND11_CPP17)\n+#        if __has_include(<filesystem>) && \\\n+          PY_VERSION_HEX >= 0x03060000\n+#            include <filesystem>\n+#            define PYBIND11_HAS_FILESYSTEM 1\n+#        elif __has_include(<experimental/filesystem>)\n+#            include <experimental/filesystem>\n+#            define PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM 1\n+#        endif\n+#    endif\n+#endif\n+\n+#if !defined(PYBIND11_HAS_FILESYSTEM) && !defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)           \\\n+    && !defined(PYBIND11_HAS_FILESYSTEM_IS_OPTIONAL)\n+#    error                                                                                        \\\n+        \"Neither #include <filesystem> nor #include <experimental/filesystem is available. (Use -DPYBIND11_HAS_FILESYSTEM_IS_OPTIONAL to ignore.)\"\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+#if defined(PYBIND11_HAS_FILESYSTEM) || defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)\n+template <typename T>\n+struct path_caster {\n+\n+private:\n+    static PyObject *unicode_from_fs_native(const std::string &w) {\n+#    if !defined(PYPY_VERSION)\n+        return PyUnicode_DecodeFSDefaultAndSize(w.c_str(), ssize_t(w.size()));\n+#    else\n+        // PyPy mistakenly declares the first parameter as non-const.\n+        return PyUnicode_DecodeFSDefaultAndSize(const_cast<char *>(w.c_str()), ssize_t(w.size()));\n+#    endif\n+    }\n+\n+    static PyObject *unicode_from_fs_native(const std::wstring &w) {\n+        return PyUnicode_FromWideChar(w.c_str(), ssize_t(w.size()));\n+    }\n+\n+public:\n+    static handle cast(const T &path, return_value_policy, handle) {\n+        if (auto py_str = unicode_from_fs_native(path.native())) {\n+            return module_::import(\"pathlib\")\n+                .attr(\"Path\")(reinterpret_steal<object>(py_str))\n+                .release();\n+        }\n+        return nullptr;\n+    }\n+\n+    bool load(handle handle, bool) {\n+        // PyUnicode_FSConverter and PyUnicode_FSDecoder normally take care of\n+        // calling PyOS_FSPath themselves, but that's broken on PyPy (PyPy\n+        // issue #3168) so we do it ourselves instead.\n+        PyObject *buf = PyOS_FSPath(handle.ptr());\n+        if (!buf) {\n+            PyErr_Clear();\n+            return false;\n+        }\n+        PyObject *native = nullptr;\n+        if constexpr (std::is_same_v<typename T::value_type, char>) {\n+            if (PyUnicode_FSConverter(buf, &native) != 0) {\n+                if (auto *c_str = PyBytes_AsString(native)) {\n+                    // AsString returns a pointer to the internal buffer, which\n+                    // must not be free'd.\n+                    value = c_str;\n+                }\n+            }\n+        } else if constexpr (std::is_same_v<typename T::value_type, wchar_t>) {\n+            if (PyUnicode_FSDecoder(buf, &native) != 0) {\n+                if (auto *c_str = PyUnicode_AsWideCharString(native, nullptr)) {\n+                    // AsWideCharString returns a new string that must be free'd.\n+                    value = c_str; // Copies the string.\n+                    PyMem_Free(c_str);\n+                }\n+            }\n+        }\n+        Py_XDECREF(native);\n+        Py_DECREF(buf);\n+        if (PyErr_Occurred()) {\n+            PyErr_Clear();\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    PYBIND11_TYPE_CASTER(T, const_name(\"os.PathLike\"));\n+};\n+\n+#endif // PYBIND11_HAS_FILESYSTEM || defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)\n+\n+#if defined(PYBIND11_HAS_FILESYSTEM)\n+template <>\n+struct type_caster<std::filesystem::path> : public path_caster<std::filesystem::path> {};\n+#elif defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)\n+template <>\n+struct type_caster<std::experimental::filesystem::path>\n+    : public path_caster<std::experimental::filesystem::path> {};\n+#endif\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/stl_bind.h", "status": "modified", "additions": 438, "deletions": 283, "changes": 721, "file_content_changes": "@@ -15,243 +15,278 @@\n #include <algorithm>\n #include <sstream>\n \n-NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n /* SFINAE helper class used by 'is_comparable */\n-template <typename T>  struct container_traits {\n-    template <typename T2> static std::true_type test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>())*);\n-    template <typename T2> static std::false_type test_comparable(...);\n-    template <typename T2> static std::true_type test_value(typename T2::value_type *);\n-    template <typename T2> static std::false_type test_value(...);\n-    template <typename T2> static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);\n-    template <typename T2> static std::false_type test_pair(...);\n-\n-    static constexpr const bool is_comparable = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;\n-    static constexpr const bool is_pair = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;\n-    static constexpr const bool is_vector = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;\n+template <typename T>\n+struct container_traits {\n+    template <typename T2>\n+    static std::true_type\n+    test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>()) *);\n+    template <typename T2>\n+    static std::false_type test_comparable(...);\n+    template <typename T2>\n+    static std::true_type test_value(typename T2::value_type *);\n+    template <typename T2>\n+    static std::false_type test_value(...);\n+    template <typename T2>\n+    static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);\n+    template <typename T2>\n+    static std::false_type test_pair(...);\n+\n+    static constexpr const bool is_comparable\n+        = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;\n+    static constexpr const bool is_pair\n+        = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;\n+    static constexpr const bool is_vector\n+        = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;\n     static constexpr const bool is_element = !is_pair && !is_vector;\n };\n \n /* Default: is_comparable -> std::false_type */\n template <typename T, typename SFINAE = void>\n-struct is_comparable : std::false_type { };\n+struct is_comparable : std::false_type {};\n \n /* For non-map data structures, check whether operator== can be instantiated */\n template <typename T>\n struct is_comparable<\n-    T, enable_if_t<container_traits<T>::is_element &&\n-                   container_traits<T>::is_comparable>>\n-    : std::true_type { };\n+    T,\n+    enable_if_t<container_traits<T>::is_element && container_traits<T>::is_comparable>>\n+    : std::true_type {};\n \n-/* For a vector/map data structure, recursively check the value type (which is std::pair for maps) */\n+/* For a vector/map data structure, recursively check the value type\n+   (which is std::pair for maps) */\n template <typename T>\n struct is_comparable<T, enable_if_t<container_traits<T>::is_vector>> {\n-    static constexpr const bool value =\n-        is_comparable<typename T::value_type>::value;\n+    static constexpr const bool value = is_comparable<typename T::value_type>::value;\n };\n \n /* For pairs, recursively check the two data types */\n template <typename T>\n struct is_comparable<T, enable_if_t<container_traits<T>::is_pair>> {\n-    static constexpr const bool value =\n-        is_comparable<typename T::first_type>::value &&\n-        is_comparable<typename T::second_type>::value;\n+    static constexpr const bool value = is_comparable<typename T::first_type>::value\n+                                        && is_comparable<typename T::second_type>::value;\n };\n \n /* Fallback functions */\n-template <typename, typename, typename... Args> void vector_if_copy_constructible(const Args &...) { }\n-template <typename, typename, typename... Args> void vector_if_equal_operator(const Args &...) { }\n-template <typename, typename, typename... Args> void vector_if_insertion_operator(const Args &...) { }\n-template <typename, typename, typename... Args> void vector_modifiers(const Args &...) { }\n+template <typename, typename, typename... Args>\n+void vector_if_copy_constructible(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_if_equal_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_if_insertion_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_modifiers(const Args &...) {}\n \n-template<typename Vector, typename Class_>\n+template <typename Vector, typename Class_>\n void vector_if_copy_constructible(enable_if_t<is_copy_constructible<Vector>::value, Class_> &cl) {\n     cl.def(init<const Vector &>(), \"Copy constructor\");\n }\n \n-template<typename Vector, typename Class_>\n+template <typename Vector, typename Class_>\n void vector_if_equal_operator(enable_if_t<is_comparable<Vector>::value, Class_> &cl) {\n     using T = typename Vector::value_type;\n \n     cl.def(self == self);\n     cl.def(self != self);\n \n-    cl.def(\"count\",\n-        [](const Vector &v, const T &x) {\n-            return std::count(v.begin(), v.end(), x);\n-        },\n+    cl.def(\n+        \"count\",\n+        [](const Vector &v, const T &x) { return std::count(v.begin(), v.end(), x); },\n         arg(\"x\"),\n-        \"Return the number of times ``x`` appears in the list\"\n-    );\n+        \"Return the number of times ``x`` appears in the list\");\n \n-    cl.def(\"remove\", [](Vector &v, const T &x) {\n+    cl.def(\n+        \"remove\",\n+        [](Vector &v, const T &x) {\n             auto p = std::find(v.begin(), v.end(), x);\n-            if (p != v.end())\n+            if (p != v.end()) {\n                 v.erase(p);\n-            else\n+            } else {\n                 throw value_error();\n+            }\n         },\n         arg(\"x\"),\n         \"Remove the first item from the list whose value is x. \"\n-        \"It is an error if there is no such item.\"\n-    );\n+        \"It is an error if there is no such item.\");\n \n-    cl.def(\"__contains__\",\n-        [](const Vector &v, const T &x) {\n-            return std::find(v.begin(), v.end(), x) != v.end();\n-        },\n+    cl.def(\n+        \"__contains__\",\n+        [](const Vector &v, const T &x) { return std::find(v.begin(), v.end(), x) != v.end(); },\n         arg(\"x\"),\n-        \"Return true the container contains ``x``\"\n-    );\n+        \"Return true the container contains ``x``\");\n }\n \n // Vector modifiers -- requires a copyable vector_type:\n-// (Technically, some of these (pop and __delitem__) don't actually require copyability, but it seems\n-// silly to allow deletion but not insertion, so include them here too.)\n+// (Technically, some of these (pop and __delitem__) don't actually require copyability, but it\n+// seems silly to allow deletion but not insertion, so include them here too.)\n template <typename Vector, typename Class_>\n-void vector_modifiers(enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {\n+void vector_modifiers(\n+    enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {\n     using T = typename Vector::value_type;\n     using SizeType = typename Vector::size_type;\n     using DiffType = typename Vector::difference_type;\n \n-    cl.def(\"append\",\n-           [](Vector &v, const T &value) { v.push_back(value); },\n-           arg(\"x\"),\n-           \"Add an item to the end of the list\");\n+    auto wrap_i = [](DiffType i, SizeType n) {\n+        if (i < 0) {\n+            i += n;\n+        }\n+        if (i < 0 || (SizeType) i >= n) {\n+            throw index_error();\n+        }\n+        return i;\n+    };\n+\n+    cl.def(\n+        \"append\",\n+        [](Vector &v, const T &value) { v.push_back(value); },\n+        arg(\"x\"),\n+        \"Add an item to the end of the list\");\n \n-    cl.def(init([](iterable it) {\n+    cl.def(init([](const iterable &it) {\n         auto v = std::unique_ptr<Vector>(new Vector());\n         v->reserve(len_hint(it));\n-        for (handle h : it)\n-           v->push_back(h.cast<T>());\n+        for (handle h : it) {\n+            v->push_back(h.cast<T>());\n+        }\n         return v.release();\n     }));\n \n-    cl.def(\"extend\",\n-       [](Vector &v, const Vector &src) {\n-           v.insert(v.end(), src.begin(), src.end());\n-       },\n-       arg(\"L\"),\n-       \"Extend the list by appending all the items in the given list\"\n-    );\n-\n-    cl.def(\"extend\",\n-       [](Vector &v, iterable it) {\n-           const size_t old_size = v.size();\n-           v.reserve(old_size + len_hint(it));\n-           try {\n-               for (handle h : it) {\n-                   v.push_back(h.cast<T>());\n-               }\n-           } catch (const cast_error &) {\n-               v.erase(v.begin() + static_cast<typename Vector::difference_type>(old_size), v.end());\n-               try {\n-                   v.shrink_to_fit();\n-               } catch (const std::exception &) {\n-                   // Do nothing\n-               }\n-               throw;\n-           }\n-       },\n-       arg(\"L\"),\n-       \"Extend the list by appending all the items in the given list\"\n-    );\n-\n-    cl.def(\"insert\",\n-        [](Vector &v, SizeType i, const T &x) {\n-            if (i > v.size())\n+    cl.def(\n+        \"clear\", [](Vector &v) { v.clear(); }, \"Clear the contents\");\n+\n+    cl.def(\n+        \"extend\",\n+        [](Vector &v, const Vector &src) { v.insert(v.end(), src.begin(), src.end()); },\n+        arg(\"L\"),\n+        \"Extend the list by appending all the items in the given list\");\n+\n+    cl.def(\n+        \"extend\",\n+        [](Vector &v, const iterable &it) {\n+            const size_t old_size = v.size();\n+            v.reserve(old_size + len_hint(it));\n+            try {\n+                for (handle h : it) {\n+                    v.push_back(h.cast<T>());\n+                }\n+            } catch (const cast_error &) {\n+                v.erase(v.begin() + static_cast<typename Vector::difference_type>(old_size),\n+                        v.end());\n+                try {\n+                    v.shrink_to_fit();\n+                } catch (const std::exception &) {\n+                    // Do nothing\n+                }\n+                throw;\n+            }\n+        },\n+        arg(\"L\"),\n+        \"Extend the list by appending all the items in the given list\");\n+\n+    cl.def(\n+        \"insert\",\n+        [](Vector &v, DiffType i, const T &x) {\n+            // Can't use wrap_i; i == v.size() is OK\n+            if (i < 0) {\n+                i += v.size();\n+            }\n+            if (i < 0 || (SizeType) i > v.size()) {\n                 throw index_error();\n-            v.insert(v.begin() + (DiffType) i, x);\n+            }\n+            v.insert(v.begin() + i, x);\n         },\n-        arg(\"i\") , arg(\"x\"),\n-        \"Insert an item at a given position.\"\n-    );\n+        arg(\"i\"),\n+        arg(\"x\"),\n+        \"Insert an item at a given position.\");\n \n-    cl.def(\"pop\",\n+    cl.def(\n+        \"pop\",\n         [](Vector &v) {\n-            if (v.empty())\n+            if (v.empty()) {\n                 throw index_error();\n-            T t = v.back();\n+            }\n+            T t = std::move(v.back());\n             v.pop_back();\n             return t;\n         },\n-        \"Remove and return the last item\"\n-    );\n-\n-    cl.def(\"pop\",\n-        [](Vector &v, SizeType i) {\n-            if (i >= v.size())\n-                throw index_error();\n-            T t = v[i];\n-            v.erase(v.begin() + (DiffType) i);\n+        \"Remove and return the last item\");\n+\n+    cl.def(\n+        \"pop\",\n+        [wrap_i](Vector &v, DiffType i) {\n+            i = wrap_i(i, v.size());\n+            T t = std::move(v[(SizeType) i]);\n+            v.erase(std::next(v.begin(), i));\n             return t;\n         },\n         arg(\"i\"),\n-        \"Remove and return the item at index ``i``\"\n-    );\n+        \"Remove and return the item at index ``i``\");\n \n-    cl.def(\"__setitem__\",\n-        [](Vector &v, SizeType i, const T &t) {\n-            if (i >= v.size())\n-                throw index_error();\n-            v[i] = t;\n-        }\n-    );\n+    cl.def(\"__setitem__\", [wrap_i](Vector &v, DiffType i, const T &t) {\n+        i = wrap_i(i, v.size());\n+        v[(SizeType) i] = t;\n+    });\n \n     /// Slicing protocol\n-    cl.def(\"__getitem__\",\n-        [](const Vector &v, slice slice) -> Vector * {\n-            size_t start, stop, step, slicelength;\n+    cl.def(\n+        \"__getitem__\",\n+        [](const Vector &v, const slice &slice) -> Vector * {\n+            size_t start = 0, stop = 0, step = 0, slicelength = 0;\n \n-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))\n+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {\n                 throw error_already_set();\n+            }\n \n-            Vector *seq = new Vector();\n+            auto *seq = new Vector();\n             seq->reserve((size_t) slicelength);\n \n-            for (size_t i=0; i<slicelength; ++i) {\n+            for (size_t i = 0; i < slicelength; ++i) {\n                 seq->push_back(v[start]);\n                 start += step;\n             }\n             return seq;\n         },\n         arg(\"s\"),\n-        \"Retrieve list elements using a slice object\"\n-    );\n+        \"Retrieve list elements using a slice object\");\n \n-    cl.def(\"__setitem__\",\n-        [](Vector &v, slice slice,  const Vector &value) {\n-            size_t start, stop, step, slicelength;\n-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))\n+    cl.def(\n+        \"__setitem__\",\n+        [](Vector &v, const slice &slice, const Vector &value) {\n+            size_t start = 0, stop = 0, step = 0, slicelength = 0;\n+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {\n                 throw error_already_set();\n+            }\n \n-            if (slicelength != value.size())\n-                throw std::runtime_error(\"Left and right hand size of slice assignment have different sizes!\");\n+            if (slicelength != value.size()) {\n+                throw std::runtime_error(\n+                    \"Left and right hand size of slice assignment have different sizes!\");\n+            }\n \n-            for (size_t i=0; i<slicelength; ++i) {\n+            for (size_t i = 0; i < slicelength; ++i) {\n                 v[start] = value[i];\n                 start += step;\n             }\n         },\n-        \"Assign list elements using a slice object\"\n-    );\n+        \"Assign list elements using a slice object\");\n \n-    cl.def(\"__delitem__\",\n-        [](Vector &v, SizeType i) {\n-            if (i >= v.size())\n-                throw index_error();\n-            v.erase(v.begin() + DiffType(i));\n+    cl.def(\n+        \"__delitem__\",\n+        [wrap_i](Vector &v, DiffType i) {\n+            i = wrap_i(i, v.size());\n+            v.erase(v.begin() + i);\n         },\n-        \"Delete the list elements at index ``i``\"\n-    );\n+        \"Delete the list elements at index ``i``\");\n \n-    cl.def(\"__delitem__\",\n-        [](Vector &v, slice slice) {\n-            size_t start, stop, step, slicelength;\n+    cl.def(\n+        \"__delitem__\",\n+        [](Vector &v, const slice &slice) {\n+            size_t start = 0, stop = 0, step = 0, slicelength = 0;\n \n-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))\n+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {\n                 throw error_already_set();\n+            }\n \n             if (step == 1 && false) {\n                 v.erase(v.begin() + (DiffType) start, v.begin() + DiffType(start + slicelength));\n@@ -262,39 +297,50 @@ void vector_modifiers(enable_if_t<is_copy_constructible<typename Vector::value_t\n                 }\n             }\n         },\n-        \"Delete list elements using a slice object\"\n-    );\n-\n+        \"Delete list elements using a slice object\");\n }\n \n // If the type has an operator[] that doesn't return a reference (most notably std::vector<bool>),\n // we have to access by copying; otherwise we return by reference.\n-template <typename Vector> using vector_needs_copy = negation<\n-    std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]), typename Vector::value_type &>>;\n+template <typename Vector>\n+using vector_needs_copy\n+    = negation<std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]),\n+                            typename Vector::value_type &>>;\n \n // The usual case: access and iterate by reference\n template <typename Vector, typename Class_>\n void vector_accessor(enable_if_t<!vector_needs_copy<Vector>::value, Class_> &cl) {\n     using T = typename Vector::value_type;\n     using SizeType = typename Vector::size_type;\n-    using ItType   = typename Vector::iterator;\n+    using DiffType = typename Vector::difference_type;\n+    using ItType = typename Vector::iterator;\n \n-    cl.def(\"__getitem__\",\n-        [](Vector &v, SizeType i) -> T & {\n-            if (i >= v.size())\n-                throw index_error();\n-            return v[i];\n+    auto wrap_i = [](DiffType i, SizeType n) {\n+        if (i < 0) {\n+            i += n;\n+        }\n+        if (i < 0 || (SizeType) i >= n) {\n+            throw index_error();\n+        }\n+        return i;\n+    };\n+\n+    cl.def(\n+        \"__getitem__\",\n+        [wrap_i](Vector &v, DiffType i) -> T & {\n+            i = wrap_i(i, v.size());\n+            return v[(SizeType) i];\n         },\n         return_value_policy::reference_internal // ref + keepalive\n     );\n \n-    cl.def(\"__iter__\",\n-           [](Vector &v) {\n-               return make_iterator<\n-                   return_value_policy::reference_internal, ItType, ItType, T&>(\n-                   v.begin(), v.end());\n-           },\n-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+    cl.def(\n+        \"__iter__\",\n+        [](Vector &v) {\n+            return make_iterator<return_value_policy::reference_internal, ItType, ItType, T &>(\n+                v.begin(), v.end());\n+        },\n+        keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n     );\n }\n \n@@ -303,103 +349,144 @@ template <typename Vector, typename Class_>\n void vector_accessor(enable_if_t<vector_needs_copy<Vector>::value, Class_> &cl) {\n     using T = typename Vector::value_type;\n     using SizeType = typename Vector::size_type;\n-    using ItType   = typename Vector::iterator;\n-    cl.def(\"__getitem__\",\n-        [](const Vector &v, SizeType i) -> T {\n-            if (i >= v.size())\n-                throw index_error();\n-            return v[i];\n+    using DiffType = typename Vector::difference_type;\n+    using ItType = typename Vector::iterator;\n+    cl.def(\"__getitem__\", [](const Vector &v, DiffType i) -> T {\n+        if (i < 0 && (i += v.size()) < 0) {\n+            throw index_error();\n         }\n-    );\n+        if ((SizeType) i >= v.size()) {\n+            throw index_error();\n+        }\n+        return v[(SizeType) i];\n+    });\n \n-    cl.def(\"__iter__\",\n-           [](Vector &v) {\n-               return make_iterator<\n-                   return_value_policy::copy, ItType, ItType, T>(\n-                   v.begin(), v.end());\n-           },\n-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+    cl.def(\n+        \"__iter__\",\n+        [](Vector &v) {\n+            return make_iterator<return_value_policy::copy, ItType, ItType, T>(v.begin(), v.end());\n+        },\n+        keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n     );\n }\n \n-template <typename Vector, typename Class_> auto vector_if_insertion_operator(Class_ &cl, std::string const &name)\n-    -> decltype(std::declval<std::ostream&>() << std::declval<typename Vector::value_type>(), void()) {\n+template <typename Vector, typename Class_>\n+auto vector_if_insertion_operator(Class_ &cl, std::string const &name)\n+    -> decltype(std::declval<std::ostream &>() << std::declval<typename Vector::value_type>(),\n+                void()) {\n     using size_type = typename Vector::size_type;\n \n-    cl.def(\"__repr__\",\n-           [name](Vector &v) {\n+    cl.def(\n+        \"__repr__\",\n+        [name](Vector &v) {\n             std::ostringstream s;\n             s << name << '[';\n-            for (size_type i=0; i < v.size(); ++i) {\n+            for (size_type i = 0; i < v.size(); ++i) {\n                 s << v[i];\n-                if (i != v.size() - 1)\n+                if (i != v.size() - 1) {\n                     s << \", \";\n+                }\n             }\n             s << ']';\n             return s.str();\n         },\n-        \"Return the canonical string representation of this list.\"\n-    );\n+        \"Return the canonical string representation of this list.\");\n }\n \n // Provide the buffer interface for vectors if we have data() and we have a format for it\n-// GCC seems to have \"void std::vector<bool>::data()\" - doing SFINAE on the existence of data() is insufficient, we need to check it returns an appropriate pointer\n+// GCC seems to have \"void std::vector<bool>::data()\" - doing SFINAE on the existence of data()\n+// is insufficient, we need to check it returns an appropriate pointer\n template <typename Vector, typename = void>\n struct vector_has_data_and_format : std::false_type {};\n template <typename Vector>\n-struct vector_has_data_and_format<Vector, enable_if_t<std::is_same<decltype(format_descriptor<typename Vector::value_type>::format(), std::declval<Vector>().data()), typename Vector::value_type*>::value>> : std::true_type {};\n+struct vector_has_data_and_format<\n+    Vector,\n+    enable_if_t<std::is_same<decltype(format_descriptor<typename Vector::value_type>::format(),\n+                                      std::declval<Vector>().data()),\n+                             typename Vector::value_type *>::value>> : std::true_type {};\n+\n+// [workaround(intel)] Separate function required here\n+// Workaround as the Intel compiler does not compile the enable_if_t part below\n+// (tested with icc (ICC) 2021.1 Beta 20200827)\n+template <typename... Args>\n+constexpr bool args_any_are_buffer() {\n+    return detail::any_of<std::is_same<Args, buffer_protocol>...>::value;\n+}\n+\n+// [workaround(intel)] Separate function required here\n+// [workaround(msvc)] Can't use constexpr bool in return type\n \n // Add the buffer interface to a vector\n template <typename Vector, typename Class_, typename... Args>\n-enable_if_t<detail::any_of<std::is_same<Args, buffer_protocol>...>::value>\n-vector_buffer(Class_& cl) {\n+void vector_buffer_impl(Class_ &cl, std::true_type) {\n     using T = typename Vector::value_type;\n \n-    static_assert(vector_has_data_and_format<Vector>::value, \"There is not an appropriate format descriptor for this vector\");\n+    static_assert(vector_has_data_and_format<Vector>::value,\n+                  \"There is not an appropriate format descriptor for this vector\");\n \n-    // numpy.h declares this for arbitrary types, but it may raise an exception and crash hard at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so check here\n+    // numpy.h declares this for arbitrary types, but it may raise an exception and crash hard\n+    // at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so check here\n     format_descriptor<T>::format();\n \n-    cl.def_buffer([](Vector& v) -> buffer_info {\n-        return buffer_info(v.data(), static_cast<ssize_t>(sizeof(T)), format_descriptor<T>::format(), 1, {v.size()}, {sizeof(T)});\n+    cl.def_buffer([](Vector &v) -> buffer_info {\n+        return buffer_info(v.data(),\n+                           static_cast<ssize_t>(sizeof(T)),\n+                           format_descriptor<T>::format(),\n+                           1,\n+                           {v.size()},\n+                           {sizeof(T)});\n     });\n \n-    cl.def(init([](buffer buf) {\n+    cl.def(init([](const buffer &buf) {\n         auto info = buf.request();\n-        if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T)))\n+        if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T))) {\n             throw type_error(\"Only valid 1D buffers can be copied to a vector\");\n-        if (!detail::compare_buffer_info<T>::compare(info) || (ssize_t) sizeof(T) != info.itemsize)\n-            throw type_error(\"Format mismatch (Python: \" + info.format + \" C++: \" + format_descriptor<T>::format() + \")\");\n+        }\n+        if (!detail::compare_buffer_info<T>::compare(info)\n+            || (ssize_t) sizeof(T) != info.itemsize) {\n+            throw type_error(\"Format mismatch (Python: \" + info.format\n+                             + \" C++: \" + format_descriptor<T>::format() + \")\");\n+        }\n \n-        auto vec = std::unique_ptr<Vector>(new Vector());\n-        vec->reserve((size_t) info.shape[0]);\n-        T *p = static_cast<T*>(info.ptr);\n+        T *p = static_cast<T *>(info.ptr);\n         ssize_t step = info.strides[0] / static_cast<ssize_t>(sizeof(T));\n         T *end = p + info.shape[0] * step;\n-        for (; p != end; p += step)\n-            vec->push_back(*p);\n-        return vec.release();\n+        if (step == 1) {\n+            return Vector(p, end);\n+        }\n+        Vector vec;\n+        vec.reserve((size_t) info.shape[0]);\n+        for (; p != end; p += step) {\n+            vec.push_back(*p);\n+        }\n+        return vec;\n     }));\n \n     return;\n }\n \n template <typename Vector, typename Class_, typename... Args>\n-enable_if_t<!detail::any_of<std::is_same<Args, buffer_protocol>...>::value> vector_buffer(Class_&) {}\n+void vector_buffer_impl(Class_ &, std::false_type) {}\n+\n+template <typename Vector, typename Class_, typename... Args>\n+void vector_buffer(Class_ &cl) {\n+    vector_buffer_impl<Vector, Class_, Args...>(\n+        cl, detail::any_of<std::is_same<Args, buffer_protocol>...>{});\n+}\n \n-NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(detail)\n \n //\n // std::vector\n //\n template <typename Vector, typename holder_type = std::unique_ptr<Vector>, typename... Args>\n-class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args&&... args) {\n+class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args &&...args) {\n     using Class_ = class_<Vector, holder_type>;\n \n     // If the value_type is unregistered (e.g. a converting type) or is itself registered\n     // module-local then make the vector binding module-local as well:\n     using vtype = typename Vector::value_type;\n-    auto vtype_info = detail::get_type_info(typeid(vtype));\n+    auto *vtype_info = detail::get_type_info(typeid(vtype));\n     bool local = !vtype_info || vtype_info->module_local;\n \n     Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);\n@@ -424,18 +511,13 @@ class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, A\n     // Accessor and iterator; return by value if copyable, otherwise we return by ref + keep-alive\n     detail::vector_accessor<Vector, Class_>(cl);\n \n-    cl.def(\"__bool__\",\n-        [](const Vector &v) -> bool {\n-            return !v.empty();\n-        },\n-        \"Check whether the list is nonempty\"\n-    );\n+    cl.def(\n+        \"__bool__\",\n+        [](const Vector &v) -> bool { return !v.empty(); },\n+        \"Check whether the list is nonempty\");\n \n     cl.def(\"__len__\", &Vector::size);\n \n-\n-\n-\n #if 0\n     // C++ style functions deprecated, leaving it here as an example\n     cl.def(init<size_type>());\n@@ -479,152 +561,225 @@ class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, A\n     return cl;\n }\n \n-\n-\n //\n // std::map, std::unordered_map\n //\n \n-NAMESPACE_BEGIN(detail)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n \n /* Fallback functions */\n-template <typename, typename, typename... Args> void map_if_insertion_operator(const Args &...) { }\n-template <typename, typename, typename... Args> void map_assignment(const Args &...) { }\n+template <typename, typename, typename... Args>\n+void map_if_insertion_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void map_assignment(const Args &...) {}\n \n // Map assignment when copy-assignable: just copy the value\n template <typename Map, typename Class_>\n-void map_assignment(enable_if_t<std::is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {\n+void map_assignment(\n+    enable_if_t<is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {\n     using KeyType = typename Map::key_type;\n     using MappedType = typename Map::mapped_type;\n \n-    cl.def(\"__setitem__\",\n-           [](Map &m, const KeyType &k, const MappedType &v) {\n-               auto it = m.find(k);\n-               if (it != m.end()) it->second = v;\n-               else m.emplace(k, v);\n-           }\n-    );\n+    cl.def(\"__setitem__\", [](Map &m, const KeyType &k, const MappedType &v) {\n+        auto it = m.find(k);\n+        if (it != m.end()) {\n+            it->second = v;\n+        } else {\n+            m.emplace(k, v);\n+        }\n+    });\n }\n \n-// Not copy-assignable, but still copy-constructible: we can update the value by erasing and reinserting\n-template<typename Map, typename Class_>\n-void map_assignment(enable_if_t<\n-        !std::is_copy_assignable<typename Map::mapped_type>::value &&\n-        is_copy_constructible<typename Map::mapped_type>::value,\n-        Class_> &cl) {\n+// Not copy-assignable, but still copy-constructible: we can update the value by erasing and\n+// reinserting\n+template <typename Map, typename Class_>\n+void map_assignment(enable_if_t<!is_copy_assignable<typename Map::mapped_type>::value\n+                                    && is_copy_constructible<typename Map::mapped_type>::value,\n+                                Class_> &cl) {\n     using KeyType = typename Map::key_type;\n     using MappedType = typename Map::mapped_type;\n \n-    cl.def(\"__setitem__\",\n-           [](Map &m, const KeyType &k, const MappedType &v) {\n-               // We can't use m[k] = v; because value type might not be default constructable\n-               auto r = m.emplace(k, v);\n-               if (!r.second) {\n-                   // value type is not copy assignable so the only way to insert it is to erase it first...\n-                   m.erase(r.first);\n-                   m.emplace(k, v);\n-               }\n-           }\n-    );\n+    cl.def(\"__setitem__\", [](Map &m, const KeyType &k, const MappedType &v) {\n+        // We can't use m[k] = v; because value type might not be default constructable\n+        auto r = m.emplace(k, v);\n+        if (!r.second) {\n+            // value type is not copy assignable so the only way to insert it is to erase it\n+            // first...\n+            m.erase(r.first);\n+            m.emplace(k, v);\n+        }\n+    });\n }\n \n-\n-template <typename Map, typename Class_> auto map_if_insertion_operator(Class_ &cl, std::string const &name)\n--> decltype(std::declval<std::ostream&>() << std::declval<typename Map::key_type>() << std::declval<typename Map::mapped_type>(), void()) {\n-\n-    cl.def(\"__repr__\",\n-           [name](Map &m) {\n+template <typename Map, typename Class_>\n+auto map_if_insertion_operator(Class_ &cl, std::string const &name)\n+    -> decltype(std::declval<std::ostream &>() << std::declval<typename Map::key_type>()\n+                                               << std::declval<typename Map::mapped_type>(),\n+                void()) {\n+\n+    cl.def(\n+        \"__repr__\",\n+        [name](Map &m) {\n             std::ostringstream s;\n             s << name << '{';\n             bool f = false;\n             for (auto const &kv : m) {\n-                if (f)\n+                if (f) {\n                     s << \", \";\n+                }\n                 s << kv.first << \": \" << kv.second;\n                 f = true;\n             }\n             s << '}';\n             return s.str();\n         },\n-        \"Return the canonical string representation of this map.\"\n-    );\n+        \"Return the canonical string representation of this map.\");\n }\n \n+template <typename Map>\n+struct keys_view {\n+    Map &map;\n+};\n+\n+template <typename Map>\n+struct values_view {\n+    Map &map;\n+};\n \n-NAMESPACE_END(detail)\n+template <typename Map>\n+struct items_view {\n+    Map &map;\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n \n template <typename Map, typename holder_type = std::unique_ptr<Map>, typename... Args>\n-class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args&&... args) {\n+class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args &&...args) {\n     using KeyType = typename Map::key_type;\n     using MappedType = typename Map::mapped_type;\n+    using KeysView = detail::keys_view<Map>;\n+    using ValuesView = detail::values_view<Map>;\n+    using ItemsView = detail::items_view<Map>;\n     using Class_ = class_<Map, holder_type>;\n \n     // If either type is a non-module-local bound type then make the map binding non-local as well;\n     // otherwise (e.g. both types are either module-local or converting) the map will be\n     // module-local.\n-    auto tinfo = detail::get_type_info(typeid(MappedType));\n+    auto *tinfo = detail::get_type_info(typeid(MappedType));\n     bool local = !tinfo || tinfo->module_local;\n     if (local) {\n         tinfo = detail::get_type_info(typeid(KeyType));\n         local = !tinfo || tinfo->module_local;\n     }\n \n     Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);\n+    class_<KeysView> keys_view(\n+        scope, (\"KeysView[\" + name + \"]\").c_str(), pybind11::module_local(local));\n+    class_<ValuesView> values_view(\n+        scope, (\"ValuesView[\" + name + \"]\").c_str(), pybind11::module_local(local));\n+    class_<ItemsView> items_view(\n+        scope, (\"ItemsView[\" + name + \"]\").c_str(), pybind11::module_local(local));\n \n     cl.def(init<>());\n \n     // Register stream insertion operator (if possible)\n     detail::map_if_insertion_operator<Map, Class_>(cl, name);\n \n-    cl.def(\"__bool__\",\n+    cl.def(\n+        \"__bool__\",\n         [](const Map &m) -> bool { return !m.empty(); },\n-        \"Check whether the map is nonempty\"\n+        \"Check whether the map is nonempty\");\n+\n+    cl.def(\n+        \"__iter__\",\n+        [](Map &m) { return make_key_iterator(m.begin(), m.end()); },\n+        keep_alive<0, 1>() /* Essential: keep map alive while iterator exists */\n+    );\n+\n+    cl.def(\n+        \"keys\",\n+        [](Map &m) { return KeysView{m}; },\n+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */\n     );\n \n-    cl.def(\"__iter__\",\n-           [](Map &m) { return make_key_iterator(m.begin(), m.end()); },\n-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+    cl.def(\n+        \"values\",\n+        [](Map &m) { return ValuesView{m}; },\n+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */\n     );\n \n-    cl.def(\"items\",\n-           [](Map &m) { return make_iterator(m.begin(), m.end()); },\n-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+    cl.def(\n+        \"items\",\n+        [](Map &m) { return ItemsView{m}; },\n+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */\n     );\n \n-    cl.def(\"__getitem__\",\n+    cl.def(\n+        \"__getitem__\",\n         [](Map &m, const KeyType &k) -> MappedType & {\n             auto it = m.find(k);\n-            if (it == m.end())\n-              throw key_error();\n-           return it->second;\n+            if (it == m.end()) {\n+                throw key_error();\n+            }\n+            return it->second;\n         },\n         return_value_policy::reference_internal // ref + keepalive\n     );\n \n-    cl.def(\"__contains__\",\n-        [](Map &m, const KeyType &k) -> bool {\n-            auto it = m.find(k);\n-            if (it == m.end())\n-              return false;\n-           return true;\n+    cl.def(\"__contains__\", [](Map &m, const KeyType &k) -> bool {\n+        auto it = m.find(k);\n+        if (it == m.end()) {\n+            return false;\n         }\n-    );\n+        return true;\n+    });\n+    // Fallback for when the object is not of the key type\n+    cl.def(\"__contains__\", [](Map &, const object &) -> bool { return false; });\n \n     // Assignment provided only if the type is copyable\n     detail::map_assignment<Map, Class_>(cl);\n \n-    cl.def(\"__delitem__\",\n-           [](Map &m, const KeyType &k) {\n-               auto it = m.find(k);\n-               if (it == m.end())\n-                   throw key_error();\n-               m.erase(it);\n-           }\n-    );\n+    cl.def(\"__delitem__\", [](Map &m, const KeyType &k) {\n+        auto it = m.find(k);\n+        if (it == m.end()) {\n+            throw key_error();\n+        }\n+        m.erase(it);\n+    });\n \n     cl.def(\"__len__\", &Map::size);\n \n+    keys_view.def(\"__len__\", [](KeysView &view) { return view.map.size(); });\n+    keys_view.def(\n+        \"__iter__\",\n+        [](KeysView &view) { return make_key_iterator(view.map.begin(), view.map.end()); },\n+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */\n+    );\n+    keys_view.def(\"__contains__\", [](KeysView &view, const KeyType &k) -> bool {\n+        auto it = view.map.find(k);\n+        if (it == view.map.end()) {\n+            return false;\n+        }\n+        return true;\n+    });\n+    // Fallback for when the object is not of the key type\n+    keys_view.def(\"__contains__\", [](KeysView &, const object &) -> bool { return false; });\n+\n+    values_view.def(\"__len__\", [](ValuesView &view) { return view.map.size(); });\n+    values_view.def(\n+        \"__iter__\",\n+        [](ValuesView &view) { return make_value_iterator(view.map.begin(), view.map.end()); },\n+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */\n+    );\n+\n+    items_view.def(\"__len__\", [](ItemsView &view) { return view.map.size(); });\n+    items_view.def(\n+        \"__iter__\",\n+        [](ItemsView &view) { return make_iterator(view.map.begin(), view.map.end()); },\n+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */\n+    );\n+\n     return cl;\n }\n \n-NAMESPACE_END(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}]