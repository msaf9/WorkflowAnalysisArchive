[{"filename": "include/triton/codegen/analysis/align.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -12,6 +12,7 @@ namespace ir {\n   class phi_node;\n   class splat_inst;\n   class cast_inst;\n+  class cmp_inst;\n   class reshape_inst;\n   class broadcast_inst;\n   class binary_operator;\n@@ -35,6 +36,7 @@ class align {\n   std::vector<cst_info> populate_is_constant_reshape(ir::reshape_inst* x);\n   std::vector<cst_info> populate_is_constant_broadcast(ir::broadcast_inst* x);\n   std::vector<cst_info> populate_is_constant_binop(ir::binary_operator* x);\n+  std::vector<cst_info> populate_is_constant_cmp(ir::cmp_inst* x);\n   std::vector<cst_info> populate_is_constant_gep(ir::getelementptr_inst* x);\n   std::vector<cst_info> populate_is_constant_default(ir::value* v);\n   std::vector<cst_info> populate_is_constant(ir::value *v);\n@@ -65,6 +67,7 @@ class align {\n   void run(ir::module &mod);\n   unsigned get(ir::value* v, unsigned ax) const;\n   std::vector<unsigned> contiguous(ir::value* v) const;\n+  std::vector<cst_info> get_cst_info(ir::value* v) const;\n \n private:\n   std::map<ir::value*, std::vector<cst_info>> is_constant_;"}, {"filename": "lib/codegen/analysis/align.cc", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "file_content_changes": "@@ -129,19 +129,49 @@ std::vector<align::cst_info> align::populate_is_constant_broadcast(ir::broadcast\n   return add_to_cache(x, result, is_constant_);\n }\n \n+std::vector<align::cst_info> align::populate_is_constant_cmp(ir::cmp_inst* x) {\n+  auto x_shapes = get_shapes(x);\n+  std::vector<cst_info> result;\n+  ir::value* lhs_op = x->get_operand(0);\n+  ir::value* rhs_op = x->get_operand(1);\n+  auto lhs = populate_is_constant(lhs_op);\n+  auto rhs = populate_is_constant(rhs_op);\n+  auto lhs_max_contiguous = populate_max_contiguous(lhs_op);\n+  auto rhs_max_contiguous = populate_max_contiguous(rhs_op);\n+  auto lhs_multiple_of = populate_starting_multiple(lhs_op);\n+  auto rhs_multiple_of = populate_starting_multiple(rhs_op);\n+  for(size_t d = 0; d < x_shapes.size(); d++) {\n+    cst_info ax = {1, 0};\n+    // if lhs (resp. rhs) is a range of M value starting at a multiple of N\n+    // and rhs (resp. lhs) is made of M constants that are multiples of N\n+    // then comparisons have M constants\n+    int min_multiple = std::min(lhs_multiple_of[d], rhs_multiple_of[d]);\n+    if(lhs_max_contiguous[d] == rhs[d].num_cst)\n+      ax = {std::min<int>(min_multiple, lhs_max_contiguous[d]), 0};\n+    else if(rhs_max_contiguous[d] == lhs[d].num_cst)\n+      ax = {std::min<int>(min_multiple, rhs_max_contiguous[d]), 0};\n+    result.push_back(ax);\n+  }\n+  return add_to_cache(x, result, is_constant_);\n+}\n+\n+\n std::vector<align::cst_info> align::populate_is_constant_binop(ir::binary_operator* x) {\n   auto x_shapes = get_shapes(x);\n   std::vector<cst_info> result;\n   ir::value* lhs_op = x->get_operand(0);\n   ir::value* rhs_op = x->get_operand(1);\n   auto lhs = populate_is_constant(lhs_op);\n   auto rhs = populate_is_constant(rhs_op);\n-  auto max_contiguous = populate_max_contiguous(lhs_op);\n+  auto lhs_max_contiguous = populate_max_contiguous(lhs_op);\n+  auto rhs_max_contiguous = populate_max_contiguous(rhs_op);\n+  auto lhs_multiple_of = populate_starting_multiple(lhs_op);\n+  auto rhs_multiple_of = populate_starting_multiple(rhs_op);\n   for(size_t d = 0; d < x_shapes.size(); d++) {\n     cst_info ax;\n     if(lhs[d].num_cst==0 && rhs[d].value && x->is_int_div()){\n       // todo might not be entirely true\n-      unsigned num_constants = gcd(max_contiguous[d], rhs[d].value);\n+      unsigned num_constants = gcd(lhs_max_contiguous[d], rhs[d].value);\n       ax = {num_constants, 0};\n     }\n     else\n@@ -184,6 +214,8 @@ std::vector<align::cst_info> align::populate_is_constant(ir::value *v) {\n     return populate_is_constant_broadcast(x);\n   if(auto *x = dynamic_cast<ir::binary_operator*>(v))\n     return populate_is_constant_binop(x);\n+  if(auto *x = dynamic_cast<ir::cmp_inst*>(v))\n+    return populate_is_constant_cmp(x);\n   if(auto *x = dynamic_cast<ir::getelementptr_inst*>(v))\n     return populate_is_constant_gep(x);\n   return populate_is_constant_default(v);\n@@ -511,12 +543,15 @@ std::vector<unsigned> align::contiguous(ir::value* v) const {\n   return max_contiguous_.at(v);\n }\n \n+std::vector<align::cst_info> align::get_cst_info(ir::value* v) const {\n+  return is_constant_.at(v);\n+}\n+\n \n void align::populate(ir::value *v) {\n   populate_is_constant(v);\n   populate_starting_multiple(v);\n   populate_max_contiguous(v);\n-\n }\n \n void align::run(ir::module &mod) {"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -743,6 +743,8 @@ void generator::visit_load_inst(ir::load_inst* x){\n   if(op->get_type()->is_block_ty()){\n     auto   ord = ords_.at(op);\n     size_t aln = alignment_->get(op, ord[0]);\n+    size_t max_eq = mx ? alignment_->get_cst_info(mx->get_mask_operand())[ord[0]].num_cst : 1;\n+    aln = std::min(aln, max_eq);\n     auto layout = layouts_->get(x)->to_scanline();\n     if(layout){\n       size_t nts = layout->nts(ord[0]);\n@@ -899,6 +901,8 @@ void generator::visit_store_inst(ir::store_inst * x){\n     auto ord = ords_.at(x->get_pointer_operand());\n     size_t aln = alignment_->get(ptr_op, ord[0]);\n     size_t nts = axes_.at(a_axes_->get(x->get_pointer_operand(), ord[0])).contiguous;\n+    size_t max_eq = mx ? alignment_->get_cst_info(mx->get_mask_operand())[ord[0]].num_cst : 1;\n+    aln = std::min(aln, max_eq);\n     vec  = std::min(nts, aln);\n   }\n   auto idxs    = idxs_.at(val_op);"}]