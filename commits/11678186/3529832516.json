[{"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 74, "deletions": 29, "changes": 103, "file_content_changes": "@@ -561,11 +561,14 @@ class RematerializeForward : public mlir::RewritePattern {\n // -----------------------------------------------------------------------------\n //\n // -----------------------------------------------------------------------------\n+namespace {\n static int computeCapabilityToMMAVersion(int computeCapability) {\n   if (computeCapability < 80) {\n     return 1;\n   } else if (computeCapability < 90) {\n     return 2;\n+  } else if (computeCapability < 100) {\n+    return 3;\n   } else {\n     assert(false && \"computeCapability > 90 not supported\");\n     return 0;\n@@ -575,16 +578,75 @@ static int computeCapabilityToMMAVersion(int computeCapability) {\n static SmallVector<int64_t, 2>\n mmaVersionToShapePerWarp(int version, const ArrayRef<int64_t> &shape,\n                          int numWarps) {\n-  if (version == 1) {\n+  if (version == 1)\n     return {16, 16};\n-  } else if (version == 2) {\n+  else if (version == 2)\n     return {16, 8};\n-  } else {\n+  else {\n     assert(false && \"version not supported\");\n     return {0, 0};\n   }\n }\n \n+inline unsigned clamp(unsigned x, unsigned a, unsigned b) {\n+  unsigned lo = std::min(a, b);\n+  unsigned hi = std::max(a, b);\n+  return std::min(std::max(x, lo), hi);\n+}\n+\n+template <int version>\n+SmallVector<unsigned, 2> warpsPerTile(const ArrayRef<int64_t> &shape,\n+                                      int numWarps);\n+\n+template <>\n+SmallVector<unsigned, 2> warpsPerTile<1>(const ArrayRef<int64_t> &shape,\n+                                         int numWarps) {\n+  SmallVector<unsigned, 2> ret = {1, 1};\n+  SmallVector<int64_t, 2> shapePerWarp =\n+      mmaVersionToShapePerWarp(1, shape, numWarps);\n+  bool changed = false;\n+  do {\n+    changed = false;\n+    if (ret[0] * ret[1] < numWarps) {\n+      ret[0] = clamp(ret[0] * 2, 1, shape[0] / shapePerWarp[0]);\n+      changed = true;\n+    }\n+    if (ret[0] * ret[1] < numWarps) {\n+      ret[1] = clamp(ret[1] * 2, 1, shape[1] / shapePerWarp[1]);\n+      changed = true;\n+    }\n+  } while (changed);\n+  return ret;\n+}\n+\n+template <>\n+SmallVector<unsigned, 2> warpsPerTile<2>(const ArrayRef<int64_t> &shape,\n+                                         int numWarps) {\n+  SmallVector<unsigned, 2> ret = {1, 1};\n+  SmallVector<int64_t, 2> shapePerWarp =\n+      mmaVersionToShapePerWarp(2, shape, numWarps);\n+  bool changed = false;\n+  do {\n+    changed = false;\n+    if (ret[0] * ret[1] >= numWarps)\n+      break;\n+    if (shape[0] / shapePerWarp[0] / ret[0] >=\n+        shape[1] / (shapePerWarp[1] * 2) / ret[1]) {\n+      if (ret[0] < shape[0] / shapePerWarp[0]) {\n+        ret[0] *= 2;\n+        changed = true;\n+      }\n+    } else {\n+      if (ret[1] < shape[1] / shapePerWarp[1]) {\n+        ret[1] *= 2;\n+        changed = true;\n+      }\n+    }\n+  } while (changed);\n+  return ret;\n+}\n+\n+} // namespace\n class BlockedToMMA : public mlir::RewritePattern {\n   int computeCapability;\n \n@@ -595,32 +657,15 @@ class BlockedToMMA : public mlir::RewritePattern {\n \n   static SmallVector<unsigned, 2>\n   getWarpsPerTile(const ArrayRef<int64_t> &shape, int version, int numWarps) {\n-    assert(version == 2);\n-    // TODO: Handle one warp per row for fused matmuls\n-    // TODO: unsigned -> int64_t to keep things uniform\n-    SmallVector<unsigned, 2> ret = {1, 1};\n-    SmallVector<int64_t, 2> shapePerWarp =\n-        mmaVersionToShapePerWarp(version, shape, numWarps);\n-    bool changed = false;\n-    // TODO (@daadaada): double-check.\n-    // original logic in\n-    // https://github.com/openai/triton/blob/master/lib/codegen/analysis/layout.cc#L252\n-    // seems buggy for shape = [32, 16] ?\n-    do {\n-      changed = false;\n-      if (ret[0] * ret[1] >= numWarps)\n-        break;\n-      if (shape[0] / shapePerWarp[0] / ret[0] >=\n-          shape[1] / (shapePerWarp[1] * 2) / ret[1]) {\n-        if (ret[0] < shape[0] / shapePerWarp[0]) {\n-          ret[0] *= 2;\n-        } else\n-          ret[1] *= 2;\n-      } else {\n-        ret[1] *= 2;\n-      }\n-    } while (true);\n-    return ret;\n+    switch (version) {\n+    case 1:\n+      return warpsPerTile<1>(shape, numWarps);\n+    case 2:\n+      return warpsPerTile<2>(shape, numWarps);\n+    default:\n+      assert(false && \"not supported version\");\n+      return {0, 0};\n+    }\n   }\n \n   mlir::LogicalResult"}]