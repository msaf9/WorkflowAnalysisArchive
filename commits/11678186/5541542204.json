[{"filename": "python/test/unit/tools/test_aot.py", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "file_content_changes": "@@ -92,7 +92,7 @@ def kernel(C, A, B,\n   cuMemAlloc(&B, K * N * 2);\n   cuMemAlloc(&C, M * N * 4);\n   cuStreamCreate(&stream, 0);\n-  load_kernel();\n+  load_matmul_fp16xfp16_16x16x16();\n \n   // initialize input data\n   int16_t hA[M*K];\n@@ -105,10 +105,9 @@ def kernel(C, A, B,\n   cuMemcpyHtoD(B, hB, K*N*2);\n \n   // launch kernel\n-  int numWarps = 1;\n   int gX = 1, gY = 1, gZ = 1;\n   cuStreamSynchronize(stream);\n-  kernel(stream, M/BM, N/BN, 1, numWarps, C, A, B, N, K, N);\n+  matmul_fp16xfp16_16x16x16(stream, M/BM, N/BN, 1, C, A, B, N, K, N);\n   cuStreamSynchronize(stream);\n \n   // read data\n@@ -119,7 +118,7 @@ def kernel(C, A, B,\n \n \n   // free cuda handles\n-  unload_kernel();\n+  unload_matmul_fp16xfp16_16x16x16();\n   cuMemFree(A);\n   cuMemFree(B);\n   cuMemFree(C);\n@@ -132,6 +131,7 @@ def test_compile_link_matmul():\n     np.random.seed(3)\n \n     with tempfile.TemporaryDirectory() as tmp_dir:\n+        tmp_dir = \"/home/chunwei/project/triton/python/test/unit/tools/out2\"\n         kernel_path = os.path.join(tmp_dir, \"kernel.py\")\n         with open(kernel_path, \"w\") as file:\n             file.write(kernel_src)\n@@ -153,10 +153,12 @@ def test_compile_link_matmul():\n             for hb in hints:\n                 sig = f'*fp32:16, *{dtype}:16, *{dtype}:16, i32{ha}, 1, i32{hb}, 1, i32:16, 1, {BM}, {BN}, {BK}'\n                 name = f\"matmul_{dtype}x{dtype}_{BM}x{BN}x{BK}\"\n-                subprocess.run([sys.executable, compiler_path, \"-n\", \"kernel\", \"--signature\", sig, \"--out-name\", name, \"-o\", name, \"-w\", 1, kernel_path], check=True, cwd=tmp_dir)\n+                subprocess.run([sys.executable, compiler_path, \"-n\", \"kernel\", \"--signature\", sig, \"--out-name\", name, \"-o\", name, \"-w\", \"1\", kernel_path], check=True, cwd=tmp_dir)\n \n         # link all desired configs\n         h_files = glob.glob(os.path.join(tmp_dir, \"*.h\"))\n+        print('h_files', h_files)\n+        print(' '.join([sys.executable, linker_path] + h_files + [\"-o\", \"kernel\"]))\n         subprocess.run([sys.executable, linker_path] + h_files + [\"-o\", \"kernel\"], check=True, cwd=tmp_dir)\n \n         # compile test case"}, {"filename": "python/triton/tools/compile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -41,7 +41,7 @@ void load_{kernel_name}() {{\n     void *bin = (void *)&CUBIN_NAME;\n     int shared = {shared};\n     CUDA_CHECK(cuModuleLoadData(&{kernel_name}_mod, bin));\n-    CUDA_CHECK(cuModuleGetFunction(&{kernel_name}_func, {kernel_name}_mod, \"{kernel_name}\"));\n+    CUDA_CHECK(cuModuleGetFunction(&{kernel_name}_func, {kernel_name}_mod, \"{triton_kernel_name}\"));\n     // set dynamic shared memory if necessary\n     int shared_optin;\n     CUDA_CHECK(cuDeviceGetAttribute(&shared_optin, CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN, dev));"}, {"filename": "python/triton/tools/compile.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "file_content_changes": "@@ -11,5 +11,6 @@\n void unload_{kernel_name}(void);\n void load_{kernel_name}(void);\n // tt-linker: {kernel_name}:{signature}\n-CUresult{kernel_name}(CUstream stream, unsigned int gX, unsigned int gY,\n-                      unsigned int gZ, {signature});\n+CUresult{_placeholder} {kernel_name}(CUstream stream, unsigned int gX,\n+                                     unsigned int gY, unsigned int gZ,\n+                                     {signature});"}, {"filename": "python/triton/tools/compile.py", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "file_content_changes": "@@ -7,6 +7,7 @@\n from typing import List\n \n import triton\n+from triton.compiler.code_generator import kernel_suffix\n from triton.compiler.make_launcher import ty_to_cpp\n \n desc = \"\"\"\n@@ -27,7 +28,7 @@\n \n The resulting entry point will have signature\n \n-CUresult kernel_{specialization_suffix}(CUstream stream, unsigned gX, unsigned gY, unsigned gZ, unsigned numWarps, float* arg0, int32_t arg1, int32_t arg2)\n+CUresult kernel_{specialization_suffix}(CUstream stream, unsigned gX, unsigned gY, unsigned gZ, float* arg0, int32_t arg1, int32_t arg2)\n \n Different such specialized entry points can be combined using the `linker.py` script.\n \n@@ -41,7 +42,7 @@\n     parser = ArgumentParser(description=desc)\n     parser.add_argument(\"path\", help=\"Path to Python source containing desired kernel in its scope. File will be executed.\")\n     parser.add_argument(\"--kernel-name\", \"-n\", type=str, default=\"\", help=\"Name of the kernel to compile\", required=True)\n-    parser.add_argument(\"--num-warps\", \"-w\", type=int, help=\"Number of warps to launch the kernel\", default=1)\n+    parser.add_argument(\"--num-warps\", \"-w\", type=int, default=1, help=\"Number of warps to launch the kernel\")\n     parser.add_argument(\"--out-name\", \"-on\", type=str, default=None, help=\"Out name for the compiled kernel\")\n     parser.add_argument(\"--out-path\", \"-o\", type=Path, default=None, help=\"Out filename\")\n     parser.add_argument(\"--signature\", \"-s\", type=str, help=\"Signature of the kernel\", required=True)\n@@ -60,6 +61,14 @@\n \n     # validate and parse signature\n     signature = list(map(lambda s: s.strip(\" \"), args.signature.split(\",\")))\n+    print('signature', signature)\n+\n+    def hash_signature(signature: List[str]):\n+        m = hashlib.sha256()\n+        m.update(\" \".join(signature).encode())\n+        return m.hexdigest()[:8]\n+\n+    sig_hash = hash_signature(signature)\n \n     def constexpr(s):\n         try:\n@@ -74,11 +83,6 @@ def constexpr(s):\n             pass\n         return None\n \n-    def hash_signature(signature: List[str]):\n-        m = hashlib.sha256()\n-        m.update(\"\".join(signature).encode())\n-        return m.hexdigest()[:8]\n-\n     hints = {i: constexpr(s.split(\":\")[1]) for i, s in enumerate(signature) if \":\" in s}\n     hints = {k: v for k, v in hints.items() if v is not None}\n     constexprs = {i: constexpr(s) for i, s in enumerate(signature)}\n@@ -95,11 +99,13 @@ def hash_signature(signature: List[str]):\n     arg_names = [kernel.arg_names[i] for i in signature.keys()]\n \n     # dump C stub code\n-    suffix = hash_signature(signature.values())\n-    func_name = '_'.join([out_name, suffix])\n+    suffix = kernel_suffix(signature.values(), config)\n+    func_name = '_'.join([out_name, sig_hash, suffix])\n+    triton_kernel_name = '_'.join([args.kernel_name, suffix])\n     hex_ = str(binascii.hexlify(ccinfo.asm[\"cubin\"]))[2:-1]\n     params = {\n         \"kernel_name\": func_name,\n+        \"triton_kernel_name\": triton_kernel_name,\n         \"bin_size\": len(hex_),\n         \"bin_data\": \", \".join([f\"0x{x}{y}\" for x, y in zip(hex_[::2], hex_[1::2])]),\n         \"signature\": \", \".join([f\"{ty_to_cpp(ty)} {name}\" for name, ty in zip(arg_names, signature.values())]),\n@@ -108,8 +114,9 @@ def hash_signature(signature: List[str]):\n         \"kernel_docstring\": \"\",\n         \"shared\": ccinfo.shared,\n         \"num_warps\": args.num_warps,\n+        \"_placeholder\": \"\",\n     }\n     for ext in ['h', 'c']:\n         template_path = Path(__file__).parent / f\"compile.{ext}\"\n-        with out_path.with_suffix(f\".{suffix}.{ext}\").open(\"w\") as fp:\n+        with out_path.with_suffix(f\".{sig_hash}_{suffix}.{ext}\").open(\"w\") as fp:\n             fp.write(Path(template_path).read_text().format(**params))"}, {"filename": "python/triton/tools/link.py", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "file_content_changes": "@@ -18,6 +18,7 @@ class KernelLinkerMeta:\n     arg_names: Sequence[str]\n     arg_ctypes: Sequence[str]\n     sizes: Sequence[Union[int, None]]\n+    sig_hash: str\n     suffix: str\n     num_specs: int\n     \"\"\" number of specialized arguments \"\"\"\n@@ -30,7 +31,7 @@ def __init__(self) -> None:\n         # [kernel_name, c signature]\n         self.linker_directives = re.compile(\"//[\\\\s]*tt-linker:[\\\\s]*([\\\\w]+):(.+)\")\n         # [name, suffix]\n-        self.kernel_name = re.compile(\"([\\\\w]+)_([\\\\w]+)\")\n+        self.kernel_name = re.compile(\"^([\\\\w]+)_([\\\\w]+)_([\\\\w]+)$\")\n         # [(argnum, d|c)]\n         self.kernel_suffix = re.compile(\"([0-9]+)([c,d])\")\n         # [(type, name)]\n@@ -45,7 +46,7 @@ def extract_linker_meta(self, header: str):\n                 m = self.linker_directives.match(ln)\n                 if _exists(m):\n                     ker_name, c_sig = m.group(1), m.group(2)\n-                    name, suffix = self._match_name(ker_name)\n+                    name, sig_hash, suffix = self._match_name(ker_name)\n                     c_types, arg_names = self._match_c_sig(c_sig)\n                     num_specs, sizes = self._match_suffix(suffix)\n                     self._add_kernel(\n@@ -54,6 +55,7 @@ def extract_linker_meta(self, header: str):\n                             arg_names=arg_names,\n                             arg_ctypes=c_types,\n                             sizes=sizes,\n+                            sig_hash=sig_hash,\n                             suffix=suffix,\n                             num_specs=num_specs,\n                         ),\n@@ -62,8 +64,8 @@ def extract_linker_meta(self, header: str):\n     def _match_name(self, ker_name: str):\n         m = self.kernel_name.match(ker_name)\n         if _exists(m):\n-            name, suffix = m.group(1), m.group(2)\n-            return name, suffix\n+            name, sig_hash, suffix = m.group(1), m.group(2), m.group(3)\n+            return name, sig_hash, suffix\n         raise LinkerError(f\"{ker_name} is not a valid kernel name\")\n \n     def _match_c_sig(self, c_sig: str):\n@@ -110,7 +112,7 @@ def gen_signature(m):\n \n def make_decls(name: str, metas: Sequence[KernelLinkerMeta]) -> str:\n     return f\"\"\"\n-CUresult {name}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, unsigned int numWarps, {gen_signature(metas[-1])});\n+CUresult {name}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, {gen_signature(metas[-1])});\n void load_{name}();\n void unload_{name}();\n     \"\"\"\n@@ -119,26 +121,26 @@ def make_decls(name: str, metas: Sequence[KernelLinkerMeta]) -> str:\n def make_kernel_dispatcher(name: str, metas: Sequence[KernelLinkerMeta]) -> str:\n     src = f\"// launcher for: {name}\\n\"\n     for meta in sorted(metas, key=lambda m: -m.num_specs):\n-        src += f\"CUresult {name}_{meta.suffix}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, unsigned int numWarps, {gen_signature(meta)});\\n\"\n+        src += f\"CUresult {name}_{meta.sig_hash}_{meta.suffix}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, {gen_signature(meta)});\\n\"\n     src += \"\\n\"\n \n-    src += f\"CUresult {name}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, unsigned int numWarps, {gen_signature(metas[-1])}){{\"\n+    src += f\"CUresult {name}(CUstream stream, unsigned int gX, unsigned int gY, unsigned int gZ, {gen_signature(metas[-1])}){{\"\n     src += \"\\n\"\n     for meta in sorted(metas, key=lambda m: -m.num_specs):\n         cond_fn = lambda val, hint: f\"({val} % {hint} == 0)\" if hint == 16 else f\"({val} == {hint})\" if hint == 1 else None\n         conds = \" && \".join([cond_fn(val, hint) for val, hint in zip(meta.arg_names, meta.sizes) if hint is not None])\n         src += f\"  if ({conds})\\n\"\n-        src += f\"    return {name}_{meta.suffix}(stream, gX, gY, gZ, numWarps, {', '.join(meta.arg_names)});\\n\"\n+        src += f\"    return {name}_{meta.sig_hash}_{meta.suffix}(stream, gX, gY, gZ, {', '.join(meta.arg_names)});\\n\"\n     src += \"}\\n\"\n \n     for mode in [\"load\", \"unload\"]:\n         src += f\"\\n// {mode} for: {name}\\n\"\n         for meta in sorted(metas, key=lambda m: -m.num_specs):\n-            src += f\"void {mode}_{name}_{meta.suffix}();\\n\"\n+            src += f\"void {mode}_{name}_{meta.sig_hash}_{meta.suffix}();\\n\"\n         src += f\"void {mode}_{name}() {{\"\n         src += \"\\n\"\n         for meta in sorted(metas, key=lambda m: -m.num_specs):\n-            src += f\"  {mode}_{name}_{meta.suffix}();\\n\"\n+            src += f\"  {mode}_{name}_{meta.sig_hash}_{meta.suffix}();\\n\"\n         src += \"}\\n\"\n     return src\n "}]