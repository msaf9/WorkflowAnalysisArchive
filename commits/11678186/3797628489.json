[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "file_content_changes": "@@ -404,10 +404,24 @@ struct ConvertLayoutOpConversion\n         coord2val[elemId] = std::make_pair(multiDimOffset, vals[elemId]);\n       }\n \n+      auto [isARow, isBRow, isAVec4, isBVec4] = mma.decodeVoltaLayoutStates();\n+\n       DotOpMmaV1ConversionHelper helper(mma);\n       // do transpose\n-      int numM = helper.getRepM(shape[0]);\n-      int numN = helper.getRepN(shape[1]);\n+      int numM = helper.getNumM(shape[0], isARow, isAVec4);\n+      int numN = helper.getNumN(shape[1], isBRow, isBVec4);\n+      numM = 4; // DEBUG\n+      numN = 4;\n+      printf(\"numM: %d\\n\", numM);\n+      printf(\"numN: %d\\n\", numN);\n+      printf(\"coord: %lu\\n\", coord2valT.size());\n+\n+      for (auto &coord : coord2val) { // DEBUG\n+        LLVM::vprintf(\n+            \"coord t-%d (%d %d) %f\",\n+            {LLVM::gThreadId, coord.first[0], coord.first[1], coord.second},\n+            rewriter);\n+      }\n       for (int r = 0; r < numM; r++) {\n         for (int c = 0; c < numN; c++) {\n           coord2valT[r * numN + c] = std::move(coord2val[c * numM + r]);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "file_content_changes": "@@ -55,6 +55,13 @@ struct DotOpMmaV1ConversionHelper {\n \n     AParam(bool isARow, ArrayRef<int64_t> shape) {\n       isAVec4 = !isARow && shape[isARow] <= 16;\n+      build(isARow);\n+    }\n+\n+    AParam(bool isARow, bool isAVec4) : isAVec4(isAVec4) { build(isARow); }\n+\n+  private:\n+    void build(bool isARow) {\n       int packSize0 = (isARow || isAVec4) ? 1 : 2;\n       int repM = 2 * packSize0;\n       int repK = 1;\n@@ -74,6 +81,14 @@ struct DotOpMmaV1ConversionHelper {\n \n     BParam(bool isBRow, ArrayRef<int64_t> shape) {\n       isBVec4 = isBRow && shape[isBRow] <= 16;\n+      build(isBRow);\n+    }\n+\n+    BParam(bool isBRow, bool isBVec4) : isBVec4(isBVec4) { build(isBRow); }\n+\n+  private:\n+    void build(bool isBRow) {\n+\n       int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n       rep.assign({0, 2 * packSize1, 1});\n       spw.assign({0, fpw[1] * 4 * rep[1], 1});\n@@ -105,6 +120,13 @@ struct DotOpMmaV1ConversionHelper {\n     return numM;\n   }\n \n+  unsigned getNumM(int M, bool isARow, bool isAVec4) const {\n+    AParam param(isARow, isAVec4);\n+\n+    unsigned numM = param.rep[0] * M / (param.spw[0] * wpt[0]);\n+    return numM;\n+  }\n+\n   // Get the number of fp16x2 elements for $b.\n   unsigned getNumN(ArrayRef<int64_t> shapeB, bool isBRow) const {\n     BParam param(isBRow, shapeB);\n@@ -113,6 +135,13 @@ struct DotOpMmaV1ConversionHelper {\n     return numN;\n   }\n \n+  unsigned getNumN(int N, bool isBRow, bool isBVec4) const {\n+    BParam param(isBRow, isBVec4);\n+\n+    unsigned numN = param.rep[1] * N / (param.spw[1] * wpt[1]);\n+    return numN;\n+  }\n+\n   int numElemsPerThreadA(ArrayRef<int64_t> shape, bool isRow, int vec) const {\n     int numM = getNumM(shape, isRow);\n     int NK = shape[1];"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpToLLVM.cpp", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "file_content_changes": "@@ -125,6 +125,8 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n \n     unsigned numM = helper.getNumM(AShape, isARow);\n     unsigned numN = helper.getNumN(BShape, isBRow);\n+    printf(\"mma884 numM: %d\\n\", numM);\n+    printf(\"mma884 numN: %d\\n\", numN);\n     unsigned NK = AShape[1];\n \n     auto has = helper.extractLoadedOperand(adaptor.a(), NK, rewriter);\n@@ -156,20 +158,6 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n       return idx;\n     };\n \n-    { // convert the acc's value from accumuator-external order to\n-      // accumulator-internal order.\n-      SmallVector<Value> accInit(acc.size());\n-\n-      for (unsigned m = 0; m < numM / 2; ++m)\n-        for (unsigned n = 0; n < numN / 2; ++n) {\n-          auto idx = getIdx(m, n);\n-          for (unsigned i = 0; i < 8; ++i)\n-            accInit[idx[i]] = acc[(m * numN / 2 + n) * 8 + i];\n-        }\n-\n-      acc = accInit;\n-    }\n-\n     auto callMMA = [&](unsigned m, unsigned n, unsigned k) {\n       auto ha = has.at({m, k});\n       auto hb = hbs.at({n, k});\n@@ -208,7 +196,6 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n       for (unsigned i = 0; i < 8; i++) {\n         Value elem = extract_val(f32_ty, res, getIntAttr(i));\n         acc[idx[i]] = elem;\n-        resVals[(m * numN / 2 + n) * 8 + i] = elem;\n       }\n     };\n \n@@ -218,6 +205,11 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n           callMMA(m, n, k);\n         }\n \n+    // res holds the same layout of acc\n+    for (size_t i = 0; i < acc.size(); ++i) {\n+      resVals[i] = acc[i];\n+    }\n+\n     Type structTy = LLVM::LLVMStructType::getLiteral(\n         ctx, SmallVector<Type>(resSize, type::f32Ty(ctx)));\n     Value res = getStructFromElements(loc, resVals, rewriter, structTy);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "file_content_changes": "@@ -500,6 +500,31 @@ struct AsyncWaitOpConversion\n   }\n };\n \n+namespace mlir {\n+namespace LLVM {\n+\n+void vprintf(StringRef msg, ValueRange args,\n+             ConversionPatternRewriter &rewriter) {\n+  PrintfOpConversion::llPrintf(msg, args, rewriter);\n+}\n+\n+void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n+                   std::string elem_repr, ConversionPatternRewriter &builder) {\n+  std::string fmt = info + \" t-%d \";\n+  std::vector<Value> new_arr({thread});\n+  for (int i = 0; i < arr.size(); ++i) {\n+    fmt += elem_repr + ((i == arr.size() - 1) ? \"\" : \", \");\n+    new_arr.push_back(arr[i]);\n+  }\n+\n+  vprintf(fmt, new_arr, builder);\n+}\n+\n+Value gThreadId;\n+\n+} // namespace LLVM\n+} // namespace mlir\n+\n void populateTritonGPUToLLVMPatterns(mlir::LLVMTypeConverter &typeConverter,\n                                      RewritePatternSet &patterns, int numWarps,\n                                      AxisInfoAnalysis &axisInfoAnalysis,\n@@ -518,4 +543,4 @@ void populateTritonGPUToLLVMPatterns(mlir::LLVMTypeConverter &typeConverter,\n   patterns.add<MakeRangeOpConversion>(typeConverter, benefit);\n   patterns.add<ReturnOpConversion>(typeConverter, benefit);\n   patterns.add<PrintfOpConversion>(typeConverter, benefit);\n-}\n\\ No newline at end of file\n+}"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "file_content_changes": "@@ -19,6 +19,20 @@ using ::mlir::triton::gpu::BlockedEncodingAttr;\n using ::mlir::triton::gpu::MmaEncodingAttr;\n using ::mlir::triton::gpu::SliceEncodingAttr;\n \n+namespace mlir {\n+namespace LLVM {\n+extern Value gThreadId;\n+\n+// Helper function for using printf in LLVM conversion.\n+void vprintf(StringRef msg, ValueRange args,\n+             ConversionPatternRewriter &rewriter);\n+\n+void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n+                   std::string elem_repr, ConversionPatternRewriter &builder);\n+\n+} // namespace LLVM\n+} // namespace mlir\n+\n // FuncOpConversion/FuncOpConversionBase is borrowed from\n // https://github.com/llvm/llvm-project/blob/fae656b2dd80246c3c6f01e9c77c49560368752c/mlir/lib/Conversion/FuncToLLVM/FuncToLLVM.cpp#L276\n // since it is not exposed on header files in mlir v14\n@@ -166,6 +180,8 @@ class ConvertTritonGPUOpToLLVMPattern\n         ValueRange{rewriter.create<::mlir::gpu::ThreadIdOp>(\n             loc, rewriter.getIndexType(), ::mlir::gpu::Dimension::x)});\n     Value threadId = cast.getResult(0);\n+    LLVM::gThreadId = threadId; // DEBUG\n+\n     return threadId;\n   }\n "}]