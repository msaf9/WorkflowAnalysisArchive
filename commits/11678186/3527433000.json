[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "file_content_changes": "@@ -2239,16 +2239,16 @@ struct AllocTensorOpConversion\n     smemBase = bitcast(smemBase, elemPtrTy);\n     auto order = resultTy.getEncoding().cast<SharedEncodingAttr>().getOrder();\n     // workaround for 3D tensors\n-    // TODO: We need to modify the pipeline pass to give a proper shared encoding to 3D tensors\n+    // TODO: We need to modify the pipeline pass to give a proper shared\n+    // encoding to 3D tensors\n     SmallVector<unsigned> newOrder;\n-    if (resultTy.getShape().size() == 3) \n+    if (resultTy.getShape().size() == 3)\n       newOrder = {1 + order[0], 1 + order[1], 0};\n     else\n       newOrder = SmallVector<unsigned>(order.begin(), order.end());\n \n-    \n-    auto smemObj =\n-        SharedMemoryObject(smemBase, resultTy.getShape(), newOrder, loc, rewriter);\n+    auto smemObj = SharedMemoryObject(smemBase, resultTy.getShape(), newOrder,\n+                                      loc, rewriter);\n     auto retVal = getStructFromSharedMemoryObject(loc, smemObj, rewriter);\n     rewriter.replaceOp(op, retVal);\n     return success();\n@@ -2882,6 +2882,8 @@ struct ConvertLayoutOpConversion\n       SmallVector<Value> multiDimWarpId(2);\n       multiDimWarpId[0] = urem(warpId, idx_val(mmaLayout.getWarpsPerCTA()[0]));\n       multiDimWarpId[1] = udiv(warpId, idx_val(mmaLayout.getWarpsPerCTA()[0]));\n+      multiDimWarpId[0] = urem(multiDimWarpId[0], idx_val(shape[0] / 16));\n+      multiDimWarpId[1] = urem(multiDimWarpId[1], idx_val(shape[1] / 8));\n       Value four = idx_val(4);\n       Value mmaGrpId = udiv(laneId, four);\n       Value mmaGrpIdP8 = add(mmaGrpId, idx_val(8));\n@@ -4128,8 +4130,9 @@ struct DotOpMmaV2ConversionHelper {\n struct MMA16816ConversionHelper {\n   MmaEncodingAttr mmaLayout;\n   ArrayRef<unsigned int> wpt;\n+  SmallVector<unsigned int> properWpt;\n \n-  Value thread, lane, warp, warpMN, warpN, warpM;\n+  Value thread, lane, warp;\n \n   DotOpMmaV2ConversionHelper helper;\n   ConversionPatternRewriter &rewriter;\n@@ -4139,20 +4142,35 @@ struct MMA16816ConversionHelper {\n \n   using ValueTable = std::map<std::pair<unsigned, unsigned>, Value>;\n \n-  MMA16816ConversionHelper(MmaEncodingAttr mmaLayout, Value thread,\n-                           ConversionPatternRewriter &rewriter,\n+  // dotOperand: type of either one operand of dotOp.\n+  MMA16816ConversionHelper(Type dotOperand, MmaEncodingAttr mmaLayout,\n+                           Value thread, ConversionPatternRewriter &rewriter,\n                            TypeConverter *typeConverter, Location loc)\n       : mmaLayout(mmaLayout), thread(thread), helper(mmaLayout),\n         rewriter(rewriter), typeConverter(typeConverter), loc(loc),\n         ctx(mmaLayout.getContext()) {\n     wpt = mmaLayout.getWarpsPerCTA();\n+    helper.deduceMmaType(dotOperand);\n \n     Value _32 = i32_val(32);\n     lane = urem(thread, _32);\n     warp = udiv(thread, _32);\n-    warpMN = udiv(warp, i32_val(wpt[0]));\n-    warpM = urem(warp, i32_val(wpt[0]));\n-    warpN = urem(warpMN, i32_val(wpt[1]));\n+    // warpMN = udiv(warp, i32_val(wpt[0]));\n+    // warpM = urem(warp, i32_val(wpt[0]));\n+    // warpN = urem(warpMN, i32_val(wpt[1]));\n+  }\n+\n+  // Get a warpId for M axis.\n+  Value getWarpM(int M) const {\n+    auto matShape = helper.getMmaMatShape();\n+    return urem(urem(warp, i32_val(wpt[0])), i32_val(M / matShape[0]));\n+  }\n+\n+  // Get a warpId for N axis.\n+  Value getWarpN(int N) const {\n+    auto matShape = helper.getMmaMatShape();\n+    Value warpMN = udiv(warp, i32_val(wpt[0]));\n+    return urem(urem(warpMN, i32_val(wpt[1])), i32_val(N / matShape[1]));\n   }\n \n   // Get the mmaInstrShape from either $a or $b.\n@@ -4214,20 +4232,18 @@ struct MMA16816ConversionHelper {\n   }\n \n   // Get number of elements per thread for $a operand.\n-  static size_t getANumElemsPerThread(RankedTensorType operand,\n-                                      ArrayRef<unsigned> wpt) {\n+  static size_t getANumElemsPerThread(RankedTensorType operand, int wpt) {\n     auto shape = operand.getShape();\n-    int repM = getNumRepM(operand, shape[0], wpt[0]);\n+    int repM = getNumRepM(operand, shape[0], wpt);\n     int repK = getNumRepK_(operand, shape[1]);\n     return 4 * repM * repK;\n   }\n \n   // Get number of elements per thread for $b operand.\n-  static size_t getBNumElemsPerThread(RankedTensorType operand,\n-                                      ArrayRef<unsigned> wpt) {\n+  static size_t getBNumElemsPerThread(RankedTensorType operand, int wpt) {\n     auto shape = operand.getShape();\n     int repK = getNumRepK_(operand, shape[0]);\n-    int repN = getNumRepN(operand, shape[1], wpt[1]);\n+    int repN = getNumRepN(operand, shape[1], wpt);\n     return 4 * std::max(repN / 2, 1) * repK;\n   }\n \n@@ -4245,6 +4261,7 @@ struct MMA16816ConversionHelper {\n     int numRepK = getNumRepK(aTensorTy, shape[1]);\n \n     if (aTensorTy.getEncoding().isa<SharedEncodingAttr>()) {\n+      Value warpM = getWarpM(shape[0]);\n       // load from smem\n       loadFn = getLoadMatrixFn(\n           tensor, smemObj, mmaLayout, mmaLayout.getWarpsPerCTA()[0] /*wpt*/,\n@@ -4278,6 +4295,7 @@ struct MMA16816ConversionHelper {\n     int numRepK = getNumRepK(tensorTy, shape[0]);\n     int numRepN = getNumRepN(tensorTy, shape[1]);\n \n+    Value warpN = getWarpN(shape[1]);\n     auto loadFn = getLoadMatrixFn(\n         tensor, smemObj, mmaLayout, mmaLayout.getWarpsPerCTA()[1] /*wpt*/,\n         0 /*kOrder*/, {mmaInstrK, mmaInstrN} /*instrShape*/,\n@@ -4606,9 +4624,9 @@ Value ConvertLayoutOpConversion::lowerSharedToDotOperandMMA(\n   Value res;\n \n   if (!isOuter && mmaLayout.getVersion() == 2 && isHMMA) { // tensor core v2\n-    MMA16816ConversionHelper mmaHelper(mmaLayout, getThreadId(rewriter, loc),\n-                                       rewriter, getTypeConverter(),\n-                                       op.getLoc());\n+    MMA16816ConversionHelper mmaHelper(src.getType(), mmaLayout,\n+                                       getThreadId(rewriter, loc), rewriter,\n+                                       getTypeConverter(), op.getLoc());\n \n     if (dotOperandLayout.getOpIdx() == 0) {\n       // operand $a\n@@ -4699,12 +4717,15 @@ DotOpConversion::convertMMA16816(triton::DotOp op, OpAdaptor adaptor,\n                        .cast<RankedTensorType>()\n                        .getEncoding()\n                        .cast<MmaEncodingAttr>();\n-  MMA16816ConversionHelper mmaHelper(mmaLayout, getThreadId(rewriter, loc),\n-                                     rewriter, getTypeConverter(), loc);\n \n   Value A = op.a();\n   Value B = op.b();\n   Value C = op.c();\n+\n+  MMA16816ConversionHelper mmaHelper(A.getType(), mmaLayout,\n+                                     getThreadId(rewriter, loc), rewriter,\n+                                     getTypeConverter(), loc);\n+\n   auto ATensorTy = A.getType().cast<RankedTensorType>();\n   auto BTensorTy = B.getType().cast<RankedTensorType>();\n \n@@ -5536,13 +5557,13 @@ class TritonGPUToLLVMTypeConverter : public LLVMTypeConverter {\n         if (mmaLayout.getVersion() == 2) {\n           if (dotOpLayout.getOpIdx() == 0) { // $a\n             int elems =\n-                MMA16816ConversionHelper::getANumElemsPerThread(type, wpt);\n+                MMA16816ConversionHelper::getANumElemsPerThread(type, wpt[0]);\n             return LLVM::LLVMStructType::getLiteral(\n                 ctx, SmallVector<Type>(elems, vecTy));\n           }\n           if (dotOpLayout.getOpIdx() == 1) { // $b\n             int elems =\n-                MMA16816ConversionHelper::getBNumElemsPerThread(type, wpt);\n+                MMA16816ConversionHelper::getBNumElemsPerThread(type, wpt[1]);\n             return struct_ty(SmallVector<Type>(elems, vecTy));\n           }\n         }\n@@ -6163,10 +6184,9 @@ class ConvertTritonGPUToLLVM\n       if (srcBlocked && dstDotOp) {\n         auto tmpType = RankedTensorType::get(\n             dstType.getShape(), dstType.getElementType(),\n-            triton::gpu::SharedEncodingAttr::get(mod.getContext(), dstDotOp,\n-                                                 srcType.getShape(),\n-                                                 getOrder(srcBlocked),\n-                                                 srcType.getElementType()));\n+            triton::gpu::SharedEncodingAttr::get(\n+                mod.getContext(), dstDotOp, srcType.getShape(),\n+                getOrder(srcBlocked), srcType.getElementType()));\n         auto tmp = builder.create<triton::gpu::ConvertLayoutOp>(\n             cvtOp.getLoc(), tmpType, cvtOp.getOperand());\n         auto newConvert = builder.create<triton::gpu::ConvertLayoutOp>("}]