[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "file_content_changes": "@@ -123,12 +123,13 @@ void LoopPipeliner::collectDeps(Value v, int stages, DenseSet<Value> &deps) {\n     return;\n \n   if (auto arg = v.dyn_cast<BlockArgument>()) {\n-    deps.insert(v);\n-    if (arg.getArgNumber() > 0)\n+    if (arg.getArgNumber() > 0) {\n       // Skip the first arg (loop induction variable)\n       // Otherwise the op idx is arg.getArgNumber()-1\n+      deps.insert(v);\n       collectDeps(yieldOp->getOperand(arg.getArgNumber() - 1), stages - 1,\n                   deps);\n+    }\n   } else { // value\n     // v might be in deps, but we still need to visit v.\n     // This is because v might depend on value in previous iterations\n@@ -379,11 +380,11 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n   OpBuilder builder(forOp);\n \n   // Order of new args:\n-  //   (original args),\n-  //   (insertSliceAsync buffer at stage numStages - 1)  for each load\n-  //   (extracted tensor)  for each load\n-  //   (depArgs at stage numStages-1)\n-  //   (iv at stage numStages-1)\n+  //   (original args)\n+  //   (insertSliceAsync buffer at stage numStages - 1) for each load\n+  //   (extracted tensor) for each load\n+  //   (depArgs at stage numStages - 1)\n+  //   (iv at stage numStages - 2)\n   //   (pipeline iteration index)\n   //   (loop iteration index)\n   SmallVector<Value> newLoopArgs;\n@@ -404,6 +405,8 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n   for (BlockArgument depArg : depArgs) {\n     depArgsIdx[depArg] = newLoopArgs.size();\n     newLoopArgs.push_back(valueMapping[depArg][numStages - 1]);\n+    llvm::errs() << \"depArg: \" << depArg << \" idx: \" << newLoopArgs.size() - 1\n+                 << \"\\n\";\n   }\n \n   size_t nextIVIdx = newLoopArgs.size();\n@@ -424,6 +427,7 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n   BlockAndValueMapping mapping;\n   for (const auto &arg : llvm::enumerate(forOp.getRegionIterArgs()))\n     mapping.map(arg.value(), newForOp.getRegionIterArgs()[arg.index()]);\n+  mapping.map(forOp.getInductionVar(), newForOp.getInductionVar());\n \n   // 2.1 clone the loop body, replace original args with args of the new ForOp\n   // Insert async wait if necessary.\n@@ -472,6 +476,7 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n   Value nextLoopCond =\n       builder.create<arith::CmpIOp>(nextIV.getLoc(), arith::CmpIPredicate::slt,\n                                     nextIV, newForOp.getUpperBound());\n+  nextMapping.map(forOp.getInductionVar(), nextIV);\n \n   // Slice index\n   SmallVector<Value> nextBuffers;\n@@ -601,9 +606,11 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n   for (Value nextSlice : extractSlices)\n     yieldValues.push_back(nextSlice);\n \n-  for (size_t i = depArgsBeginIdx; i < nextIVIdx; ++i)\n-    yieldValues.push_back(\n-        depArgsMapping.lookup(newForOp.getRegionIterArgs()[i]));\n+  for (size_t i = depArgsBeginIdx; i < nextIVIdx; ++i) {\n+    auto arg = newForOp.getRegionIterArgs()[i];\n+    assert(depArgsMapping.count(arg) && \"Missing loop-carried value\");\n+    yieldValues.push_back(depArgsMapping[arg]);\n+  }\n   yieldValues.push_back(nextIV);\n   yieldValues.push_back(pipelineIterIdx);\n   yieldValues.push_back(loopIterIdx);"}]