[{"filename": "include/triton/Conversion/TritonGPUToLLVM/AsmFormat.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "file_content_changes": "@@ -4,6 +4,7 @@\n #include \"mlir/IR/Value.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"llvm/ADT/SmallVector.h\"\n+#include \"llvm/ADT/StringExtras.h\"\n #include \"llvm/ADT/StringRef.h\"\n #include <memory>\n #include <string>\n@@ -17,14 +18,7 @@ using llvm::StringRef;\n \n inline std::string strJoin(llvm::ArrayRef<std::string> strs,\n                            llvm::StringRef delimiter) {\n-  std::string osStr;\n-  llvm::raw_string_ostream os(osStr);\n-  for (size_t i = 0; !strs.empty() && i < strs.size() - 1; ++i)\n-    os << strs[i] << delimiter;\n-  if (!strs.empty())\n-    os << strs.back();\n-  os.flush();\n-  return osStr;\n+  return llvm::join(strs.begin(), strs.end(), delimiter);\n }\n \n } // namespace triton"}, {"filename": "include/triton/Conversion/TritonGPUToLLVM/GCNAsmFormat.h", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "file_content_changes": "@@ -19,6 +19,69 @@ class GCNInstr;\n class GCNInstrCommon;\n class GCNInstrExecution;\n \n+// GCNBuilder helps to manage a GCN asm program consists of one or multiple\n+// instructions.\n+//\n+// A helper for building an ASM program, the objective of GCNBuilder is to give\n+// a thin encapsulation and make the ASM code for MLIR LLVM Dialect more clear.\n+// Currently, several factors are introduced to reduce the need for mixing\n+// string and C++ if-else code.\n+//\n+// Usage:\n+// To create a multiplcation operation\n+//\n+//\n+// GCNBuilder gcnBuilder;\n+// unsigned bitwidth = elemTy.getIntOrFloatBitWidth();\n+//\n+// const std::string readConstraint = \"v\";\n+// const std::string writeConstraint = \"=v\";\n+// auto res = gcnBuilder.newOperand(writeConstraint);\n+// auto lhs = gcnBuilder.newOperand(operands[0], readConstraint);\n+// auto rhs = gcnBuilder.newOperand(operands[1], readConstraint);\n+//\n+// create inst\n+// auto &mul_inst =\n+// gcnBuilder.create<GCNInstr>(\"v_mul\")->float_op_type(bitwidth);\n+//\n+// launch insts\n+// mul_inst(res, lhs, rhs);\n+//\n+// return result\n+// Value ret = gcnBuilder.launch(rewriter, loc, elemTy, false);\n+// return ret;\n+// To get the asm code:\n+// builder.dump()\n+//\n+// To get all the mlir::Value used in the GCN code,\n+//\n+// builder.getAllMlirArgs() // get {pVal, iVal, jVal, kVal}\n+//\n+// To get the string containing all the constraints with \",\" separated,\n+// builder.getConstraints() // get \"=v,v,v\"\n+//\n+// GCNBuilder can build a GCN asm with multiple instructions, sample code:\n+//\n+// GCNBuilder builder;\n+// auto &rcp = gcnBuilder.create<GCNInstr>(\"v_rcp\")->float_op_type(bitwidth);\n+// auto &mul_inst =\n+// gcnBuilder.create<GCNInstr>(\"v_mul\")->float_op_type(bitwidth);\n+//\n+// rcp(...);\n+// mul_inst(...);\n+// This will get a GCN code with two instructions.\n+//\n+// Similar to a C function, a declared GCNInstr instance can be launched\n+// multiple times with different operands, e.g.\n+//\n+//   auto &mul_inst =\n+//   gcnBuilder.create<GCNInstr>(\"v_mul\")->float_op_type(bitwidth); mul_inst(...\n+//   some operands ...); mul_inst(... some different operands ...);\n+//\n+// Finally, we will get a GCN code with two mov instructions.\n+//\n+// There are several derived instruction type for typical instructions, for\n+// example, the GCNIOInstr for ld and st instructions.\n struct GCNBuilder {\n   struct Operand {\n     std::string constraint;"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "file_content_changes": "@@ -129,11 +129,11 @@ void init_triton_ir(py::module &&m) {\n       .def(\"load_triton\", [](mlir::MLIRContext &self) {\n         self.getOrLoadDialect<mlir::triton::TritonDialect>();\n         self.getOrLoadDialect<mlir::index::IndexDialect>();\n+        self.getOrLoadDialect<mlir::triton::TritonDialect>();\n+        self.getOrLoadDialect<mlir::gpu::GPUDialect>();\n         // we load LLVM because the frontend uses LLVM.undef for\n         // some placeholders\n-        self.getOrLoadDialect<mlir::triton::TritonDialect>();\n         self.getOrLoadDialect<mlir::LLVM::LLVMDialect>();\n-        self.getOrLoadDialect<mlir::gpu::GPUDialect>();\n       });\n   // .def(py::init([](){\n   //   mlir::MLIRContext context;\n@@ -404,7 +404,8 @@ void init_triton_ir(py::module &&m) {\n                         mlir::triton::gpu::TritonGPUDialect,\n                         mlir::math::MathDialect, mlir::arith::ArithDialect,\n                         mlir::index::IndexDialect, mlir::func::FuncDialect,\n-                        mlir::scf::SCFDialect, mlir::cf::ControlFlowDialect>();\n+                        mlir::scf::SCFDialect, mlir::cf::ControlFlowDialect,\n+                        mlir::LLVM::LLVMDialect>();\n         context.appendDialectRegistry(registry);\n         context.loadAllAvailableDialects();\n "}]