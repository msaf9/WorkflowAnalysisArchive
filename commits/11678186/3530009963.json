[{"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "file_content_changes": "@@ -567,8 +567,6 @@ static int computeCapabilityToMMAVersion(int computeCapability) {\n     return 1;\n   } else if (computeCapability < 90) {\n     return 2;\n-  } else if (computeCapability < 100) {\n-    return 3;\n   } else {\n     assert(false && \"computeCapability > 90 not supported\");\n     return 0;\n@@ -588,18 +586,12 @@ mmaVersionToShapePerWarp(int version, const ArrayRef<int64_t> &shape,\n   }\n }\n \n-inline unsigned clamp(unsigned x, unsigned a, unsigned b) {\n-  unsigned lo = std::min(a, b);\n-  unsigned hi = std::max(a, b);\n-  return std::min(std::max(x, lo), hi);\n-}\n-\n template <int version>\n-SmallVector<unsigned, 2> warpsPerTile(const ArrayRef<int64_t> &shape,\n+SmallVector<unsigned, 2> warpsPerTile(const ArrayRef<int64_t> shape,\n                                       int numWarps);\n \n template <>\n-SmallVector<unsigned, 2> warpsPerTile<1>(const ArrayRef<int64_t> &shape,\n+SmallVector<unsigned, 2> warpsPerTile<1>(const ArrayRef<int64_t> shape,\n                                          int numWarps) {\n   SmallVector<unsigned, 2> ret = {1, 1};\n   SmallVector<int64_t, 2> shapePerWarp =\n@@ -608,41 +600,40 @@ SmallVector<unsigned, 2> warpsPerTile<1>(const ArrayRef<int64_t> &shape,\n   do {\n     changed = false;\n     if (ret[0] * ret[1] < numWarps) {\n-      ret[0] = clamp(ret[0] * 2, 1, shape[0] / shapePerWarp[0]);\n+      ret[0] = std::clamp<unsigned>(ret[0] * 2, 1, shape[0] / shapePerWarp[0]);\n       changed = true;\n     }\n     if (ret[0] * ret[1] < numWarps) {\n-      ret[1] = clamp(ret[1] * 2, 1, shape[1] / shapePerWarp[1]);\n+      ret[1] = std::clamp<unsigned>(ret[1] * 2, 1, shape[1] / shapePerWarp[1]);\n       changed = true;\n     }\n   } while (changed);\n   return ret;\n }\n \n template <>\n-SmallVector<unsigned, 2> warpsPerTile<2>(const ArrayRef<int64_t> &shape,\n+SmallVector<unsigned, 2> warpsPerTile<2>(const ArrayRef<int64_t> shape,\n                                          int numWarps) {\n   SmallVector<unsigned, 2> ret = {1, 1};\n   SmallVector<int64_t, 2> shapePerWarp =\n       mmaVersionToShapePerWarp(2, shape, numWarps);\n-  bool changed = false;\n+  // TODO (@daadaada): double-check.\n+  // original logic in\n+  // https://github.com/openai/triton/blob/master/lib/codegen/analysis/layout.cc#L252\n+  // seems buggy for shape = [32, 16] ?\n   do {\n-    changed = false;\n     if (ret[0] * ret[1] >= numWarps)\n       break;\n     if (shape[0] / shapePerWarp[0] / ret[0] >=\n         shape[1] / (shapePerWarp[1] * 2) / ret[1]) {\n       if (ret[0] < shape[0] / shapePerWarp[0]) {\n         ret[0] *= 2;\n-        changed = true;\n-      }\n-    } else {\n-      if (ret[1] < shape[1] / shapePerWarp[1]) {\n+      } else\n         ret[1] *= 2;\n-        changed = true;\n-      }\n+    } else {\n+      ret[1] *= 2;\n     }\n-  } while (changed);\n+  } while (true);\n   return ret;\n }\n \n@@ -655,8 +646,8 @@ class BlockedToMMA : public mlir::RewritePattern {\n       : mlir::RewritePattern(triton::DotOp::getOperationName(), 2, context),\n         computeCapability(computeCapability) {}\n \n-  static SmallVector<unsigned, 2>\n-  getWarpsPerTile(const ArrayRef<int64_t> &shape, int version, int numWarps) {\n+  static SmallVector<unsigned, 2> getWarpsPerTile(const ArrayRef<int64_t> shape,\n+                                                  int version, int numWarps) {\n     switch (version) {\n     case 1:\n       return warpsPerTile<1>(shape, numWarps);"}]