[{"filename": "lib/Dialect/TritonGPU/Transforms/RemoveLayoutConversions.cpp", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "file_content_changes": "@@ -174,26 +174,26 @@ inline bool expensiveLoadOrStore(Operation *op, Attribute &targetEncoding) {\n   // same\n   if (isSingleValue(op->getOperand(0)))\n     return false;\n-  //auto ptr = op->getOperand(0);\n-  //// Case 2: We assume that `evict_last` loads/stores have high hit rate\n-  //if (auto load = dyn_cast<triton::LoadOp>(op))\n-  //  if (load.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n-  //    return false;\n-  //if (auto store = dyn_cast<triton::StoreOp>(op))\n-  //  if (store.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n-  //    return false;\n-  //if (auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>()) {\n-  //  auto encoding = tensorTy.getEncoding();\n-  //  // Case 3: Different type conversion is expensive (e.g., mma <-> block)\n-  //  if (encoding.getTypeID() != targetEncoding.getTypeID())\n-  //    return true;\n-  //  auto sizePerThread = triton::gpu::getSizePerThread(encoding);\n-  //  auto targetSizePerThread = triton::gpu::getSizePerThread(targetEncoding);\n-  //  auto order = triton::gpu::getOrder(encoding);\n-  //  auto targetOrder = triton::gpu::getOrder(targetEncoding);\n-  //  // Case 4: The targeEncoding may expose more vectorization opportunities\n-  //  return sizePerThread[order[0]] >= targetSizePerThread[targetOrder[0]];\n-  //}\n+  auto ptr = op->getOperand(0);\n+  // Case 2: We assume that `evict_last` loads/stores have high hit rate\n+  if (auto load = dyn_cast<triton::LoadOp>(op))\n+    if (load.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n+      return false;\n+  if (auto store = dyn_cast<triton::StoreOp>(op))\n+    if (store.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n+      return false;\n+  if (auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>()) {\n+    auto encoding = tensorTy.getEncoding();\n+    // Case 3: Different type conversion is expensive (e.g., mma <-> block)\n+    if (encoding.getTypeID() != targetEncoding.getTypeID())\n+      return true;\n+    auto sizePerThread = triton::gpu::getSizePerThread(encoding);\n+    auto targetSizePerThread = triton::gpu::getSizePerThread(targetEncoding);\n+    auto order = triton::gpu::getOrder(encoding);\n+    auto targetOrder = triton::gpu::getOrder(targetEncoding);\n+    // Case 4: The targeEncoding may expose more vectorization opportunities\n+    return sizePerThread[order[0]] >= targetSizePerThread[targetOrder[0]];\n+  }\n   return false;\n }\n "}]