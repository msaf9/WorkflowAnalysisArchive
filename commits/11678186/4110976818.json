[{"filename": "lib/Dialect/TritonGPU/Transforms/Coalesce.cpp", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "file_content_changes": "@@ -26,6 +26,8 @@ SmallVector<unsigned, 4> argSort(const T& arr){\n   return ret;\n }\n \n+typedef DenseMap<Value, std::function<Type(Type)>> LayoutMap;\n+\n struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n   Attribute getCoalescedEncoding(AxisInfoAnalysis &axisInfo, Value ptr,\n                                  int numWarps) {\n@@ -40,16 +42,17 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n     // `ptr`\n     SetVector<Value> withSameOrder;\n     withSameOrder.insert(ptr);\n-    for(Operation *op: mlir::getSlice(ptr.getDefiningOp())){\n-      for(Value val: op->getResults()){\n-        if(val.getType() != origType) \n-          continue;\n-        auto valInfo = axisInfo.lookupLatticeElement(val);\n-        auto currOrder = argSort(valInfo->getValue().getContiguity());\n-        if(order == currOrder)\n-          withSameOrder.insert(val);\n+    if(ptr.getDefiningOp())\n+      for(Operation *op: mlir::getSlice(ptr.getDefiningOp())){\n+        for(Value val: op->getResults()){\n+          if(val.getType() != origType) \n+            continue;\n+          auto valInfo = axisInfo.lookupLatticeElement(val);\n+          auto currOrder = argSort(valInfo->getValue().getContiguity());\n+          if(order == currOrder)\n+            withSameOrder.insert(val);\n+        }\n       }\n-    }\n     int numElems = product(origType.getShape());\n     int numThreads = numWarps * 32;\n     int numElemsPerThread = std::max(numElems / numThreads, 1);\n@@ -87,16 +90,12 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n   }\n \n   template <class T>\n-  void coalesceOp(AxisInfoAnalysis &axisInfo, Operation *op, Value ptr,\n+  void coalesceOp(LayoutMap& layoutMap, Operation *op, Value ptr,\n                   OpBuilder builder) {\n     RankedTensorType ty = ptr.getType().template dyn_cast<RankedTensorType>();\n     if (!ty)\n       return;\n-    auto mod = op->getParentOfType<ModuleOp>();\n-    int numWarps = triton::gpu::TritonGPUDialect::getNumWarps(mod);\n-\n-    AxisInfo info = axisInfo.lookupLatticeElement(ptr)->getValue();\n-    auto convertType = getTypeConverter(axisInfo, ptr, numWarps);\n+    auto convertType = layoutMap.lookup(ptr);\n     // convert operands\n     SmallVector<Value, 4> newArgs;\n     for (auto v : op->getOperands()) {\n@@ -134,6 +133,33 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n     AxisInfoAnalysis axisInfo(&getContext());\n     axisInfo.run(op);\n \n+    // For each i/o operation, we determine what layout\n+    // the pointers should have for best memory coalescing\n+    LayoutMap layoutMap;\n+    op->walk([&](Operation *curr) {\n+        Value ptr;\n+        if (auto op = dyn_cast<triton::LoadOp>(curr)) \n+          ptr = op.ptr();\n+        if (auto op = dyn_cast<triton::AtomicRMWOp>(curr)) \n+          ptr = op.ptr();\n+        if (auto op = dyn_cast<triton::AtomicCASOp>(curr)) \n+          ptr = op.ptr();\n+        if (auto op = dyn_cast<triton::gpu::InsertSliceAsyncOp>(curr)) \n+          ptr = op.src();\n+        if (auto op = dyn_cast<triton::StoreOp>(curr)) \n+          ptr = op.ptr();\n+        if(!ptr)\n+          return;\n+        RankedTensorType ty =  ptr.getType().template dyn_cast<RankedTensorType>();\n+        if(!ty || !ty.getElementType().isa<PointerType>())\n+          return;\n+        AxisInfo info = axisInfo.lookupLatticeElement(ptr)->getValue();\n+        auto mod = curr->getParentOfType<ModuleOp>();\n+        int numWarps = triton::gpu::TritonGPUDialect::getNumWarps(mod);\n+        auto convertType = getTypeConverter(axisInfo, ptr, numWarps);\n+        layoutMap[ptr] = convertType;\n+    });\n+\n     // For each memory op that has a layout L1:\n     // 1. Create a coalesced memory layout L2 of the pointer operands\n     // 2. Convert all operands from layout L1 to layout L2\n@@ -144,24 +170,24 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n     op->walk([&](Operation *curr) {\n       OpBuilder builder(curr);\n       if (auto load = dyn_cast<triton::LoadOp>(curr)) {\n-        coalesceOp<triton::LoadOp>(axisInfo, curr, load.ptr(), builder);\n+        coalesceOp<triton::LoadOp>(layoutMap, curr, load.ptr(), builder);\n         return;\n       }\n       if (auto op = dyn_cast<triton::AtomicRMWOp>(curr)) {\n-        coalesceOp<triton::AtomicRMWOp>(axisInfo, curr, op.ptr(), builder);\n+        coalesceOp<triton::AtomicRMWOp>(layoutMap, curr, op.ptr(), builder);\n         return;\n       }\n       if (auto op = dyn_cast<triton::AtomicCASOp>(curr)) {\n-        coalesceOp<triton::AtomicCASOp>(axisInfo, curr, op.ptr(), builder);\n+        coalesceOp<triton::AtomicCASOp>(layoutMap, curr, op.ptr(), builder);\n         return;\n       }\n       if (auto load = dyn_cast<triton::gpu::InsertSliceAsyncOp>(curr)) {\n-        coalesceOp<triton::gpu::InsertSliceAsyncOp>(axisInfo, curr, load.src(),\n+        coalesceOp<triton::gpu::InsertSliceAsyncOp>(layoutMap, curr, load.src(),\n                                                     builder);\n         return;\n       }\n       if (auto store = dyn_cast<triton::StoreOp>(curr)) {\n-        coalesceOp<triton::StoreOp>(axisInfo, curr, store.ptr(), builder);\n+        coalesceOp<triton::StoreOp>(layoutMap, curr, store.ptr(), builder);\n         return;\n       }\n     });"}]