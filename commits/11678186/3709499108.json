[{"filename": "lib/Conversion/TritonGPUToLLVM/DotHelpers.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1518,7 +1518,6 @@ Value DotOpMmaV1ConversionHelper::loadB(\n     Value hb01 = bitcast(extract_element(hb, i32_val(1)), f16x2Ty);\n     ld(hbs, n, K, hb00, hb01);\n     if (vecB > 4) {\n-      assert(false && \"vecB > 4 is not supported yet\");\n       Value hb10 = bitcast(extract_element(hb, i32_val(2)), f16x2Ty);\n       Value hb11 = bitcast(extract_element(hb, i32_val(3)), f16x2Ty);\n       if (isBRow)"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "file_content_changes": "@@ -3949,18 +3949,19 @@ class TritonGPUToLLVMTypeConverter : public LLVMTypeConverter {\n         if (mmaLayout.isVolta()) {\n           DotOpMmaV1ConversionHelper helper(mmaLayout);\n \n-          // TODO[Superjomn]: The order of A and B are not available here.\n-          SmallVector<unsigned> order({1, 0});\n+          auto [isARow, isBRow, isAVec4, isBVec4] =\n+              mmaLayout.decodeVoltaLayoutStates();\n+\n           // TODO[Superjomn] vec is not available here, but currently the vec\n           // seems always no greater than 4, so we simply assign 4 here.\n           bool vec = 4;\n           if (dotOpLayout.getOpIdx() == 0) { // $a\n-            int elems = helper.numElemsPerThreadA(shape, order[0] == 1, vec);\n+            int elems = helper.numElemsPerThreadA(shape, isARow, vec);\n             Type x2Ty = vec_ty(elemTy, 2);\n             return struct_ty(SmallVector<Type>(elems, x2Ty));\n           }\n           if (dotOpLayout.getOpIdx() == 1) { // $b\n-            int elems = helper.numElemsPerThreadB(shape, order[0] == 1, vec);\n+            int elems = helper.numElemsPerThreadB(shape, isBRow, vec);\n             Type x2Ty = vec_ty(elemTy, 2);\n             return struct_ty(SmallVector<Type>(elems, x2Ty));\n           }"}]