[{"filename": "python/test/unit/runtime/test_cache.py", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "file_content_changes": "@@ -106,9 +106,9 @@ def inc_counter(*args, **kwargs):\n \n \n @pytest.mark.parametrize(\"value, value_type\", [\n-    (-1, 'int32'), (0, 'int32'), (1, None), (-2**31, 'int32'), (2**31 - 1, 'int32'),\n-    (2**32, 'int64'), (2**63 - 1, 'int64'), (-2**63, 'int64'),\n-    (2**31, 'uint32'), (2**32 - 1, 'uint32'), (2**63, 'uint64'), (2**64 - 1, 'uint64')\n+    (-1, 'i32'), (0, 'i32'), (1, 'i32'), (-2**31, 'i32'), (2**31 - 1, 'i32'),\n+    (2**32, 'i64'), (2**63 - 1, 'i64'), (-2**63, 'i64'),\n+    (2**31, 'u32'), (2**32 - 1, 'u32'), (2**63, 'u64'), (2**64 - 1, 'u64')\n ])\n def test_value_specialization(value: int, value_type: str, device='cuda') -> None:\n \n@@ -120,14 +120,14 @@ def kernel(VALUE, X):\n \n     def get_cache_str(*args, **kwargs):\n         nonlocal cache_str\n-        cache_str = kwargs['key'].split('-')\n-    triton.code_gen.JITFunction.cache_hook = get_cache_str\n+        cache_str = kwargs[\"repr\"]\n+    triton.JITFunction.cache_hook = get_cache_str\n     reset_tmp_dir()\n     x = torch.tensor([3.14159], device='cuda')\n     kernel[(1, )](value, x)\n-    triton.code_gen.JITFunction.cache_hook = None\n+    triton.JITFunction.cache_hook = None\n \n-    cache_str_match = re.match(r'_(\\w+)\\[multipleof\\(\\d+\\)]_float32\\*\\[multipleof\\(16\\)\\]', cache_str[-1])\n+    cache_str_match = re.match(r\".*VALUE: (\\w+).*\", cache_str)\n     spec_type = None if cache_str_match is None else cache_str_match.group(1)\n     assert spec_type == value_type\n "}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "file_content_changes": "@@ -185,8 +185,7 @@ def _spec_of(arg):\n             return (arg % 16 == 0, arg == 1)\n         return (arg is None, )\n \n-    @staticmethod\n-    def _get_config(*args):\n+    def _get_config(self, *args):\n         def is_divisible_by_16(x):\n             if hasattr(x, \"data_ptr\"):\n                 return x.data_ptr() % JITFunction.divisibility == 0\n@@ -195,8 +194,8 @@ def is_divisible_by_16(x):\n             if x is None:\n                 return True\n             return False\n-        divisible_by_16 = {i for i, arg in enumerate(args) if is_divisible_by_16(arg)}\n-        equal_to_1 = {i for i, arg in enumerate(args) if isinstance(arg, int) and arg == 1}\n+        divisible_by_16 = {i for i, arg in enumerate(args) if is_divisible_by_16(arg) and i not in self.do_not_specialize}\n+        equal_to_1 = {i for i, arg in enumerate(args) if isinstance(arg, int) and arg == 1 and i not in self.do_not_specialize}\n         return _triton.code_gen.instance_descriptor(divisible_by_16, equal_to_1)\n \n     @staticmethod\n@@ -236,10 +235,9 @@ def _call_hook(self, key, signature, device, constants, num_warps, num_stages, e\n         if JITFunction.cache_hook is None:\n             return False\n         # TODO: assemble compilation-key into human-readable format\n-        # name = self.fn.__name__\n-        # arg_reprs = ', '.join([f'{name}: {ty}' for name, ty in zip(self.arg_names, sig_key)])\n-        # repr = f\"{name}[num_warps={num_warps}, num_stages={num_stages}]({arg_reprs})\"\n-        repr = ''\n+        name = self.fn.__name__\n+        arg_reprs = ', '.join([f'{name}: {ty}' for name, ty in zip(self.arg_names, key[1])])\n+        repr = f\"{name}[num_warps={num_warps}, num_stages={num_stages}]({arg_reprs})\"\n \n         class LegacyCompiler:\n             def __init__(self):\n@@ -267,7 +265,7 @@ def _make_launcher(self):\n         specializations = []\n         for i, arg in enumerate(regular_args):\n             if i in self.do_not_specialize:\n-              pass\n+              continue\n             specializations += [f'({arg}.data_ptr() % {JITFunction.divisibility} == 0) if hasattr({arg}, \"data_ptr\") '\n                                 f'else ({arg} % {JITFunction.divisibility} == 0, {arg} == 1) if isinstance({arg}, int) '\n                                 f'else (False,)']\n@@ -299,6 +297,10 @@ def {self.fn.__name__}({', '.join(self.arg_names)}, grid, num_warps=4, num_stage\n       args = [{args}]\n       signature, constants = self._make_signature(sig_key)\n       constants.update({{i: None for i, arg in enumerate(args) if arg is None}})\n+      for i, arg in constants.items():\n+        if callable(arg):\n+          raise TypeError(f\"Callable constexpr at index {i} is not supported\")\n+        \n       configs = [self._get_config(*args)]\n       device = 0\n       if not self._call_hook(key, signature, device, constants, num_warps, num_stages, extern_libs, configs):\n@@ -317,13 +319,13 @@ def {self.fn.__name__}({', '.join(self.arg_names)}, grid, num_warps=4, num_stage\n     def __init__(self, fn, version=None, do_not_specialize=None):\n         self.fn = fn\n         self.module = fn.__module__\n-        # specialization hints\n-        self.do_not_specialize = [] if do_not_specialize is None else do_not_specialize\n-        self.do_not_specialize = set([self.arg_names.index(arg) if isinstance(arg, str) else arg for arg in self.do_not_specialize])\n         # function signature information\n         signature = inspect.signature(fn)\n         self.arg_names = [v.name for v in signature.parameters.values()]\n         self.has_defaults = any([v.default != inspect._empty for v in signature.parameters.values()])\n+        # specialization hints\n+        self.do_not_specialize = [] if do_not_specialize is None else do_not_specialize\n+        self.do_not_specialize = set([self.arg_names.index(arg) if isinstance(arg, str) else arg for arg in self.do_not_specialize])\n         # function source code (without decorators)\n         self.src = textwrap.dedent(inspect.getsource(fn))\n         self.src = self.src[self.src.find(\"def\"):]"}]