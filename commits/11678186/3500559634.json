[{"filename": "lib/codegen/pass.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -1,5 +1,6 @@\n #include \"triton/codegen/pass.h\"\n \n+#include \"llvm/Pass.h\"\n #include \"llvm/IR/Constants.h\"\n #include \"llvm/IR/LegacyPassManager.h\"\n #include \"llvm/IR/Module.h\""}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "file_content_changes": "@@ -316,10 +316,13 @@ void generator::visit_launch_inst(ir::launch_inst *launch) {\n                                            ArrayType::get(builder_->getInt32Ty(), 3),\n                                            ArrayType::get(builder_->getInt32Ty(), 3),\n                                            builder_->getInt32Ty()};\n-  FunctionType* get_param_ty = FunctionType::get(PointerType::get(builder_->getInt8Ty(), 0), get_param_arg_tys, false);\n+  Type* get_param_return_ty = PointerType::get(builder_->getInt8Ty(), 0);\n+  FunctionType* get_param_ty = FunctionType::get(get_param_return_ty, get_param_arg_tys, false);\n   Function* get_param_buffer = Function::Create(get_param_ty, Function::ExternalLinkage, \"cudaGetParameterBufferV2\", mod_);\n-  AllocaInst* grid = builder_->CreateAlloca(get_param_arg_tys[1]);\n-  AllocaInst* block = builder_->CreateAlloca(get_param_arg_tys[2]);\n+  Type* grid_ty = get_param_arg_tys[1];\n+  Type* block_ty = get_param_arg_tys[2];\n+  AllocaInst* grid = builder_->CreateAlloca(grid_ty);\n+  AllocaInst* block = builder_->CreateAlloca(block_ty);\n   ConstantInt* _0 = builder_->getInt32(0);\n   ConstantInt* _1 = builder_->getInt32(1);\n   ConstantInt* _2 = builder_->getInt32(2);\n@@ -332,16 +335,16 @@ void generator::visit_launch_inst(ir::launch_inst *launch) {\n   builder_->SetInsertPoint(launch_bb);\n \n   //\n-  builder_->CreateStore(vals_[launch->get_grid()[0]][{}], builder_->CreateGEP(grid, {_0, _0}));\n-  builder_->CreateStore(vals_[launch->get_grid()[1]][{}], builder_->CreateGEP(grid, {_0, _1}));\n-  builder_->CreateStore(vals_[launch->get_grid()[2]][{}], builder_->CreateGEP(grid, {_0, _2}));\n+  builder_->CreateStore(vals_[launch->get_grid()[0]][{}], builder_->CreateGEP(grid_ty, grid, {_0, _0}));\n+  builder_->CreateStore(vals_[launch->get_grid()[1]][{}], builder_->CreateGEP(grid_ty, grid, {_0, _1}));\n+  builder_->CreateStore(vals_[launch->get_grid()[2]][{}], builder_->CreateGEP(grid_ty, grid, {_0, _2}));\n   Value* num_warps = mul(builder_->getInt32(32), vals_[launch->get_num_warps()][{}]);\n-  builder_->CreateStore(num_warps, builder_->CreateGEP(block, {_0, _0}));\n-  builder_->CreateStore(builder_->getInt32(1), builder_->CreateGEP(block, {_0, _1}));\n-  builder_->CreateStore(builder_->getInt32(1), builder_->CreateGEP(block, {_0, _2}));\n+  builder_->CreateStore(num_warps, builder_->CreateGEP(block_ty, block, {_0, _0}));\n+  builder_->CreateStore(builder_->getInt32(1), builder_->CreateGEP(block_ty, block, {_0, _1}));\n+  builder_->CreateStore(builder_->getInt32(1), builder_->CreateGEP(block_ty, block, {_0, _2}));\n   Function* called_fn = fns_[fn];\n   Value* callee = ConstantExpr::getCast(Instruction::BitCast, called_fn, get_param_arg_tys[0]);\n-  Value* arg_ptr = builder_->CreateCall(get_param_buffer, {callee, builder_->CreateLoad(grid), builder_->CreateLoad(block), builder_->getInt32(0)});\n+  Value* arg_ptr = builder_->CreateCall(get_param_buffer, {callee, builder_->CreateLoad(grid_ty, grid), builder_->CreateLoad(block_ty, block), builder_->getInt32(0)});\n   // forwrd-declare cudaLaunchDeviceV2\n   std::vector<Type*> launch_device_arg_tys = {get_param_ty->getReturnType(), builder_->getInt64Ty()};\n   FunctionType* launch_device_ty = FunctionType::get(builder_->getInt32Ty(), launch_device_arg_tys, false);\n@@ -364,7 +367,7 @@ void generator::visit_launch_inst(ir::launch_inst *launch) {\n     unsigned size = curr_arg_ty->isPointerTy() ? 8 : curr_arg_ty->getPrimitiveSizeInBits() / 8;\n     off = (off + size - 1) / size * size;\n     // get pointer to current arg\n-    Value* curr_arg_ptr = builder_->CreateGEP(arg_ptr, builder_->getInt32(off));\n+    Value* curr_arg_ptr = builder_->CreateGEP(get_param_return_ty, arg_ptr, builder_->getInt32(off));\n     curr_arg_ptr = builder_->CreateBitCast(curr_arg_ptr, curr_arg_ty->getPointerTo(addr_space));\n     // store arg\n     builder_->CreateStore(curr_arg, curr_arg_ptr);\n@@ -3644,6 +3647,14 @@ Value *generator::cast_shared_layout_ptr(analysis::data_layout *layout,\n   return base;\n }\n \n+void addAttribute(Function* fn, unsigned id, Attribute attr) {\n+#if LLVM_VERSION_MAJOR >= 15\n+  fn->addAttributeAtIndex(id, attr);\n+#else\n+  fn->addAttribute(id, attr);\n+#endif\n+}\n+\n void generator::visit_function(ir::function* fn) {\n   idxs_.clear();\n   vals_.clear();\n@@ -3660,7 +3671,7 @@ void generator::visit_function(ir::function* fn) {\n     if(attr.is_llvm_attr()){\n       llvm::Attribute llattr = cvt(attr);\n       if(llattr.getKindAsEnum() != llvm::Attribute::None)\n-        ret->addAttribute(id, cvt(attr));\n+        addAttribute(ret, id, llattr);\n     }\n   }\n   // set metadata"}, {"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -40,7 +40,11 @@\n #include \"llvm/Support/CommandLine.h\"\n #include \"llvm/Support/SourceMgr.h\"\n #include \"llvm/Support/raw_ostream.h\"\n+#if LLVM_VERSION_MAJOR >= 15\n+#include \"llvm/MC/TargetRegistry.h\"\n+#else\n #include \"llvm/Support/TargetRegistry.h\"\n+#endif\n #include \"llvm/Support/TargetSelect.h\"\n #include \"llvm/Target/TargetMachine.h\"\n #include \"llvm/Target/TargetOptions.h\""}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -448,6 +448,9 @@ void init_triton_codegen(py::module &&m) {\n             name = ir.get_function_list()[0]->get_name();\n             ir.print(ttir);\n             llvm::LLVMContext ctx;\n+#if LLVM_VERSION_MAJOR >= 15\n+\t    ctx.setOpaquePointers(false);\n+#endif\n             // construct extern lib map\n             triton::codegen::ExternLibMap extern_lib_map;\n             for (auto item : extern_libs) {"}]