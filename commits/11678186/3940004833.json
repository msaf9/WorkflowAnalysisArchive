[{"filename": "include/triton/Dialect/TritonGPU/IR/TritonGPUAttrDefs.td", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "file_content_changes": "@@ -420,11 +420,6 @@ For example, the matrix L corresponding to blockTileSize=[32,16] is:\n     // Number of bits in versionMinor to hold the ID of the MMA encoding instance.\n     // Here 5 bits can hold 32 IDs in a single module.\n     static constexpr int numBitsToHoldMmaV1ID{5};\n-\n-    // Here is a temporary flag that indicates whether we need to update the warpsPerCTA for MMAv1, since the current backend cannot support the updated wpt.\n-    // The mmav1's wpt-related logic is separated into multiple files, so a global flag is added here for universal coordination.\n-    // TODO[Superjomn]: Remove this flag once the MMAv1 backend is ready.\n-    static constexpr bool _mmaV1UpdateWpt{true};\n   }];\n \n }"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -306,7 +306,7 @@ struct ConvertLayoutOpConversion\n         // }\n       }\n \n-#define SHOW_ACCI 1\n+#define SHOW_ACCI 0\n #if SHOW_ACCI\n       for (unsigned elemId = 0; elemId < accumSizePerThread; elemId++) {\n         auto [coord, currVal] = coord2val[elemId];"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ViewOpToLLVM.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -84,7 +84,7 @@ struct SplatOpConversion\n         } else {\n           DotOpMmaV1ConversionHelper::BParam bParam(isBRow, isBVec4);\n           numElems =\n-              helper.numElemsPerThreadA(shape, isBRow, isBVec4, bParam.vec);\n+              helper.numElemsPerThreadB(shape, isBRow, isBVec4, bParam.vec);\n         }\n       }\n     } else if (auto blockedLayout = parent.dyn_cast<BlockedEncodingAttr>()) {"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "file_content_changes": "@@ -887,31 +887,8 @@ SmallVector<int64_t, 2> mmaVersionToShapePerWarp(int version) {\n \n SmallVector<unsigned, 2> warpsPerTileV1(const ArrayRef<int64_t> shape,\n                                         int numWarps) {\n-  if (!MmaEncodingAttr::_mmaV1UpdateWpt) {\n-    SmallVector<unsigned, 2> ret = {1, 1};\n-    SmallVector<int64_t, 2> shapePerWarp =\n-        mmaVersionToShapePerWarp(1 /*version*/);\n-    bool changed = false;\n-    do {\n-      changed = false;\n-      int pre = ret[0];\n-      if (ret[0] * ret[1] < numWarps) {\n-        ret[0] =\n-            std::clamp<unsigned>(ret[0] * 2, 1, shape[0] / shapePerWarp[0]);\n-        changed = pre != ret[0];\n-      }\n-      if (ret[0] * ret[1] < numWarps) {\n-        pre = ret[1];\n-        ret[1] =\n-            std::clamp<unsigned>(ret[1] * 2, 1, shape[1] / shapePerWarp[1]);\n-        changed = pre != ret[1];\n-      }\n-    } while (changed);\n-    return ret;\n-  } else {\n-    // Set a default value and ensure product of wpt equals numWarps\n-    return {static_cast<unsigned>(numWarps), 1};\n-  }\n+  // Set a default value and ensure product of wpt equals numWarps\n+  return {static_cast<unsigned>(numWarps), 1};\n }\n \n SmallVector<unsigned, 2> warpsPerTileV2(triton::DotOp dotOp,\n@@ -1108,13 +1085,8 @@ class BlockedToMMA : public mlir::RewritePattern {\n         getWarpsPerTile(dotOp, retShape, versionMajor, numWarps);\n     triton::gpu::MmaEncodingAttr mmaEnc;\n     if (versionMajor == 1) {\n-      if (MmaEncodingAttr::_mmaV1UpdateWpt)\n-        mmaEnc = triton::gpu::MmaEncodingAttr::get(\n-            oldRetType.getContext(), versionMajor, numWarps, mmaV1Counter++);\n-      else\n-        mmaEnc = triton::gpu::MmaEncodingAttr::get(\n-            dotOp->getContext(), versionMajor, 0 /*versionMinor*/,\n-            warpsPerTileV1(retShape, numWarps));\n+      mmaEnc = triton::gpu::MmaEncodingAttr::get(\n+          oldRetType.getContext(), versionMajor, numWarps, mmaV1Counter++);\n     } else if (versionMajor == 2) {\n       mmaEnc = triton::gpu::MmaEncodingAttr::get(\n           oldRetType.getContext(), versionMajor, 0 /*versionMinor*/,"}, {"filename": "lib/Dialect/TritonGPU/Transforms/UpdateMmaForVolta.cpp", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "file_content_changes": "@@ -39,6 +39,8 @@ class CollectMmaToUpdateForVolta : public mlir::RewritePattern {\n     auto AT = dotOp.a().getType().cast<RankedTensorType>();\n     auto BT = dotOp.b().getType().cast<RankedTensorType>();\n     auto DT = dotOp.d().getType().cast<RankedTensorType>();\n+    auto shapeA = AT.getShape();\n+    auto shapeB = BT.getShape();\n     if (!DT.getEncoding())\n       return failure();\n     auto mmaLayout = DT.getEncoding().dyn_cast<MmaEncodingAttr>();\n@@ -60,12 +62,13 @@ class CollectMmaToUpdateForVolta : public mlir::RewritePattern {\n     // could only be set here for those states might be updated by previous\n     // patterns in the Combine Pass.\n     if (isARow_ == isARow && isBRow_ == isBRow) {\n+      isAVec4 = !isARow && (shapeA[isARow] <= 16);\n+      isBVec4 = isBRow && (shapeB[isBRow] <= 16);\n       auto tgtWpt =\n           getWarpsPerCTA(DT.getShape(), isARow, isBRow, isAVec4, isBVec4,\n                          product(mmaLayout.getWarpsPerCTA()));\n       // Check if the wpt should be updated.\n-      if (tgtWpt == mmaLayout.getWarpsPerCTA() ||\n-          !MmaEncodingAttr::_mmaV1UpdateWpt)\n+      if (tgtWpt == mmaLayout.getWarpsPerCTA())\n         return failure();\n     }\n \n@@ -83,12 +86,9 @@ class CollectMmaToUpdateForVolta : public mlir::RewritePattern {\n       auto updatedWpt =\n           getWarpsPerCTA(DT.getShape(), isARow_, isBRow_, isAVec4_, isBVec4_,\n                          product(mmaLayout.getWarpsPerCTA()));\n-      auto newWpt = MmaEncodingAttr::_mmaV1UpdateWpt\n-                        ? updatedWpt\n-                        : mmaLayout.getWarpsPerCTA();\n       newMmaLayout = MmaEncodingAttr::get(ctx, mmaLayout.getVersionMajor(),\n-                                          newWpt, AT.getShape(), BT.getShape(),\n-                                          isARow, isBRow, mmaId);\n+                                          updatedWpt, AT.getShape(),\n+                                          BT.getShape(), isARow, isBRow, mmaId);\n     }\n \n     // Collect the wrong MMA Layouts, and mark need to update.\n@@ -118,6 +118,7 @@ class CollectMmaToUpdateForVolta : public mlir::RewritePattern {\n     int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n     rep[1] = 2 * packSize1;\n     spw[1] = fpw[1] * 4 * rep[1];\n+    printf(\"wpt-spw t-0 %d %d\\n\", spw[0], spw[1]);\n \n     do {\n       wpt_nm1 = wpt;"}]