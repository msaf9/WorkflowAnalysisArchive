[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "file_content_changes": "@@ -2927,7 +2927,7 @@ struct DotOpMmaV1ConversionHelper {\n   // Loading $c to registers, returns a LLVM::Struct.\n   Value loadC(Value C, Value llC, ConversionPatternRewriter &rewriter) const;\n \n-  static ArrayRef<unsigned> getOrder() { return order; }\n+  static ArrayRef<unsigned> getOrder() { return mmaOrder; }\n \n   // Compute the offset of the matrix to load.\n   // Returns offsetAM, offsetAK, offsetBN, offsetBK.\n@@ -2947,7 +2947,7 @@ struct DotOpMmaV1ConversionHelper {\n \n private:\n   static constexpr unsigned instrShape[] = {16, 16, 4};\n-  static constexpr unsigned order[] = {0, 1};\n+  static constexpr unsigned mmaOrder[] = {0, 1};\n };\n \n // Helper for conversion of DotOp with mma<version=2>, that is sm>=80\n@@ -3874,7 +3874,7 @@ Value DotOpMmaV1ConversionHelper::loadA(\n     int stepAK = isARow ? k / (numPtrA * vecA) * (numPtrA * vecA) : k;\n     Value pa = gep(f16PtrTy, thePtrA,\n                    i32_val(stepAM * strideRepM * strideAM + stepAK * strideAK));\n-    Type aPtrTy = ptr_ty(vec_ty(i32_ty, vecA / 2), 3);\n+    Type aPtrTy = ptr_ty(vec_ty(i32_ty, std::max<int>(vecA / 2, 1)), 3);\n     Value ha = load(bitcast(pa, aPtrTy));\n     // record lds that needs to be moved\n     Value ha00 = bitcast(extract_element(ha, i32_val(0)), f16x2Ty);\n@@ -3976,7 +3976,8 @@ Value DotOpMmaV1ConversionHelper::loadB(\n     int stepBK = isBRow ? K : K / (numPtrB * vecB) * (numPtrB * vecB);\n     Value pb = gep(f16PtrTy, thePtrB,\n                    i32_val(stepBN * strideRepN * strideBN + stepBK * strideBK));\n-    Value hb = load(bitcast(pb, ptr_ty(vec_ty(i32_ty, vecB / 2), 3)));\n+    Value hb =\n+        load(bitcast(pb, ptr_ty(vec_ty(i32_ty, std::max(vecB / 2, 1)), 3)));\n     // record lds that needs to be moved\n     Value hb00 = bitcast(extract_element(hb, i32_val(0)), f16x2Ty);\n     Value hb01 = bitcast(extract_element(hb, i32_val(1)), f16x2Ty);\n@@ -4086,7 +4087,8 @@ DotOpMmaV1ConversionHelper::extractLoadedOperand(\n   int offset = 0;\n   for (int i = 0; i < n0; ++i)\n     for (int k = 0; k < n1; k += 4) {\n-      rcds[{i, k}] = std::make_pair(elems[offset++], elems[offset++]);\n+      rcds[{i, k}] = std::make_pair(elems[offset], elems[offset + 1]);\n+      offset += 2;\n     }\n \n   return rcds;"}, {"filename": "test/Conversion/tritongpu_to_llvm.mlir", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -755,6 +755,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n     %b_mat = triton_gpu.convert_layout %b : (tensor<32x256xf16, #shared>) -> tensor<32x256xf16, #dot_operand_b>\n \n     %28 = tt.dot %a_mat, %b_mat, %cst {allowTF32 = true, transA = false, transB = false} : tensor<128x32xf16, #dot_operand_a> * tensor<32x256xf16, #dot_operand_b> -> tensor<128x256xf32, #mma>\n+    // TODO[goostavz]: uncomment the following lines after convert_layout[mma<v1> -> blocked] is ready.\n     // %38 = triton_gpu.convert_layout %28 : (tensor<128x256xf32, #mma>) -> tensor<128x256xf32, #blocked>\n     // %30 = tt.splat %ptr : (!tt.ptr<f32>) -> tensor<128x1x!tt.ptr<f32>, #blocked>\n     // %36 = tt.broadcast %30 : (tensor<128x1x!tt.ptr<f32>, #blocked>) -> tensor<128x256x!tt.ptr<f32>, #blocked>"}]