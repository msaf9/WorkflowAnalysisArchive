[{"filename": "lib/Dialect/Triton/IR/Ops.cpp", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "file_content_changes": "@@ -230,6 +230,54 @@ void LoadOp::build(::mlir::OpBuilder &builder, ::mlir::OperationState &state,\n   state.addTypes({resultType});\n }\n \n+// load(ptr, splat(1), ...)        -> load(ptr, ...)\n+// load(ptr, splat(0), other, ...) -> other\n+struct CanonicalizeMaskedLoadPattern\n+    : public mlir::OpRewritePattern<triton::LoadOp> {\n+  CanonicalizeMaskedLoadPattern(mlir::MLIRContext *context)\n+      : OpRewritePattern<triton::LoadOp>(context, 1) {}\n+\n+  mlir::LogicalResult\n+  matchAndRewrite(triton::LoadOp loadOp,\n+                  mlir::PatternRewriter &rewriter) const override {\n+    auto mask = loadOp.getMask();\n+    if (!mask)\n+      return mlir::failure();\n+\n+    auto constantMask =\n+        llvm::dyn_cast_or_null<arith::ConstantOp>(mask.getDefiningOp());\n+    if (!constantMask)\n+      return mlir::failure();\n+\n+    auto splatMask = constantMask.getValue().dyn_cast<SplatElementsAttr>();\n+    if (!splatMask)\n+      return mlir::failure();\n+\n+    if (splatMask.getSplatValue<IntegerAttr>().getValue() == true) {\n+      // mask = splat(1)\n+      rewriter.replaceOpWithNewOp<triton::LoadOp>(\n+          loadOp, loadOp.getType(), loadOp.getPtr(), Value(), Value(),\n+          loadOp.getBoundaryCheckAttr(), loadOp.getPaddingAttr(),\n+          loadOp.getCache(), loadOp.getEvict(), loadOp.getIsVolatile());\n+    } else {\n+      // mask = splat(0)\n+\n+      // If there's no \"other\", the value is \"undef\".  Perhaps we want to\n+      // optimize it in the future.x\n+      auto otherVal = loadOp.getOther();\n+      if (!otherVal)\n+        return mlir::failure();\n+      rewriter.replaceOp(loadOp, otherVal);\n+    }\n+    return mlir::success();\n+  }\n+};\n+\n+void triton::LoadOp::getCanonicalizationPatterns(RewritePatternSet &results,\n+                                                 MLIRContext *context) {\n+  results.add<CanonicalizeMaskedLoadPattern>(context);\n+}\n+\n //-- StoreOp --\n void StoreOp::build(::mlir::OpBuilder &builder, ::mlir::OperationState &state,\n                     ::mlir::Value ptr, ::mlir::Value value,\n@@ -257,6 +305,47 @@ void StoreOp::build(::mlir::OpBuilder &builder, ::mlir::OperationState &state,\n                         evict);\n }\n \n+// store(ptr, value, splat(1), ...) -> store(ptr, value, ...)\n+// store(ptr, value, splat(0), ...) -> [none]\n+struct CanonicalizeMaskedStorePattern\n+    : public mlir::OpRewritePattern<triton::StoreOp> {\n+  CanonicalizeMaskedStorePattern(mlir::MLIRContext *context)\n+      : OpRewritePattern<triton::StoreOp>(context, 1) {}\n+\n+  mlir::LogicalResult\n+  matchAndRewrite(triton::StoreOp storeOp,\n+                  mlir::PatternRewriter &rewriter) const override {\n+    auto mask = storeOp.getMask();\n+    if (!mask)\n+      return mlir::failure();\n+\n+    auto constantMask =\n+        llvm::dyn_cast_or_null<arith::ConstantOp>(mask.getDefiningOp());\n+    if (!constantMask)\n+      return mlir::failure();\n+\n+    auto splatMask = constantMask.getValue().dyn_cast<SplatElementsAttr>();\n+    if (!splatMask)\n+      return mlir::failure();\n+\n+    if (splatMask.getSplatValue<IntegerAttr>().getValue() == true) {\n+      // mask = splat(1)\n+      rewriter.replaceOpWithNewOp<triton::StoreOp>(\n+          storeOp, storeOp.getPtr(), storeOp.getValue(), storeOp.getCache(),\n+          storeOp.getEvict());\n+    } else {\n+      // mask = splat(0)\n+      rewriter.eraseOp(storeOp);\n+    }\n+    return mlir::success();\n+  }\n+};\n+\n+void triton::StoreOp::getCanonicalizationPatterns(RewritePatternSet &results,\n+                                                  MLIRContext *context) {\n+  results.add<CanonicalizeMaskedStorePattern>(context);\n+}\n+\n //-- TransOp --\n mlir::LogicalResult mlir::triton::TransOp::inferReturnTypes(\n     MLIRContext *context, std::optional<Location> location, ValueRange operands,"}, {"filename": "lib/Dialect/Triton/Transforms/Combine.cpp", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "file_content_changes": "@@ -101,95 +101,6 @@ class CombineSelectMaskedLoadPattern : public mlir::RewritePattern {\n   }\n };\n \n-// load(ptr, splat(1), ...)        -> load(ptr, ...)\n-// load(ptr, splat(0), other, ...) -> other\n-struct CanonicalizeMaskedLoadPattern\n-    : public mlir::OpRewritePattern<triton::LoadOp> {\n-  CanonicalizeMaskedLoadPattern(mlir::MLIRContext *context)\n-      : OpRewritePattern<triton::LoadOp>(context, 1) {}\n-\n-  mlir::LogicalResult\n-  matchAndRewrite(triton::LoadOp loadOp,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto mask = loadOp.getMask();\n-    if (!mask)\n-      return mlir::failure();\n-\n-    auto constantMask =\n-        llvm::dyn_cast_or_null<arith::ConstantOp>(mask.getDefiningOp());\n-    if (!constantMask)\n-      return mlir::failure();\n-\n-    auto splatMask = constantMask.getValue().dyn_cast<SplatElementsAttr>();\n-    if (!splatMask)\n-      return mlir::failure();\n-\n-    if (splatMask.getSplatValue<IntegerAttr>().getValue() == true) {\n-      // mask = splat(1)\n-      rewriter.replaceOpWithNewOp<triton::LoadOp>(\n-          loadOp, loadOp.getType(), loadOp.getPtr(), Value(), Value(),\n-          loadOp.getBoundaryCheckAttr(), loadOp.getPaddingAttr(),\n-          loadOp.getCache(), loadOp.getEvict(), loadOp.getIsVolatile());\n-    } else {\n-      // mask = splat(0)\n-\n-      // If there's no \"other\", the value is \"undef\".  Perhaps we want to\n-      // optimize it in the future.x\n-      auto otherVal = loadOp.getOther();\n-      if (!otherVal)\n-        return mlir::failure();\n-      rewriter.replaceOp(loadOp, otherVal);\n-    }\n-    return mlir::success();\n-  }\n-};\n-\n-void triton::LoadOp::getCanonicalizationPatterns(RewritePatternSet &results,\n-                                                 MLIRContext *context) {\n-  results.add<CanonicalizeMaskedLoadPattern>(context);\n-}\n-\n-// store(ptr, value, splat(1), ...) -> store(ptr, value, ...)\n-// store(ptr, value, splat(0), ...) -> [none]\n-struct CanonicalizeMaskedStorePattern\n-    : public mlir::OpRewritePattern<triton::StoreOp> {\n-  CanonicalizeMaskedStorePattern(mlir::MLIRContext *context)\n-      : OpRewritePattern<triton::StoreOp>(context, 1) {}\n-\n-  mlir::LogicalResult\n-  matchAndRewrite(triton::StoreOp storeOp,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto mask = storeOp.getMask();\n-    if (!mask)\n-      return mlir::failure();\n-\n-    auto constantMask =\n-        llvm::dyn_cast_or_null<arith::ConstantOp>(mask.getDefiningOp());\n-    if (!constantMask)\n-      return mlir::failure();\n-\n-    auto splatMask = constantMask.getValue().dyn_cast<SplatElementsAttr>();\n-    if (!splatMask)\n-      return mlir::failure();\n-\n-    if (splatMask.getSplatValue<IntegerAttr>().getValue() == true) {\n-      // mask = splat(1)\n-      rewriter.replaceOpWithNewOp<triton::StoreOp>(\n-          storeOp, storeOp.getPtr(), storeOp.getValue(), storeOp.getCache(),\n-          storeOp.getEvict());\n-    } else {\n-      // mask = splat(0)\n-      rewriter.eraseOp(storeOp);\n-    }\n-    return mlir::success();\n-  }\n-};\n-\n-void triton::StoreOp::getCanonicalizationPatterns(RewritePatternSet &results,\n-                                                  MLIRContext *context) {\n-  results.add<CanonicalizeMaskedStorePattern>(context);\n-}\n-\n #define GEN_PASS_CLASSES\n #include \"triton/Dialect/Triton/Transforms/Passes.h.inc\"\n "}]