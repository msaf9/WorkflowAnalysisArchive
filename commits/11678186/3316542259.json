[{"filename": "lib/Dialect/TritonGPU/Transforms/Swizzle.cpp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "file_content_changes": "@@ -39,23 +39,23 @@ struct SwizzlePass : public TritonGPUSwizzleBase<SwizzlePass> {\n       return SwizzleInfo{vec, perPhase, maxPhase};\n     } else if (version == 2) {\n       auto eltTy = ty.getElementType();\n-      std::vector<size_t> mat_shape = {8, 8,\n-                                       2 * 64 / eltTy.getIntOrFloatBitWidth()};\n+      std::vector<size_t> matShape = {8, 8,\n+                                      2 * 64 / eltTy.getIntOrFloatBitWidth()};\n       // for now, disable swizzle when using transposed int8 tensor cores\n-      bool is_int8_mma = ty.getElementType().isInteger(8);\n-      if (is_int8_mma && order[0] == inner)\n+      bool isInt8Mma = ty.getElementType().isInteger(8);\n+      if (isInt8Mma && order[0] == inner)\n         return noSwizzling;\n       // compute swizzling for A operand\n       if (opIdx == 0) {\n-        int vec = order[0] == 1 ? mat_shape[2] : mat_shape[0]; // k : m\n-        int mmaStride = order[0] == 1 ? mat_shape[0] : mat_shape[2];\n+        int vec = order[0] == 1 ? matShape[2] : matShape[0]; // k : m\n+        int mmaStride = order[0] == 1 ? matShape[0] : matShape[2];\n         int maxPhase = mmaStride / perPhase;\n         return SwizzleInfo{vec, perPhase, maxPhase};\n       }\n       // compute swizzling for B operand\n       else if (opIdx == 1) {\n-        int vec = order[0] == 1 ? mat_shape[1] : mat_shape[2]; // n : k\n-        int mmaStride = order[0] == 1 ? mat_shape[2] : mat_shape[1];\n+        int vec = order[0] == 1 ? matShape[1] : matShape[2]; // n : k\n+        int mmaStride = order[0] == 1 ? matShape[2] : matShape[1];\n         int maxPhase = mmaStride / perPhase;\n         return SwizzleInfo{vec, perPhase, maxPhase};\n       } else {"}]