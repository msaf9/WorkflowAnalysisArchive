[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 157, "deletions": 166, "changes": 323, "file_content_changes": "@@ -339,7 +339,7 @@ Value getStructFromElements(Location loc, ValueRange resultVals,\n   }\n \n   Value llvmStruct = rewriter.create<LLVM::UndefOp>(loc, structType);\n-  for (const auto& v : llvm::enumerate(resultVals)) {\n+  for (const auto &v : llvm::enumerate(resultVals)) {\n     assert(v.value() && \"can not insert null values\");\n     llvmStruct = insert_val(structType, llvmStruct, v.value(),\n                             rewriter.getI64ArrayAttr(v.index()));\n@@ -702,12 +702,12 @@ class ConvertTritonGPUOpToLLVMPattern\n   emitOffsetForMmaLayoutV2(const MmaEncodingAttr &mmaLayout,\n                            ArrayRef<int64_t> shape) const {\n     SmallVector<SmallVector<unsigned>> ret;\n-    for (int64_t i = 0; i < shape[0]; i += getShapePerCTA(mmaLayout)[0]) {\n-      for (int64_t j = 0; j < shape[1]; j += getShapePerCTA(mmaLayout)[1]) {\n+    for (unsigned i = 0; i < shape[0]; i += getShapePerCTA(mmaLayout)[0]) {\n+      for (unsigned j = 0; j < shape[1]; j += getShapePerCTA(mmaLayout)[1]) {\n         ret.push_back({i, j});\n         ret.push_back({i, j + 1});\n       }\n-      for (int64_t j = 0; j < shape[1]; j += getShapePerCTA(mmaLayout)[1]) {\n+      for (unsigned j = 0; j < shape[1]; j += getShapePerCTA(mmaLayout)[1]) {\n         ret.push_back({i + 8, j});\n         ret.push_back({i + 8, j + 1});\n       }\n@@ -750,14 +750,13 @@ class ConvertTritonGPUOpToLLVMPattern\n   // Emit indices calculation within each ConversionPattern, and returns a\n   // [elemsPerThread X rank] index matrix.\n \n-// TODO: [phil] redundant indices commputation do not appear to hurt\n+  // TODO: [phil] redundant indices commputation do not appear to hurt\n   // performance much, but they could still significantly slow down\n   // computations.\n   SmallVector<SmallVector<Value>> emitIndicesForDistributedLayout(\n       Location loc, ConversionPatternRewriter &rewriter,\n       const Attribute &layout, ArrayRef<int64_t> shape) const {\n \n-\n     // step 1, delinearize threadId to get the base index\n     auto multiDimBase = emitBaseIndexForLayout(loc, rewriter, layout, shape);\n     // step 2, get offset of each element\n@@ -1046,8 +1045,8 @@ struct LoadOpConversion\n \n     // Determine the vectorization size\n     Type valueTy = op.getResult().getType();\n-    Type valueElemTy = typeConverter->convertType(\n-        getElementTypeOrSelf(valueTy));\n+    Type valueElemTy =\n+        typeConverter->convertType(getElementTypeOrSelf(valueTy));\n     unsigned vec = getVectorSize(ptr);\n     unsigned numElems = getElemsPerThread(ptr.getType());\n     if (llMask)\n@@ -1242,8 +1241,8 @@ struct StoreOpConversion\n     MLIRContext *ctx = rewriter.getContext();\n \n     auto valueTy = value.getType();\n-    Type valueElemTy = typeConverter->convertType(\n-        getElementTypeOrSelf(valueTy));\n+    Type valueElemTy =\n+        typeConverter->convertType(getElementTypeOrSelf(valueTy));\n \n     unsigned vec = getVectorSize(ptr);\n     unsigned numElems = getElemsPerThread(ptr.getType());\n@@ -2198,9 +2197,10 @@ struct FpToFpOpConversion\n   using ConvertTritonGPUOpToLLVMPattern<\n       triton::FpToFpOp>::ConvertTritonGPUOpToLLVMPattern;\n \n-  static SmallVector<Value> convertFp8x4ToFp16x4(\n-      Location loc, ConversionPatternRewriter &rewriter,\n-      const Value& v0, const Value& v1, const Value& v2, const Value& v3) {\n+  static SmallVector<Value>\n+  convertFp8x4ToFp16x4(Location loc, ConversionPatternRewriter &rewriter,\n+                       const Value &v0, const Value &v1, const Value &v2,\n+                       const Value &v3) {\n     auto ctx = rewriter.getContext();\n     auto fp8x4VecTy = vec_ty(i8_ty, 4);\n     Value fp8x4Vec = undef(fp8x4VecTy);\n@@ -2211,18 +2211,17 @@ struct FpToFpOpConversion\n     fp8x4Vec = bitcast(fp8x4Vec, i32_ty);\n \n     PTXBuilder builder;\n-    auto *ptxAsm =\n-        \"{                                      \\n\"\n-        \".reg .b32 a<2>, b<2>;                  \\n\"\n-        \"prmt.b32 a0, 0, $2, 0x5040;            \\n\"\n-        \"prmt.b32 a1, 0, $2, 0x7060;            \\n\"\n-        \"lop3.b32 b0, a0, 0x7fff7fff, 0, 0xc0;  \\n\"\n-        \"lop3.b32 b1, a1, 0x7fff7fff, 0, 0xc0;  \\n\"\n-        \"shr.b32  b0, b0, 1;                    \\n\"\n-        \"shr.b32  b1, b1, 1;                    \\n\"\n-        \"lop3.b32 $0, b0, 0x80008000, a0, 0xf8; \\n\"\n-        \"lop3.b32 $1, b1, 0x80008000, a1, 0xf8; \\n\"\n-        \"}\";\n+    auto *ptxAsm = \"{                                      \\n\"\n+                   \".reg .b32 a<2>, b<2>;                  \\n\"\n+                   \"prmt.b32 a0, 0, $2, 0x5040;            \\n\"\n+                   \"prmt.b32 a1, 0, $2, 0x7060;            \\n\"\n+                   \"lop3.b32 b0, a0, 0x7fff7fff, 0, 0xc0;  \\n\"\n+                   \"lop3.b32 b1, a1, 0x7fff7fff, 0, 0xc0;  \\n\"\n+                   \"shr.b32  b0, b0, 1;                    \\n\"\n+                   \"shr.b32  b1, b1, 1;                    \\n\"\n+                   \"lop3.b32 $0, b0, 0x80008000, a0, 0xf8; \\n\"\n+                   \"lop3.b32 $1, b1, 0x80008000, a1, 0xf8; \\n\"\n+                   \"}\";\n     auto &call = *builder.create(ptxAsm);\n \n     auto *o0 = builder.newOperand(\"=r\");\n@@ -2235,21 +2234,20 @@ struct FpToFpOpConversion\n         struct_ty(SmallVector<Type>{fp16x2VecTy, fp16x2VecTy});\n     auto fp16x2x2Struct =\n         builder.launch(rewriter, loc, fp16x2x2StructTy, false);\n-    auto fp16x2Vec0 = extract_val(fp16x2VecTy, fp16x2x2Struct,\n-                                  rewriter.getI32ArrayAttr({0}));\n-    auto fp16x2Vec1 = extract_val(fp16x2VecTy, fp16x2x2Struct,\n-                                  rewriter.getI32ArrayAttr({1}));\n-    return {\n-        extract_element(f16_ty, fp16x2Vec0, i32_val(0)),\n-        extract_element(f16_ty, fp16x2Vec0, i32_val(1)),\n-        extract_element(f16_ty, fp16x2Vec1, i32_val(0)),\n-        extract_element(f16_ty, fp16x2Vec1, i32_val(1))\n-    };\n+    auto fp16x2Vec0 =\n+        extract_val(fp16x2VecTy, fp16x2x2Struct, rewriter.getI32ArrayAttr({0}));\n+    auto fp16x2Vec1 =\n+        extract_val(fp16x2VecTy, fp16x2x2Struct, rewriter.getI32ArrayAttr({1}));\n+    return {extract_element(f16_ty, fp16x2Vec0, i32_val(0)),\n+            extract_element(f16_ty, fp16x2Vec0, i32_val(1)),\n+            extract_element(f16_ty, fp16x2Vec1, i32_val(0)),\n+            extract_element(f16_ty, fp16x2Vec1, i32_val(1))};\n   }\n \n-  static SmallVector<Value> convertFp16x4ToFp8x4(\n-      Location loc, ConversionPatternRewriter &rewriter,\n-      const Value& v0, const Value& v1, const Value& v2, const Value& v3) {\n+  static SmallVector<Value>\n+  convertFp16x4ToFp8x4(Location loc, ConversionPatternRewriter &rewriter,\n+                       const Value &v0, const Value &v1, const Value &v2,\n+                       const Value &v3) {\n     auto ctx = rewriter.getContext();\n     auto fp16x2VecTy = vec_ty(f16_ty, 2);\n     Value fp16x2Vec0 = undef(fp16x2VecTy);\n@@ -2262,19 +2260,18 @@ struct FpToFpOpConversion\n     fp16x2Vec1 = bitcast(fp16x2Vec1, i32_ty);\n \n     PTXBuilder builder;\n-    auto *ptxAsm =\n-        \"{                                      \\n\"\n-        \".reg .b32 a<2>, b<2>;                  \\n\"\n-        \"shl.b32 a0, $1, 1;                     \\n\"\n-        \"shl.b32 a1, $2, 1;                     \\n\"\n-        \"lop3.b32 a0, a0, 0x7fff7fff, 0, 0xc0;  \\n\"\n-        \"lop3.b32 a1, a1, 0x7fff7fff, 0, 0xc0;  \\n\"\n-        \"add.u32 a0, a0, 0x00800080;            \\n\"\n-        \"add.u32 a1, a1, 0x00800080;            \\n\"\n-        \"lop3.b32 b0, $1, 0x80008000, a0, 0xea; \\n\"\n-        \"lop3.b32 b1, $2, 0x80008000, a1, 0xea; \\n\"\n-        \"prmt.b32 $0, b0, b1, 0x7531;           \\n\"\n-        \"}\";\n+    auto *ptxAsm = \"{                                      \\n\"\n+                   \".reg .b32 a<2>, b<2>;                  \\n\"\n+                   \"shl.b32 a0, $1, 1;                     \\n\"\n+                   \"shl.b32 a1, $2, 1;                     \\n\"\n+                   \"lop3.b32 a0, a0, 0x7fff7fff, 0, 0xc0;  \\n\"\n+                   \"lop3.b32 a1, a1, 0x7fff7fff, 0, 0xc0;  \\n\"\n+                   \"add.u32 a0, a0, 0x00800080;            \\n\"\n+                   \"add.u32 a1, a1, 0x00800080;            \\n\"\n+                   \"lop3.b32 b0, $1, 0x80008000, a0, 0xea; \\n\"\n+                   \"lop3.b32 b1, $2, 0x80008000, a1, 0xea; \\n\"\n+                   \"prmt.b32 $0, b0, b1, 0x7531;           \\n\"\n+                   \"}\";\n     auto &call = *builder.create(ptxAsm);\n \n     auto *o = builder.newOperand(\"=r\");\n@@ -2284,17 +2281,16 @@ struct FpToFpOpConversion\n \n     auto fp8x4VecTy = vec_ty(i8_ty, 4);\n     auto fp8x4Vec = builder.launch(rewriter, loc, fp8x4VecTy, false);\n-    return {\n-        extract_element(i8_ty, fp8x4Vec, i32_val(0)),\n-        extract_element(i8_ty, fp8x4Vec, i32_val(1)),\n-        extract_element(i8_ty, fp8x4Vec, i32_val(2)),\n-        extract_element(i8_ty, fp8x4Vec, i32_val(3))\n-    };\n+    return {extract_element(i8_ty, fp8x4Vec, i32_val(0)),\n+            extract_element(i8_ty, fp8x4Vec, i32_val(1)),\n+            extract_element(i8_ty, fp8x4Vec, i32_val(2)),\n+            extract_element(i8_ty, fp8x4Vec, i32_val(3))};\n   }\n \n-  static SmallVector<Value> convertFp8x4ToBf16x4(\n-      Location loc, ConversionPatternRewriter &rewriter,\n-      const Value& v0, const Value& v1, const Value& v2, const Value& v3) {\n+  static SmallVector<Value>\n+  convertFp8x4ToBf16x4(Location loc, ConversionPatternRewriter &rewriter,\n+                       const Value &v0, const Value &v1, const Value &v2,\n+                       const Value &v3) {\n     auto ctx = rewriter.getContext();\n     auto fp8x4VecTy = vec_ty(i8_ty, 4);\n     Value fp8x4Vec = undef(fp8x4VecTy);\n@@ -2305,22 +2301,21 @@ struct FpToFpOpConversion\n     fp8x4Vec = bitcast(fp8x4Vec, i32_ty);\n \n     PTXBuilder builder;\n-    auto *ptxAsm =\n-        \"{                                          \\n\"\n-        \".reg .b32 a<2>, sign<2>, nosign<2>, b<2>;  \\n\"\n-        \"prmt.b32 a0, 0, $2, 0x5040;                \\n\"\n-        \"prmt.b32 a1, 0, $2, 0x7060;                \\n\"\n-        \"and.b32 sign0, a0, 0x80008000;             \\n\"\n-        \"and.b32 sign1, a1, 0x80008000;             \\n\"\n-        \"and.b32 nosign0, a0, 0x7fff7fff;           \\n\"\n-        \"and.b32 nosign1, a1, 0x7fff7fff;           \\n\"\n-        \"shr.b32 nosign0, nosign0, 4;               \\n\"\n-        \"shr.b32 nosign1, nosign1, 4;               \\n\"\n-        \"add.u32 nosign0, nosign0, 0x38003800;      \\n\"\n-        \"add.u32 nosign1, nosign1, 0x38003800;      \\n\"\n-        \"or.b32 $0, sign0, nosign0;                 \\n\"\n-        \"or.b32 $1, sign1, nosign1;                 \\n\"\n-        \"}\";\n+    auto *ptxAsm = \"{                                          \\n\"\n+                   \".reg .b32 a<2>, sign<2>, nosign<2>, b<2>;  \\n\"\n+                   \"prmt.b32 a0, 0, $2, 0x5040;                \\n\"\n+                   \"prmt.b32 a1, 0, $2, 0x7060;                \\n\"\n+                   \"and.b32 sign0, a0, 0x80008000;             \\n\"\n+                   \"and.b32 sign1, a1, 0x80008000;             \\n\"\n+                   \"and.b32 nosign0, a0, 0x7fff7fff;           \\n\"\n+                   \"and.b32 nosign1, a1, 0x7fff7fff;           \\n\"\n+                   \"shr.b32 nosign0, nosign0, 4;               \\n\"\n+                   \"shr.b32 nosign1, nosign1, 4;               \\n\"\n+                   \"add.u32 nosign0, nosign0, 0x38003800;      \\n\"\n+                   \"add.u32 nosign1, nosign1, 0x38003800;      \\n\"\n+                   \"or.b32 $0, sign0, nosign0;                 \\n\"\n+                   \"or.b32 $1, sign1, nosign1;                 \\n\"\n+                   \"}\";\n     auto &call = *builder.create(ptxAsm);\n \n     auto *o0 = builder.newOperand(\"=r\");\n@@ -2333,21 +2328,20 @@ struct FpToFpOpConversion\n         struct_ty(SmallVector<Type>{bf16x2VecTy, bf16x2VecTy});\n     auto bf16x2x2Struct =\n         builder.launch(rewriter, loc, bf16x2x2StructTy, false);\n-    auto bf16x2Vec0 = extract_val(bf16x2VecTy, bf16x2x2Struct,\n-                                  rewriter.getI32ArrayAttr({0}));\n-    auto bf16x2Vec1 = extract_val(bf16x2VecTy, bf16x2x2Struct,\n-                                  rewriter.getI32ArrayAttr({1}));\n-    return {\n-        extract_element(bf16_ty, bf16x2Vec0, i32_val(0)),\n-        extract_element(bf16_ty, bf16x2Vec0, i32_val(1)),\n-        extract_element(bf16_ty, bf16x2Vec1, i32_val(0)),\n-        extract_element(bf16_ty, bf16x2Vec1, i32_val(1))\n-    };\n+    auto bf16x2Vec0 =\n+        extract_val(bf16x2VecTy, bf16x2x2Struct, rewriter.getI32ArrayAttr({0}));\n+    auto bf16x2Vec1 =\n+        extract_val(bf16x2VecTy, bf16x2x2Struct, rewriter.getI32ArrayAttr({1}));\n+    return {extract_element(bf16_ty, bf16x2Vec0, i32_val(0)),\n+            extract_element(bf16_ty, bf16x2Vec0, i32_val(1)),\n+            extract_element(bf16_ty, bf16x2Vec1, i32_val(0)),\n+            extract_element(bf16_ty, bf16x2Vec1, i32_val(1))};\n   }\n \n-  static SmallVector<Value> convertBf16x4ToFp8x4(\n-      Location loc, ConversionPatternRewriter &rewriter,\n-      const Value& v0, const Value& v1, const Value& v2, const Value& v3) {\n+  static SmallVector<Value>\n+  convertBf16x4ToFp8x4(Location loc, ConversionPatternRewriter &rewriter,\n+                       const Value &v0, const Value &v1, const Value &v2,\n+                       const Value &v3) {\n     auto ctx = rewriter.getContext();\n     auto bf16x2VecTy = vec_ty(bf16_ty, 2);\n     Value bf16x2Vec0 = undef(bf16x2VecTy);\n@@ -2360,43 +2354,42 @@ struct FpToFpOpConversion\n     bf16x2Vec1 = bitcast(bf16x2Vec1, i32_ty);\n \n     PTXBuilder builder;\n-    auto *ptxAsm =\n-        \"{                                            \\n\"\n-        \".reg .u32 sign, sign<2>, nosign, nosign<2>;  \\n\"\n-        \".reg .u32 fp8_min, fp8_max, rn_, zero;       \\n\"\n-        \"mov.u32 fp8_min, 0x38003800;                 \\n\"\n-        \"mov.u32 fp8_max, 0x3ff03ff0;                 \\n\"\n-        \"mov.u32 rn_, 0x80008;                        \\n\"\n-        \"mov.u32 zero, 0;                             \\n\"\n-        \"and.b32 sign0, $1, 0x80008000;               \\n\"\n-        \"and.b32 sign1, $2, 0x80008000;               \\n\"\n-        \"prmt.b32 sign, sign0, sign1, 0x7531;         \\n\"\n-        \"and.b32 nosign0, $1, 0x7fff7fff;             \\n\"\n-        \"and.b32 nosign1, $2, 0x7fff7fff;             \\n\"\n-        \".reg .u32 nosign_0_<2>, nosign_1_<2>;        \\n\"\n-        \"and.b32 nosign_0_0, nosign0, 0xffff0000;     \\n\"\n-        \"max.u32 nosign_0_0, nosign_0_0, 0x38000000;  \\n\"\n-        \"min.u32 nosign_0_0, nosign_0_0, 0x3ff00000;  \\n\"\n-        \"and.b32 nosign_0_1, nosign0, 0x0000ffff;     \\n\"\n-        \"max.u32 nosign_0_1, nosign_0_1, 0x3800;      \\n\"\n-        \"min.u32 nosign_0_1, nosign_0_1, 0x3ff0;      \\n\"\n-        \"or.b32 nosign0, nosign_0_0, nosign_0_1;      \\n\"\n-        \"and.b32 nosign_1_0, nosign1, 0xffff0000;     \\n\"\n-        \"max.u32 nosign_1_0, nosign_1_0, 0x38000000;  \\n\"\n-        \"min.u32 nosign_1_0, nosign_1_0, 0x3ff00000;  \\n\"\n-        \"and.b32 nosign_1_1, nosign1, 0x0000ffff;     \\n\"\n-        \"max.u32 nosign_1_1, nosign_1_1, 0x3800;      \\n\"\n-        \"min.u32 nosign_1_1, nosign_1_1, 0x3ff0;      \\n\"\n-        \"or.b32 nosign1, nosign_1_0, nosign_1_1;      \\n\"\n-        \"add.u32 nosign0, nosign0, rn_;               \\n\"\n-        \"add.u32 nosign1, nosign1, rn_;               \\n\"\n-        \"sub.u32 nosign0, nosign0, 0x38003800;        \\n\"\n-        \"sub.u32 nosign1, nosign1, 0x38003800;        \\n\"\n-        \"shr.u32 nosign0, nosign0, 4;                 \\n\"\n-        \"shr.u32 nosign1, nosign1, 4;                 \\n\"\n-        \"prmt.b32 nosign, nosign0, nosign1, 0x6420;   \\n\"\n-        \"or.b32 $0, nosign, sign;                     \\n\"\n-        \"}\";\n+    auto *ptxAsm = \"{                                            \\n\"\n+                   \".reg .u32 sign, sign<2>, nosign, nosign<2>;  \\n\"\n+                   \".reg .u32 fp8_min, fp8_max, rn_, zero;       \\n\"\n+                   \"mov.u32 fp8_min, 0x38003800;                 \\n\"\n+                   \"mov.u32 fp8_max, 0x3ff03ff0;                 \\n\"\n+                   \"mov.u32 rn_, 0x80008;                        \\n\"\n+                   \"mov.u32 zero, 0;                             \\n\"\n+                   \"and.b32 sign0, $1, 0x80008000;               \\n\"\n+                   \"and.b32 sign1, $2, 0x80008000;               \\n\"\n+                   \"prmt.b32 sign, sign0, sign1, 0x7531;         \\n\"\n+                   \"and.b32 nosign0, $1, 0x7fff7fff;             \\n\"\n+                   \"and.b32 nosign1, $2, 0x7fff7fff;             \\n\"\n+                   \".reg .u32 nosign_0_<2>, nosign_1_<2>;        \\n\"\n+                   \"and.b32 nosign_0_0, nosign0, 0xffff0000;     \\n\"\n+                   \"max.u32 nosign_0_0, nosign_0_0, 0x38000000;  \\n\"\n+                   \"min.u32 nosign_0_0, nosign_0_0, 0x3ff00000;  \\n\"\n+                   \"and.b32 nosign_0_1, nosign0, 0x0000ffff;     \\n\"\n+                   \"max.u32 nosign_0_1, nosign_0_1, 0x3800;      \\n\"\n+                   \"min.u32 nosign_0_1, nosign_0_1, 0x3ff0;      \\n\"\n+                   \"or.b32 nosign0, nosign_0_0, nosign_0_1;      \\n\"\n+                   \"and.b32 nosign_1_0, nosign1, 0xffff0000;     \\n\"\n+                   \"max.u32 nosign_1_0, nosign_1_0, 0x38000000;  \\n\"\n+                   \"min.u32 nosign_1_0, nosign_1_0, 0x3ff00000;  \\n\"\n+                   \"and.b32 nosign_1_1, nosign1, 0x0000ffff;     \\n\"\n+                   \"max.u32 nosign_1_1, nosign_1_1, 0x3800;      \\n\"\n+                   \"min.u32 nosign_1_1, nosign_1_1, 0x3ff0;      \\n\"\n+                   \"or.b32 nosign1, nosign_1_0, nosign_1_1;      \\n\"\n+                   \"add.u32 nosign0, nosign0, rn_;               \\n\"\n+                   \"add.u32 nosign1, nosign1, rn_;               \\n\"\n+                   \"sub.u32 nosign0, nosign0, 0x38003800;        \\n\"\n+                   \"sub.u32 nosign1, nosign1, 0x38003800;        \\n\"\n+                   \"shr.u32 nosign0, nosign0, 4;                 \\n\"\n+                   \"shr.u32 nosign1, nosign1, 4;                 \\n\"\n+                   \"prmt.b32 nosign, nosign0, nosign1, 0x6420;   \\n\"\n+                   \"or.b32 $0, nosign, sign;                     \\n\"\n+                   \"}\";\n     auto &call = *builder.create(ptxAsm);\n \n     auto *o = builder.newOperand(\"=r\");\n@@ -2406,51 +2399,49 @@ struct FpToFpOpConversion\n \n     auto fp8x4VecTy = vec_ty(i8_ty, 4);\n     auto fp8x4Vec = builder.launch(rewriter, loc, fp8x4VecTy, false);\n-    return {\n-        extract_element(i8_ty, fp8x4Vec, i32_val(0)),\n-        extract_element(i8_ty, fp8x4Vec, i32_val(1)),\n-        extract_element(i8_ty, fp8x4Vec, i32_val(2)),\n-        extract_element(i8_ty, fp8x4Vec, i32_val(3))\n-    };\n+    return {extract_element(i8_ty, fp8x4Vec, i32_val(0)),\n+            extract_element(i8_ty, fp8x4Vec, i32_val(1)),\n+            extract_element(i8_ty, fp8x4Vec, i32_val(2)),\n+            extract_element(i8_ty, fp8x4Vec, i32_val(3))};\n   }\n \n-  static SmallVector<Value> convertFp8x4ToFp32x4(\n-      Location loc, ConversionPatternRewriter &rewriter,\n-      const Value& v0, const Value& v1, const Value& v2, const Value& v3) {\n+  static SmallVector<Value>\n+  convertFp8x4ToFp32x4(Location loc, ConversionPatternRewriter &rewriter,\n+                       const Value &v0, const Value &v1, const Value &v2,\n+                       const Value &v3) {\n     auto fp16Values = convertFp8x4ToFp16x4(loc, rewriter, v0, v1, v2, v3);\n-    return {\n-        rewriter.create<LLVM::FPExtOp>(loc, f32_ty, fp16Values[0]),\n-        rewriter.create<LLVM::FPExtOp>(loc, f32_ty, fp16Values[1]),\n-        rewriter.create<LLVM::FPExtOp>(loc, f32_ty, fp16Values[2]),\n-        rewriter.create<LLVM::FPExtOp>(loc, f32_ty, fp16Values[3])\n-    };\n+    return {rewriter.create<LLVM::FPExtOp>(loc, f32_ty, fp16Values[0]),\n+            rewriter.create<LLVM::FPExtOp>(loc, f32_ty, fp16Values[1]),\n+            rewriter.create<LLVM::FPExtOp>(loc, f32_ty, fp16Values[2]),\n+            rewriter.create<LLVM::FPExtOp>(loc, f32_ty, fp16Values[3])};\n   }\n \n-  static SmallVector<Value> convertFp32x4ToFp8x4(\n-      Location loc, ConversionPatternRewriter &rewriter,\n-      const Value& v0, const Value& v1, const Value& v2, const Value& v3) {\n-      auto c0 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v0);\n-      auto c1 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v1);\n-      auto c2 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v2);\n-      auto c3 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v3);\n-      return convertFp16x4ToFp8x4(loc, rewriter, c0, c1, c2, c3);\n+  static SmallVector<Value>\n+  convertFp32x4ToFp8x4(Location loc, ConversionPatternRewriter &rewriter,\n+                       const Value &v0, const Value &v1, const Value &v2,\n+                       const Value &v3) {\n+    auto c0 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v0);\n+    auto c1 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v1);\n+    auto c2 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v2);\n+    auto c3 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v3);\n+    return convertFp16x4ToFp8x4(loc, rewriter, c0, c1, c2, c3);\n   }\n \n-  static SmallVector<Value> convertFp8x4ToFp64x4(\n-      Location loc, ConversionPatternRewriter &rewriter,\n-      const Value& v0, const Value& v1, const Value& v2, const Value& v3) {\n+  static SmallVector<Value>\n+  convertFp8x4ToFp64x4(Location loc, ConversionPatternRewriter &rewriter,\n+                       const Value &v0, const Value &v1, const Value &v2,\n+                       const Value &v3) {\n     auto fp16Values = convertFp8x4ToFp16x4(loc, rewriter, v0, v1, v2, v3);\n-    return {\n-        rewriter.create<LLVM::FPExtOp>(loc, f64_ty, fp16Values[0]),\n-        rewriter.create<LLVM::FPExtOp>(loc, f64_ty, fp16Values[1]),\n-        rewriter.create<LLVM::FPExtOp>(loc, f64_ty, fp16Values[2]),\n-        rewriter.create<LLVM::FPExtOp>(loc, f64_ty, fp16Values[3])\n-    };\n+    return {rewriter.create<LLVM::FPExtOp>(loc, f64_ty, fp16Values[0]),\n+            rewriter.create<LLVM::FPExtOp>(loc, f64_ty, fp16Values[1]),\n+            rewriter.create<LLVM::FPExtOp>(loc, f64_ty, fp16Values[2]),\n+            rewriter.create<LLVM::FPExtOp>(loc, f64_ty, fp16Values[3])};\n   }\n \n-  static SmallVector<Value> convertFp64x4ToFp8x4(\n-      Location loc, ConversionPatternRewriter &rewriter,\n-      const Value& v0, const Value& v1, const Value& v2, const Value& v3) {\n+  static SmallVector<Value>\n+  convertFp64x4ToFp8x4(Location loc, ConversionPatternRewriter &rewriter,\n+                       const Value &v0, const Value &v1, const Value &v2,\n+                       const Value &v3) {\n     auto c0 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v0);\n     auto c1 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v1);\n     auto c2 = rewriter.create<LLVM::FPTruncOp>(loc, f16_ty, v2);\n@@ -2473,9 +2464,10 @@ struct FpToFpOpConversion\n         this->getTypeConverter()->convertType(dstEltType);\n \n     // Select convertor\n-    std::function<SmallVector<Value>(Location, ConversionPatternRewriter&,\n-                                     const Value&, const Value&,\n-                                     const Value&, const Value&)> convertor;\n+    std::function<SmallVector<Value>(Location, ConversionPatternRewriter &,\n+                                     const Value &, const Value &,\n+                                     const Value &, const Value &)>\n+        convertor;\n     if (srcEltType.isa<triton::Float8Type>() && dstEltType.isF16()) {\n       convertor = convertFp8x4ToFp16x4;\n     } else if (srcEltType.isF16() && dstEltType.isa<triton::Float8Type>()) {\n@@ -2504,8 +2496,7 @@ struct FpToFpOpConversion\n     auto elements = getElementsFromStruct(loc, adaptor.from(), rewriter);\n     SmallVector<Value> resultVals;\n     for (size_t i = 0; i < elems; i += 4) {\n-      auto converted = convertor(loc, rewriter,\n-                                 elements[i], elements[i + 1],\n+      auto converted = convertor(loc, rewriter, elements[i], elements[i + 1],\n                                  elements[i + 2], elements[i + 3]);\n       resultVals.append(converted);\n     }"}]