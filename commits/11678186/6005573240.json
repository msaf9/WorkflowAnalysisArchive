[{"filename": "include/triton/Dialect/NVGPU/IR/NVGPUOps.td", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "file_content_changes": "@@ -97,7 +97,15 @@ def WGMMADesc_ModeAttr : I32EnumAttr<\"WGMMADescMode\",\n }\n \n def NVGPU_WGMMADescCreateOp : NVGPU_Op<\"wgmma_desc_create\", []> {\n-  let arguments = (ins LLVM_AnyPointer:$buffer, I32:$height, WGMMADesc_ModeAttr:$mode);\n+  let arguments = (ins LLVM_AnyPointer:$buffer, I32:$height, WGMMADesc_ModeAttr:$mode, I64Attr:$swizzling);\n+  let builders = [\n+    OpBuilder<(ins \"Value\":$buffer,\n+                     \"Value\":$height,\n+                     \"WGMMADescMode\":$mode), [{\n+                      uint32_t mode_ = static_cast<uint32_t>(mode);\n+                      uint64_t swizzling = (mode_ == 1 ? 128 : mode_ == 2 ? 64 : 32);\n+                      build($_builder, $_state, $_builder.getIntegerType(64), buffer, height, WGMMADescModeAttr::get($_builder.getContext(), mode), $_builder.getI64IntegerAttr(swizzling));\n+                     }]>];\n   let results = (outs I64:$res);\n   let assemblyFormat = \"$buffer `,` $height attr-dict `:` functional-type(operands, results)\";\n }"}, {"filename": "lib/Conversion/NVGPUToLLVM/NVGPUToLLVMPass.cpp", "status": "modified", "additions": 23, "deletions": 54, "changes": 77, "file_content_changes": "@@ -35,6 +35,24 @@ const std::string Fence_Mbarrier_Init_Op =\n const std::string Cga_Barrier_Arrive_Op = \"barrier.cluster.arrive;\";\n const std::string Cga_Barrier_Wait_Op = \"barrier.cluster.wait;\";\n const std::string Reg_Dealloc_Op = \"setmaxnreg.dec.sync.aligned.u32 #regCount;\";\n+const std::string Wgmma_Desc_Create_op =\n+    \"{\\n\"\n+    \".reg .u64 a<5>;                              \\n\"\n+    \"mov.u64 a0, #swizzling;\\n\"\n+    \"shl.b64 a1, a0, 3;\\n\"             // stride dimension\n+    \"shr.b64 a1, a1, 4;\\n\"             // stride dimension\n+    \"mul.lo.u64 a2, $2, #swizzling;\\n\" // leadingDimension\n+    \"shr.b64 a2, a2, 4;\\n\"             // leadingDimension\n+    \"shl.b64 a3, $1, 46; \\n\"           // startAddr\n+    \"shr.b64 a3, a3, 50; \\n\"           // startAddr\n+    \"mov.u64 a4, #mode; \\n\"            // mode\n+    \"shl.b64 a4, a4, 62; \\n\"\n+    \"shl.b64 a1, a1, 32; \\n\"\n+    \"or.b64 a1, a4, a1; \\n\"\n+    \"shl.b64 a2, a2, 16; \\n\"\n+    \"or.b64 a1, a1, a2; \\n\"\n+    \"or.b64 $0, a1, a3; \\n\"\n+    \"}\";\n \n const std::string Mbarrier_Init_Op =\n     \"@$1 mbarrier.init.shared.b64 [$0], #count;\";\n@@ -835,59 +853,6 @@ class WGMMAOpPattern : public NVGPUOpPatternBase<ttn::WGMMAOp, WGMMAOpPattern> {\n   }\n };\n \n-class WGMMADescCreateOpPattern\n-    : public NVGPUOpPatternBase<ttn::WGMMADescCreateOp,\n-                                WGMMADescCreateOpPattern> {\n-public:\n-  using Base =\n-      NVGPUOpPatternBase<ttn::WGMMADescCreateOp, WGMMADescCreateOpPattern>;\n-  using Base::Base;\n-\n-  std::vector<std::string>\n-  getOutputConstraints(ttn::WGMMADescCreateOp op) const {\n-    return {\"=l\"};\n-  }\n-\n-  OperandsAndConstraints\n-  getOperandsAndConstraints(ttn::WGMMADescCreateOp op) const {\n-    OperandsAndConstraints operandsAndConstraints;\n-    auto buffer = op.getBuffer();\n-    auto height = op.getHeight();\n-\n-    operandsAndConstraints.push_back({buffer, \"l\"});\n-    operandsAndConstraints.push_back({height, \"l\"});\n-\n-    return operandsAndConstraints;\n-  }\n-\n-  std::string getPtxAsm(ttn::WGMMADescCreateOp op) const {\n-    uint32_t mode = static_cast<uint32_t>(op.getMode());\n-    uint64_t swizzling = (mode == 1 ? 128 : mode == 2 ? 64 : 32);\n-    auto ptxAsm = \"{\\n\"\n-                  \".reg .u64 a<5>;                              \\n\"\n-                  \"mov.u64 a0, \" +\n-                  std::to_string(swizzling) +\n-                  \";\\n\"\n-                  \"shl.b64 a1, a0, 3;\\n\" // stride dimension\n-                  \"shr.b64 a1, a1, 4;\\n\" // stride dimension\n-                  \"mul.lo.u64 a2, $2, \" +\n-                  std::to_string(swizzling) +\n-                  \";\\n\"                    // leadingDimension\n-                  \"shr.b64 a2, a2, 4;\\n\"   // leadingDimension\n-                  \"shl.b64 a3, $1, 46; \\n\" // startAddr\n-                  \"shr.b64 a3, a3, 50; \\n\" // startAddr\n-                  \"mov.u64 a4, #mode; \\n\"  // mode\n-                  \"shl.b64 a4, a4, 62; \\n\"\n-                  \"shl.b64 a1, a1, 32; \\n\"\n-                  \"or.b64 a1, a4, a1; \\n\"\n-                  \"shl.b64 a2, a2, 16; \\n\"\n-                  \"or.b64 a1, a1, a2; \\n\"\n-                  \"or.b64 $0, a1, a3; \\n\"\n-                  \"}\";\n-    return ptxAsm;\n-  }\n-};\n-\n class OffsetOfSts64OpPattern\n     : public NVGPUOpPatternBase<ttn::OffsetOfSts64Op, OffsetOfSts64OpPattern> {\n public:\n@@ -1015,6 +980,8 @@ class OffsetOfStmatrixV4OpPattern\n       } else if (rowStride == 16) {\n         perPhase = 4;\n         maxPhase = 2;\n+      } else {\n+        assert(false && \"Unsupported rowStride\");\n       }\n \n       ptxAsm =\n@@ -1123,11 +1090,13 @@ class ConvertNVGPUToLLVM : public ConvertNVGPUToLLVMBase<ConvertNVGPUToLLVM> {\n     patterns.add<NVGPUOpGenericPattern<ttn::ClusterCTAIdOp>>(\n         context, Cluster_Cta_Id_Op, std::vector<std::string>({\"=r\"}),\n         std::vector<std::string>());\n+    patterns.add<NVGPUOpGenericPattern<ttn::WGMMADescCreateOp>>(\n+        context, Wgmma_Desc_Create_op, std::vector<std::string>({\"=l\"}),\n+        std::vector<std::string>({\"l\", \"l\"}));\n \n     patterns.add<FenceAsyncSharedOpPattern>(context);\n     patterns.add<StoreMatrixOpPattern>(context);\n     patterns.add<OffsetOfStmatrixV4OpPattern>(context);\n-    patterns.add<WGMMADescCreateOpPattern>(context);\n     patterns.add<MBarrierArriveOpPattern>(context);\n     patterns.add<ClusterArriveOpPattern>(context);\n     patterns.add<TMALoadTiledOpPattern>(context);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpToLLVM/WGMMA.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -115,7 +115,7 @@ class DotOpMmaV3SmemLoader {\n     mode = getModeFromLayout(sharedLayout, widthInByte);\n \n     baseDesc = rewriter.create<triton::nvgpu::WGMMADescCreateOp>(\n-        loc, i64_ty, base, i32_val(shape[ord[1]]), mode);\n+        loc, base, i32_val(shape[ord[1]]), mode);\n   }\n \n   Value smemLoad(int a, int b) {"}]