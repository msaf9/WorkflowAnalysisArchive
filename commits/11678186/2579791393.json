[{"filename": "include/triton/ir/instructions.h", "status": "modified", "additions": 432, "deletions": 551, "changes": 983, "file_content_changes": "@@ -3,24 +3,23 @@\n #ifndef _TRITON_IR_INSTRUCTIONS_H_\n #define _TRITON_IR_INSTRUCTIONS_H_\n \n-#include <map>\n #include <vector>\n-\n-#include \"triton/ir/constant.h\"\n+#include <map>\n #include \"triton/ir/enums.h\"\n-#include \"triton/ir/metadata.h\"\n-#include \"triton/ir/type.h\"\n+#include \"triton/ir/constant.h\"\n #include \"triton/ir/value.h\"\n+#include \"triton/ir/type.h\"\n+#include \"triton/ir/metadata.h\"\n #include \"triton/ir/visitor.h\"\n \n #define _TRITON_DEFINE_CLONE(name) \\\n-  ir::instruction *clone_impl() const { return new name(*this); }\n+  ir::instruction* clone_impl() const { return new name(*this); }\n \n #define _TRITON_DEFINE_ACCEPT(name) \\\n-  void accept(visitor *v) { v->visit_##name(this); }\n+  void accept(visitor* v) { v->visit_ ## name (this); }\n \n-namespace triton {\n-namespace ir {\n+namespace triton{\n+namespace ir{\n \n class constant_int;\n class constant;\n@@ -35,38 +34,38 @@ class visitor;\n \n class result_reference;\n \n-class instruction : public user {\n- public:\n+\n+class instruction: public user{\n+public:\n   virtual std::string repr_impl() const = 0;\n \n- private:\n-  virtual ir::instruction *clone_impl() const = 0;\n+private:\n+  virtual ir::instruction* clone_impl() const = 0;\n \n- protected:\n+protected:\n   // constructors\n   instruction(type *ty, value_id_t ity, unsigned num_ops,\n               const std::string &name = \"\", instruction *next = nullptr);\n \n- public:\n+public:\n   // parent\n-  void set_parent(basic_block *block) { parent_ = block; }\n-  const basic_block *get_parent() const { return parent_; }\n-  basic_block *get_parent() { return parent_; }\n+  void set_parent(basic_block *block)                         { parent_ = block; }\n+  const basic_block *get_parent() const                       { return parent_;  }\n+  basic_block *get_parent()                                   { return parent_;  }\n   void erase_from_parent();\n   // helpers\n   bool has_tile_result_or_op();\n   // repr\n-  std::string repr() const { return repr_impl(); }\n+  std::string repr() const                                    { return repr_impl(); }\n   // metadata\n-  void set_metadata(ir::metadata::kind_t kind, unsigned value) {\n-    metadatas_[kind] = value;\n-  }\n-  unsigned get_metadata(ir::metadata::kind_t kind) { return metadatas_[kind]; }\n+  void set_metadata(ir::metadata::kind_t kind,\n+                    unsigned value)                           { metadatas_[kind] = value;}\n+  unsigned get_metadata(ir::metadata::kind_t kind)            { return metadatas_[kind];}\n   // cloning\n-  ir::instruction *clone() {\n-    ir::instruction *res = clone_impl();\n-    //    for(auto it = op_begin(); it != op_end(); it++)\n-    //      (*it)->add_use(res);\n+  ir::instruction* clone() {\n+    ir::instruction* res = clone_impl();\n+//    for(auto it = op_begin(); it != op_end(); it++)\n+//      (*it)->add_use(res);\n     res->parent_ = nullptr;\n     res->users_.clear();\n     return res;\n@@ -76,7 +75,7 @@ class instruction : public user {\n \n   void print(std::ostream &os);\n \n- private:\n+private:\n   basic_block *parent_;\n   std::map<ir::metadata::kind_t, unsigned> metadatas_;\n   value_id_t id_;\n@@ -86,49 +85,42 @@ class instruction : public user {\n //                               call_inst classes\n //===----------------------------------------------------------------------===//\n \n-class call_inst : public instruction {\n- private:\n+class call_inst: public instruction {\n+private:\n   std::string repr_impl() const;\n-  call_inst(ir::function *fn, const std::vector<ir::value *> &values,\n-            const std::string &name, instruction *next);\n+  call_inst(ir::function* fn, const std::vector<ir::value*>& values, const std::string& name, instruction* next);\n \n- public:\n-  static call_inst *create(ir::function *fn,\n-                           const std::vector<ir::value *> &values,\n-                           const std::string &name = \"\",\n-                           instruction *next = nullptr);\n-  ir::function *get_fn() { return fn_; }\n+public:\n+  static call_inst* create(ir::function* fn, const std::vector<ir::value*>& values, const std::string &name = \"\", instruction *next = nullptr);\n+  ir::function* get_fn() { return fn_; }\n \n   _TRITON_DEFINE_CLONE(call_inst)\n   _TRITON_DEFINE_ACCEPT(call_inst)\n \n- private:\n-  ir::function *fn_;\n+private:\n+  ir::function* fn_;\n };\n \n-class launch_inst : public instruction {\n- private:\n+class launch_inst: public instruction {\n+private:\n   std::string repr_impl() const { return \"launch\"; }\n-  launch_inst(ir::function *fn, const std::vector<ir::value *> &values,\n-              const std::vector<ir::value *> &grid, ir::value *num_warps,\n+  launch_inst(ir::function* fn, const std::vector<ir::value*>& values, const std::vector<ir::value*>& grid, ir::value* num_warps,\n               const std::string &name = \"\", instruction *next = nullptr);\n \n- public:\n-  static launch_inst *create(ir::function *fn,\n-                             const std::vector<ir::value *> &values,\n-                             const std::vector<ir::value *> &grid,\n-                             ir::value *num_warps, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static launch_inst* create(ir::function* fn, const std::vector<ir::value*>& values, const std::vector<ir::value*>& grid, ir::value* num_warps,\n+                             const std::string& name = \"\", instruction* next = nullptr);\n+\n+  ir::function* get_fn();\n+  std::vector<ir::value*> get_values();\n+  std::vector<ir::value*> get_grid();\n+  ir::value* get_num_warps();\n \n-  ir::function *get_fn();\n-  std::vector<ir::value *> get_values();\n-  std::vector<ir::value *> get_grid();\n-  ir::value *get_num_warps();\n \n   _TRITON_DEFINE_CLONE(launch_inst)\n   _TRITON_DEFINE_ACCEPT(launch_inst)\n \n- private:\n+private:\n   unsigned val_begin;\n   unsigned val_end;\n   unsigned grid_begin;\n@@ -139,13 +131,12 @@ class launch_inst : public instruction {\n //                               phi_node classes\n //===----------------------------------------------------------------------===//\n \n-class phi_node : public instruction {\n- private:\n-  phi_node(type *ty, unsigned num_reserved, const std::string &name,\n-           instruction *next);\n+class phi_node: public instruction {\n+private:\n+  phi_node(type *ty, unsigned num_reserved, const std::string &name, instruction *next);\n   std::string repr_impl() const { return \"phi\"; }\n \n- public:\n+public:\n   void set_incoming_value(unsigned i, value *v);\n   void set_incoming_block(unsigned i, basic_block *block);\n   value *get_value_for_block(basic_block *block);\n@@ -158,125 +149,118 @@ class phi_node : public instruction {\n   void set_type(type *ty) { ty_ = ty; }\n \n   // Factory methods\n-  static phi_node *create(type *ty, unsigned num_reserved,\n-                          const std::string &name = \"\",\n-                          instruction *next = nullptr);\n+  static phi_node* create(type *ty, unsigned num_reserved, const std::string &name = \"\", instruction *next = nullptr);\n \n   _TRITON_DEFINE_CLONE(phi_node)\n   _TRITON_DEFINE_ACCEPT(phi_node)\n \n- private:\n+private:\n   unsigned num_reserved_;\n-  std::vector<basic_block *> blocks_;\n+  std::vector<basic_block*> blocks_;\n };\n \n //===----------------------------------------------------------------------===//\n //                               binary_operator classes\n //===----------------------------------------------------------------------===//\n \n-class binary_operator : public instruction {\n- public:\n+class binary_operator: public instruction {\n+public:\n   typedef binary_op_t op_t;\n \n- private:\n+private:\n   std::string repr_impl() const;\n \n- protected:\n+protected:\n   // Constructors\n-  binary_operator(binary_op_t op, value *lhs, value *rhs, type *ty,\n-                  const std::string &name, instruction *next);\n+  binary_operator(binary_op_t op, value *lhs, value *rhs, type *ty, const std::string &name, instruction *next);\n \n- public:\n+public:\n   // Get operand\n   binary_op_t get_op() const { return op_; }\n \n   // Bool\n-  bool is_terminator() const;\n-  bool is_binary_op() const;\n+  bool is_terminator()  const;\n+  bool is_binary_op()   const;\n   bool is_int_div_rem() const;\n-  bool is_shift() const;\n-  bool is_cast() const;\n-  bool is_int_mult() const;\n+  bool is_shift()       const;\n+  bool is_cast()        const;\n+  bool is_int_mult()    const;\n   bool is_int_add_sub() const;\n-  bool is_int_div() const;\n-  bool is_int_rem() const;\n-  bool is_shl() const;\n-  bool is_shr() const;\n+  bool is_int_div()     const;\n+  bool is_int_rem()     const;\n+  bool is_shl()         const;\n+  bool is_shr()         const;\n \n   // Approx\n   void set_fdiv_ieee_rounding(bool rnd) { fdiv_ieee_rnd_ = rnd; }\n   bool get_fdiv_ieee_rounding() { return fdiv_ieee_rnd_; }\n \n   // Wraps\n   void set_has_no_unsigned_wrap(bool b = true) { has_no_unsigned_wrap_ = b; }\n-  void set_has_no_signed_wrap(bool b = true) { has_no_signed_wrap_ = b; }\n+  void set_has_no_signed_wrap(bool b = true)   { has_no_signed_wrap_ = b; }\n \n   // Factory methods\n   static binary_operator *create(binary_op_t op, value *lhs, value *rhs,\n-                                 const std::string &name = \"\",\n-                                 instruction *next = nullptr);\n-  //  static binary_operator *create_fneg(value *arg, const std::string &name =\n-  //  \"\", instruction *next = nullptr); static binary_operator *create_neg(value\n-  //  *arg, const std::string &name = \"\", instruction *next = nullptr); static\n-  //  binary_operator *create_not(value *arg, const std::string &name = \"\",\n-  //  instruction *next = nullptr);\n+                                 const std::string &name = \"\", instruction *next = nullptr);\n+//  static binary_operator *create_fneg(value *arg, const std::string &name = \"\", instruction *next = nullptr);\n+//  static binary_operator *create_neg(value *arg, const std::string &name = \"\", instruction *next = nullptr);\n+//  static binary_operator *create_not(value *arg, const std::string &name = \"\", instruction *next = nullptr);\n \n   _TRITON_DEFINE_CLONE(binary_operator)\n   _TRITON_DEFINE_ACCEPT(binary_operator)\n \n- public:\n+public:\n   binary_op_t op_;\n   bool has_no_unsigned_wrap_;\n   bool has_no_signed_wrap_;\n \n   bool fdiv_ieee_rnd_;\n };\n \n+\n //===----------------------------------------------------------------------===//\n //                               cmp_inst classes\n //===----------------------------------------------------------------------===//\n \n-class cmp_inst : public instruction {\n- public:\n+class cmp_inst: public instruction{\n+public:\n   typedef cmp_pred_t pred_t;\n \n- private:\n+private:\n   std::string repr_impl() const;\n \n- protected:\n-  cmp_inst(type *ty, value_id_t id, cmp_pred_t pred, value *lhs, value *rhs,\n-           const std::string &name, instruction *next);\n+protected:\n+  cmp_inst(type *ty, value_id_t id, cmp_pred_t pred,\n+           value *lhs, value *rhs, const std::string &name, instruction *next);\n   static bool is_fp_predicate(cmp_pred_t pred);\n   static bool is_int_predicate(cmp_pred_t pred);\n-  static type *make_cmp_result_type(type *ty);\n+  static type* make_cmp_result_type(type *ty);\n \n- public:\n+public:\n   cmp_pred_t get_pred() const { return pred_; }\n \n- private:\n+private:\n   cmp_pred_t pred_;\n };\n \n-class icmp_inst : public cmp_inst {\n-  icmp_inst(type *ty, cmp_pred_t pred, value *lhs, value *rhs,\n-            const std::string &name, instruction *next);\n+class icmp_inst: public cmp_inst {\n+  icmp_inst(type *ty, cmp_pred_t pred,\n+            value *lhs, value *rhs, const std::string &name, instruction *next);\n \n- public:\n-  static icmp_inst *create(cmp_pred_t pred, value *lhs, value *rhs,\n-                           const std::string &name = \"\",\n-                           instruction *next = nullptr);\n+public:\n+  static icmp_inst* create(cmp_pred_t pred, value *lhs, value *rhs,\n+                    const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(icmp_inst)\n   _TRITON_DEFINE_ACCEPT(icmp_inst)\n };\n \n-class fcmp_inst : public cmp_inst {\n-  fcmp_inst(type *ty, cmp_pred_t pred, value *lhs, value *rhs,\n-            const std::string &name, instruction *next);\n+class fcmp_inst: public cmp_inst {\n+  fcmp_inst(type *ty, cmp_pred_t pred,\n+            value *lhs, value *rhs, const std::string &name, instruction *next);\n \n- public:\n-  static fcmp_inst *create(cmp_pred_t pred, value *lhs, value *rhs,\n-                           const std::string &name = \"\",\n-                           instruction *next = nullptr);\n+public:\n+  static fcmp_inst* create(cmp_pred_t pred, value *lhs, value *rhs,\n+                    const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(fcmp_inst)\n   _TRITON_DEFINE_ACCEPT(fcmp_inst)\n };\n@@ -285,183 +269,163 @@ class fcmp_inst : public cmp_inst {\n //                               unary_inst classes\n //===----------------------------------------------------------------------===//\n \n-class unary_inst : public instruction {\n- protected:\n-  unary_inst(type *ty, value_id_t id, value *v, const std::string &name,\n-             instruction *next);\n+class unary_inst: public instruction {\n+protected:\n+  unary_inst(type *ty, value_id_t id, value *v, const std::string &name, instruction *next);\n };\n \n+\n //===----------------------------------------------------------------------===//\n //                               cast_inst classes\n //===----------------------------------------------------------------------===//\n \n-class cast_inst : public unary_inst {\n- private:\n+class cast_inst: public unary_inst{\n+private:\n   std::string repr_impl() const;\n \n- protected:\n-  cast_inst(type *ty, value_id_t id, value *v, const std::string &name,\n-            instruction *next, cast_op_t op)\n-      : unary_inst(ty, id, v, name, next), op_(op) {}\n+protected:\n+  cast_inst(type *ty, value_id_t id, value *v, const std::string &name, instruction *next, cast_op_t op)\n+    : unary_inst(ty, id, v, name, next), op_(op) { }\n \n- private:\n+private:\n   static bool is_valid(cast_op_t op, value *arg, type *ty);\n \n- public:\n+public:\n   // accessors\n   cast_op_t get_op() const { return op_; }\n \n   // factory methods\n   static cast_inst *create(cast_op_t op, value *arg, type *ty,\n-                           const std::string &name = \"\",\n-                           instruction *next = nullptr);\n+                           const std::string &name = \"\", instruction *next = nullptr);\n   static cast_inst *create_integer_cast(value *arg, type *ty, bool is_signed,\n-                                        const std::string &name = \"\",\n-                                        instruction *next = nullptr);\n+                           const std::string &name = \"\", instruction *next = nullptr);\n \n   _TRITON_DEFINE_ACCEPT(cast_inst)\n \n- private:\n+private:\n   cast_op_t op_;\n };\n \n-#define TRITON_IR_DECLARE_CAST_INST_SIMPL(name, id, op)                  \\\n-  class name : public cast_inst {                                        \\\n-    _TRITON_DEFINE_CLONE(name)                                           \\\n-    friend class cast_inst;                                              \\\n-    name(type *ty, value *v, const std::string &name, instruction *next) \\\n-        : cast_inst(ty, id, v, name, next, op) {}                        \\\n-  };\n+#define TRITON_IR_DECLARE_CAST_INST_SIMPL(name, id, op) \\\n+class name : public cast_inst { \\\n+  _TRITON_DEFINE_CLONE(name) \\\n+  friend class cast_inst; \\\n+  name(type *ty, value *v, const std::string &name, instruction *next) \\\n+    : cast_inst(ty, id, v, name, next, op){ } \\\n+};\n \n TRITON_IR_DECLARE_CAST_INST_SIMPL(trunc_inst, INST_CAST_TRUNC, cast_op_t::Trunc)\n TRITON_IR_DECLARE_CAST_INST_SIMPL(z_ext_inst, INST_CAST_ZEXT, cast_op_t::ZExt)\n TRITON_IR_DECLARE_CAST_INST_SIMPL(s_ext_inst, INST_CAST_SEXT, cast_op_t::SExt)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(fp_trunc_inst, INST_CAST_FP_TRUNC,\n-                                  cast_op_t::FPTrunc)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(fp_ext_inst, INST_CAST_FP_EXT,\n-                                  cast_op_t::FPExt)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(ui_to_fp_inst, INST_CAST_UI_TO_FP,\n-                                  cast_op_t::UIToFP)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(si_to_fp_inst, INST_CAST_SI_TO_FP,\n-                                  cast_op_t::SIToFP)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(fp_to_ui_inst, INST_CAST_FP_TO_UI,\n-                                  cast_op_t::FPToUI)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(fp_to_si_inst, INST_CAST_FP_TO_SI,\n-                                  cast_op_t::FPToSI)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(ptr_to_int_inst, INST_CAST_PTR_TO_INT,\n-                                  cast_op_t::PtrToInt)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(int_to_ptr_inst, INST_CAST_INT_TO_PTR,\n-                                  cast_op_t::IntToPtr)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(bit_cast_inst, INST_CAST_BIT_CAST,\n-                                  cast_op_t::BitCast)\n-TRITON_IR_DECLARE_CAST_INST_SIMPL(addr_space_cast_inst,\n-                                  INST_CAST_ADDR_SPACE_CAST,\n-                                  cast_op_t::AddrSpaceCast)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(fp_trunc_inst, INST_CAST_FP_TRUNC, cast_op_t::FPTrunc)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(fp_ext_inst, INST_CAST_FP_EXT, cast_op_t::FPExt)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(ui_to_fp_inst, INST_CAST_UI_TO_FP, cast_op_t::UIToFP)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(si_to_fp_inst, INST_CAST_SI_TO_FP, cast_op_t::SIToFP)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(fp_to_ui_inst, INST_CAST_FP_TO_UI, cast_op_t::FPToUI)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(fp_to_si_inst, INST_CAST_FP_TO_SI, cast_op_t::FPToSI)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(ptr_to_int_inst, INST_CAST_PTR_TO_INT, cast_op_t::PtrToInt)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(int_to_ptr_inst, INST_CAST_INT_TO_PTR, cast_op_t::IntToPtr)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(bit_cast_inst, INST_CAST_BIT_CAST, cast_op_t::BitCast)\n+TRITON_IR_DECLARE_CAST_INST_SIMPL(addr_space_cast_inst, INST_CAST_ADDR_SPACE_CAST, cast_op_t::AddrSpaceCast)\n \n //===----------------------------------------------------------------------===//\n //                               terminator_inst classes\n //===----------------------------------------------------------------------===//\n \n-class terminator_inst : public instruction {\n+class terminator_inst: public instruction{\n   using instruction::instruction;\n };\n \n // return instruction\n-class return_inst : public terminator_inst {\n- private:\n+class return_inst: public terminator_inst {\n+private:\n   std::string repr_impl() const { return \"ret\"; }\n   return_inst(context &ctx, value *ret_val, instruction *next);\n \n- public:\n+public:\n   // accessors\n-  value *get_return_value() {\n-    return get_num_operands() ? get_operand(0) : nullptr;\n-  }\n+  value *get_return_value()\n+  { return get_num_operands() ? get_operand(0) : nullptr; }\n \n   unsigned get_num_successors() const { return 0; }\n \n   // factory methods\n-  static return_inst *create(context &ctx, value *ret_val = nullptr,\n-                             instruction *next = nullptr);\n+  static return_inst* create(context &ctx, value *ret_val = nullptr, instruction *next = nullptr);\n \n   _TRITON_DEFINE_CLONE(return_inst)\n   _TRITON_DEFINE_ACCEPT(return_inst)\n };\n \n // base branch instruction\n-class branch_inst : public terminator_inst {\n- private:\n+class branch_inst: public terminator_inst{\n+private:\n   std::string repr_impl() const { return \"br\"; }\n \n- protected:\n+protected:\n   using terminator_inst::terminator_inst;\n \n- public:\n-  static branch_inst *create(basic_block *dest, instruction *next = nullptr);\n-  static branch_inst *create(value *cond, basic_block *if_dest,\n-                             basic_block *else_dest,\n+public:\n+  static branch_inst* create(basic_block *dest,\n+                             instruction *next = nullptr);\n+  static branch_inst* create(value *cond, basic_block *if_dest, basic_block *else_dest,\n                              instruction *next = nullptr);\n };\n \n // conditional branch\n-class cond_branch_inst : public branch_inst {\n- private:\n+class cond_branch_inst: public branch_inst {\n+private:\n   friend class branch_inst;\n-  cond_branch_inst(basic_block *if_dst, basic_block *else_dst, value *cond,\n-                   instruction *next);\n+  cond_branch_inst(basic_block *if_dst, basic_block *else_dst, value *cond, instruction *next);\n \n- public:\n-  basic_block *get_true_dest() { return (basic_block *)get_operand(0); }\n-  basic_block *get_false_dest() { return (basic_block *)get_operand(1); }\n-  value *get_cond() { return get_operand(2); }\n+public:\n+  basic_block *get_true_dest()  { return (basic_block*)get_operand(0); }\n+  basic_block *get_false_dest() { return (basic_block*)get_operand(1); }\n+  value *get_cond()             { return get_operand(2); }\n   _TRITON_DEFINE_CLONE(cond_branch_inst)\n   _TRITON_DEFINE_ACCEPT(cond_branch_inst)\n };\n \n // unconditional branch\n-class uncond_branch_inst : public branch_inst {\n- private:\n+class uncond_branch_inst: public branch_inst {\n+private:\n   friend class branch_inst;\n   uncond_branch_inst(basic_block *dst, instruction *next);\n \n- public:\n-  basic_block *get_dest() { return (basic_block *)get_operand(0); }\n+public:\n+  basic_block *get_dest()  { return (basic_block*)get_operand(0); }\n   _TRITON_DEFINE_CLONE(uncond_branch_inst)\n   _TRITON_DEFINE_ACCEPT(uncond_branch_inst)\n };\n \n+\n //===----------------------------------------------------------------------===//\n //                               getelementptr_inst classes\n //===----------------------------------------------------------------------===//\n \n-class getelementptr_inst : public instruction {\n- private:\n+class getelementptr_inst: public instruction {\n+private:\n   std::string repr_impl() const { return \"getelementptr\"; }\n-  getelementptr_inst(type *pointee_ty, value *ptr,\n-                     const std::vector<value *> &idx, const std::string &name,\n-                     instruction *next);\n+  getelementptr_inst(type *pointee_ty, value *ptr, const std::vector<value*> &idx, const std::string &name, instruction *next);\n \n- private:\n-  static type *get_return_type(type *ty, value *ptr,\n-                               const std::vector<value *> &idx);\n+private:\n+  static type *get_return_type(type *ty, value *ptr, const std::vector<value*> &idx);\n   static type *get_indexed_type_impl(type *ty, const std::vector<value *> &idx);\n-  static type *get_indexed_type(type *ty, const std::vector<value *> &idx);\n+  static type *get_indexed_type(type *ty, const std::vector<value*> &idx);\n \n- public:\n+public:\n   // accessors\n   type *get_source_elt_ty() { return source_elt_ty; }\n-  op_iterator idx_begin() { return op_begin() + 1; }\n-  op_iterator idx_end() { return op_end(); }\n-  value *get_pointer_operand() { return *op_begin(); }\n+  op_iterator idx_begin()       { return op_begin() + 1; }\n+  op_iterator idx_end()         { return op_end(); }\n+  value *get_pointer_operand()  { return *op_begin(); }\n \n   // factory methods\n-  static getelementptr_inst *create(value *ptr, const std::vector<value *> &idx,\n-                                    const std::string &name = \"\",\n-                                    instruction *next = nullptr);\n+  static getelementptr_inst* create(value *ptr, const std::vector<value*> &idx,\n+                                    const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(getelementptr_inst)\n   _TRITON_DEFINE_ACCEPT(getelementptr_inst)\n \n- private:\n+private:\n   type *source_elt_ty;\n   type *res_elt_ty;\n };\n@@ -470,27 +434,27 @@ class getelementptr_inst : public instruction {\n //                          load_inst/store_inst classes\n //===----------------------------------------------------------------------===//\n \n-class io_inst : public instruction {\n- protected:\n+class io_inst: public instruction {\n+protected:\n   io_inst(type *ty, value_id_t id, unsigned num_ops,\n           const std::string &name = \"\", instruction *next = nullptr);\n \n- public:\n+public:\n   // accessors\n   value *get_pointer_operand() { return get_operand(0); }\n };\n \n // load\n-class load_inst : public io_inst {\n- public:\n+class load_inst: public io_inst {\n+public:\n   enum CACHE_MODIFIER : uint32_t {\n-    NONE = 0,\n+    NONE=0,\n     CA,\n     CG,\n   };\n \n   enum EVICTION_POLICY : uint32_t {\n-    NORMAL = 0,\n+    NORMAL=0,\n     EVICT_FIRST,\n     EVICT_LAST,\n   };\n@@ -499,14 +463,14 @@ class load_inst : public io_inst {\n   EVICTION_POLICY get_eviction_policy() const { return eviction_; }\n   bool get_is_volatile() const { return is_volatile_; }\n \n- protected:\n-  load_inst(value *ptr, value_id_t id, unsigned num_ops, CACHE_MODIFIER cache,\n-            EVICTION_POLICY eviction, bool is_volatile,\n-            const std::string &name = \"\", instruction *next = nullptr);\n+protected:\n+  load_inst(value *ptr, value_id_t id, unsigned num_ops, CACHE_MODIFIER cache, EVICTION_POLICY eviction,\n+          bool is_volatile,\n+          const std::string &name = \"\", instruction *next = nullptr);\n   std::string get_cache_modifier_repr() const {\n     if (cache_ == CA) return \".ca\";\n     if (cache_ == CG) return \".cg\";\n-    return \"\";\n+    return \"\"; \n   }\n   std::string get_eviction_policy_repr() const {\n     if (eviction_ == EVICT_FIRST) return \".L1::evict_first\";\n@@ -516,119 +480,112 @@ class load_inst : public io_inst {\n   EVICTION_POLICY eviction_;\n   CACHE_MODIFIER cache_;\n \n-  std::string get_volatile_repr() { return is_volatile_ ? \".volatile\" : \"\"; }\n+  std::string get_volatile_repr() {\n+    return is_volatile_ ? \".volatile\" : \"\";\n+  }\n   bool is_volatile_;\n \n- private:\n+private:\n   static type *get_pointee_type(type *ty);\n };\n \n // unmasked load\n-class unmasked_load_inst : public load_inst {\n- private:\n-  std::string repr_impl() const {\n-    return \"unmasked_load\" + get_cache_modifier_repr();\n-  }\n-  unmasked_load_inst(value *ptr, load_inst::CACHE_MODIFIER cache,\n-                     load_inst::EVICTION_POLICY eviction, bool is_volatile,\n-                     const std::string &name, instruction *next);\n-\n- public:\n-  static unmasked_load_inst *create(value *ptr, CACHE_MODIFIER cache,\n-                                    EVICTION_POLICY eviction, bool is_volatile,\n+class unmasked_load_inst: public load_inst {\n+private:\n+  std::string repr_impl() const { return \"unmasked_load\" + get_cache_modifier_repr(); }\n+  unmasked_load_inst(value *ptr, load_inst::CACHE_MODIFIER cache, load_inst::EVICTION_POLICY eviction, bool is_volatile, const std::string &name, instruction *next);\n+\n+public:\n+  static unmasked_load_inst* create(value *ptr,\n+                                    CACHE_MODIFIER cache, EVICTION_POLICY eviction,\n+                                    bool is_volatile,\n                                     const std::string &name = \"\",\n                                     instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(unmasked_load_inst)\n   _TRITON_DEFINE_ACCEPT(unmasked_load_inst)\n };\n \n // masked load\n-class masked_load_inst : public load_inst {\n- private:\n-  std::string repr_impl() const {\n-    return \"masked_load\" + get_cache_modifier_repr();\n-  }\n-  masked_load_inst(value *ptr, value *mask, value *false_value,\n-                   load_inst::CACHE_MODIFIER cache,\n-                   load_inst::EVICTION_POLICY eviction, bool is_volatile,\n+class masked_load_inst: public load_inst {\n+private:\n+  std::string repr_impl() const { return \"masked_load\" + get_cache_modifier_repr(); }\n+  masked_load_inst(value *ptr, value *mask, value *false_value, load_inst::CACHE_MODIFIER cache, load_inst::EVICTION_POLICY eviction, bool is_volatile,\n                    const std::string &name, instruction *next);\n \n- public:\n+public:\n   // accessors\n   value *get_mask_operand() { return get_operand(1); }\n   value *get_false_value_operand() { return get_operand(2); }\n   // factory method\n-  static masked_load_inst *create(value *ptr, value *mask, value *false_value,\n-                                  CACHE_MODIFIER cache,\n-                                  EVICTION_POLICY eviction, bool is_volatile,\n+  static masked_load_inst* create(value *ptr, value *mask, value *false_value,\n+                                  CACHE_MODIFIER cache, EVICTION_POLICY eviction,\n+                                  bool is_volatile,\n                                   const std::string &name = \"\",\n                                   instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(masked_load_inst)\n   _TRITON_DEFINE_ACCEPT(masked_load_inst)\n };\n \n // masked load async\n-class masked_load_async_inst : public load_inst {\n- private:\n-  std::string repr_impl() const {\n-    return \"masked_load_async\" + get_cache_modifier_repr();\n-  }\n+class masked_load_async_inst: public load_inst {\n+private:\n+  std::string repr_impl() const { return \"masked_load_async\" + get_cache_modifier_repr(); }\n   masked_load_async_inst(value *ptr, value *mask, value *false_value,\n                          CACHE_MODIFIER cache, EVICTION_POLICY eviction,\n                          const std::string &name, instruction *next);\n \n- public:\n+public:\n   // accessors\n   value *get_mask_operand() { return get_operand(1); }\n   value *get_false_value_operand() { return get_operand(2); }\n   // factory method\n-  static masked_load_async_inst *create(value *ptr, value *mask,\n-                                        value *false_value,\n-                                        load_inst::CACHE_MODIFIER cache,\n-                                        EVICTION_POLICY eviction,\n-                                        const std::string &name = \"\",\n-                                        instruction *next = nullptr);\n+  static masked_load_async_inst* create(value *ptr, value *mask, value *false_value,\n+                                  load_inst::CACHE_MODIFIER cache,\n+                                  EVICTION_POLICY eviction,\n+                                  const std::string &name = \"\",\n+                                  instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(masked_load_async_inst)\n   _TRITON_DEFINE_ACCEPT(masked_load_async_inst)\n };\n \n+\n+\n // store\n-class store_inst : public io_inst {\n- protected:\n+class store_inst: public io_inst {\n+protected:\n   store_inst(value *ptr, value_id_t id, unsigned num_ops,\n-             const std::string &name = \"\", instruction *next = nullptr);\n+            const std::string &name = \"\", instruction *next = nullptr);\n \n- public:\n+public:\n   value *get_value_operand() { return get_operand(1); }\n };\n \n // unmasked_store\n-class unmasked_store_inst : public store_inst {\n- private:\n+class unmasked_store_inst: public store_inst{\n+private:\n   std::string repr_impl() const { return \"unmasked_store\"; }\n-  unmasked_store_inst(value *ptr, value *v, const std::string &name,\n-                      instruction *next);\n+  unmasked_store_inst(value *ptr, value *v, const std::string &name, instruction *next);\n \n- public:\n+public:\n   // factory method\n-  static unmasked_store_inst *create(value *ptr, value *v,\n-                                     const std::string &name = \"\",\n-                                     instruction *next = nullptr);\n+  static unmasked_store_inst* create(value* ptr, value *v,\n+                                    const std::string &name = \"\",\n+                                    instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(unmasked_store_inst)\n   _TRITON_DEFINE_ACCEPT(unmasked_store_inst)\n };\n \n-class masked_store_inst : public store_inst {\n- private:\n+class masked_store_inst: public store_inst{\n+private:\n   std::string repr_impl() const { return \"masked_store\"; }\n-  masked_store_inst(value *ptr, value *v, value *mask, const std::string &name,\n-                    instruction *next);\n+  masked_store_inst(value *ptr, value *v, value *mask,\n+                    const std::string &name, instruction *next);\n \n- public:\n+public:\n   // accessors\n   value *get_mask_operand() { return get_operand(2); }\n   // factory method\n-  static masked_store_inst *create(value *ptr, value *v, value *mask,\n+  static masked_store_inst* create(value *ptr, value *v, value *mask,\n                                    const std::string &name = \"\",\n                                    instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(masked_store_inst)\n@@ -641,41 +598,35 @@ class masked_store_inst : public store_inst {\n \n // insert_value\n \n-class insert_value_inst : public instruction {\n- private:\n+class insert_value_inst: public instruction {\n+private:\n   std::string repr_impl() const { return \"insertvalue\"; }\n-  insert_value_inst(value *val, value *elt, size_t idx, const std::string &name,\n-                    instruction *next);\n+  insert_value_inst(value *val, value *elt, size_t idx, const std::string &name, instruction *next);\n \n- public:\n-  static insert_value_inst *create(value *val, value *elt, size_t idx,\n-                                   const std::string &name = \"\",\n-                                   instruction *next = nullptr);\n+public:\n+  static insert_value_inst* create(value *val, value* elt, size_t idx, const std::string &name = \"\", instruction *next = nullptr);\n   size_t get_idx() { return idx_; }\n   _TRITON_DEFINE_CLONE(insert_value_inst)\n   _TRITON_DEFINE_ACCEPT(insert_value_inst)\n \n- private:\n+private:\n   size_t idx_;\n };\n \n // extract_value\n \n-class extract_value_inst : public instruction {\n- private:\n+class extract_value_inst: public instruction {\n+private:\n   std::string repr_impl() const { return \"extractvalue\"; }\n-  extract_value_inst(value *val, size_t idx, const std::string &name,\n-                     instruction *next);\n+  extract_value_inst(value *val, size_t idx, const std::string &name, instruction *next);\n \n- public:\n-  static extract_value_inst *create(value *val, size_t idx,\n-                                    const std::string &name = \"\",\n-                                    instruction *next = nullptr);\n+public:\n+  static extract_value_inst* create(value *val, size_t idx, const std::string &name = \"\", instruction *next = nullptr);\n   size_t get_idx() { return idx_; }\n   _TRITON_DEFINE_CLONE(extract_value_inst)\n   _TRITON_DEFINE_ACCEPT(extract_value_inst)\n \n- private:\n+private:\n   size_t idx_;\n };\n \n@@ -685,13 +636,13 @@ class extract_value_inst : public instruction {\n \n // cat\n \n-class cat_inst : public instruction {\n- private:\n+class cat_inst: public instruction {\n+private:\n   std::string repr_impl() const { return \"cat\"; }\n   cat_inst(value *x, value *y, const std::string &name, instruction *next);\n \n- public:\n-  static instruction *create(value *lhs, value *rhs,\n+public:\n+  static instruction* create(value *lhs, value *rhs,\n                              const std::string &name = \"\",\n                              instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(cat_inst)\n@@ -700,70 +651,63 @@ class cat_inst : public instruction {\n \n // retile\n \n-class retile_inst : public unary_inst {\n- protected:\n-  retile_inst(value *arg, value_id_t id, const type::block_shapes_t &shapes,\n-              const std::string &name, instruction *next);\n+class retile_inst: public unary_inst {\n+protected:\n+  retile_inst(value *arg, value_id_t id, const type::block_shapes_t &shapes, const std::string &name, instruction *next);\n };\n \n // reshape\n \n-class reshape_inst : public retile_inst {\n- private:\n+class reshape_inst: public retile_inst {\n+private:\n   using retile_inst::retile_inst;\n   std::string repr_impl() const { return \"reshape\"; }\n \n- public:\n-  static instruction *create(value *arg,\n-                             const type::block_shapes_t &shape_suffix,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *arg, const type::block_shapes_t &shape_suffix,\n+                      const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(reshape_inst)\n   _TRITON_DEFINE_ACCEPT(reshape_inst)\n };\n \n // splat\n \n-class splat_inst : public retile_inst {\n- private:\n+class splat_inst: public retile_inst {\n+private:\n   using retile_inst::retile_inst;\n   std::string repr_impl() const { return \"splat\"; }\n \n- public:\n-  static instruction *create(value *arg,\n-                             const type::block_shapes_t &shape_suffix,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *arg, const type::block_shapes_t &shape_suffix,\n+                      const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(splat_inst)\n   _TRITON_DEFINE_ACCEPT(splat_inst)\n };\n \n // broadcast\n \n-class broadcast_inst : public retile_inst {\n- private:\n+class broadcast_inst: public retile_inst {\n+private:\n   using retile_inst::retile_inst;\n   std::string repr_impl() const { return \"broadcast\"; }\n \n- public:\n-  static instruction *create(value *arg,\n-                             const type::block_shapes_t &shape_suffix,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *arg, const type::block_shapes_t &shape_suffix,\n+                      const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(broadcast_inst)\n   _TRITON_DEFINE_ACCEPT(broadcast_inst)\n };\n \n+\n // downcast\n \n-class downcast_inst : public unary_inst {\n- private:\n+class downcast_inst: public unary_inst {\n+private:\n   using unary_inst::unary_inst;\n   std::string repr_impl() const { return \"downcast\"; }\n \n- public:\n-  static instruction *create(value *arg, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *arg, const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(downcast_inst)\n   _TRITON_DEFINE_ACCEPT(downcast_inst)\n };\n@@ -772,428 +716,364 @@ class downcast_inst : public unary_inst {\n //                               builtin_inst classes\n //===----------------------------------------------------------------------===//\n \n-class builtin_inst : public instruction {\n- protected:\n+class builtin_inst: public instruction{\n+protected:\n   using instruction::instruction;\n };\n \n-class get_program_id_inst : public builtin_inst {\n- private:\n-  get_program_id_inst(type *ty, unsigned axis, const std::string &name,\n-                      instruction *next);\n-  std::string repr_impl() const {\n-    return \"get_program_id(\" + std::to_string(axis_) + \")\";\n-  }\n+class get_program_id_inst: public builtin_inst {\n+private:\n+  get_program_id_inst(type *ty, unsigned axis, const std::string &name, instruction *next);\n+  std::string repr_impl() const { return \"get_program_id(\" + std::to_string(axis_) + \")\"; }\n \n- public:\n-  static instruction *create(context &ctx, unsigned axis,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(context &ctx, unsigned axis, const std::string &name = \"\", instruction *next = nullptr);\n   unsigned get_axis() const { return axis_; }\n   _TRITON_DEFINE_CLONE(get_program_id_inst)\n   _TRITON_DEFINE_ACCEPT(get_program_id_inst)\n \n- private:\n+private:\n   unsigned axis_;\n };\n \n-class get_num_programs_inst : public builtin_inst {\n- private:\n-  get_num_programs_inst(type *ty, unsigned axis, const std::string &name,\n-                        instruction *next);\n-  std::string repr_impl() const {\n-    return \"get_num_programs(\" + std::to_string(axis_) + \")\";\n-  }\n+class get_num_programs_inst: public builtin_inst {\n+private:\n+  get_num_programs_inst(type *ty, unsigned axis, const std::string &name, instruction *next);\n+  std::string repr_impl() const { return \"get_num_programs(\" + std::to_string(axis_) + \")\"; }\n \n- public:\n-  static instruction *create(context &ctx, unsigned axis,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(context &ctx, unsigned axis, const std::string &name = \"\", instruction *next = nullptr);\n   unsigned get_axis() const { return axis_; }\n   _TRITON_DEFINE_CLONE(get_num_programs_inst)\n   _TRITON_DEFINE_ACCEPT(get_num_programs_inst)\n \n- private:\n+private:\n   unsigned axis_;\n };\n \n-class atomic_inst : public io_inst {\n- public:\n+\n+class atomic_inst: public io_inst {\n+public:\n   using io_inst::io_inst;\n };\n \n-class atomic_rmw_inst : public atomic_inst {\n- private:\n-  atomic_rmw_inst(atomic_rmw_op_t op, value *ptr, value *val, value *msk,\n-                  const std::string &name = \"\", instruction *next = nullptr);\n+class atomic_rmw_inst: public atomic_inst {\n+private:\n+  atomic_rmw_inst(atomic_rmw_op_t op, value *ptr, value *val, value *msk, const std::string &name = \"\", instruction *next = nullptr);\n   std::string repr_impl() const { return \"atomic_rmw\"; }\n   _TRITON_DEFINE_CLONE(atomic_rmw_inst)\n   _TRITON_DEFINE_ACCEPT(atomic_rmw_inst)\n \n- public:\n-  static instruction *create(atomic_rmw_op_t op, value *ptr, value *val,\n-                             value *msk, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(atomic_rmw_op_t op, value *ptr, value *val, value *msk, const std::string &name = \"\", instruction *next = nullptr);\n   atomic_rmw_op_t get_op() { return op_; }\n \n- private:\n+private:\n   atomic_rmw_op_t op_;\n };\n \n-class atomic_cas_inst : public atomic_inst {\n- private:\n-  atomic_cas_inst(value *ptr, value *cmp, value *val, const std::string &name,\n-                  instruction *next);\n+class atomic_cas_inst: public atomic_inst {\n+private:\n+  atomic_cas_inst(value *ptr, value *cmp, value *val, const std::string &name, instruction *next);\n   std::string repr_impl() const { return \"atomic_cas\"; }\n   _TRITON_DEFINE_CLONE(atomic_cas_inst)\n   _TRITON_DEFINE_ACCEPT(atomic_cas_inst)\n \n- public:\n-  static instruction *create(value *ptr, value *cmp, value *val,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *ptr, value *cmp, value *val, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n-class umulhi_inst : public builtin_inst {\n- private:\n-  umulhi_inst(value *lhs, value *rhs, const std::string &name = \"\",\n-              instruction *next = nullptr);\n+class umulhi_inst: public builtin_inst {\n+private:\n+  umulhi_inst(value *lhs, value *rhs, const std::string &name = \"\", instruction *next = nullptr);\n   std::string repr_impl() const { return \"umulhi\"; }\n   _TRITON_DEFINE_CLONE(umulhi_inst)\n   _TRITON_DEFINE_ACCEPT(umulhi_inst)\n \n- public:\n-  static instruction *create(value *lhs, value *rhs,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *lhs, value *rhs, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n-class exp_inst : public builtin_inst {\n- private:\n-  exp_inst(value *val, const std::string &name = \"\",\n-           instruction *next = nullptr);\n+class exp_inst: public builtin_inst {\n+private:\n+  exp_inst(value *val, const std::string &name = \"\", instruction *next = nullptr);\n   std::string repr_impl() const { return \"exp\"; }\n   _TRITON_DEFINE_CLONE(exp_inst)\n   _TRITON_DEFINE_ACCEPT(exp_inst)\n \n- public:\n-  static instruction *create(value *val, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *val, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n-class cos_inst : public builtin_inst {\n- private:\n-  cos_inst(value *val, const std::string &name = \"\",\n-           instruction *next = nullptr);\n+class cos_inst: public builtin_inst {\n+private:\n+  cos_inst(value *val, const std::string &name = \"\", instruction *next = nullptr);\n   std::string repr_impl() const { return \"cos\"; }\n   _TRITON_DEFINE_CLONE(cos_inst)\n   _TRITON_DEFINE_ACCEPT(cos_inst)\n \n- public:\n-  static instruction *create(value *val, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *val, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n-class sin_inst : public builtin_inst {\n- private:\n-  sin_inst(value *val, const std::string &name = \"\",\n-           instruction *next = nullptr);\n+class sin_inst: public builtin_inst {\n+private:\n+  sin_inst(value *val, const std::string &name = \"\", instruction *next = nullptr);\n   std::string repr_impl() const { return \"sin\"; }\n   _TRITON_DEFINE_CLONE(sin_inst)\n   _TRITON_DEFINE_ACCEPT(sin_inst)\n \n- public:\n-  static instruction *create(value *val, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *val, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n-class log_inst : public builtin_inst {\n- private:\n-  log_inst(value *val, const std::string &name = \"\",\n-           instruction *next = nullptr);\n+class log_inst: public builtin_inst {\n+private:\n+  log_inst(value *val, const std::string &name = \"\", instruction *next = nullptr);\n   std::string repr_impl() const { return \"log\"; }\n   _TRITON_DEFINE_CLONE(log_inst)\n   _TRITON_DEFINE_ACCEPT(log_inst)\n \n- public:\n-  static instruction *create(value *val, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *val, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n-class dot_inst : public builtin_inst {\n- public:\n+\n+class dot_inst: public builtin_inst {\n+public:\n   enum TransT { NoTrans, Trans };\n-  enum DataType {\n-    FP8,\n-    FP16,\n-    BF16,\n-    TF32,\n-    FP32,\n-    INT1,\n-    INT4,\n-    INT8,\n-    INT32,\n+  enum DataType { \n+    FP8, FP16, BF16, TF32, FP32, \n+    INT1, INT4, INT8, INT32, \n     UNKNOWN,\n   };\n \n- private:\n-  dot_inst(value *A, value *B, value *C, TransT AT, TransT BT, bool allow_tf32,\n-           const std::string &name, instruction *next);\n+private:\n+  dot_inst(value *A, value *B, value *C, TransT AT, TransT BT, bool allow_tf32, const std::string &name, instruction *next);\n   std::string repr_impl() const { return \"dot\"; }\n-\n- public:\n+  \n+public:\n   bool is_prefetched() const { return is_prefetched_; }\n   void set_prefetched(bool is_prefetched) { is_prefetched_ = is_prefetched; }\n   bool allow_tf32() const { return allow_tf32_; }\n \n- public:\n-  static instruction *create(value *A, value *B, value *C, bool AT, bool BT,\n-                             bool allow_tf32, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n-  static instruction *create_nn(value *A, value *B, value *C, bool allow_tf32,\n-                                const std::string &name = \"\",\n-                                instruction *next = nullptr);\n-  static instruction *create_nt(value *A, value *B, value *C, bool allow_tf32,\n-                                const std::string &name = \"\",\n-                                instruction *next = nullptr);\n-  static instruction *create_tn(value *A, value *B, value *C, bool allow_tf32,\n-                                const std::string &name = \"\",\n-                                instruction *next = nullptr);\n-  static instruction *create_tt(value *A, value *B, value *C, bool allow_tf32,\n-                                const std::string &name = \"\",\n-                                instruction *next = nullptr);\n+public:\n+  static instruction *create(value *A, value *B, value *C, bool AT, bool BT, bool allow_tf32, const std::string &name = \"\", instruction *next = nullptr);\n+  static instruction* create_nn(value *A, value *B, value *C, bool allow_tf32, const std::string &name = \"\", instruction *next = nullptr);\n+  static instruction* create_nt(value *A, value *B, value *C, bool allow_tf32, const std::string &name = \"\", instruction *next = nullptr);\n+  static instruction* create_tn(value *A, value *B, value *C, bool allow_tf32, const std::string &name = \"\", instruction *next = nullptr);\n+  static instruction* create_tt(value *A, value *B, value *C, bool allow_tf32, const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(dot_inst)\n   _TRITON_DEFINE_ACCEPT(dot_inst)\n \n- private:\n+private:\n   bool is_prefetched_ = false;\n   bool allow_tf32_ = false;\n   DataType C_type_ = DataType::FP32;\n   DataType A_type_ = DataType::FP16;\n   DataType B_type_ = DataType::FP16;\n };\n \n-// class outer_inst: public builtin_inst {\n-// private:\n-//   outer_inst(value *A, value *B, value *C, const std::string &name,\n-//   instruction *next);\n-// public:\n-//   static instruction* create(value *A, value *B, value *C, const std::string\n-//   &name = \"\", instruction *next = nullptr);\n-// };\n+//class outer_inst: public builtin_inst {\n+//private:\n+//  outer_inst(value *A, value *B, value *C, const std::string &name, instruction *next);\n+//public:\n+//  static instruction* create(value *A, value *B, value *C, const std::string &name = \"\", instruction *next = nullptr);\n+//};\n \n-class trans_inst : public builtin_inst {\n- public:\n-  ir::type *get_res_ty(ir::type *in, std::vector<int> perm);\n-  std::vector<int> init_perm(ir::type *ty, const std::vector<int> &perm);\n+class trans_inst: public builtin_inst {\n+public:\n+  ir::type* get_res_ty(ir::type* in, std::vector<int> perm);\n+  std::vector<int> init_perm(ir::type* ty, const std::vector<int>& perm);\n \n- private:\n-  trans_inst(value *arg, const std::vector<int> &perm, const std::string &name,\n-             instruction *next);\n+private:\n+  trans_inst(value *arg, const std::vector<int>& perm, const std::string& name, instruction* next);\n   std::string repr_impl() const { return \"trans\"; }\n \n- public:\n-  static instruction *create(value *arg, const std::vector<int> &perm = {},\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *arg, const std::vector<int> &perm = {}, const std::string &name = \"\", instruction *next = nullptr);\n   const std::vector<int> get_perm() const;\n   _TRITON_DEFINE_CLONE(trans_inst)\n   _TRITON_DEFINE_ACCEPT(trans_inst)\n \n- private:\n+private:\n   std::vector<int> perm_;\n };\n \n-class sqrt_inst : public builtin_inst {\n- private:\n-  sqrt_inst(value *arg, const std::string &name, instruction *next);\n+class sqrt_inst: public builtin_inst {\n+private:\n+  sqrt_inst(value *arg, const std::string& name, instruction* next);\n   std::string repr_impl() const { return \"sqrt\"; }\n-\n- public:\n-  static instruction *create(value *arg, const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *arg, const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(sqrt_inst)\n   _TRITON_DEFINE_ACCEPT(sqrt_inst)\n };\n \n-class reduce_inst : public builtin_inst {\n- public:\n-  enum op_t { ADD, SUB, MAX, MIN, UMAX, UMIN, FADD, FSUB, FMAX, FMIN, XOR };\n+class reduce_inst: public builtin_inst {\n+public:\n+  enum op_t{\n+    ADD, SUB, MAX, MIN, UMAX, UMIN,\n+    FADD, FSUB, FMAX, FMIN,\n+    XOR\n+  };\n \n- private:\n-  static type *get_res_type(value *arg, unsigned axis);\n+private:\n+  static type* get_res_type(value *arg, unsigned axis);\n   static std::string to_str(op_t op);\n \n- private:\n-  reduce_inst(value *arg, op_t op, unsigned axis, const std::string &name,\n-              instruction *next);\n+private:\n+  reduce_inst(value* arg, op_t op, unsigned axis, const std::string& name, instruction* next);\n   std::string repr_impl() const { return \"reduce\"; }\n   _TRITON_DEFINE_CLONE(reduce_inst)\n   _TRITON_DEFINE_ACCEPT(reduce_inst)\n \n- public:\n-  static instruction *create(value *arg, op_t op, unsigned axis,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n+public:\n+  static instruction* create(value *arg, op_t op, unsigned axis, const std::string &name = \"\", instruction *next = nullptr);\n   unsigned get_axis() const { return axis_; }\n   op_t get_op() const { return op_; }\n \n- private:\n+private:\n   unsigned axis_;\n   op_t op_;\n };\n \n-class select_inst : public builtin_inst {\n- private:\n-  select_inst(value *pred, value *if_value, value *else_value,\n-              const std::string &name, instruction *next);\n+class select_inst: public builtin_inst {\n+private:\n+  select_inst(value *pred, value *if_value, value *else_value, const std::string& name, instruction* next);\n   std::string repr_impl() const { return \"select\"; }\n   _TRITON_DEFINE_CLONE(select_inst)\n   _TRITON_DEFINE_ACCEPT(select_inst)\n \n- public:\n-  static instruction *create(value *pred, value *if_value, value *else_value,\n-                             const std::string &name = \"\",\n-                             instruction *next = nullptr);\n-  value *get_pred_op() { return get_operand(0); }\n-  value *get_if_value_op() { return get_operand(1); }\n-  value *get_else_value_op() { return get_operand(2); }\n+public:\n+  static instruction* create(value *pred, value *if_value, value *else_value, const std::string &name = \"\", instruction *next = nullptr);\n+  value* get_pred_op() { return get_operand(0); }\n+  value* get_if_value_op() { return get_operand(1); }\n+  value* get_else_value_op() { return get_operand(2); }\n };\n \n //===----------------------------------------------------------------------===//\n //                               intrinsics classes\n //===----------------------------------------------------------------------===//\n \n-class copy_to_shared_inst : public unary_inst {\n- private:\n+\n+class copy_to_shared_inst: public unary_inst{\n+private:\n   using unary_inst::unary_inst;\n   std::string repr_impl() const { return \"copy_to_shared\"; }\n \n- public:\n-  static copy_to_shared_inst *create(value *arg, const std::string &name = \"\",\n+public:\n+  static copy_to_shared_inst* create(value *arg, const std::string &name = \"\",\n                                      instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(copy_to_shared_inst)\n   _TRITON_DEFINE_ACCEPT(copy_to_shared_inst)\n };\n \n-class copy_from_shared_inst : public unary_inst {\n- private:\n+class copy_from_shared_inst: public unary_inst{\n+private:\n   using unary_inst::unary_inst;\n   std::string repr_impl() const { return \"copy_from_shared\"; }\n \n- public:\n-  static copy_from_shared_inst *create(value *arg, const std::string &name = \"\",\n-                                       instruction *next = nullptr);\n+public:\n+  static copy_from_shared_inst* create(value *arg, const std::string &name = \"\",\n+                                     instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(copy_from_shared_inst)\n   _TRITON_DEFINE_ACCEPT(copy_from_shared_inst)\n };\n \n-class cvt_layout_inst : public unary_inst {\n- private:\n+class cvt_layout_inst: public unary_inst {\n+private:\n   using unary_inst::unary_inst;\n   std::string repr_impl() const { return \"cvt_layout_inst\"; }\n \n- public:\n-  static cvt_layout_inst *create(value *arg, const std::string &name = \"\",\n-                                 instruction *next = nullptr);\n+public:\n+  static cvt_layout_inst* create(value *arg, const std::string &name = \"\", instruction *next = nullptr);\n   _TRITON_DEFINE_CLONE(cvt_layout_inst)\n   _TRITON_DEFINE_ACCEPT(cvt_layout_inst)\n };\n \n-class barrier_inst : public instruction {\n- private:\n+class barrier_inst: public instruction{\n+private:\n   barrier_inst(context &ctx, const std::string &name, instruction *next);\n   std::string repr_impl() const { return \"barrier\"; }\n   _TRITON_DEFINE_CLONE(barrier_inst)\n   _TRITON_DEFINE_ACCEPT(barrier_inst)\n \n- public:\n-  static barrier_inst *create(context &ctx, const std::string &name = \"\",\n-                              instruction *next = nullptr);\n+public:\n+  static barrier_inst* create(context &ctx, const std::string &name = \"\",\n+                                            instruction *next = nullptr);\n };\n \n-class async_wait_inst : public instruction {\n- private:\n-  async_wait_inst(context &ctx, int N, const std::string &name,\n-                  instruction *next);\n-  std::string repr_impl() const {\n-    return \"async_wait_group \" + std::to_string(N_);\n-  }\n+class async_wait_inst: public instruction{\n+private:\n+  async_wait_inst(context &ctx, int N, const std::string &name, instruction *next);\n+  std::string repr_impl() const { return \"async_wait_group \" + std::to_string(N_) ; }\n   _TRITON_DEFINE_CLONE(async_wait_inst)\n   _TRITON_DEFINE_ACCEPT(async_wait_inst)\n \n- public:\n-  static async_wait_inst *create(context &ctx, int N,\n-                                 const std::string &name = \"\",\n-                                 instruction *next = nullptr);\n+public:\n+  static async_wait_inst* create(context &ctx, int N,\n+                                 const std::string &name = \"\", instruction *next = nullptr);\n   int get_N() { return N_; }\n   void set_N(int n) { N_ = n; }\n \n- private:\n+private:\n   int N_;\n };\n \n class prefetch_s_inst : public instruction {\n   std::string repr_impl() const { return \"prefetch_s\"; }\n   _TRITON_DEFINE_CLONE(prefetch_s_inst)\n   _TRITON_DEFINE_ACCEPT(prefetch_s_inst)\n-\n+  \n   /// inc_: 0->first, 1->latch\n   int inc_ = 0;\n-\n- public:\n-  prefetch_s_inst(context &ctx, value *arg, int inc, const std::string &name,\n-                  instruction *next)\n-      : instruction(type::get_void_ty(ctx), INST_PREFETCH_S, 1, name, next),\n-        inc_(inc) {\n+public:\n+  prefetch_s_inst(context &ctx, value *arg, int inc, const std::string &name, instruction *next) \n+    : instruction(type::get_void_ty(ctx), INST_PREFETCH_S, 1, name, next), inc_(inc) {\n     set_operand(0, arg);\n   }\n   int get_inc() const { return inc_; }\n-  static prefetch_s_inst *create(context &ctx, value *arg, int inc,\n-                                 const std::string &name = \"\",\n-                                 instruction *next = nullptr);\n+  static prefetch_s_inst *create(context &ctx, value *arg, int inc, const std::string &name = \"\",\n+   instruction *next=nullptr);\n };\n \n /* constant range */\n-class make_range : public instruction {\n-  make_range(type *ty, constant_int *first, constant_int *last);\n-  std::string repr_impl() const {\n-    return \"make_range[\" + first_->repr() + \" : \" + last_->repr() + \"]\";\n-  }\n+class make_range: public instruction{\n+  make_range(type *ty, constant_int* first, constant_int* last);\n+  std::string repr_impl() const { return \"make_range[\" + first_->repr() + \" : \" + last_->repr() + \"]\"; }\n   _TRITON_DEFINE_CLONE(make_range)\n   _TRITON_DEFINE_ACCEPT(make_range)\n \n- public:\n+public:\n   static make_range *create(constant_int *first, constant_int *last);\n-  const constant_int *get_first() const;\n-  const constant_int *get_last() const;\n+  const constant_int* get_first() const;\n+  const constant_int* get_last() const;\n \n- private:\n-  constant_int *first_;\n-  constant_int *last_;\n+private:\n+  constant_int* first_;\n+  constant_int* last_;\n };\n \n /* timing utilities */\n-class clock_inst : public instruction {\n+class clock_inst: public instruction{\n   clock_inst(context &ctx, const std::string &name, instruction *next);\n   std::string repr_impl() const { return \"clock\"; }\n   _TRITON_DEFINE_CLONE(clock_inst)\n   _TRITON_DEFINE_ACCEPT(clock_inst)\n \n- public:\n-  static clock_inst *create(context &ctx, const std::string &name = \"\",\n-                            instruction *next = nullptr);\n+public:\n+  static clock_inst* create(context &ctx, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n-class globaltimer_inst : public instruction {\n+class globaltimer_inst: public instruction{\n   globaltimer_inst(context &ctx, const std::string &name, instruction *next);\n   std::string repr_impl() const { return \"globaltimer\"; }\n   _TRITON_DEFINE_CLONE(globaltimer_inst)\n   _TRITON_DEFINE_ACCEPT(globaltimer_inst)\n \n- public:\n-  static globaltimer_inst *create(context &ctx, const std::string &name = \"\",\n-                                  instruction *next = nullptr);\n+public:\n+  static globaltimer_inst* create(context &ctx, const std::string &name = \"\", instruction *next = nullptr);\n };\n \n class extern_elementwise_inst : public instruction {\n@@ -1218,7 +1098,8 @@ class extern_elementwise_inst : public instruction {\n   std::string lib_name_ = \"\";\n   std::string lib_path_ = \"\";\n };\n-}  // namespace ir\n-}  // namespace triton\n+\n+}\n+}\n \n #endif"}]