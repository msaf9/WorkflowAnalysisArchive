[{"filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "file_content_changes": "@@ -1,6 +1,3 @@\n [submodule \"deps/dlfcn-win32\"]\n \tpath = deps/dlfcn-win32\n \turl = https://github.com/dlfcn-win32/dlfcn-win32.git\n-[submodule \"third-party/pybind11\"]\n-\tpath = third-party/pybind11\n-\turl = https://github.com/pybind/pybind11.git"}, {"filename": "CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "file_content_changes": "@@ -26,9 +26,6 @@ endif()\n # Compiler flags\n include_directories(${CMAKE_CURRENT_SOURCE_DIR}/include)\n \n-# Third-party\n-include_directories(${CMAKE_CURRENT_SOURCE_DIR}/third-party/pybind11/include)\n-\n if(WIN32)\n     SET(BUILD_SHARED_LIBS OFF)\n     include_directories(${CMAKE_CURRENT_SOURCE_DIR}/deps/dlfcn-win32/src)"}, {"filename": "python/setup.py", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "file_content_changes": "@@ -28,20 +28,6 @@ def get_build_type():\n         return \"Release\"\n \n \n-def check_submodule():\n-    submodule_paths = [\"third-party/pybind11/include/pybind11\"]\n-    if not all([os.path.exists(p) for p in submodule_paths]):\n-        print(\"initializing submodules ...\")\n-        try:\n-            cwd = os.path.abspath(os.path.dirname(__file__))\n-            subprocess.check_call([\"git\", \"submodule\", \"update\", \"--init\", \"--recursive\"], cwd=cwd)\n-            print(\"submodule initialization succeeded\")\n-        except Exception:\n-            print(\"submodule initialization failed\")\n-            print(\" Please run:\\n\\tgit submodule update --init --recursive\")\n-            exit(-1)\n-\n-\n def get_llvm():\n     # tries to find system LLVM\n     versions = ['-11.0', '-11', '-11-64']\n@@ -106,7 +92,6 @@ def run(self):\n             self.build_extension(ext)\n \n     def build_extension(self, ext):\n-        check_submodule()\n         llvm_include_dir, llvm_library_dir = get_llvm()\n         extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.path)))\n         # create build directories"}, {"filename": "python/src/pybind11/attr.h", "status": "added", "additions": 678, "deletions": 0, "changes": 678, "file_content_changes": "@@ -0,0 +1,678 @@\n+/*\n+    pybind11/attr.h: Infrastructure for processing custom\n+    type and function attributes\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+#include \"cast.h\"\n+\n+#include <functional>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+/// \\addtogroup annotations\n+/// @{\n+\n+/// Annotation for methods\n+struct is_method {\n+    handle class_;\n+    explicit is_method(const handle &c) : class_(c) {}\n+};\n+\n+/// Annotation for operators\n+struct is_operator {};\n+\n+/// Annotation for classes that cannot be subclassed\n+struct is_final {};\n+\n+/// Annotation for parent scope\n+struct scope {\n+    handle value;\n+    explicit scope(const handle &s) : value(s) {}\n+};\n+\n+/// Annotation for documentation\n+struct doc {\n+    const char *value;\n+    explicit doc(const char *value) : value(value) {}\n+};\n+\n+/// Annotation for function names\n+struct name {\n+    const char *value;\n+    explicit name(const char *value) : value(value) {}\n+};\n+\n+/// Annotation indicating that a function is an overload associated with a given \"sibling\"\n+struct sibling {\n+    handle value;\n+    explicit sibling(const handle &value) : value(value.ptr()) {}\n+};\n+\n+/// Annotation indicating that a class derives from another given type\n+template <typename T>\n+struct base {\n+\n+    PYBIND11_DEPRECATED(\n+        \"base<T>() was deprecated in favor of specifying 'T' as a template argument to class_\")\n+    base() = default;\n+};\n+\n+/// Keep patient alive while nurse lives\n+template <size_t Nurse, size_t Patient>\n+struct keep_alive {};\n+\n+/// Annotation indicating that a class is involved in a multiple inheritance relationship\n+struct multiple_inheritance {};\n+\n+/// Annotation which enables dynamic attributes, i.e. adds `__dict__` to a class\n+struct dynamic_attr {};\n+\n+/// Annotation which enables the buffer protocol for a type\n+struct buffer_protocol {};\n+\n+/// Annotation which requests that a special metaclass is created for a type\n+struct metaclass {\n+    handle value;\n+\n+    PYBIND11_DEPRECATED(\"py::metaclass() is no longer required. It's turned on by default now.\")\n+    metaclass() = default;\n+\n+    /// Override pybind11's default metaclass\n+    explicit metaclass(handle value) : value(value) {}\n+};\n+\n+/// Specifies a custom callback with signature `void (PyHeapTypeObject*)` that\n+/// may be used to customize the Python type.\n+///\n+/// The callback is invoked immediately before `PyType_Ready`.\n+///\n+/// Note: This is an advanced interface, and uses of it may require changes to\n+/// work with later versions of pybind11.  You may wish to consult the\n+/// implementation of `make_new_python_type` in `detail/classes.h` to understand\n+/// the context in which the callback will be run.\n+struct custom_type_setup {\n+    using callback = std::function<void(PyHeapTypeObject *heap_type)>;\n+\n+    explicit custom_type_setup(callback value) : value(std::move(value)) {}\n+\n+    callback value;\n+};\n+\n+/// Annotation that marks a class as local to the module:\n+struct module_local {\n+    const bool value;\n+    constexpr explicit module_local(bool v = true) : value(v) {}\n+};\n+\n+/// Annotation to mark enums as an arithmetic type\n+struct arithmetic {};\n+\n+/// Mark a function for addition at the beginning of the existing overload chain instead of the end\n+struct prepend {};\n+\n+/** \\rst\n+    A call policy which places one or more guard variables (``Ts...``) around the function call.\n+\n+    For example, this definition:\n+\n+    .. code-block:: cpp\n+\n+        m.def(\"foo\", foo, py::call_guard<T>());\n+\n+    is equivalent to the following pseudocode:\n+\n+    .. code-block:: cpp\n+\n+        m.def(\"foo\", [](args...) {\n+            T scope_guard;\n+            return foo(args...); // forwarded arguments\n+        });\n+ \\endrst */\n+template <typename... Ts>\n+struct call_guard;\n+\n+template <>\n+struct call_guard<> {\n+    using type = detail::void_type;\n+};\n+\n+template <typename T>\n+struct call_guard<T> {\n+    static_assert(std::is_default_constructible<T>::value,\n+                  \"The guard type must be default constructible\");\n+\n+    using type = T;\n+};\n+\n+template <typename T, typename... Ts>\n+struct call_guard<T, Ts...> {\n+    struct type {\n+        T guard{}; // Compose multiple guard types with left-to-right default-constructor order\n+        typename call_guard<Ts...>::type next{};\n+    };\n+};\n+\n+/// @} annotations\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+/* Forward declarations */\n+enum op_id : int;\n+enum op_type : int;\n+struct undefined_t;\n+template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t>\n+struct op_;\n+void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);\n+\n+/// Internal data structure which holds metadata about a keyword argument\n+struct argument_record {\n+    const char *name;  ///< Argument name\n+    const char *descr; ///< Human-readable version of the argument value\n+    handle value;      ///< Associated Python object\n+    bool convert : 1;  ///< True if the argument is allowed to convert when loading\n+    bool none : 1;     ///< True if None is allowed when loading\n+\n+    argument_record(const char *name, const char *descr, handle value, bool convert, bool none)\n+        : name(name), descr(descr), value(value), convert(convert), none(none) {}\n+};\n+\n+/// Internal data structure which holds metadata about a bound function (signature, overloads,\n+/// etc.)\n+struct function_record {\n+    function_record()\n+        : is_constructor(false), is_new_style_constructor(false), is_stateless(false),\n+          is_operator(false), is_method(false), has_args(false), has_kwargs(false),\n+          prepend(false) {}\n+\n+    /// Function name\n+    char *name = nullptr; /* why no C++ strings? They generate heavier code.. */\n+\n+    // User-specified documentation string\n+    char *doc = nullptr;\n+\n+    /// Human-readable version of the function signature\n+    char *signature = nullptr;\n+\n+    /// List of registered keyword arguments\n+    std::vector<argument_record> args;\n+\n+    /// Pointer to lambda function which converts arguments and performs the actual call\n+    handle (*impl)(function_call &) = nullptr;\n+\n+    /// Storage for the wrapped function pointer and captured data, if any\n+    void *data[3] = {};\n+\n+    /// Pointer to custom destructor for 'data' (if needed)\n+    void (*free_data)(function_record *ptr) = nullptr;\n+\n+    /// Return value policy associated with this function\n+    return_value_policy policy = return_value_policy::automatic;\n+\n+    /// True if name == '__init__'\n+    bool is_constructor : 1;\n+\n+    /// True if this is a new-style `__init__` defined in `detail/init.h`\n+    bool is_new_style_constructor : 1;\n+\n+    /// True if this is a stateless function pointer\n+    bool is_stateless : 1;\n+\n+    /// True if this is an operator (__add__), etc.\n+    bool is_operator : 1;\n+\n+    /// True if this is a method\n+    bool is_method : 1;\n+\n+    /// True if the function has a '*args' argument\n+    bool has_args : 1;\n+\n+    /// True if the function has a '**kwargs' argument\n+    bool has_kwargs : 1;\n+\n+    /// True if this function is to be inserted at the beginning of the overload resolution chain\n+    bool prepend : 1;\n+\n+    /// Number of arguments (including py::args and/or py::kwargs, if present)\n+    std::uint16_t nargs;\n+\n+    /// Number of leading positional arguments, which are terminated by a py::args or py::kwargs\n+    /// argument or by a py::kw_only annotation.\n+    std::uint16_t nargs_pos = 0;\n+\n+    /// Number of leading arguments (counted in `nargs`) that are positional-only\n+    std::uint16_t nargs_pos_only = 0;\n+\n+    /// Python method object\n+    PyMethodDef *def = nullptr;\n+\n+    /// Python handle to the parent scope (a class or a module)\n+    handle scope;\n+\n+    /// Python handle to the sibling function representing an overload chain\n+    handle sibling;\n+\n+    /// Pointer to next overload\n+    function_record *next = nullptr;\n+};\n+\n+/// Special data structure which (temporarily) holds metadata about a bound class\n+struct type_record {\n+    PYBIND11_NOINLINE type_record()\n+        : multiple_inheritance(false), dynamic_attr(false), buffer_protocol(false),\n+          default_holder(true), module_local(false), is_final(false) {}\n+\n+    /// Handle to the parent scope\n+    handle scope;\n+\n+    /// Name of the class\n+    const char *name = nullptr;\n+\n+    // Pointer to RTTI type_info data structure\n+    const std::type_info *type = nullptr;\n+\n+    /// How large is the underlying C++ type?\n+    size_t type_size = 0;\n+\n+    /// What is the alignment of the underlying C++ type?\n+    size_t type_align = 0;\n+\n+    /// How large is the type's holder?\n+    size_t holder_size = 0;\n+\n+    /// The global operator new can be overridden with a class-specific variant\n+    void *(*operator_new)(size_t) = nullptr;\n+\n+    /// Function pointer to class_<..>::init_instance\n+    void (*init_instance)(instance *, const void *) = nullptr;\n+\n+    /// Function pointer to class_<..>::dealloc\n+    void (*dealloc)(detail::value_and_holder &) = nullptr;\n+\n+    /// List of base classes of the newly created type\n+    list bases;\n+\n+    /// Optional docstring\n+    const char *doc = nullptr;\n+\n+    /// Custom metaclass (optional)\n+    handle metaclass;\n+\n+    /// Custom type setup.\n+    custom_type_setup::callback custom_type_setup_callback;\n+\n+    /// Multiple inheritance marker\n+    bool multiple_inheritance : 1;\n+\n+    /// Does the class manage a __dict__?\n+    bool dynamic_attr : 1;\n+\n+    /// Does the class implement the buffer protocol?\n+    bool buffer_protocol : 1;\n+\n+    /// Is the default (unique_ptr) holder type used?\n+    bool default_holder : 1;\n+\n+    /// Is the class definition local to the module shared object?\n+    bool module_local : 1;\n+\n+    /// Is the class inheritable from python classes?\n+    bool is_final : 1;\n+\n+    PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *) ) {\n+        auto *base_info = detail::get_type_info(base, false);\n+        if (!base_info) {\n+            std::string tname(base.name());\n+            detail::clean_type_id(tname);\n+            pybind11_fail(\"generic_type: type \\\"\" + std::string(name)\n+                          + \"\\\" referenced unknown base type \\\"\" + tname + \"\\\"\");\n+        }\n+\n+        if (default_holder != base_info->default_holder) {\n+            std::string tname(base.name());\n+            detail::clean_type_id(tname);\n+            pybind11_fail(\"generic_type: type \\\"\" + std::string(name) + \"\\\" \"\n+                          + (default_holder ? \"does not have\" : \"has\")\n+                          + \" a non-default holder type while its base \\\"\" + tname + \"\\\" \"\n+                          + (base_info->default_holder ? \"does not\" : \"does\"));\n+        }\n+\n+        bases.append((PyObject *) base_info->type);\n+\n+#if PY_VERSION_HEX < 0x030B0000\n+        dynamic_attr |= base_info->type->tp_dictoffset != 0;\n+#else\n+        dynamic_attr |= (base_info->type->tp_flags & Py_TPFLAGS_MANAGED_DICT) != 0;\n+#endif\n+\n+        if (caster) {\n+            base_info->implicit_casts.emplace_back(type, caster);\n+        }\n+    }\n+};\n+\n+inline function_call::function_call(const function_record &f, handle p) : func(f), parent(p) {\n+    args.reserve(f.nargs);\n+    args_convert.reserve(f.nargs);\n+}\n+\n+/// Tag for a new-style `__init__` defined in `detail/init.h`\n+struct is_new_style_constructor {};\n+\n+/**\n+ * Partial template specializations to process custom attributes provided to\n+ * cpp_function_ and class_. These are either used to initialize the respective\n+ * fields in the type_record and function_record data structures or executed at\n+ * runtime to deal with custom call policies (e.g. keep_alive).\n+ */\n+template <typename T, typename SFINAE = void>\n+struct process_attribute;\n+\n+template <typename T>\n+struct process_attribute_default {\n+    /// Default implementation: do nothing\n+    static void init(const T &, function_record *) {}\n+    static void init(const T &, type_record *) {}\n+    static void precall(function_call &) {}\n+    static void postcall(function_call &, handle) {}\n+};\n+\n+/// Process an attribute specifying the function's name\n+template <>\n+struct process_attribute<name> : process_attribute_default<name> {\n+    static void init(const name &n, function_record *r) { r->name = const_cast<char *>(n.value); }\n+};\n+\n+/// Process an attribute specifying the function's docstring\n+template <>\n+struct process_attribute<doc> : process_attribute_default<doc> {\n+    static void init(const doc &n, function_record *r) { r->doc = const_cast<char *>(n.value); }\n+};\n+\n+/// Process an attribute specifying the function's docstring (provided as a C-style string)\n+template <>\n+struct process_attribute<const char *> : process_attribute_default<const char *> {\n+    static void init(const char *d, function_record *r) { r->doc = const_cast<char *>(d); }\n+    static void init(const char *d, type_record *r) { r->doc = const_cast<char *>(d); }\n+};\n+template <>\n+struct process_attribute<char *> : process_attribute<const char *> {};\n+\n+/// Process an attribute indicating the function's return value policy\n+template <>\n+struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {\n+    static void init(const return_value_policy &p, function_record *r) { r->policy = p; }\n+};\n+\n+/// Process an attribute which indicates that this is an overloaded function associated with a\n+/// given sibling\n+template <>\n+struct process_attribute<sibling> : process_attribute_default<sibling> {\n+    static void init(const sibling &s, function_record *r) { r->sibling = s.value; }\n+};\n+\n+/// Process an attribute which indicates that this function is a method\n+template <>\n+struct process_attribute<is_method> : process_attribute_default<is_method> {\n+    static void init(const is_method &s, function_record *r) {\n+        r->is_method = true;\n+        r->scope = s.class_;\n+    }\n+};\n+\n+/// Process an attribute which indicates the parent scope of a method\n+template <>\n+struct process_attribute<scope> : process_attribute_default<scope> {\n+    static void init(const scope &s, function_record *r) { r->scope = s.value; }\n+};\n+\n+/// Process an attribute which indicates that this function is an operator\n+template <>\n+struct process_attribute<is_operator> : process_attribute_default<is_operator> {\n+    static void init(const is_operator &, function_record *r) { r->is_operator = true; }\n+};\n+\n+template <>\n+struct process_attribute<is_new_style_constructor>\n+    : process_attribute_default<is_new_style_constructor> {\n+    static void init(const is_new_style_constructor &, function_record *r) {\n+        r->is_new_style_constructor = true;\n+    }\n+};\n+\n+inline void check_kw_only_arg(const arg &a, function_record *r) {\n+    if (r->args.size() > r->nargs_pos && (!a.name || a.name[0] == '\\0')) {\n+        pybind11_fail(\"arg(): cannot specify an unnamed argument after a kw_only() annotation or \"\n+                      \"args() argument\");\n+    }\n+}\n+\n+inline void append_self_arg_if_needed(function_record *r) {\n+    if (r->is_method && r->args.empty()) {\n+        r->args.emplace_back(\"self\", nullptr, handle(), /*convert=*/true, /*none=*/false);\n+    }\n+}\n+\n+/// Process a keyword argument attribute (*without* a default value)\n+template <>\n+struct process_attribute<arg> : process_attribute_default<arg> {\n+    static void init(const arg &a, function_record *r) {\n+        append_self_arg_if_needed(r);\n+        r->args.emplace_back(a.name, nullptr, handle(), !a.flag_noconvert, a.flag_none);\n+\n+        check_kw_only_arg(a, r);\n+    }\n+};\n+\n+/// Process a keyword argument attribute (*with* a default value)\n+template <>\n+struct process_attribute<arg_v> : process_attribute_default<arg_v> {\n+    static void init(const arg_v &a, function_record *r) {\n+        if (r->is_method && r->args.empty()) {\n+            r->args.emplace_back(\n+                \"self\", /*descr=*/nullptr, /*parent=*/handle(), /*convert=*/true, /*none=*/false);\n+        }\n+\n+        if (!a.value) {\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            std::string descr(\"'\");\n+            if (a.name) {\n+                descr += std::string(a.name) + \": \";\n+            }\n+            descr += a.type + \"'\";\n+            if (r->is_method) {\n+                if (r->name) {\n+                    descr += \" in method '\" + (std::string) str(r->scope) + \".\"\n+                             + (std::string) r->name + \"'\";\n+                } else {\n+                    descr += \" in method of '\" + (std::string) str(r->scope) + \"'\";\n+                }\n+            } else if (r->name) {\n+                descr += \" in function '\" + (std::string) r->name + \"'\";\n+            }\n+            pybind11_fail(\"arg(): could not convert default argument \" + descr\n+                          + \" into a Python object (type not registered yet?)\");\n+#else\n+            pybind11_fail(\"arg(): could not convert default argument \"\n+                          \"into a Python object (type not registered yet?). \"\n+                          \"#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for \"\n+                          \"more information.\");\n+#endif\n+        }\n+        r->args.emplace_back(a.name, a.descr, a.value.inc_ref(), !a.flag_noconvert, a.flag_none);\n+\n+        check_kw_only_arg(a, r);\n+    }\n+};\n+\n+/// Process a keyword-only-arguments-follow pseudo argument\n+template <>\n+struct process_attribute<kw_only> : process_attribute_default<kw_only> {\n+    static void init(const kw_only &, function_record *r) {\n+        append_self_arg_if_needed(r);\n+        if (r->has_args && r->nargs_pos != static_cast<std::uint16_t>(r->args.size())) {\n+            pybind11_fail(\"Mismatched args() and kw_only(): they must occur at the same relative \"\n+                          \"argument location (or omit kw_only() entirely)\");\n+        }\n+        r->nargs_pos = static_cast<std::uint16_t>(r->args.size());\n+    }\n+};\n+\n+/// Process a positional-only-argument maker\n+template <>\n+struct process_attribute<pos_only> : process_attribute_default<pos_only> {\n+    static void init(const pos_only &, function_record *r) {\n+        append_self_arg_if_needed(r);\n+        r->nargs_pos_only = static_cast<std::uint16_t>(r->args.size());\n+        if (r->nargs_pos_only > r->nargs_pos) {\n+            pybind11_fail(\"pos_only(): cannot follow a py::args() argument\");\n+        }\n+        // It also can't follow a kw_only, but a static_assert in pybind11.h checks that\n+    }\n+};\n+\n+/// Process a parent class attribute.  Single inheritance only (class_ itself already guarantees\n+/// that)\n+template <typename T>\n+struct process_attribute<T, enable_if_t<is_pyobject<T>::value>>\n+    : process_attribute_default<handle> {\n+    static void init(const handle &h, type_record *r) { r->bases.append(h); }\n+};\n+\n+/// Process a parent class attribute (deprecated, does not support multiple inheritance)\n+template <typename T>\n+struct process_attribute<base<T>> : process_attribute_default<base<T>> {\n+    static void init(const base<T> &, type_record *r) { r->add_base(typeid(T), nullptr); }\n+};\n+\n+/// Process a multiple inheritance attribute\n+template <>\n+struct process_attribute<multiple_inheritance> : process_attribute_default<multiple_inheritance> {\n+    static void init(const multiple_inheritance &, type_record *r) {\n+        r->multiple_inheritance = true;\n+    }\n+};\n+\n+template <>\n+struct process_attribute<dynamic_attr> : process_attribute_default<dynamic_attr> {\n+    static void init(const dynamic_attr &, type_record *r) { r->dynamic_attr = true; }\n+};\n+\n+template <>\n+struct process_attribute<custom_type_setup> {\n+    static void init(const custom_type_setup &value, type_record *r) {\n+        r->custom_type_setup_callback = value.value;\n+    }\n+};\n+\n+template <>\n+struct process_attribute<is_final> : process_attribute_default<is_final> {\n+    static void init(const is_final &, type_record *r) { r->is_final = true; }\n+};\n+\n+template <>\n+struct process_attribute<buffer_protocol> : process_attribute_default<buffer_protocol> {\n+    static void init(const buffer_protocol &, type_record *r) { r->buffer_protocol = true; }\n+};\n+\n+template <>\n+struct process_attribute<metaclass> : process_attribute_default<metaclass> {\n+    static void init(const metaclass &m, type_record *r) { r->metaclass = m.value; }\n+};\n+\n+template <>\n+struct process_attribute<module_local> : process_attribute_default<module_local> {\n+    static void init(const module_local &l, type_record *r) { r->module_local = l.value; }\n+};\n+\n+/// Process a 'prepend' attribute, putting this at the beginning of the overload chain\n+template <>\n+struct process_attribute<prepend> : process_attribute_default<prepend> {\n+    static void init(const prepend &, function_record *r) { r->prepend = true; }\n+};\n+\n+/// Process an 'arithmetic' attribute for enums (does nothing here)\n+template <>\n+struct process_attribute<arithmetic> : process_attribute_default<arithmetic> {};\n+\n+template <typename... Ts>\n+struct process_attribute<call_guard<Ts...>> : process_attribute_default<call_guard<Ts...>> {};\n+\n+/**\n+ * Process a keep_alive call policy -- invokes keep_alive_impl during the\n+ * pre-call handler if both Nurse, Patient != 0 and use the post-call handler\n+ * otherwise\n+ */\n+template <size_t Nurse, size_t Patient>\n+struct process_attribute<keep_alive<Nurse, Patient>>\n+    : public process_attribute_default<keep_alive<Nurse, Patient>> {\n+    template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>\n+    static void precall(function_call &call) {\n+        keep_alive_impl(Nurse, Patient, call, handle());\n+    }\n+    template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>\n+    static void postcall(function_call &, handle) {}\n+    template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>\n+    static void precall(function_call &) {}\n+    template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>\n+    static void postcall(function_call &call, handle ret) {\n+        keep_alive_impl(Nurse, Patient, call, ret);\n+    }\n+};\n+\n+/// Recursively iterate over variadic template arguments\n+template <typename... Args>\n+struct process_attributes {\n+    static void init(const Args &...args, function_record *r) {\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(r);\n+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(r);\n+        using expander = int[];\n+        (void) expander{\n+            0, ((void) process_attribute<typename std::decay<Args>::type>::init(args, r), 0)...};\n+    }\n+    static void init(const Args &...args, type_record *r) {\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(r);\n+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(r);\n+        using expander = int[];\n+        (void) expander{0,\n+                        (process_attribute<typename std::decay<Args>::type>::init(args, r), 0)...};\n+    }\n+    static void precall(function_call &call) {\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(call);\n+        using expander = int[];\n+        (void) expander{0,\n+                        (process_attribute<typename std::decay<Args>::type>::precall(call), 0)...};\n+    }\n+    static void postcall(function_call &call, handle fn_ret) {\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(call, fn_ret);\n+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(fn_ret);\n+        using expander = int[];\n+        (void) expander{\n+            0, (process_attribute<typename std::decay<Args>::type>::postcall(call, fn_ret), 0)...};\n+    }\n+};\n+\n+template <typename T>\n+using is_call_guard = is_instantiation<call_guard, T>;\n+\n+/// Extract the ``type`` from the first `call_guard` in `Extras...` (or `void_type` if none found)\n+template <typename... Extra>\n+using extract_guard_t = typename exactly_one_t<is_call_guard, call_guard<>, Extra...>::type;\n+\n+/// Check the number of named arguments at compile time\n+template <typename... Extra,\n+          size_t named = constexpr_sum(std::is_base_of<arg, Extra>::value...),\n+          size_t self = constexpr_sum(std::is_same<is_method, Extra>::value...)>\n+constexpr bool expected_num_args(size_t nargs, bool has_args, bool has_kwargs) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(nargs, has_args, has_kwargs);\n+    return named == 0 || (self + named + size_t(has_args) + size_t(has_kwargs)) == nargs;\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/buffer_info.h", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "file_content_changes": "@@ -0,0 +1,193 @@\n+/*\n+    pybind11/buffer_info.h: Python buffer object interface\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// Default, C-style strides\n+inline std::vector<ssize_t> c_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {\n+    auto ndim = shape.size();\n+    std::vector<ssize_t> strides(ndim, itemsize);\n+    if (ndim > 0) {\n+        for (size_t i = ndim - 1; i > 0; --i) {\n+            strides[i - 1] = strides[i] * shape[i];\n+        }\n+    }\n+    return strides;\n+}\n+\n+// F-style strides; default when constructing an array_t with `ExtraFlags & f_style`\n+inline std::vector<ssize_t> f_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {\n+    auto ndim = shape.size();\n+    std::vector<ssize_t> strides(ndim, itemsize);\n+    for (size_t i = 1; i < ndim; ++i) {\n+        strides[i] = strides[i - 1] * shape[i - 1];\n+    }\n+    return strides;\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+/// Information record describing a Python buffer object\n+struct buffer_info {\n+    void *ptr = nullptr;          // Pointer to the underlying storage\n+    ssize_t itemsize = 0;         // Size of individual items in bytes\n+    ssize_t size = 0;             // Total number of entries\n+    std::string format;           // For homogeneous buffers, this should be set to\n+                                  // format_descriptor<T>::format()\n+    ssize_t ndim = 0;             // Number of dimensions\n+    std::vector<ssize_t> shape;   // Shape of the tensor (1 entry per dimension)\n+    std::vector<ssize_t> strides; // Number of bytes between adjacent entries\n+                                  // (for each per dimension)\n+    bool readonly = false;        // flag to indicate if the underlying storage may be written to\n+\n+    buffer_info() = default;\n+\n+    buffer_info(void *ptr,\n+                ssize_t itemsize,\n+                const std::string &format,\n+                ssize_t ndim,\n+                detail::any_container<ssize_t> shape_in,\n+                detail::any_container<ssize_t> strides_in,\n+                bool readonly = false)\n+        : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),\n+          shape(std::move(shape_in)), strides(std::move(strides_in)), readonly(readonly) {\n+        if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size()) {\n+            pybind11_fail(\"buffer_info: ndim doesn't match shape and/or strides length\");\n+        }\n+        for (size_t i = 0; i < (size_t) ndim; ++i) {\n+            size *= shape[i];\n+        }\n+    }\n+\n+    template <typename T>\n+    buffer_info(T *ptr,\n+                detail::any_container<ssize_t> shape_in,\n+                detail::any_container<ssize_t> strides_in,\n+                bool readonly = false)\n+        : buffer_info(private_ctr_tag(),\n+                      ptr,\n+                      sizeof(T),\n+                      format_descriptor<T>::format(),\n+                      static_cast<ssize_t>(shape_in->size()),\n+                      std::move(shape_in),\n+                      std::move(strides_in),\n+                      readonly) {}\n+\n+    buffer_info(void *ptr,\n+                ssize_t itemsize,\n+                const std::string &format,\n+                ssize_t size,\n+                bool readonly = false)\n+        : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}, readonly) {}\n+\n+    template <typename T>\n+    buffer_info(T *ptr, ssize_t size, bool readonly = false)\n+        : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size, readonly) {}\n+\n+    template <typename T>\n+    buffer_info(const T *ptr, ssize_t size, bool readonly = true)\n+        : buffer_info(\n+            const_cast<T *>(ptr), sizeof(T), format_descriptor<T>::format(), size, readonly) {}\n+\n+    explicit buffer_info(Py_buffer *view, bool ownview = true)\n+        : buffer_info(\n+            view->buf,\n+            view->itemsize,\n+            view->format,\n+            view->ndim,\n+            {view->shape, view->shape + view->ndim},\n+            /* Though buffer::request() requests PyBUF_STRIDES, ctypes objects\n+             * ignore this flag and return a view with NULL strides.\n+             * When strides are NULL, build them manually.  */\n+            view->strides\n+                ? std::vector<ssize_t>(view->strides, view->strides + view->ndim)\n+                : detail::c_strides({view->shape, view->shape + view->ndim}, view->itemsize),\n+            (view->readonly != 0)) {\n+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)\n+        this->m_view = view;\n+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)\n+        this->ownview = ownview;\n+    }\n+\n+    buffer_info(const buffer_info &) = delete;\n+    buffer_info &operator=(const buffer_info &) = delete;\n+\n+    buffer_info(buffer_info &&other) noexcept { (*this) = std::move(other); }\n+\n+    buffer_info &operator=(buffer_info &&rhs) noexcept {\n+        ptr = rhs.ptr;\n+        itemsize = rhs.itemsize;\n+        size = rhs.size;\n+        format = std::move(rhs.format);\n+        ndim = rhs.ndim;\n+        shape = std::move(rhs.shape);\n+        strides = std::move(rhs.strides);\n+        std::swap(m_view, rhs.m_view);\n+        std::swap(ownview, rhs.ownview);\n+        readonly = rhs.readonly;\n+        return *this;\n+    }\n+\n+    ~buffer_info() {\n+        if (m_view && ownview) {\n+            PyBuffer_Release(m_view);\n+            delete m_view;\n+        }\n+    }\n+\n+    Py_buffer *view() const { return m_view; }\n+    Py_buffer *&view() { return m_view; }\n+\n+private:\n+    struct private_ctr_tag {};\n+\n+    buffer_info(private_ctr_tag,\n+                void *ptr,\n+                ssize_t itemsize,\n+                const std::string &format,\n+                ssize_t ndim,\n+                detail::any_container<ssize_t> &&shape_in,\n+                detail::any_container<ssize_t> &&strides_in,\n+                bool readonly)\n+        : buffer_info(\n+            ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in), readonly) {}\n+\n+    Py_buffer *m_view = nullptr;\n+    bool ownview = false;\n+};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+template <typename T, typename SFINAE = void>\n+struct compare_buffer_info {\n+    static bool compare(const buffer_info &b) {\n+        return b.format == format_descriptor<T>::format() && b.itemsize == (ssize_t) sizeof(T);\n+    }\n+};\n+\n+template <typename T>\n+struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {\n+    static bool compare(const buffer_info &b) {\n+        return (size_t) b.itemsize == sizeof(T)\n+               && (b.format == format_descriptor<T>::value\n+                   || ((sizeof(T) == sizeof(long))\n+                       && b.format == (std::is_unsigned<T>::value ? \"L\" : \"l\"))\n+                   || ((sizeof(T) == sizeof(size_t))\n+                       && b.format == (std::is_unsigned<T>::value ? \"N\" : \"n\")));\n+    }\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/cast.h", "status": "added", "additions": 1665, "deletions": 0, "changes": 1665, "file_content_changes": "@@ -0,0 +1,1665 @@\n+/*\n+    pybind11/cast.h: Partial template specializations to cast between\n+    C++ and Python types\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+#include \"detail/descr.h\"\n+#include \"detail/type_caster_base.h\"\n+#include \"detail/typeid.h\"\n+#include \"pytypes.h\"\n+\n+#include <array>\n+#include <cstring>\n+#include <functional>\n+#include <iosfwd>\n+#include <iterator>\n+#include <memory>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+template <typename type, typename SFINAE = void>\n+class type_caster : public type_caster_base<type> {};\n+template <typename type>\n+using make_caster = type_caster<intrinsic_t<type>>;\n+\n+// Shortcut for calling a caster's `cast_op_type` cast operator for casting a type_caster to a T\n+template <typename T>\n+typename make_caster<T>::template cast_op_type<T> cast_op(make_caster<T> &caster) {\n+    return caster.operator typename make_caster<T>::template cast_op_type<T>();\n+}\n+template <typename T>\n+typename make_caster<T>::template cast_op_type<typename std::add_rvalue_reference<T>::type>\n+cast_op(make_caster<T> &&caster) {\n+    return std::move(caster).operator typename make_caster<T>::\n+        template cast_op_type<typename std::add_rvalue_reference<T>::type>();\n+}\n+\n+template <typename type>\n+class type_caster<std::reference_wrapper<type>> {\n+private:\n+    using caster_t = make_caster<type>;\n+    caster_t subcaster;\n+    using reference_t = type &;\n+    using subcaster_cast_op_type = typename caster_t::template cast_op_type<reference_t>;\n+\n+    static_assert(\n+        std::is_same<typename std::remove_const<type>::type &, subcaster_cast_op_type>::value\n+            || std::is_same<reference_t, subcaster_cast_op_type>::value,\n+        \"std::reference_wrapper<T> caster requires T to have a caster with an \"\n+        \"`operator T &()` or `operator const T &()`\");\n+\n+public:\n+    bool load(handle src, bool convert) { return subcaster.load(src, convert); }\n+    static constexpr auto name = caster_t::name;\n+    static handle\n+    cast(const std::reference_wrapper<type> &src, return_value_policy policy, handle parent) {\n+        // It is definitely wrong to take ownership of this pointer, so mask that rvp\n+        if (policy == return_value_policy::take_ownership\n+            || policy == return_value_policy::automatic) {\n+            policy = return_value_policy::automatic_reference;\n+        }\n+        return caster_t::cast(&src.get(), policy, parent);\n+    }\n+    template <typename T>\n+    using cast_op_type = std::reference_wrapper<type>;\n+    explicit operator std::reference_wrapper<type>() { return cast_op<type &>(subcaster); }\n+};\n+\n+#define PYBIND11_TYPE_CASTER(type, py_name)                                                       \\\n+protected:                                                                                        \\\n+    type value;                                                                                   \\\n+                                                                                                  \\\n+public:                                                                                           \\\n+    static constexpr auto name = py_name;                                                         \\\n+    template <typename T_,                                                                        \\\n+              ::pybind11::detail::enable_if_t<                                                    \\\n+                  std::is_same<type, ::pybind11::detail::remove_cv_t<T_>>::value,                 \\\n+                  int> = 0>                                                                       \\\n+    static ::pybind11::handle cast(                                                               \\\n+        T_ *src, ::pybind11::return_value_policy policy, ::pybind11::handle parent) {             \\\n+        if (!src)                                                                                 \\\n+            return ::pybind11::none().release();                                                  \\\n+        if (policy == ::pybind11::return_value_policy::take_ownership) {                          \\\n+            auto h = cast(std::move(*src), policy, parent);                                       \\\n+            delete src;                                                                           \\\n+            return h;                                                                             \\\n+        }                                                                                         \\\n+        return cast(*src, policy, parent);                                                        \\\n+    }                                                                                             \\\n+    operator type *() { return &value; }               /* NOLINT(bugprone-macro-parentheses) */   \\\n+    operator type &() { return value; }                /* NOLINT(bugprone-macro-parentheses) */   \\\n+    operator type &&() && { return std::move(value); } /* NOLINT(bugprone-macro-parentheses) */   \\\n+    template <typename T_>                                                                        \\\n+    using cast_op_type = ::pybind11::detail::movable_cast_op_type<T_>\n+\n+template <typename CharT>\n+using is_std_char_type = any_of<std::is_same<CharT, char>, /* std::string */\n+#if defined(PYBIND11_HAS_U8STRING)\n+                                std::is_same<CharT, char8_t>, /* std::u8string */\n+#endif\n+                                std::is_same<CharT, char16_t>, /* std::u16string */\n+                                std::is_same<CharT, char32_t>, /* std::u32string */\n+                                std::is_same<CharT, wchar_t>   /* std::wstring */\n+                                >;\n+\n+template <typename T>\n+struct type_caster<T, enable_if_t<std::is_arithmetic<T>::value && !is_std_char_type<T>::value>> {\n+    using _py_type_0 = conditional_t<sizeof(T) <= sizeof(long), long, long long>;\n+    using _py_type_1 = conditional_t<std::is_signed<T>::value,\n+                                     _py_type_0,\n+                                     typename std::make_unsigned<_py_type_0>::type>;\n+    using py_type = conditional_t<std::is_floating_point<T>::value, double, _py_type_1>;\n+\n+public:\n+    bool load(handle src, bool convert) {\n+        py_type py_value;\n+\n+        if (!src) {\n+            return false;\n+        }\n+\n+#if !defined(PYPY_VERSION)\n+        auto index_check = [](PyObject *o) { return PyIndex_Check(o); };\n+#else\n+        // In PyPy 7.3.3, `PyIndex_Check` is implemented by calling `__index__`,\n+        // while CPython only considers the existence of `nb_index`/`__index__`.\n+        auto index_check = [](PyObject *o) { return hasattr(o, \"__index__\"); };\n+#endif\n+\n+        if (std::is_floating_point<T>::value) {\n+            if (convert || PyFloat_Check(src.ptr())) {\n+                py_value = (py_type) PyFloat_AsDouble(src.ptr());\n+            } else {\n+                return false;\n+            }\n+        } else if (PyFloat_Check(src.ptr())\n+                   || (!convert && !PYBIND11_LONG_CHECK(src.ptr()) && !index_check(src.ptr()))) {\n+            return false;\n+        } else {\n+            handle src_or_index = src;\n+            // PyPy: 7.3.7's 3.8 does not implement PyLong_*'s __index__ calls.\n+#if PY_VERSION_HEX < 0x03080000 || defined(PYPY_VERSION)\n+            object index;\n+            if (!PYBIND11_LONG_CHECK(src.ptr())) { // So: index_check(src.ptr())\n+                index = reinterpret_steal<object>(PyNumber_Index(src.ptr()));\n+                if (!index) {\n+                    PyErr_Clear();\n+                    if (!convert)\n+                        return false;\n+                } else {\n+                    src_or_index = index;\n+                }\n+            }\n+#endif\n+            if (std::is_unsigned<py_type>::value) {\n+                py_value = as_unsigned<py_type>(src_or_index.ptr());\n+            } else { // signed integer:\n+                py_value = sizeof(T) <= sizeof(long)\n+                               ? (py_type) PyLong_AsLong(src_or_index.ptr())\n+                               : (py_type) PYBIND11_LONG_AS_LONGLONG(src_or_index.ptr());\n+            }\n+        }\n+\n+        // Python API reported an error\n+        bool py_err = py_value == (py_type) -1 && PyErr_Occurred();\n+\n+        // Check to see if the conversion is valid (integers should match exactly)\n+        // Signed/unsigned checks happen elsewhere\n+        if (py_err\n+            || (std::is_integral<T>::value && sizeof(py_type) != sizeof(T)\n+                && py_value != (py_type) (T) py_value)) {\n+            PyErr_Clear();\n+            if (py_err && convert && (PyNumber_Check(src.ptr()) != 0)) {\n+                auto tmp = reinterpret_steal<object>(std::is_floating_point<T>::value\n+                                                         ? PyNumber_Float(src.ptr())\n+                                                         : PyNumber_Long(src.ptr()));\n+                PyErr_Clear();\n+                return load(tmp, false);\n+            }\n+            return false;\n+        }\n+\n+        value = (T) py_value;\n+        return true;\n+    }\n+\n+    template <typename U = T>\n+    static typename std::enable_if<std::is_floating_point<U>::value, handle>::type\n+    cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+        return PyFloat_FromDouble((double) src);\n+    }\n+\n+    template <typename U = T>\n+    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_signed<U>::value\n+                                       && (sizeof(U) <= sizeof(long)),\n+                                   handle>::type\n+    cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+        return PYBIND11_LONG_FROM_SIGNED((long) src);\n+    }\n+\n+    template <typename U = T>\n+    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_unsigned<U>::value\n+                                       && (sizeof(U) <= sizeof(unsigned long)),\n+                                   handle>::type\n+    cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+        return PYBIND11_LONG_FROM_UNSIGNED((unsigned long) src);\n+    }\n+\n+    template <typename U = T>\n+    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_signed<U>::value\n+                                       && (sizeof(U) > sizeof(long)),\n+                                   handle>::type\n+    cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+        return PyLong_FromLongLong((long long) src);\n+    }\n+\n+    template <typename U = T>\n+    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_unsigned<U>::value\n+                                       && (sizeof(U) > sizeof(unsigned long)),\n+                                   handle>::type\n+    cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+        return PyLong_FromUnsignedLongLong((unsigned long long) src);\n+    }\n+\n+    PYBIND11_TYPE_CASTER(T, const_name<std::is_integral<T>::value>(\"int\", \"float\"));\n+};\n+\n+template <typename T>\n+struct void_caster {\n+public:\n+    bool load(handle src, bool) {\n+        if (src && src.is_none()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+    static handle cast(T, return_value_policy /* policy */, handle /* parent */) {\n+        return none().inc_ref();\n+    }\n+    PYBIND11_TYPE_CASTER(T, const_name(\"None\"));\n+};\n+\n+template <>\n+class type_caster<void_type> : public void_caster<void_type> {};\n+\n+template <>\n+class type_caster<void> : public type_caster<void_type> {\n+public:\n+    using type_caster<void_type>::cast;\n+\n+    bool load(handle h, bool) {\n+        if (!h) {\n+            return false;\n+        }\n+        if (h.is_none()) {\n+            value = nullptr;\n+            return true;\n+        }\n+\n+        /* Check if this is a capsule */\n+        if (isinstance<capsule>(h)) {\n+            value = reinterpret_borrow<capsule>(h);\n+            return true;\n+        }\n+\n+        /* Check if this is a C++ type */\n+        const auto &bases = all_type_info((PyTypeObject *) type::handle_of(h).ptr());\n+        if (bases.size() == 1) { // Only allowing loading from a single-value type\n+            value = values_and_holders(reinterpret_cast<instance *>(h.ptr())).begin()->value_ptr();\n+            return true;\n+        }\n+\n+        /* Fail */\n+        return false;\n+    }\n+\n+    static handle cast(const void *ptr, return_value_policy /* policy */, handle /* parent */) {\n+        if (ptr) {\n+            return capsule(ptr).release();\n+        }\n+        return none().inc_ref();\n+    }\n+\n+    template <typename T>\n+    using cast_op_type = void *&;\n+    explicit operator void *&() { return value; }\n+    static constexpr auto name = const_name(\"capsule\");\n+\n+private:\n+    void *value = nullptr;\n+};\n+\n+template <>\n+class type_caster<std::nullptr_t> : public void_caster<std::nullptr_t> {};\n+\n+template <>\n+class type_caster<bool> {\n+public:\n+    bool load(handle src, bool convert) {\n+        if (!src) {\n+            return false;\n+        }\n+        if (src.ptr() == Py_True) {\n+            value = true;\n+            return true;\n+        }\n+        if (src.ptr() == Py_False) {\n+            value = false;\n+            return true;\n+        }\n+        if (convert || (std::strcmp(\"numpy.bool_\", Py_TYPE(src.ptr())->tp_name) == 0)) {\n+            // (allow non-implicit conversion for numpy booleans)\n+\n+            Py_ssize_t res = -1;\n+            if (src.is_none()) {\n+                res = 0; // None is implicitly converted to False\n+            }\n+#if defined(PYPY_VERSION)\n+            // On PyPy, check that \"__bool__\" attr exists\n+            else if (hasattr(src, PYBIND11_BOOL_ATTR)) {\n+                res = PyObject_IsTrue(src.ptr());\n+            }\n+#else\n+            // Alternate approach for CPython: this does the same as the above, but optimized\n+            // using the CPython API so as to avoid an unneeded attribute lookup.\n+            else if (auto *tp_as_number = src.ptr()->ob_type->tp_as_number) {\n+                if (PYBIND11_NB_BOOL(tp_as_number)) {\n+                    res = (*PYBIND11_NB_BOOL(tp_as_number))(src.ptr());\n+                }\n+            }\n+#endif\n+            if (res == 0 || res == 1) {\n+                value = (res != 0);\n+                return true;\n+            }\n+            PyErr_Clear();\n+        }\n+        return false;\n+    }\n+    static handle cast(bool src, return_value_policy /* policy */, handle /* parent */) {\n+        return handle(src ? Py_True : Py_False).inc_ref();\n+    }\n+    PYBIND11_TYPE_CASTER(bool, const_name(\"bool\"));\n+};\n+\n+// Helper class for UTF-{8,16,32} C++ stl strings:\n+template <typename StringType, bool IsView = false>\n+struct string_caster {\n+    using CharT = typename StringType::value_type;\n+\n+    // Simplify life by being able to assume standard char sizes (the standard only guarantees\n+    // minimums, but Python requires exact sizes)\n+    static_assert(!std::is_same<CharT, char>::value || sizeof(CharT) == 1,\n+                  \"Unsupported char size != 1\");\n+#if defined(PYBIND11_HAS_U8STRING)\n+    static_assert(!std::is_same<CharT, char8_t>::value || sizeof(CharT) == 1,\n+                  \"Unsupported char8_t size != 1\");\n+#endif\n+    static_assert(!std::is_same<CharT, char16_t>::value || sizeof(CharT) == 2,\n+                  \"Unsupported char16_t size != 2\");\n+    static_assert(!std::is_same<CharT, char32_t>::value || sizeof(CharT) == 4,\n+                  \"Unsupported char32_t size != 4\");\n+    // wchar_t can be either 16 bits (Windows) or 32 (everywhere else)\n+    static_assert(!std::is_same<CharT, wchar_t>::value || sizeof(CharT) == 2 || sizeof(CharT) == 4,\n+                  \"Unsupported wchar_t size != 2/4\");\n+    static constexpr size_t UTF_N = 8 * sizeof(CharT);\n+\n+    bool load(handle src, bool) {\n+        handle load_src = src;\n+        if (!src) {\n+            return false;\n+        }\n+        if (!PyUnicode_Check(load_src.ptr())) {\n+            return load_raw(load_src);\n+        }\n+\n+        // For UTF-8 we avoid the need for a temporary `bytes` object by using\n+        // `PyUnicode_AsUTF8AndSize`.\n+        if (PYBIND11_SILENCE_MSVC_C4127(UTF_N == 8)) {\n+            Py_ssize_t size = -1;\n+            const auto *buffer\n+                = reinterpret_cast<const CharT *>(PyUnicode_AsUTF8AndSize(load_src.ptr(), &size));\n+            if (!buffer) {\n+                PyErr_Clear();\n+                return false;\n+            }\n+            value = StringType(buffer, static_cast<size_t>(size));\n+            return true;\n+        }\n+\n+        auto utfNbytes\n+            = reinterpret_steal<object>(PyUnicode_AsEncodedString(load_src.ptr(),\n+                                                                  UTF_N == 8    ? \"utf-8\"\n+                                                                  : UTF_N == 16 ? \"utf-16\"\n+                                                                                : \"utf-32\",\n+                                                                  nullptr));\n+        if (!utfNbytes) {\n+            PyErr_Clear();\n+            return false;\n+        }\n+\n+        const auto *buffer\n+            = reinterpret_cast<const CharT *>(PYBIND11_BYTES_AS_STRING(utfNbytes.ptr()));\n+        size_t length = (size_t) PYBIND11_BYTES_SIZE(utfNbytes.ptr()) / sizeof(CharT);\n+        // Skip BOM for UTF-16/32\n+        if (PYBIND11_SILENCE_MSVC_C4127(UTF_N > 8)) {\n+            buffer++;\n+            length--;\n+        }\n+        value = StringType(buffer, length);\n+\n+        // If we're loading a string_view we need to keep the encoded Python object alive:\n+        if (IsView) {\n+            loader_life_support::add_patient(utfNbytes);\n+        }\n+\n+        return true;\n+    }\n+\n+    static handle\n+    cast(const StringType &src, return_value_policy /* policy */, handle /* parent */) {\n+        const char *buffer = reinterpret_cast<const char *>(src.data());\n+        auto nbytes = ssize_t(src.size() * sizeof(CharT));\n+        handle s = decode_utfN(buffer, nbytes);\n+        if (!s) {\n+            throw error_already_set();\n+        }\n+        return s;\n+    }\n+\n+    PYBIND11_TYPE_CASTER(StringType, const_name(PYBIND11_STRING_NAME));\n+\n+private:\n+    static handle decode_utfN(const char *buffer, ssize_t nbytes) {\n+#if !defined(PYPY_VERSION)\n+        return UTF_N == 8    ? PyUnicode_DecodeUTF8(buffer, nbytes, nullptr)\n+               : UTF_N == 16 ? PyUnicode_DecodeUTF16(buffer, nbytes, nullptr, nullptr)\n+                             : PyUnicode_DecodeUTF32(buffer, nbytes, nullptr, nullptr);\n+#else\n+        // PyPy segfaults when on PyUnicode_DecodeUTF16 (and possibly on PyUnicode_DecodeUTF32 as\n+        // well), so bypass the whole thing by just passing the encoding as a string value, which\n+        // works properly:\n+        return PyUnicode_Decode(buffer,\n+                                nbytes,\n+                                UTF_N == 8    ? \"utf-8\"\n+                                : UTF_N == 16 ? \"utf-16\"\n+                                              : \"utf-32\",\n+                                nullptr);\n+#endif\n+    }\n+\n+    // When loading into a std::string or char*, accept a bytes/bytearray object as-is (i.e.\n+    // without any encoding/decoding attempt).  For other C++ char sizes this is a no-op.\n+    // which supports loading a unicode from a str, doesn't take this path.\n+    template <typename C = CharT>\n+    bool load_raw(enable_if_t<std::is_same<C, char>::value, handle> src) {\n+        if (PYBIND11_BYTES_CHECK(src.ptr())) {\n+            // We were passed raw bytes; accept it into a std::string or char*\n+            // without any encoding attempt.\n+            const char *bytes = PYBIND11_BYTES_AS_STRING(src.ptr());\n+            if (!bytes) {\n+                pybind11_fail(\"Unexpected PYBIND11_BYTES_AS_STRING() failure.\");\n+            }\n+            value = StringType(bytes, (size_t) PYBIND11_BYTES_SIZE(src.ptr()));\n+            return true;\n+        }\n+        if (PyByteArray_Check(src.ptr())) {\n+            // We were passed a bytearray; accept it into a std::string or char*\n+            // without any encoding attempt.\n+            const char *bytearray = PyByteArray_AsString(src.ptr());\n+            if (!bytearray) {\n+                pybind11_fail(\"Unexpected PyByteArray_AsString() failure.\");\n+            }\n+            value = StringType(bytearray, (size_t) PyByteArray_Size(src.ptr()));\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    template <typename C = CharT>\n+    bool load_raw(enable_if_t<!std::is_same<C, char>::value, handle>) {\n+        return false;\n+    }\n+};\n+\n+template <typename CharT, class Traits, class Allocator>\n+struct type_caster<std::basic_string<CharT, Traits, Allocator>,\n+                   enable_if_t<is_std_char_type<CharT>::value>>\n+    : string_caster<std::basic_string<CharT, Traits, Allocator>> {};\n+\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+template <typename CharT, class Traits>\n+struct type_caster<std::basic_string_view<CharT, Traits>,\n+                   enable_if_t<is_std_char_type<CharT>::value>>\n+    : string_caster<std::basic_string_view<CharT, Traits>, true> {};\n+#endif\n+\n+// Type caster for C-style strings.  We basically use a std::string type caster, but also add the\n+// ability to use None as a nullptr char* (which the string caster doesn't allow).\n+template <typename CharT>\n+struct type_caster<CharT, enable_if_t<is_std_char_type<CharT>::value>> {\n+    using StringType = std::basic_string<CharT>;\n+    using StringCaster = make_caster<StringType>;\n+    StringCaster str_caster;\n+    bool none = false;\n+    CharT one_char = 0;\n+\n+public:\n+    bool load(handle src, bool convert) {\n+        if (!src) {\n+            return false;\n+        }\n+        if (src.is_none()) {\n+            // Defer accepting None to other overloads (if we aren't in convert mode):\n+            if (!convert) {\n+                return false;\n+            }\n+            none = true;\n+            return true;\n+        }\n+        return str_caster.load(src, convert);\n+    }\n+\n+    static handle cast(const CharT *src, return_value_policy policy, handle parent) {\n+        if (src == nullptr) {\n+            return pybind11::none().inc_ref();\n+        }\n+        return StringCaster::cast(StringType(src), policy, parent);\n+    }\n+\n+    static handle cast(CharT src, return_value_policy policy, handle parent) {\n+        if (std::is_same<char, CharT>::value) {\n+            handle s = PyUnicode_DecodeLatin1((const char *) &src, 1, nullptr);\n+            if (!s) {\n+                throw error_already_set();\n+            }\n+            return s;\n+        }\n+        return StringCaster::cast(StringType(1, src), policy, parent);\n+    }\n+\n+    explicit operator CharT *() {\n+        return none ? nullptr : const_cast<CharT *>(static_cast<StringType &>(str_caster).c_str());\n+    }\n+    explicit operator CharT &() {\n+        if (none) {\n+            throw value_error(\"Cannot convert None to a character\");\n+        }\n+\n+        auto &value = static_cast<StringType &>(str_caster);\n+        size_t str_len = value.size();\n+        if (str_len == 0) {\n+            throw value_error(\"Cannot convert empty string to a character\");\n+        }\n+\n+        // If we're in UTF-8 mode, we have two possible failures: one for a unicode character that\n+        // is too high, and one for multiple unicode characters (caught later), so we need to\n+        // figure out how long the first encoded character is in bytes to distinguish between these\n+        // two errors.  We also allow want to allow unicode characters U+0080 through U+00FF, as\n+        // those can fit into a single char value.\n+        if (PYBIND11_SILENCE_MSVC_C4127(StringCaster::UTF_N == 8) && str_len > 1 && str_len <= 4) {\n+            auto v0 = static_cast<unsigned char>(value[0]);\n+            // low bits only: 0-127\n+            // 0b110xxxxx - start of 2-byte sequence\n+            // 0b1110xxxx - start of 3-byte sequence\n+            // 0b11110xxx - start of 4-byte sequence\n+            size_t char0_bytes = (v0 & 0x80) == 0      ? 1\n+                                 : (v0 & 0xE0) == 0xC0 ? 2\n+                                 : (v0 & 0xF0) == 0xE0 ? 3\n+                                                       : 4;\n+\n+            if (char0_bytes == str_len) {\n+                // If we have a 128-255 value, we can decode it into a single char:\n+                if (char0_bytes == 2 && (v0 & 0xFC) == 0xC0) { // 0x110000xx 0x10xxxxxx\n+                    one_char = static_cast<CharT>(((v0 & 3) << 6)\n+                                                  + (static_cast<unsigned char>(value[1]) & 0x3F));\n+                    return one_char;\n+                }\n+                // Otherwise we have a single character, but it's > U+00FF\n+                throw value_error(\"Character code point not in range(0x100)\");\n+            }\n+        }\n+\n+        // UTF-16 is much easier: we can only have a surrogate pair for values above U+FFFF, thus a\n+        // surrogate pair with total length 2 instantly indicates a range error (but not a \"your\n+        // string was too long\" error).\n+        else if (PYBIND11_SILENCE_MSVC_C4127(StringCaster::UTF_N == 16) && str_len == 2) {\n+            one_char = static_cast<CharT>(value[0]);\n+            if (one_char >= 0xD800 && one_char < 0xE000) {\n+                throw value_error(\"Character code point not in range(0x10000)\");\n+            }\n+        }\n+\n+        if (str_len != 1) {\n+            throw value_error(\"Expected a character, but multi-character string found\");\n+        }\n+\n+        one_char = value[0];\n+        return one_char;\n+    }\n+\n+    static constexpr auto name = const_name(PYBIND11_STRING_NAME);\n+    template <typename _T>\n+    using cast_op_type = pybind11::detail::cast_op_type<_T>;\n+};\n+\n+// Base implementation for std::tuple and std::pair\n+template <template <typename...> class Tuple, typename... Ts>\n+class tuple_caster {\n+    using type = Tuple<Ts...>;\n+    static constexpr auto size = sizeof...(Ts);\n+    using indices = make_index_sequence<size>;\n+\n+public:\n+    bool load(handle src, bool convert) {\n+        if (!isinstance<sequence>(src)) {\n+            return false;\n+        }\n+        const auto seq = reinterpret_borrow<sequence>(src);\n+        if (seq.size() != size) {\n+            return false;\n+        }\n+        return load_impl(seq, convert, indices{});\n+    }\n+\n+    template <typename T>\n+    static handle cast(T &&src, return_value_policy policy, handle parent) {\n+        return cast_impl(std::forward<T>(src), policy, parent, indices{});\n+    }\n+\n+    // copied from the PYBIND11_TYPE_CASTER macro\n+    template <typename T>\n+    static handle cast(T *src, return_value_policy policy, handle parent) {\n+        if (!src) {\n+            return none().release();\n+        }\n+        if (policy == return_value_policy::take_ownership) {\n+            auto h = cast(std::move(*src), policy, parent);\n+            delete src;\n+            return h;\n+        }\n+        return cast(*src, policy, parent);\n+    }\n+\n+    static constexpr auto name\n+        = const_name(\"Tuple[\") + concat(make_caster<Ts>::name...) + const_name(\"]\");\n+\n+    template <typename T>\n+    using cast_op_type = type;\n+\n+    explicit operator type() & { return implicit_cast(indices{}); }\n+    explicit operator type() && { return std::move(*this).implicit_cast(indices{}); }\n+\n+protected:\n+    template <size_t... Is>\n+    type implicit_cast(index_sequence<Is...>) & {\n+        return type(cast_op<Ts>(std::get<Is>(subcasters))...);\n+    }\n+    template <size_t... Is>\n+    type implicit_cast(index_sequence<Is...>) && {\n+        return type(cast_op<Ts>(std::move(std::get<Is>(subcasters)))...);\n+    }\n+\n+    static constexpr bool load_impl(const sequence &, bool, index_sequence<>) { return true; }\n+\n+    template <size_t... Is>\n+    bool load_impl(const sequence &seq, bool convert, index_sequence<Is...>) {\n+#ifdef __cpp_fold_expressions\n+        if ((... || !std::get<Is>(subcasters).load(seq[Is], convert))) {\n+            return false;\n+        }\n+#else\n+        for (bool r : {std::get<Is>(subcasters).load(seq[Is], convert)...}) {\n+            if (!r) {\n+                return false;\n+            }\n+        }\n+#endif\n+        return true;\n+    }\n+\n+    /* Implementation: Convert a C++ tuple into a Python tuple */\n+    template <typename T, size_t... Is>\n+    static handle\n+    cast_impl(T &&src, return_value_policy policy, handle parent, index_sequence<Is...>) {\n+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(src, policy, parent);\n+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(policy, parent);\n+        std::array<object, size> entries{{reinterpret_steal<object>(\n+            make_caster<Ts>::cast(std::get<Is>(std::forward<T>(src)), policy, parent))...}};\n+        for (const auto &entry : entries) {\n+            if (!entry) {\n+                return handle();\n+            }\n+        }\n+        tuple result(size);\n+        int counter = 0;\n+        for (auto &entry : entries) {\n+            PyTuple_SET_ITEM(result.ptr(), counter++, entry.release().ptr());\n+        }\n+        return result.release();\n+    }\n+\n+    Tuple<make_caster<Ts>...> subcasters;\n+};\n+\n+template <typename T1, typename T2>\n+class type_caster<std::pair<T1, T2>> : public tuple_caster<std::pair, T1, T2> {};\n+\n+template <typename... Ts>\n+class type_caster<std::tuple<Ts...>> : public tuple_caster<std::tuple, Ts...> {};\n+\n+/// Helper class which abstracts away certain actions. Users can provide specializations for\n+/// custom holders, but it's only necessary if the type has a non-standard interface.\n+template <typename T>\n+struct holder_helper {\n+    static auto get(const T &p) -> decltype(p.get()) { return p.get(); }\n+};\n+\n+/// Type caster for holder types like std::shared_ptr, etc.\n+/// The SFINAE hook is provided to help work around the current lack of support\n+/// for smart-pointer interoperability. Please consider it an implementation\n+/// detail that may change in the future, as formal support for smart-pointer\n+/// interoperability is added into pybind11.\n+template <typename type, typename holder_type, typename SFINAE = void>\n+struct copyable_holder_caster : public type_caster_base<type> {\n+public:\n+    using base = type_caster_base<type>;\n+    static_assert(std::is_base_of<base, type_caster<type>>::value,\n+                  \"Holder classes are only supported for custom types\");\n+    using base::base;\n+    using base::cast;\n+    using base::typeinfo;\n+    using base::value;\n+\n+    bool load(handle src, bool convert) {\n+        return base::template load_impl<copyable_holder_caster<type, holder_type>>(src, convert);\n+    }\n+\n+    explicit operator type *() { return this->value; }\n+    // static_cast works around compiler error with MSVC 17 and CUDA 10.2\n+    // see issue #2180\n+    explicit operator type &() { return *(static_cast<type *>(this->value)); }\n+    explicit operator holder_type *() { return std::addressof(holder); }\n+    explicit operator holder_type &() { return holder; }\n+\n+    static handle cast(const holder_type &src, return_value_policy, handle) {\n+        const auto *ptr = holder_helper<holder_type>::get(src);\n+        return type_caster_base<type>::cast_holder(ptr, &src);\n+    }\n+\n+protected:\n+    friend class type_caster_generic;\n+    void check_holder_compat() {\n+        if (typeinfo->default_holder) {\n+            throw cast_error(\"Unable to load a custom holder type from a default-holder instance\");\n+        }\n+    }\n+\n+    bool load_value(value_and_holder &&v_h) {\n+        if (v_h.holder_constructed()) {\n+            value = v_h.value_ptr();\n+            holder = v_h.template holder<holder_type>();\n+            return true;\n+        }\n+        throw cast_error(\"Unable to cast from non-held to held instance (T& to Holder<T>) \"\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+                         \"(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for \"\n+                         \"type information)\");\n+#else\n+                         \"of type '\"\n+                         + type_id<holder_type>() + \"''\");\n+#endif\n+    }\n+\n+    template <typename T = holder_type,\n+              detail::enable_if_t<!std::is_constructible<T, const T &, type *>::value, int> = 0>\n+    bool try_implicit_casts(handle, bool) {\n+        return false;\n+    }\n+\n+    template <typename T = holder_type,\n+              detail::enable_if_t<std::is_constructible<T, const T &, type *>::value, int> = 0>\n+    bool try_implicit_casts(handle src, bool convert) {\n+        for (auto &cast : typeinfo->implicit_casts) {\n+            copyable_holder_caster sub_caster(*cast.first);\n+            if (sub_caster.load(src, convert)) {\n+                value = cast.second(sub_caster.value);\n+                holder = holder_type(sub_caster.holder, (type *) value);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static bool try_direct_conversions(handle) { return false; }\n+\n+    holder_type holder;\n+};\n+\n+/// Specialize for the common std::shared_ptr, so users don't need to\n+template <typename T>\n+class type_caster<std::shared_ptr<T>> : public copyable_holder_caster<T, std::shared_ptr<T>> {};\n+\n+/// Type caster for holder types like std::unique_ptr.\n+/// Please consider the SFINAE hook an implementation detail, as explained\n+/// in the comment for the copyable_holder_caster.\n+template <typename type, typename holder_type, typename SFINAE = void>\n+struct move_only_holder_caster {\n+    static_assert(std::is_base_of<type_caster_base<type>, type_caster<type>>::value,\n+                  \"Holder classes are only supported for custom types\");\n+\n+    static handle cast(holder_type &&src, return_value_policy, handle) {\n+        auto *ptr = holder_helper<holder_type>::get(src);\n+        return type_caster_base<type>::cast_holder(ptr, std::addressof(src));\n+    }\n+    static constexpr auto name = type_caster_base<type>::name;\n+};\n+\n+template <typename type, typename deleter>\n+class type_caster<std::unique_ptr<type, deleter>>\n+    : public move_only_holder_caster<type, std::unique_ptr<type, deleter>> {};\n+\n+template <typename type, typename holder_type>\n+using type_caster_holder = conditional_t<is_copy_constructible<holder_type>::value,\n+                                         copyable_holder_caster<type, holder_type>,\n+                                         move_only_holder_caster<type, holder_type>>;\n+\n+template <typename T, bool Value = false>\n+struct always_construct_holder {\n+    static constexpr bool value = Value;\n+};\n+\n+/// Create a specialization for custom holder types (silently ignores std::shared_ptr)\n+#define PYBIND11_DECLARE_HOLDER_TYPE(type, holder_type, ...)                                      \\\n+    PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)                                                  \\\n+    namespace detail {                                                                            \\\n+    template <typename type>                                                                      \\\n+    struct always_construct_holder<holder_type> : always_construct_holder<void, ##__VA_ARGS__> {  \\\n+    };                                                                                            \\\n+    template <typename type>                                                                      \\\n+    class type_caster<holder_type, enable_if_t<!is_shared_ptr<holder_type>::value>>               \\\n+        : public type_caster_holder<type, holder_type> {};                                        \\\n+    }                                                                                             \\\n+    PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)\n+\n+// PYBIND11_DECLARE_HOLDER_TYPE holder types:\n+template <typename base, typename holder>\n+struct is_holder_type\n+    : std::is_base_of<detail::type_caster_holder<base, holder>, detail::type_caster<holder>> {};\n+// Specialization for always-supported unique_ptr holders:\n+template <typename base, typename deleter>\n+struct is_holder_type<base, std::unique_ptr<base, deleter>> : std::true_type {};\n+\n+template <typename T>\n+struct handle_type_name {\n+    static constexpr auto name = const_name<T>();\n+};\n+template <>\n+struct handle_type_name<bool_> {\n+    static constexpr auto name = const_name(\"bool\");\n+};\n+template <>\n+struct handle_type_name<bytes> {\n+    static constexpr auto name = const_name(PYBIND11_BYTES_NAME);\n+};\n+template <>\n+struct handle_type_name<int_> {\n+    static constexpr auto name = const_name(\"int\");\n+};\n+template <>\n+struct handle_type_name<iterable> {\n+    static constexpr auto name = const_name(\"Iterable\");\n+};\n+template <>\n+struct handle_type_name<iterator> {\n+    static constexpr auto name = const_name(\"Iterator\");\n+};\n+template <>\n+struct handle_type_name<float_> {\n+    static constexpr auto name = const_name(\"float\");\n+};\n+template <>\n+struct handle_type_name<none> {\n+    static constexpr auto name = const_name(\"None\");\n+};\n+template <>\n+struct handle_type_name<args> {\n+    static constexpr auto name = const_name(\"*args\");\n+};\n+template <>\n+struct handle_type_name<kwargs> {\n+    static constexpr auto name = const_name(\"**kwargs\");\n+};\n+\n+template <typename type>\n+struct pyobject_caster {\n+    template <typename T = type, enable_if_t<std::is_same<T, handle>::value, int> = 0>\n+    pyobject_caster() : value() {}\n+\n+    // `type` may not be default constructible (e.g. frozenset, anyset).  Initializing `value`\n+    // to a nil handle is safe since it will only be accessed if `load` succeeds.\n+    template <typename T = type, enable_if_t<std::is_base_of<object, T>::value, int> = 0>\n+    pyobject_caster() : value(reinterpret_steal<type>(handle())) {}\n+\n+    template <typename T = type, enable_if_t<std::is_same<T, handle>::value, int> = 0>\n+    bool load(handle src, bool /* convert */) {\n+        value = src;\n+        return static_cast<bool>(value);\n+    }\n+\n+    template <typename T = type, enable_if_t<std::is_base_of<object, T>::value, int> = 0>\n+    bool load(handle src, bool /* convert */) {\n+        if (!isinstance<type>(src)) {\n+            return false;\n+        }\n+        value = reinterpret_borrow<type>(src);\n+        return true;\n+    }\n+\n+    static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {\n+        return src.inc_ref();\n+    }\n+    PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name);\n+};\n+\n+template <typename T>\n+class type_caster<T, enable_if_t<is_pyobject<T>::value>> : public pyobject_caster<T> {};\n+\n+// Our conditions for enabling moving are quite restrictive:\n+// At compile time:\n+// - T needs to be a non-const, non-pointer, non-reference type\n+// - type_caster<T>::operator T&() must exist\n+// - the type must be move constructible (obviously)\n+// At run-time:\n+// - if the type is non-copy-constructible, the object must be the sole owner of the type (i.e. it\n+//   must have ref_count() == 1)h\n+// If any of the above are not satisfied, we fall back to copying.\n+template <typename T>\n+using move_is_plain_type\n+    = satisfies_none_of<T, std::is_void, std::is_pointer, std::is_reference, std::is_const>;\n+template <typename T, typename SFINAE = void>\n+struct move_always : std::false_type {};\n+template <typename T>\n+struct move_always<\n+    T,\n+    enable_if_t<\n+        all_of<move_is_plain_type<T>,\n+               negation<is_copy_constructible<T>>,\n+               std::is_move_constructible<T>,\n+               std::is_same<decltype(std::declval<make_caster<T>>().operator T &()), T &>>::value>>\n+    : std::true_type {};\n+template <typename T, typename SFINAE = void>\n+struct move_if_unreferenced : std::false_type {};\n+template <typename T>\n+struct move_if_unreferenced<\n+    T,\n+    enable_if_t<\n+        all_of<move_is_plain_type<T>,\n+               negation<move_always<T>>,\n+               std::is_move_constructible<T>,\n+               std::is_same<decltype(std::declval<make_caster<T>>().operator T &()), T &>>::value>>\n+    : std::true_type {};\n+template <typename T>\n+using move_never = none_of<move_always<T>, move_if_unreferenced<T>>;\n+\n+// Detect whether returning a `type` from a cast on type's type_caster is going to result in a\n+// reference or pointer to a local variable of the type_caster.  Basically, only\n+// non-reference/pointer `type`s and reference/pointers from a type_caster_generic are safe;\n+// everything else returns a reference/pointer to a local variable.\n+template <typename type>\n+using cast_is_temporary_value_reference\n+    = bool_constant<(std::is_reference<type>::value || std::is_pointer<type>::value)\n+                    && !std::is_base_of<type_caster_generic, make_caster<type>>::value\n+                    && !std::is_same<intrinsic_t<type>, void>::value>;\n+\n+// When a value returned from a C++ function is being cast back to Python, we almost always want to\n+// force `policy = move`, regardless of the return value policy the function/method was declared\n+// with.\n+template <typename Return, typename SFINAE = void>\n+struct return_value_policy_override {\n+    static return_value_policy policy(return_value_policy p) { return p; }\n+};\n+\n+template <typename Return>\n+struct return_value_policy_override<\n+    Return,\n+    detail::enable_if_t<std::is_base_of<type_caster_generic, make_caster<Return>>::value, void>> {\n+    static return_value_policy policy(return_value_policy p) {\n+        return !std::is_lvalue_reference<Return>::value && !std::is_pointer<Return>::value\n+                   ? return_value_policy::move\n+                   : p;\n+    }\n+};\n+\n+// Basic python -> C++ casting; throws if casting fails\n+template <typename T, typename SFINAE>\n+type_caster<T, SFINAE> &load_type(type_caster<T, SFINAE> &conv, const handle &handle) {\n+    static_assert(!detail::is_pyobject<T>::value,\n+                  \"Internal error: type_caster should only be used for C++ types\");\n+    if (!conv.load(handle, true)) {\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+        throw cast_error(\"Unable to cast Python instance to C++ type (#define \"\n+                         \"PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)\");\n+#else\n+        throw cast_error(\"Unable to cast Python instance of type \"\n+                         + (std::string) str(type::handle_of(handle)) + \" to C++ type '\"\n+                         + type_id<T>() + \"'\");\n+#endif\n+    }\n+    return conv;\n+}\n+// Wrapper around the above that also constructs and returns a type_caster\n+template <typename T>\n+make_caster<T> load_type(const handle &handle) {\n+    make_caster<T> conv;\n+    load_type(conv, handle);\n+    return conv;\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+// pytype -> C++ type\n+template <typename T, detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>\n+T cast(const handle &handle) {\n+    using namespace detail;\n+    static_assert(!cast_is_temporary_value_reference<T>::value,\n+                  \"Unable to cast type to reference: value is local to type caster\");\n+    return cast_op<T>(load_type<T>(handle));\n+}\n+\n+// pytype -> pytype (calls converting constructor)\n+template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>\n+T cast(const handle &handle) {\n+    return T(reinterpret_borrow<object>(handle));\n+}\n+\n+// C++ type -> py::object\n+template <typename T, detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>\n+object cast(T &&value,\n+            return_value_policy policy = return_value_policy::automatic_reference,\n+            handle parent = handle()) {\n+    using no_ref_T = typename std::remove_reference<T>::type;\n+    if (policy == return_value_policy::automatic) {\n+        policy = std::is_pointer<no_ref_T>::value     ? return_value_policy::take_ownership\n+                 : std::is_lvalue_reference<T>::value ? return_value_policy::copy\n+                                                      : return_value_policy::move;\n+    } else if (policy == return_value_policy::automatic_reference) {\n+        policy = std::is_pointer<no_ref_T>::value     ? return_value_policy::reference\n+                 : std::is_lvalue_reference<T>::value ? return_value_policy::copy\n+                                                      : return_value_policy::move;\n+    }\n+    return reinterpret_steal<object>(\n+        detail::make_caster<T>::cast(std::forward<T>(value), policy, parent));\n+}\n+\n+template <typename T>\n+T handle::cast() const {\n+    return pybind11::cast<T>(*this);\n+}\n+template <>\n+inline void handle::cast() const {\n+    return;\n+}\n+\n+template <typename T>\n+detail::enable_if_t<!detail::move_never<T>::value, T> move(object &&obj) {\n+    if (obj.ref_count() > 1) {\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+        throw cast_error(\n+            \"Unable to cast Python instance to C++ rvalue: instance has multiple references\"\n+            \" (#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)\");\n+#else\n+        throw cast_error(\"Unable to move from Python \" + (std::string) str(type::handle_of(obj))\n+                         + \" instance to C++ \" + type_id<T>()\n+                         + \" instance: instance has multiple references\");\n+#endif\n+    }\n+\n+    // Move into a temporary and return that, because the reference may be a local value of `conv`\n+    T ret = std::move(detail::load_type<T>(obj).operator T &());\n+    return ret;\n+}\n+\n+// Calling cast() on an rvalue calls pybind11::cast with the object rvalue, which does:\n+// - If we have to move (because T has no copy constructor), do it.  This will fail if the moved\n+//   object has multiple references, but trying to copy will fail to compile.\n+// - If both movable and copyable, check ref count: if 1, move; otherwise copy\n+// - Otherwise (not movable), copy.\n+template <typename T>\n+detail::enable_if_t<!detail::is_pyobject<T>::value && detail::move_always<T>::value, T>\n+cast(object &&object) {\n+    return move<T>(std::move(object));\n+}\n+template <typename T>\n+detail::enable_if_t<!detail::is_pyobject<T>::value && detail::move_if_unreferenced<T>::value, T>\n+cast(object &&object) {\n+    if (object.ref_count() > 1) {\n+        return cast<T>(object);\n+    }\n+    return move<T>(std::move(object));\n+}\n+template <typename T>\n+detail::enable_if_t<!detail::is_pyobject<T>::value && detail::move_never<T>::value, T>\n+cast(object &&object) {\n+    return cast<T>(object);\n+}\n+\n+// pytype rvalue -> pytype (calls converting constructor)\n+template <typename T>\n+detail::enable_if_t<detail::is_pyobject<T>::value, T> cast(object &&object) {\n+    return T(std::move(object));\n+}\n+\n+template <typename T>\n+T object::cast() const & {\n+    return pybind11::cast<T>(*this);\n+}\n+template <typename T>\n+T object::cast() && {\n+    return pybind11::cast<T>(std::move(*this));\n+}\n+template <>\n+inline void object::cast() const & {\n+    return;\n+}\n+template <>\n+inline void object::cast() && {\n+    return;\n+}\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// Declared in pytypes.h:\n+template <typename T, enable_if_t<!is_pyobject<T>::value, int>>\n+object object_or_cast(T &&o) {\n+    return pybind11::cast(std::forward<T>(o));\n+}\n+\n+// Placeholder type for the unneeded (and dead code) static variable in the\n+// PYBIND11_OVERRIDE_OVERRIDE macro\n+struct override_unused {};\n+template <typename ret_type>\n+using override_caster_t = conditional_t<cast_is_temporary_value_reference<ret_type>::value,\n+                                        make_caster<ret_type>,\n+                                        override_unused>;\n+\n+// Trampoline use: for reference/pointer types to value-converted values, we do a value cast, then\n+// store the result in the given variable.  For other types, this is a no-op.\n+template <typename T>\n+enable_if_t<cast_is_temporary_value_reference<T>::value, T> cast_ref(object &&o,\n+                                                                     make_caster<T> &caster) {\n+    return cast_op<T>(load_type(caster, o));\n+}\n+template <typename T>\n+enable_if_t<!cast_is_temporary_value_reference<T>::value, T> cast_ref(object &&,\n+                                                                      override_unused &) {\n+    pybind11_fail(\"Internal error: cast_ref fallback invoked\");\n+}\n+\n+// Trampoline use: Having a pybind11::cast with an invalid reference type is going to\n+// static_assert, even though if it's in dead code, so we provide a \"trampoline\" to pybind11::cast\n+// that only does anything in cases where pybind11::cast is valid.\n+template <typename T>\n+enable_if_t<cast_is_temporary_value_reference<T>::value, T> cast_safe(object &&) {\n+    pybind11_fail(\"Internal error: cast_safe fallback invoked\");\n+}\n+template <typename T>\n+enable_if_t<std::is_same<void, intrinsic_t<T>>::value, void> cast_safe(object &&) {}\n+template <typename T>\n+enable_if_t<detail::none_of<cast_is_temporary_value_reference<T>,\n+                            std::is_same<void, intrinsic_t<T>>>::value,\n+            T>\n+cast_safe(object &&o) {\n+    return pybind11::cast<T>(std::move(o));\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+// The overloads could coexist, i.e. the #if is not strictly speaking needed,\n+// but it is an easy minor optimization.\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+inline cast_error cast_error_unable_to_convert_call_arg() {\n+    return cast_error(\"Unable to convert call argument to Python object (#define \"\n+                      \"PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)\");\n+}\n+#else\n+inline cast_error cast_error_unable_to_convert_call_arg(const std::string &name,\n+                                                        const std::string &type) {\n+    return cast_error(\"Unable to convert call argument '\" + name + \"' of type '\" + type\n+                      + \"' to Python object\");\n+}\n+#endif\n+\n+template <return_value_policy policy = return_value_policy::automatic_reference>\n+tuple make_tuple() {\n+    return tuple(0);\n+}\n+\n+template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>\n+tuple make_tuple(Args &&...args_) {\n+    constexpr size_t size = sizeof...(Args);\n+    std::array<object, size> args{{reinterpret_steal<object>(\n+        detail::make_caster<Args>::cast(std::forward<Args>(args_), policy, nullptr))...}};\n+    for (size_t i = 0; i < args.size(); i++) {\n+        if (!args[i]) {\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            throw cast_error_unable_to_convert_call_arg();\n+#else\n+            std::array<std::string, size> argtypes{{type_id<Args>()...}};\n+            throw cast_error_unable_to_convert_call_arg(std::to_string(i), argtypes[i]);\n+#endif\n+        }\n+    }\n+    tuple result(size);\n+    int counter = 0;\n+    for (auto &arg_value : args) {\n+        PyTuple_SET_ITEM(result.ptr(), counter++, arg_value.release().ptr());\n+    }\n+    return result;\n+}\n+\n+/// \\ingroup annotations\n+/// Annotation for arguments\n+struct arg {\n+    /// Constructs an argument with the name of the argument; if null or omitted, this is a\n+    /// positional argument.\n+    constexpr explicit arg(const char *name = nullptr)\n+        : name(name), flag_noconvert(false), flag_none(true) {}\n+    /// Assign a value to this argument\n+    template <typename T>\n+    arg_v operator=(T &&value) const;\n+    /// Indicate that the type should not be converted in the type caster\n+    arg &noconvert(bool flag = true) {\n+        flag_noconvert = flag;\n+        return *this;\n+    }\n+    /// Indicates that the argument should/shouldn't allow None (e.g. for nullable pointer args)\n+    arg &none(bool flag = true) {\n+        flag_none = flag;\n+        return *this;\n+    }\n+\n+    const char *name;        ///< If non-null, this is a named kwargs argument\n+    bool flag_noconvert : 1; ///< If set, do not allow conversion (requires a supporting type\n+                             ///< caster!)\n+    bool flag_none : 1;      ///< If set (the default), allow None to be passed to this argument\n+};\n+\n+/// \\ingroup annotations\n+/// Annotation for arguments with values\n+struct arg_v : arg {\n+private:\n+    template <typename T>\n+    arg_v(arg &&base, T &&x, const char *descr = nullptr)\n+        : arg(base), value(reinterpret_steal<object>(detail::make_caster<T>::cast(\n+                         std::forward<T>(x), return_value_policy::automatic, {}))),\n+          descr(descr)\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+          ,\n+          type(type_id<T>())\n+#endif\n+    {\n+        // Workaround! See:\n+        // https://github.com/pybind/pybind11/issues/2336\n+        // https://github.com/pybind/pybind11/pull/2685#issuecomment-731286700\n+        if (PyErr_Occurred()) {\n+            PyErr_Clear();\n+        }\n+    }\n+\n+public:\n+    /// Direct construction with name, default, and description\n+    template <typename T>\n+    arg_v(const char *name, T &&x, const char *descr = nullptr)\n+        : arg_v(arg(name), std::forward<T>(x), descr) {}\n+\n+    /// Called internally when invoking `py::arg(\"a\") = value`\n+    template <typename T>\n+    arg_v(const arg &base, T &&x, const char *descr = nullptr)\n+        : arg_v(arg(base), std::forward<T>(x), descr) {}\n+\n+    /// Same as `arg::noconvert()`, but returns *this as arg_v&, not arg&\n+    arg_v &noconvert(bool flag = true) {\n+        arg::noconvert(flag);\n+        return *this;\n+    }\n+\n+    /// Same as `arg::nonone()`, but returns *this as arg_v&, not arg&\n+    arg_v &none(bool flag = true) {\n+        arg::none(flag);\n+        return *this;\n+    }\n+\n+    /// The default value\n+    object value;\n+    /// The (optional) description of the default value\n+    const char *descr;\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+    /// The C++ type name of the default value (only available when compiled in debug mode)\n+    std::string type;\n+#endif\n+};\n+\n+/// \\ingroup annotations\n+/// Annotation indicating that all following arguments are keyword-only; the is the equivalent of\n+/// an unnamed '*' argument\n+struct kw_only {};\n+\n+/// \\ingroup annotations\n+/// Annotation indicating that all previous arguments are positional-only; the is the equivalent of\n+/// an unnamed '/' argument (in Python 3.8)\n+struct pos_only {};\n+\n+template <typename T>\n+arg_v arg::operator=(T &&value) const {\n+    return {*this, std::forward<T>(value)};\n+}\n+\n+/// Alias for backward compatibility -- to be removed in version 2.0\n+template <typename /*unused*/>\n+using arg_t = arg_v;\n+\n+inline namespace literals {\n+/** \\rst\n+    String literal version of `arg`\n+ \\endrst */\n+constexpr arg operator\"\" _a(const char *name, size_t) { return arg(name); }\n+} // namespace literals\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+template <typename T>\n+using is_kw_only = std::is_same<intrinsic_t<T>, kw_only>;\n+template <typename T>\n+using is_pos_only = std::is_same<intrinsic_t<T>, pos_only>;\n+\n+// forward declaration (definition in attr.h)\n+struct function_record;\n+\n+/// Internal data associated with a single function call\n+struct function_call {\n+    function_call(const function_record &f, handle p); // Implementation in attr.h\n+\n+    /// The function data:\n+    const function_record &func;\n+\n+    /// Arguments passed to the function:\n+    std::vector<handle> args;\n+\n+    /// The `convert` value the arguments should be loaded with\n+    std::vector<bool> args_convert;\n+\n+    /// Extra references for the optional `py::args` and/or `py::kwargs` arguments (which, if\n+    /// present, are also in `args` but without a reference).\n+    object args_ref, kwargs_ref;\n+\n+    /// The parent, if any\n+    handle parent;\n+\n+    /// If this is a call to an initializer, this argument contains `self`\n+    handle init_self;\n+};\n+\n+/// Helper class which loads arguments for C++ functions called from Python\n+template <typename... Args>\n+class argument_loader {\n+    using indices = make_index_sequence<sizeof...(Args)>;\n+\n+    template <typename Arg>\n+    using argument_is_args = std::is_same<intrinsic_t<Arg>, args>;\n+    template <typename Arg>\n+    using argument_is_kwargs = std::is_same<intrinsic_t<Arg>, kwargs>;\n+    // Get kwargs argument position, or -1 if not present:\n+    static constexpr auto kwargs_pos = constexpr_last<argument_is_kwargs, Args...>();\n+\n+    static_assert(kwargs_pos == -1 || kwargs_pos == (int) sizeof...(Args) - 1,\n+                  \"py::kwargs is only permitted as the last argument of a function\");\n+\n+public:\n+    static constexpr bool has_kwargs = kwargs_pos != -1;\n+\n+    // py::args argument position; -1 if not present.\n+    static constexpr int args_pos = constexpr_last<argument_is_args, Args...>();\n+\n+    static_assert(args_pos == -1 || args_pos == constexpr_first<argument_is_args, Args...>(),\n+                  \"py::args cannot be specified more than once\");\n+\n+    static constexpr auto arg_names = concat(type_descr(make_caster<Args>::name)...);\n+\n+    bool load_args(function_call &call) { return load_impl_sequence(call, indices{}); }\n+\n+    template <typename Return, typename Guard, typename Func>\n+    // NOLINTNEXTLINE(readability-const-return-type)\n+    enable_if_t<!std::is_void<Return>::value, Return> call(Func &&f) && {\n+        return std::move(*this).template call_impl<remove_cv_t<Return>>(\n+            std::forward<Func>(f), indices{}, Guard{});\n+    }\n+\n+    template <typename Return, typename Guard, typename Func>\n+    enable_if_t<std::is_void<Return>::value, void_type> call(Func &&f) && {\n+        std::move(*this).template call_impl<remove_cv_t<Return>>(\n+            std::forward<Func>(f), indices{}, Guard{});\n+        return void_type();\n+    }\n+\n+private:\n+    static bool load_impl_sequence(function_call &, index_sequence<>) { return true; }\n+\n+    template <size_t... Is>\n+    bool load_impl_sequence(function_call &call, index_sequence<Is...>) {\n+#ifdef __cpp_fold_expressions\n+        if ((... || !std::get<Is>(argcasters).load(call.args[Is], call.args_convert[Is]))) {\n+            return false;\n+        }\n+#else\n+        for (bool r : {std::get<Is>(argcasters).load(call.args[Is], call.args_convert[Is])...}) {\n+            if (!r) {\n+                return false;\n+            }\n+        }\n+#endif\n+        return true;\n+    }\n+\n+    template <typename Return, typename Func, size_t... Is, typename Guard>\n+    Return call_impl(Func &&f, index_sequence<Is...>, Guard &&) && {\n+        return std::forward<Func>(f)(cast_op<Args>(std::move(std::get<Is>(argcasters)))...);\n+    }\n+\n+    std::tuple<make_caster<Args>...> argcasters;\n+};\n+\n+/// Helper class which collects only positional arguments for a Python function call.\n+/// A fancier version below can collect any argument, but this one is optimal for simple calls.\n+template <return_value_policy policy>\n+class simple_collector {\n+public:\n+    template <typename... Ts>\n+    explicit simple_collector(Ts &&...values)\n+        : m_args(pybind11::make_tuple<policy>(std::forward<Ts>(values)...)) {}\n+\n+    const tuple &args() const & { return m_args; }\n+    dict kwargs() const { return {}; }\n+\n+    tuple args() && { return std::move(m_args); }\n+\n+    /// Call a Python function and pass the collected arguments\n+    object call(PyObject *ptr) const {\n+        PyObject *result = PyObject_CallObject(ptr, m_args.ptr());\n+        if (!result) {\n+            throw error_already_set();\n+        }\n+        return reinterpret_steal<object>(result);\n+    }\n+\n+private:\n+    tuple m_args;\n+};\n+\n+/// Helper class which collects positional, keyword, * and ** arguments for a Python function call\n+template <return_value_policy policy>\n+class unpacking_collector {\n+public:\n+    template <typename... Ts>\n+    explicit unpacking_collector(Ts &&...values) {\n+        // Tuples aren't (easily) resizable so a list is needed for collection,\n+        // but the actual function call strictly requires a tuple.\n+        auto args_list = list();\n+        using expander = int[];\n+        (void) expander{0, (process(args_list, std::forward<Ts>(values)), 0)...};\n+\n+        m_args = std::move(args_list);\n+    }\n+\n+    const tuple &args() const & { return m_args; }\n+    const dict &kwargs() const & { return m_kwargs; }\n+\n+    tuple args() && { return std::move(m_args); }\n+    dict kwargs() && { return std::move(m_kwargs); }\n+\n+    /// Call a Python function and pass the collected arguments\n+    object call(PyObject *ptr) const {\n+        PyObject *result = PyObject_Call(ptr, m_args.ptr(), m_kwargs.ptr());\n+        if (!result) {\n+            throw error_already_set();\n+        }\n+        return reinterpret_steal<object>(result);\n+    }\n+\n+private:\n+    template <typename T>\n+    void process(list &args_list, T &&x) {\n+        auto o = reinterpret_steal<object>(\n+            detail::make_caster<T>::cast(std::forward<T>(x), policy, {}));\n+        if (!o) {\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            throw cast_error_unable_to_convert_call_arg();\n+#else\n+            throw cast_error_unable_to_convert_call_arg(std::to_string(args_list.size()),\n+                                                        type_id<T>());\n+#endif\n+        }\n+        args_list.append(std::move(o));\n+    }\n+\n+    void process(list &args_list, detail::args_proxy ap) {\n+        for (auto a : ap) {\n+            args_list.append(a);\n+        }\n+    }\n+\n+    void process(list & /*args_list*/, arg_v a) {\n+        if (!a.name) {\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            nameless_argument_error();\n+#else\n+            nameless_argument_error(a.type);\n+#endif\n+        }\n+        if (m_kwargs.contains(a.name)) {\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            multiple_values_error();\n+#else\n+            multiple_values_error(a.name);\n+#endif\n+        }\n+        if (!a.value) {\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            throw cast_error_unable_to_convert_call_arg();\n+#else\n+            throw cast_error_unable_to_convert_call_arg(a.name, a.type);\n+#endif\n+        }\n+        m_kwargs[a.name] = a.value;\n+    }\n+\n+    void process(list & /*args_list*/, detail::kwargs_proxy kp) {\n+        if (!kp) {\n+            return;\n+        }\n+        for (auto k : reinterpret_borrow<dict>(kp)) {\n+            if (m_kwargs.contains(k.first)) {\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+                multiple_values_error();\n+#else\n+                multiple_values_error(str(k.first));\n+#endif\n+            }\n+            m_kwargs[k.first] = k.second;\n+        }\n+    }\n+\n+    [[noreturn]] static void nameless_argument_error() {\n+        throw type_error(\n+            \"Got kwargs without a name; only named arguments \"\n+            \"may be passed via py::arg() to a python function call. \"\n+            \"(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)\");\n+    }\n+    [[noreturn]] static void nameless_argument_error(const std::string &type) {\n+        throw type_error(\"Got kwargs without a name of type '\" + type\n+                         + \"'; only named \"\n+                           \"arguments may be passed via py::arg() to a python function call. \");\n+    }\n+    [[noreturn]] static void multiple_values_error() {\n+        throw type_error(\n+            \"Got multiple values for keyword argument \"\n+            \"(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)\");\n+    }\n+\n+    [[noreturn]] static void multiple_values_error(const std::string &name) {\n+        throw type_error(\"Got multiple values for keyword argument '\" + name + \"'\");\n+    }\n+\n+private:\n+    tuple m_args;\n+    dict m_kwargs;\n+};\n+\n+// [workaround(intel)] Separate function required here\n+// We need to put this into a separate function because the Intel compiler\n+// fails to compile enable_if_t<!all_of<is_positional<Args>...>::value>\n+// (tested with ICC 2021.1 Beta 20200827).\n+template <typename... Args>\n+constexpr bool args_are_all_positional() {\n+    return all_of<is_positional<Args>...>::value;\n+}\n+\n+/// Collect only positional arguments for a Python function call\n+template <return_value_policy policy,\n+          typename... Args,\n+          typename = enable_if_t<args_are_all_positional<Args...>()>>\n+simple_collector<policy> collect_arguments(Args &&...args) {\n+    return simple_collector<policy>(std::forward<Args>(args)...);\n+}\n+\n+/// Collect all arguments, including keywords and unpacking (only instantiated when needed)\n+template <return_value_policy policy,\n+          typename... Args,\n+          typename = enable_if_t<!args_are_all_positional<Args...>()>>\n+unpacking_collector<policy> collect_arguments(Args &&...args) {\n+    // Following argument order rules for generalized unpacking according to PEP 448\n+    static_assert(constexpr_last<is_positional, Args...>()\n+                          < constexpr_first<is_keyword_or_ds, Args...>()\n+                      && constexpr_last<is_s_unpacking, Args...>()\n+                             < constexpr_first<is_ds_unpacking, Args...>(),\n+                  \"Invalid function call: positional args must precede keywords and ** unpacking; \"\n+                  \"* unpacking must precede ** unpacking\");\n+    return unpacking_collector<policy>(std::forward<Args>(args)...);\n+}\n+\n+template <typename Derived>\n+template <return_value_policy policy, typename... Args>\n+object object_api<Derived>::operator()(Args &&...args) const {\n+#ifndef NDEBUG\n+    if (!PyGILState_Check()) {\n+        pybind11_fail(\"pybind11::object_api<>::operator() PyGILState_Check() failure.\");\n+    }\n+#endif\n+    return detail::collect_arguments<policy>(std::forward<Args>(args)...).call(derived().ptr());\n+}\n+\n+template <typename Derived>\n+template <return_value_policy policy, typename... Args>\n+object object_api<Derived>::call(Args &&...args) const {\n+    return operator()<policy>(std::forward<Args>(args)...);\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+template <typename T>\n+handle type::handle_of() {\n+    static_assert(std::is_base_of<detail::type_caster_generic, detail::make_caster<T>>::value,\n+                  \"py::type::of<T> only supports the case where T is a registered C++ types.\");\n+\n+    return detail::get_type_handle(typeid(T), true);\n+}\n+\n+#define PYBIND11_MAKE_OPAQUE(...)                                                                 \\\n+    PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)                                                  \\\n+    namespace detail {                                                                            \\\n+    template <>                                                                                   \\\n+    class type_caster<__VA_ARGS__> : public type_caster_base<__VA_ARGS__> {};                     \\\n+    }                                                                                             \\\n+    PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)\n+\n+/// Lets you pass a type containing a `,` through a macro parameter without needing a separate\n+/// typedef, e.g.:\n+/// `PYBIND11_OVERRIDE(PYBIND11_TYPE(ReturnType<A, B>), PYBIND11_TYPE(Parent<C, D>), f, arg)`\n+#define PYBIND11_TYPE(...) __VA_ARGS__\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/chrono.h", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "file_content_changes": "@@ -0,0 +1,225 @@\n+/*\n+    pybind11/chrono.h: Transparent conversion between std::chrono and python's datetime\n+\n+    Copyright (c) 2016 Trent Houliston <trent@houliston.me> and\n+                       Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+#include <chrono>\n+#include <cmath>\n+#include <ctime>\n+#include <datetime.h>\n+#include <mutex>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+template <typename type>\n+class duration_caster {\n+public:\n+    using rep = typename type::rep;\n+    using period = typename type::period;\n+\n+    // signed 25 bits required by the standard.\n+    using days = std::chrono::duration<int_least32_t, std::ratio<86400>>;\n+\n+    bool load(handle src, bool) {\n+        using namespace std::chrono;\n+\n+        // Lazy initialise the PyDateTime import\n+        if (!PyDateTimeAPI) {\n+            PyDateTime_IMPORT;\n+        }\n+\n+        if (!src) {\n+            return false;\n+        }\n+        // If invoked with datetime.delta object\n+        if (PyDelta_Check(src.ptr())) {\n+            value = type(duration_cast<duration<rep, period>>(\n+                days(PyDateTime_DELTA_GET_DAYS(src.ptr()))\n+                + seconds(PyDateTime_DELTA_GET_SECONDS(src.ptr()))\n+                + microseconds(PyDateTime_DELTA_GET_MICROSECONDS(src.ptr()))));\n+            return true;\n+        }\n+        // If invoked with a float we assume it is seconds and convert\n+        if (PyFloat_Check(src.ptr())) {\n+            value = type(duration_cast<duration<rep, period>>(\n+                duration<double>(PyFloat_AsDouble(src.ptr()))));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    // If this is a duration just return it back\n+    static const std::chrono::duration<rep, period> &\n+    get_duration(const std::chrono::duration<rep, period> &src) {\n+        return src;\n+    }\n+\n+    // If this is a time_point get the time_since_epoch\n+    template <typename Clock>\n+    static std::chrono::duration<rep, period>\n+    get_duration(const std::chrono::time_point<Clock, std::chrono::duration<rep, period>> &src) {\n+        return src.time_since_epoch();\n+    }\n+\n+    static handle cast(const type &src, return_value_policy /* policy */, handle /* parent */) {\n+        using namespace std::chrono;\n+\n+        // Use overloaded function to get our duration from our source\n+        // Works out if it is a duration or time_point and get the duration\n+        auto d = get_duration(src);\n+\n+        // Lazy initialise the PyDateTime import\n+        if (!PyDateTimeAPI) {\n+            PyDateTime_IMPORT;\n+        }\n+\n+        // Declare these special duration types so the conversions happen with the correct\n+        // primitive types (int)\n+        using dd_t = duration<int, std::ratio<86400>>;\n+        using ss_t = duration<int, std::ratio<1>>;\n+        using us_t = duration<int, std::micro>;\n+\n+        auto dd = duration_cast<dd_t>(d);\n+        auto subd = d - dd;\n+        auto ss = duration_cast<ss_t>(subd);\n+        auto us = duration_cast<us_t>(subd - ss);\n+        return PyDelta_FromDSU(dd.count(), ss.count(), us.count());\n+    }\n+\n+    PYBIND11_TYPE_CASTER(type, const_name(\"datetime.timedelta\"));\n+};\n+\n+inline std::tm *localtime_thread_safe(const std::time_t *time, std::tm *buf) {\n+#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || defined(_MSC_VER)\n+    if (localtime_s(buf, time))\n+        return nullptr;\n+    return buf;\n+#else\n+    static std::mutex mtx;\n+    std::lock_guard<std::mutex> lock(mtx);\n+    std::tm *tm_ptr = std::localtime(time);\n+    if (tm_ptr != nullptr) {\n+        *buf = *tm_ptr;\n+    }\n+    return tm_ptr;\n+#endif\n+}\n+\n+// This is for casting times on the system clock into datetime.datetime instances\n+template <typename Duration>\n+class type_caster<std::chrono::time_point<std::chrono::system_clock, Duration>> {\n+public:\n+    using type = std::chrono::time_point<std::chrono::system_clock, Duration>;\n+    bool load(handle src, bool) {\n+        using namespace std::chrono;\n+\n+        // Lazy initialise the PyDateTime import\n+        if (!PyDateTimeAPI) {\n+            PyDateTime_IMPORT;\n+        }\n+\n+        if (!src) {\n+            return false;\n+        }\n+\n+        std::tm cal;\n+        microseconds msecs;\n+\n+        if (PyDateTime_Check(src.ptr())) {\n+            cal.tm_sec = PyDateTime_DATE_GET_SECOND(src.ptr());\n+            cal.tm_min = PyDateTime_DATE_GET_MINUTE(src.ptr());\n+            cal.tm_hour = PyDateTime_DATE_GET_HOUR(src.ptr());\n+            cal.tm_mday = PyDateTime_GET_DAY(src.ptr());\n+            cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;\n+            cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;\n+            cal.tm_isdst = -1;\n+            msecs = microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));\n+        } else if (PyDate_Check(src.ptr())) {\n+            cal.tm_sec = 0;\n+            cal.tm_min = 0;\n+            cal.tm_hour = 0;\n+            cal.tm_mday = PyDateTime_GET_DAY(src.ptr());\n+            cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;\n+            cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;\n+            cal.tm_isdst = -1;\n+            msecs = microseconds(0);\n+        } else if (PyTime_Check(src.ptr())) {\n+            cal.tm_sec = PyDateTime_TIME_GET_SECOND(src.ptr());\n+            cal.tm_min = PyDateTime_TIME_GET_MINUTE(src.ptr());\n+            cal.tm_hour = PyDateTime_TIME_GET_HOUR(src.ptr());\n+            cal.tm_mday = 1;  // This date (day, month, year) = (1, 0, 70)\n+            cal.tm_mon = 0;   // represents 1-Jan-1970, which is the first\n+            cal.tm_year = 70; // earliest available date for Python's datetime\n+            cal.tm_isdst = -1;\n+            msecs = microseconds(PyDateTime_TIME_GET_MICROSECOND(src.ptr()));\n+        } else {\n+            return false;\n+        }\n+\n+        value = time_point_cast<Duration>(system_clock::from_time_t(std::mktime(&cal)) + msecs);\n+        return true;\n+    }\n+\n+    static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src,\n+                       return_value_policy /* policy */,\n+                       handle /* parent */) {\n+        using namespace std::chrono;\n+\n+        // Lazy initialise the PyDateTime import\n+        if (!PyDateTimeAPI) {\n+            PyDateTime_IMPORT;\n+        }\n+\n+        // Get out microseconds, and make sure they are positive, to avoid bug in eastern\n+        // hemisphere time zones (cfr. https://github.com/pybind/pybind11/issues/2417)\n+        using us_t = duration<int, std::micro>;\n+        auto us = duration_cast<us_t>(src.time_since_epoch() % seconds(1));\n+        if (us.count() < 0) {\n+            us += seconds(1);\n+        }\n+\n+        // Subtract microseconds BEFORE `system_clock::to_time_t`, because:\n+        // > If std::time_t has lower precision, it is implementation-defined whether the value is\n+        // rounded or truncated. (https://en.cppreference.com/w/cpp/chrono/system_clock/to_time_t)\n+        std::time_t tt\n+            = system_clock::to_time_t(time_point_cast<system_clock::duration>(src - us));\n+\n+        std::tm localtime;\n+        std::tm *localtime_ptr = localtime_thread_safe(&tt, &localtime);\n+        if (!localtime_ptr) {\n+            throw cast_error(\"Unable to represent system_clock in local time\");\n+        }\n+        return PyDateTime_FromDateAndTime(localtime.tm_year + 1900,\n+                                          localtime.tm_mon + 1,\n+                                          localtime.tm_mday,\n+                                          localtime.tm_hour,\n+                                          localtime.tm_min,\n+                                          localtime.tm_sec,\n+                                          us.count());\n+    }\n+    PYBIND11_TYPE_CASTER(type, const_name(\"datetime.datetime\"));\n+};\n+\n+// Other clocks that are not the system clock are not measured as datetime.datetime objects\n+// since they are not measured on calendar time. So instead we just make them timedeltas\n+// Or if they have passed us a time as a float we convert that\n+template <typename Clock, typename Duration>\n+class type_caster<std::chrono::time_point<Clock, Duration>>\n+    : public duration_caster<std::chrono::time_point<Clock, Duration>> {};\n+\n+template <typename Rep, typename Period>\n+class type_caster<std::chrono::duration<Rep, Period>>\n+    : public duration_caster<std::chrono::duration<Rep, Period>> {};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/common.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -0,0 +1,2 @@\n+#include \"detail/common.h\"\n+#warning \"Including 'common.h' is deprecated. It will be removed in v3.0. Use 'pybind11.h'.\""}, {"filename": "python/src/pybind11/complex.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "file_content_changes": "@@ -0,0 +1,74 @@\n+/*\n+    pybind11/complex.h: Complex number support\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+#include <complex>\n+\n+/// glibc defines I as a macro which breaks things, e.g., boost template names\n+#ifdef I\n+#    undef I\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+template <typename T>\n+struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {\n+    static constexpr const char c = format_descriptor<T>::c;\n+    static constexpr const char value[3] = {'Z', c, '\\0'};\n+    static std::string format() { return std::string(value); }\n+};\n+\n+#ifndef PYBIND11_CPP17\n+\n+template <typename T>\n+constexpr const char\n+    format_descriptor<std::complex<T>,\n+                      detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];\n+\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+template <typename T>\n+struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {\n+    static constexpr bool value = true;\n+    static constexpr int index = is_fmt_numeric<T>::index + 3;\n+};\n+\n+template <typename T>\n+class type_caster<std::complex<T>> {\n+public:\n+    bool load(handle src, bool convert) {\n+        if (!src) {\n+            return false;\n+        }\n+        if (!convert && !PyComplex_Check(src.ptr())) {\n+            return false;\n+        }\n+        Py_complex result = PyComplex_AsCComplex(src.ptr());\n+        if (result.real == -1.0 && PyErr_Occurred()) {\n+            PyErr_Clear();\n+            return false;\n+        }\n+        value = std::complex<T>((T) result.real, (T) result.imag);\n+        return true;\n+    }\n+\n+    static handle\n+    cast(const std::complex<T> &src, return_value_policy /* policy */, handle /* parent */) {\n+        return PyComplex_FromDoubles((double) src.real(), (double) src.imag());\n+    }\n+\n+    PYBIND11_TYPE_CASTER(std::complex<T>, const_name(\"complex\"));\n+};\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/class.h", "status": "added", "additions": 742, "deletions": 0, "changes": 742, "file_content_changes": "@@ -0,0 +1,742 @@\n+/*\n+    pybind11/detail/class.h: Python C API implementation details for py::class_\n+\n+    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"../attr.h\"\n+#include \"../options.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+#if !defined(PYPY_VERSION)\n+#    define PYBIND11_BUILTIN_QUALNAME\n+#    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)\n+#else\n+// In PyPy, we still set __qualname__ so that we can produce reliable function type\n+// signatures; in CPython this macro expands to nothing:\n+#    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)                                             \\\n+        setattr((PyObject *) obj, \"__qualname__\", nameobj)\n+#endif\n+\n+inline std::string get_fully_qualified_tp_name(PyTypeObject *type) {\n+#if !defined(PYPY_VERSION)\n+    return type->tp_name;\n+#else\n+    auto module_name = handle((PyObject *) type).attr(\"__module__\").cast<std::string>();\n+    if (module_name == PYBIND11_BUILTINS_MODULE)\n+        return type->tp_name;\n+    else\n+        return std::move(module_name) + \".\" + type->tp_name;\n+#endif\n+}\n+\n+inline PyTypeObject *type_incref(PyTypeObject *type) {\n+    Py_INCREF(type);\n+    return type;\n+}\n+\n+#if !defined(PYPY_VERSION)\n+\n+/// `pybind11_static_property.__get__()`: Always pass the class instead of the instance.\n+extern \"C\" inline PyObject *pybind11_static_get(PyObject *self, PyObject * /*ob*/, PyObject *cls) {\n+    return PyProperty_Type.tp_descr_get(self, cls, cls);\n+}\n+\n+/// `pybind11_static_property.__set__()`: Just like the above `__get__()`.\n+extern \"C\" inline int pybind11_static_set(PyObject *self, PyObject *obj, PyObject *value) {\n+    PyObject *cls = PyType_Check(obj) ? obj : (PyObject *) Py_TYPE(obj);\n+    return PyProperty_Type.tp_descr_set(self, cls, value);\n+}\n+\n+/** A `static_property` is the same as a `property` but the `__get__()` and `__set__()`\n+    methods are modified to always use the object type instead of a concrete instance.\n+    Return value: New reference. */\n+inline PyTypeObject *make_static_property_type() {\n+    constexpr auto *name = \"pybind11_static_property\";\n+    auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));\n+\n+    /* Danger zone: from now (and until PyType_Ready), make sure to\n+       issue no Python C API calls which could potentially invoke the\n+       garbage collector (the GC will call type_traverse(), which will in\n+       turn find the newly constructed type in an invalid state) */\n+    auto *heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);\n+    if (!heap_type) {\n+        pybind11_fail(\"make_static_property_type(): error allocating type!\");\n+    }\n+\n+    heap_type->ht_name = name_obj.inc_ref().ptr();\n+#    ifdef PYBIND11_BUILTIN_QUALNAME\n+    heap_type->ht_qualname = name_obj.inc_ref().ptr();\n+#    endif\n+\n+    auto *type = &heap_type->ht_type;\n+    type->tp_name = name;\n+    type->tp_base = type_incref(&PyProperty_Type);\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n+    type->tp_descr_get = pybind11_static_get;\n+    type->tp_descr_set = pybind11_static_set;\n+\n+    if (PyType_Ready(type) < 0) {\n+        pybind11_fail(\"make_static_property_type(): failure in PyType_Ready()!\");\n+    }\n+\n+    setattr((PyObject *) type, \"__module__\", str(\"pybind11_builtins\"));\n+    PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n+\n+    return type;\n+}\n+\n+#else // PYPY\n+\n+/** PyPy has some issues with the above C API, so we evaluate Python code instead.\n+    This function will only be called once so performance isn't really a concern.\n+    Return value: New reference. */\n+inline PyTypeObject *make_static_property_type() {\n+    auto d = dict();\n+    PyObject *result = PyRun_String(R\"(\\\n+class pybind11_static_property(property):\n+    def __get__(self, obj, cls):\n+        return property.__get__(self, cls, cls)\n+\n+    def __set__(self, obj, value):\n+        cls = obj if isinstance(obj, type) else type(obj)\n+        property.__set__(self, cls, value)\n+)\",\n+                                    Py_file_input,\n+                                    d.ptr(),\n+                                    d.ptr());\n+    if (result == nullptr)\n+        throw error_already_set();\n+    Py_DECREF(result);\n+    return (PyTypeObject *) d[\"pybind11_static_property\"].cast<object>().release().ptr();\n+}\n+\n+#endif // PYPY\n+\n+/** Types with static properties need to handle `Type.static_prop = x` in a specific way.\n+    By default, Python replaces the `static_property` itself, but for wrapped C++ types\n+    we need to call `static_property.__set__()` in order to propagate the new value to\n+    the underlying C++ data structure. */\n+extern \"C\" inline int pybind11_meta_setattro(PyObject *obj, PyObject *name, PyObject *value) {\n+    // Use `_PyType_Lookup()` instead of `PyObject_GetAttr()` in order to get the raw\n+    // descriptor (`property`) instead of calling `tp_descr_get` (`property.__get__()`).\n+    PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);\n+\n+    // The following assignment combinations are possible:\n+    //   1. `Type.static_prop = value`             --> descr_set: `Type.static_prop.__set__(value)`\n+    //   2. `Type.static_prop = other_static_prop` --> setattro:  replace existing `static_prop`\n+    //   3. `Type.regular_attribute = value`       --> setattro:  regular attribute assignment\n+    auto *const static_prop = (PyObject *) get_internals().static_property_type;\n+    const auto call_descr_set = (descr != nullptr) && (value != nullptr)\n+                                && (PyObject_IsInstance(descr, static_prop) != 0)\n+                                && (PyObject_IsInstance(value, static_prop) == 0);\n+    if (call_descr_set) {\n+        // Call `static_property.__set__()` instead of replacing the `static_property`.\n+#if !defined(PYPY_VERSION)\n+        return Py_TYPE(descr)->tp_descr_set(descr, obj, value);\n+#else\n+        if (PyObject *result = PyObject_CallMethod(descr, \"__set__\", \"OO\", obj, value)) {\n+            Py_DECREF(result);\n+            return 0;\n+        } else {\n+            return -1;\n+        }\n+#endif\n+    } else {\n+        // Replace existing attribute.\n+        return PyType_Type.tp_setattro(obj, name, value);\n+    }\n+}\n+\n+/**\n+ * Python 3's PyInstanceMethod_Type hides itself via its tp_descr_get, which prevents aliasing\n+ * methods via cls.attr(\"m2\") = cls.attr(\"m1\"): instead the tp_descr_get returns a plain function,\n+ * when called on a class, or a PyMethod, when called on an instance.  Override that behaviour here\n+ * to do a special case bypass for PyInstanceMethod_Types.\n+ */\n+extern \"C\" inline PyObject *pybind11_meta_getattro(PyObject *obj, PyObject *name) {\n+    PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);\n+    if (descr && PyInstanceMethod_Check(descr)) {\n+        Py_INCREF(descr);\n+        return descr;\n+    }\n+    return PyType_Type.tp_getattro(obj, name);\n+}\n+\n+/// metaclass `__call__` function that is used to create all pybind11 objects.\n+extern \"C\" inline PyObject *pybind11_meta_call(PyObject *type, PyObject *args, PyObject *kwargs) {\n+\n+    // use the default metaclass call to create/initialize the object\n+    PyObject *self = PyType_Type.tp_call(type, args, kwargs);\n+    if (self == nullptr) {\n+        return nullptr;\n+    }\n+\n+    // This must be a pybind11 instance\n+    auto *instance = reinterpret_cast<detail::instance *>(self);\n+\n+    // Ensure that the base __init__ function(s) were called\n+    for (const auto &vh : values_and_holders(instance)) {\n+        if (!vh.holder_constructed()) {\n+            PyErr_Format(PyExc_TypeError,\n+                         \"%.200s.__init__() must be called when overriding __init__\",\n+                         get_fully_qualified_tp_name(vh.type->type).c_str());\n+            Py_DECREF(self);\n+            return nullptr;\n+        }\n+    }\n+\n+    return self;\n+}\n+\n+/// Cleanup the type-info for a pybind11-registered type.\n+extern \"C\" inline void pybind11_meta_dealloc(PyObject *obj) {\n+    auto *type = (PyTypeObject *) obj;\n+    auto &internals = get_internals();\n+\n+    // A pybind11-registered type will:\n+    // 1) be found in internals.registered_types_py\n+    // 2) have exactly one associated `detail::type_info`\n+    auto found_type = internals.registered_types_py.find(type);\n+    if (found_type != internals.registered_types_py.end() && found_type->second.size() == 1\n+        && found_type->second[0]->type == type) {\n+\n+        auto *tinfo = found_type->second[0];\n+        auto tindex = std::type_index(*tinfo->cpptype);\n+        internals.direct_conversions.erase(tindex);\n+\n+        if (tinfo->module_local) {\n+            get_local_internals().registered_types_cpp.erase(tindex);\n+        } else {\n+            internals.registered_types_cpp.erase(tindex);\n+        }\n+        internals.registered_types_py.erase(tinfo->type);\n+\n+        // Actually just `std::erase_if`, but that's only available in C++20\n+        auto &cache = internals.inactive_override_cache;\n+        for (auto it = cache.begin(), last = cache.end(); it != last;) {\n+            if (it->first == (PyObject *) tinfo->type) {\n+                it = cache.erase(it);\n+            } else {\n+                ++it;\n+            }\n+        }\n+\n+        delete tinfo;\n+    }\n+\n+    PyType_Type.tp_dealloc(obj);\n+}\n+\n+/** This metaclass is assigned by default to all pybind11 types and is required in order\n+    for static properties to function correctly. Users may override this using `py::metaclass`.\n+    Return value: New reference. */\n+inline PyTypeObject *make_default_metaclass() {\n+    constexpr auto *name = \"pybind11_type\";\n+    auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));\n+\n+    /* Danger zone: from now (and until PyType_Ready), make sure to\n+       issue no Python C API calls which could potentially invoke the\n+       garbage collector (the GC will call type_traverse(), which will in\n+       turn find the newly constructed type in an invalid state) */\n+    auto *heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);\n+    if (!heap_type) {\n+        pybind11_fail(\"make_default_metaclass(): error allocating metaclass!\");\n+    }\n+\n+    heap_type->ht_name = name_obj.inc_ref().ptr();\n+#ifdef PYBIND11_BUILTIN_QUALNAME\n+    heap_type->ht_qualname = name_obj.inc_ref().ptr();\n+#endif\n+\n+    auto *type = &heap_type->ht_type;\n+    type->tp_name = name;\n+    type->tp_base = type_incref(&PyType_Type);\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n+\n+    type->tp_call = pybind11_meta_call;\n+\n+    type->tp_setattro = pybind11_meta_setattro;\n+    type->tp_getattro = pybind11_meta_getattro;\n+\n+    type->tp_dealloc = pybind11_meta_dealloc;\n+\n+    if (PyType_Ready(type) < 0) {\n+        pybind11_fail(\"make_default_metaclass(): failure in PyType_Ready()!\");\n+    }\n+\n+    setattr((PyObject *) type, \"__module__\", str(\"pybind11_builtins\"));\n+    PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n+\n+    return type;\n+}\n+\n+/// For multiple inheritance types we need to recursively register/deregister base pointers for any\n+/// base classes with pointers that are difference from the instance value pointer so that we can\n+/// correctly recognize an offset base class pointer. This calls a function with any offset base\n+/// ptrs.\n+inline void traverse_offset_bases(void *valueptr,\n+                                  const detail::type_info *tinfo,\n+                                  instance *self,\n+                                  bool (*f)(void * /*parentptr*/, instance * /*self*/)) {\n+    for (handle h : reinterpret_borrow<tuple>(tinfo->type->tp_bases)) {\n+        if (auto *parent_tinfo = get_type_info((PyTypeObject *) h.ptr())) {\n+            for (auto &c : parent_tinfo->implicit_casts) {\n+                if (c.first == tinfo->cpptype) {\n+                    auto *parentptr = c.second(valueptr);\n+                    if (parentptr != valueptr) {\n+                        f(parentptr, self);\n+                    }\n+                    traverse_offset_bases(parentptr, parent_tinfo, self, f);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+inline bool register_instance_impl(void *ptr, instance *self) {\n+    get_internals().registered_instances.emplace(ptr, self);\n+    return true; // unused, but gives the same signature as the deregister func\n+}\n+inline bool deregister_instance_impl(void *ptr, instance *self) {\n+    auto &registered_instances = get_internals().registered_instances;\n+    auto range = registered_instances.equal_range(ptr);\n+    for (auto it = range.first; it != range.second; ++it) {\n+        if (self == it->second) {\n+            registered_instances.erase(it);\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+inline void register_instance(instance *self, void *valptr, const type_info *tinfo) {\n+    register_instance_impl(valptr, self);\n+    if (!tinfo->simple_ancestors) {\n+        traverse_offset_bases(valptr, tinfo, self, register_instance_impl);\n+    }\n+}\n+\n+inline bool deregister_instance(instance *self, void *valptr, const type_info *tinfo) {\n+    bool ret = deregister_instance_impl(valptr, self);\n+    if (!tinfo->simple_ancestors) {\n+        traverse_offset_bases(valptr, tinfo, self, deregister_instance_impl);\n+    }\n+    return ret;\n+}\n+\n+/// Instance creation function for all pybind11 types. It allocates the internal instance layout\n+/// for holding C++ objects and holders.  Allocation is done lazily (the first time the instance is\n+/// cast to a reference or pointer), and initialization is done by an `__init__` function.\n+inline PyObject *make_new_instance(PyTypeObject *type) {\n+#if defined(PYPY_VERSION)\n+    // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first\n+    // inherited object is a plain Python type (i.e. not derived from an extension type).  Fix it.\n+    ssize_t instance_size = static_cast<ssize_t>(sizeof(instance));\n+    if (type->tp_basicsize < instance_size) {\n+        type->tp_basicsize = instance_size;\n+    }\n+#endif\n+    PyObject *self = type->tp_alloc(type, 0);\n+    auto *inst = reinterpret_cast<instance *>(self);\n+    // Allocate the value/holder internals:\n+    inst->allocate_layout();\n+\n+    return self;\n+}\n+\n+/// Instance creation function for all pybind11 types. It only allocates space for the\n+/// C++ object, but doesn't call the constructor -- an `__init__` function must do that.\n+extern \"C\" inline PyObject *pybind11_object_new(PyTypeObject *type, PyObject *, PyObject *) {\n+    return make_new_instance(type);\n+}\n+\n+/// An `__init__` function constructs the C++ object. Users should provide at least one\n+/// of these using `py::init` or directly with `.def(__init__, ...)`. Otherwise, the\n+/// following default function will be used which simply throws an exception.\n+extern \"C\" inline int pybind11_object_init(PyObject *self, PyObject *, PyObject *) {\n+    PyTypeObject *type = Py_TYPE(self);\n+    std::string msg = get_fully_qualified_tp_name(type) + \": No constructor defined!\";\n+    PyErr_SetString(PyExc_TypeError, msg.c_str());\n+    return -1;\n+}\n+\n+inline void add_patient(PyObject *nurse, PyObject *patient) {\n+    auto &internals = get_internals();\n+    auto *instance = reinterpret_cast<detail::instance *>(nurse);\n+    instance->has_patients = true;\n+    Py_INCREF(patient);\n+    internals.patients[nurse].push_back(patient);\n+}\n+\n+inline void clear_patients(PyObject *self) {\n+    auto *instance = reinterpret_cast<detail::instance *>(self);\n+    auto &internals = get_internals();\n+    auto pos = internals.patients.find(self);\n+    assert(pos != internals.patients.end());\n+    // Clearing the patients can cause more Python code to run, which\n+    // can invalidate the iterator. Extract the vector of patients\n+    // from the unordered_map first.\n+    auto patients = std::move(pos->second);\n+    internals.patients.erase(pos);\n+    instance->has_patients = false;\n+    for (PyObject *&patient : patients) {\n+        Py_CLEAR(patient);\n+    }\n+}\n+\n+/// Clears all internal data from the instance and removes it from registered instances in\n+/// preparation for deallocation.\n+inline void clear_instance(PyObject *self) {\n+    auto *instance = reinterpret_cast<detail::instance *>(self);\n+\n+    // Deallocate any values/holders, if present:\n+    for (auto &v_h : values_and_holders(instance)) {\n+        if (v_h) {\n+\n+            // We have to deregister before we call dealloc because, for virtual MI types, we still\n+            // need to be able to get the parent pointers.\n+            if (v_h.instance_registered()\n+                && !deregister_instance(instance, v_h.value_ptr(), v_h.type)) {\n+                pybind11_fail(\n+                    \"pybind11_object_dealloc(): Tried to deallocate unregistered instance!\");\n+            }\n+\n+            if (instance->owned || v_h.holder_constructed()) {\n+                v_h.type->dealloc(v_h);\n+            }\n+        }\n+    }\n+    // Deallocate the value/holder layout internals:\n+    instance->deallocate_layout();\n+\n+    if (instance->weakrefs) {\n+        PyObject_ClearWeakRefs(self);\n+    }\n+\n+    PyObject **dict_ptr = _PyObject_GetDictPtr(self);\n+    if (dict_ptr) {\n+        Py_CLEAR(*dict_ptr);\n+    }\n+\n+    if (instance->has_patients) {\n+        clear_patients(self);\n+    }\n+}\n+\n+/// Instance destructor function for all pybind11 types. It calls `type_info.dealloc`\n+/// to destroy the C++ object itself, while the rest is Python bookkeeping.\n+extern \"C\" inline void pybind11_object_dealloc(PyObject *self) {\n+    clear_instance(self);\n+\n+    auto *type = Py_TYPE(self);\n+    type->tp_free(self);\n+\n+#if PY_VERSION_HEX < 0x03080000\n+    // `type->tp_dealloc != pybind11_object_dealloc` means that we're being called\n+    // as part of a derived type's dealloc, in which case we're not allowed to decref\n+    // the type here. For cross-module compatibility, we shouldn't compare directly\n+    // with `pybind11_object_dealloc`, but with the common one stashed in internals.\n+    auto pybind11_object_type = (PyTypeObject *) get_internals().instance_base;\n+    if (type->tp_dealloc == pybind11_object_type->tp_dealloc)\n+        Py_DECREF(type);\n+#else\n+    // This was not needed before Python 3.8 (Python issue 35810)\n+    // https://github.com/pybind/pybind11/issues/1946\n+    Py_DECREF(type);\n+#endif\n+}\n+\n+std::string error_string();\n+\n+/** Create the type which can be used as a common base for all classes.  This is\n+    needed in order to satisfy Python's requirements for multiple inheritance.\n+    Return value: New reference. */\n+inline PyObject *make_object_base_type(PyTypeObject *metaclass) {\n+    constexpr auto *name = \"pybind11_object\";\n+    auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));\n+\n+    /* Danger zone: from now (and until PyType_Ready), make sure to\n+       issue no Python C API calls which could potentially invoke the\n+       garbage collector (the GC will call type_traverse(), which will in\n+       turn find the newly constructed type in an invalid state) */\n+    auto *heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);\n+    if (!heap_type) {\n+        pybind11_fail(\"make_object_base_type(): error allocating type!\");\n+    }\n+\n+    heap_type->ht_name = name_obj.inc_ref().ptr();\n+#ifdef PYBIND11_BUILTIN_QUALNAME\n+    heap_type->ht_qualname = name_obj.inc_ref().ptr();\n+#endif\n+\n+    auto *type = &heap_type->ht_type;\n+    type->tp_name = name;\n+    type->tp_base = type_incref(&PyBaseObject_Type);\n+    type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n+\n+    type->tp_new = pybind11_object_new;\n+    type->tp_init = pybind11_object_init;\n+    type->tp_dealloc = pybind11_object_dealloc;\n+\n+    /* Support weak references (needed for the keep_alive feature) */\n+    type->tp_weaklistoffset = offsetof(instance, weakrefs);\n+\n+    if (PyType_Ready(type) < 0) {\n+        pybind11_fail(\"PyType_Ready failed in make_object_base_type(): \" + error_string());\n+    }\n+\n+    setattr((PyObject *) type, \"__module__\", str(\"pybind11_builtins\"));\n+    PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n+\n+    assert(!PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));\n+    return (PyObject *) heap_type;\n+}\n+\n+/// dynamic_attr: Support for `d = instance.__dict__`.\n+extern \"C\" inline PyObject *pybind11_get_dict(PyObject *self, void *) {\n+    PyObject *&dict = *_PyObject_GetDictPtr(self);\n+    if (!dict) {\n+        dict = PyDict_New();\n+    }\n+    Py_XINCREF(dict);\n+    return dict;\n+}\n+\n+/// dynamic_attr: Support for `instance.__dict__ = dict()`.\n+extern \"C\" inline int pybind11_set_dict(PyObject *self, PyObject *new_dict, void *) {\n+    if (!PyDict_Check(new_dict)) {\n+        PyErr_Format(PyExc_TypeError,\n+                     \"__dict__ must be set to a dictionary, not a '%.200s'\",\n+                     get_fully_qualified_tp_name(Py_TYPE(new_dict)).c_str());\n+        return -1;\n+    }\n+    PyObject *&dict = *_PyObject_GetDictPtr(self);\n+    Py_INCREF(new_dict);\n+    Py_CLEAR(dict);\n+    dict = new_dict;\n+    return 0;\n+}\n+\n+/// dynamic_attr: Allow the garbage collector to traverse the internal instance `__dict__`.\n+extern \"C\" inline int pybind11_traverse(PyObject *self, visitproc visit, void *arg) {\n+    PyObject *&dict = *_PyObject_GetDictPtr(self);\n+    Py_VISIT(dict);\n+// https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse\n+#if PY_VERSION_HEX >= 0x03090000\n+    Py_VISIT(Py_TYPE(self));\n+#endif\n+    return 0;\n+}\n+\n+/// dynamic_attr: Allow the GC to clear the dictionary.\n+extern \"C\" inline int pybind11_clear(PyObject *self) {\n+    PyObject *&dict = *_PyObject_GetDictPtr(self);\n+    Py_CLEAR(dict);\n+    return 0;\n+}\n+\n+/// Give instances of this type a `__dict__` and opt into garbage collection.\n+inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type) {\n+    auto *type = &heap_type->ht_type;\n+    type->tp_flags |= Py_TPFLAGS_HAVE_GC;\n+#if PY_VERSION_HEX < 0x030B0000\n+    type->tp_dictoffset = type->tp_basicsize;           // place dict at the end\n+    type->tp_basicsize += (ssize_t) sizeof(PyObject *); // and allocate enough space for it\n+#else\n+    type->tp_flags |= Py_TPFLAGS_MANAGED_DICT;\n+#endif\n+    type->tp_traverse = pybind11_traverse;\n+    type->tp_clear = pybind11_clear;\n+\n+    static PyGetSetDef getset[] = {\n+        {const_cast<char *>(\"__dict__\"), pybind11_get_dict, pybind11_set_dict, nullptr, nullptr},\n+        {nullptr, nullptr, nullptr, nullptr, nullptr}};\n+    type->tp_getset = getset;\n+}\n+\n+/// buffer_protocol: Fill in the view as specified by flags.\n+extern \"C\" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view, int flags) {\n+    // Look for a `get_buffer` implementation in this type's info or any bases (following MRO).\n+    type_info *tinfo = nullptr;\n+    for (auto type : reinterpret_borrow<tuple>(Py_TYPE(obj)->tp_mro)) {\n+        tinfo = get_type_info((PyTypeObject *) type.ptr());\n+        if (tinfo && tinfo->get_buffer) {\n+            break;\n+        }\n+    }\n+    if (view == nullptr || !tinfo || !tinfo->get_buffer) {\n+        if (view) {\n+            view->obj = nullptr;\n+        }\n+        PyErr_SetString(PyExc_BufferError, \"pybind11_getbuffer(): Internal error\");\n+        return -1;\n+    }\n+    std::memset(view, 0, sizeof(Py_buffer));\n+    buffer_info *info = tinfo->get_buffer(obj, tinfo->get_buffer_data);\n+    if ((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE && info->readonly) {\n+        delete info;\n+        // view->obj = nullptr;  // Was just memset to 0, so not necessary\n+        PyErr_SetString(PyExc_BufferError, \"Writable buffer requested for readonly storage\");\n+        return -1;\n+    }\n+    view->obj = obj;\n+    view->ndim = 1;\n+    view->internal = info;\n+    view->buf = info->ptr;\n+    view->itemsize = info->itemsize;\n+    view->len = view->itemsize;\n+    for (auto s : info->shape) {\n+        view->len *= s;\n+    }\n+    view->readonly = static_cast<int>(info->readonly);\n+    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT) {\n+        view->format = const_cast<char *>(info->format.c_str());\n+    }\n+    if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES) {\n+        view->ndim = (int) info->ndim;\n+        view->strides = info->strides.data();\n+        view->shape = info->shape.data();\n+    }\n+    Py_INCREF(view->obj);\n+    return 0;\n+}\n+\n+/// buffer_protocol: Release the resources of the buffer.\n+extern \"C\" inline void pybind11_releasebuffer(PyObject *, Py_buffer *view) {\n+    delete (buffer_info *) view->internal;\n+}\n+\n+/// Give this type a buffer interface.\n+inline void enable_buffer_protocol(PyHeapTypeObject *heap_type) {\n+    heap_type->ht_type.tp_as_buffer = &heap_type->as_buffer;\n+\n+    heap_type->as_buffer.bf_getbuffer = pybind11_getbuffer;\n+    heap_type->as_buffer.bf_releasebuffer = pybind11_releasebuffer;\n+}\n+\n+/** Create a brand new Python type according to the `type_record` specification.\n+    Return value: New reference. */\n+inline PyObject *make_new_python_type(const type_record &rec) {\n+    auto name = reinterpret_steal<object>(PYBIND11_FROM_STRING(rec.name));\n+\n+    auto qualname = name;\n+    if (rec.scope && !PyModule_Check(rec.scope.ptr()) && hasattr(rec.scope, \"__qualname__\")) {\n+        qualname = reinterpret_steal<object>(\n+            PyUnicode_FromFormat(\"%U.%U\", rec.scope.attr(\"__qualname__\").ptr(), name.ptr()));\n+    }\n+\n+    object module_;\n+    if (rec.scope) {\n+        if (hasattr(rec.scope, \"__module__\")) {\n+            module_ = rec.scope.attr(\"__module__\");\n+        } else if (hasattr(rec.scope, \"__name__\")) {\n+            module_ = rec.scope.attr(\"__name__\");\n+        }\n+    }\n+\n+    const auto *full_name = c_str(\n+#if !defined(PYPY_VERSION)\n+        module_ ? str(module_).cast<std::string>() + \".\" + rec.name :\n+#endif\n+                rec.name);\n+\n+    char *tp_doc = nullptr;\n+    if (rec.doc && options::show_user_defined_docstrings()) {\n+        /* Allocate memory for docstring (using PyObject_MALLOC, since\n+           Python will free this later on) */\n+        size_t size = std::strlen(rec.doc) + 1;\n+        tp_doc = (char *) PyObject_MALLOC(size);\n+        std::memcpy((void *) tp_doc, rec.doc, size);\n+    }\n+\n+    auto &internals = get_internals();\n+    auto bases = tuple(rec.bases);\n+    auto *base = (bases.empty()) ? internals.instance_base : bases[0].ptr();\n+\n+    /* Danger zone: from now (and until PyType_Ready), make sure to\n+       issue no Python C API calls which could potentially invoke the\n+       garbage collector (the GC will call type_traverse(), which will in\n+       turn find the newly constructed type in an invalid state) */\n+    auto *metaclass\n+        = rec.metaclass.ptr() ? (PyTypeObject *) rec.metaclass.ptr() : internals.default_metaclass;\n+\n+    auto *heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);\n+    if (!heap_type) {\n+        pybind11_fail(std::string(rec.name) + \": Unable to create type object!\");\n+    }\n+\n+    heap_type->ht_name = name.release().ptr();\n+#ifdef PYBIND11_BUILTIN_QUALNAME\n+    heap_type->ht_qualname = qualname.inc_ref().ptr();\n+#endif\n+\n+    auto *type = &heap_type->ht_type;\n+    type->tp_name = full_name;\n+    type->tp_doc = tp_doc;\n+    type->tp_base = type_incref((PyTypeObject *) base);\n+    type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));\n+    if (!bases.empty()) {\n+        type->tp_bases = bases.release().ptr();\n+    }\n+\n+    /* Don't inherit base __init__ */\n+    type->tp_init = pybind11_object_init;\n+\n+    /* Supported protocols */\n+    type->tp_as_number = &heap_type->as_number;\n+    type->tp_as_sequence = &heap_type->as_sequence;\n+    type->tp_as_mapping = &heap_type->as_mapping;\n+    type->tp_as_async = &heap_type->as_async;\n+\n+    /* Flags */\n+    type->tp_flags |= Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE;\n+    if (!rec.is_final) {\n+        type->tp_flags |= Py_TPFLAGS_BASETYPE;\n+    }\n+\n+    if (rec.dynamic_attr) {\n+        enable_dynamic_attributes(heap_type);\n+    }\n+\n+    if (rec.buffer_protocol) {\n+        enable_buffer_protocol(heap_type);\n+    }\n+\n+    if (rec.custom_type_setup_callback) {\n+        rec.custom_type_setup_callback(heap_type);\n+    }\n+\n+    if (PyType_Ready(type) < 0) {\n+        pybind11_fail(std::string(rec.name) + \": PyType_Ready failed: \" + error_string());\n+    }\n+\n+    assert(!rec.dynamic_attr || PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));\n+\n+    /* Register type with the parent scope */\n+    if (rec.scope) {\n+        setattr(rec.scope, rec.name, (PyObject *) type);\n+    } else {\n+        Py_INCREF(type); // Keep it alive forever (reference leak)\n+    }\n+\n+    if (module_) { // Needed by pydoc\n+        setattr((PyObject *) type, \"__module__\", module_);\n+    }\n+\n+    PYBIND11_SET_OLDPY_QUALNAME(type, qualname);\n+\n+    return (PyObject *) type;\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/common.h", "status": "added", "additions": 1169, "deletions": 0, "changes": 1169, "file_content_changes": "@@ -0,0 +1,1169 @@\n+/*\n+    pybind11/detail/common.h -- Basic macros\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#define PYBIND11_VERSION_MAJOR 2\n+#define PYBIND11_VERSION_MINOR 10\n+#define PYBIND11_VERSION_PATCH 0\n+\n+// Similar to Python's convention: https://docs.python.org/3/c-api/apiabiversion.html\n+// Additional convention: 0xD = dev\n+#define PYBIND11_VERSION_HEX 0x020A0000\n+\n+#define PYBIND11_NAMESPACE_BEGIN(name) namespace name {\n+#define PYBIND11_NAMESPACE_END(name) }\n+\n+// Robust support for some features and loading modules compiled against different pybind versions\n+// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute\n+// on the main `pybind11` namespace.\n+#if !defined(PYBIND11_NAMESPACE)\n+#    ifdef __GNUG__\n+#        define PYBIND11_NAMESPACE pybind11 __attribute__((visibility(\"hidden\")))\n+#    else\n+#        define PYBIND11_NAMESPACE pybind11\n+#    endif\n+#endif\n+\n+#if !(defined(_MSC_VER) && __cplusplus == 199711L)\n+#    if __cplusplus >= 201402L\n+#        define PYBIND11_CPP14\n+#        if __cplusplus >= 201703L\n+#            define PYBIND11_CPP17\n+#            if __cplusplus >= 202002L\n+#                define PYBIND11_CPP20\n+// Please update tests/pybind11_tests.cpp `cpp_std()` when adding a macro here.\n+#            endif\n+#        endif\n+#    endif\n+#elif defined(_MSC_VER) && __cplusplus == 199711L\n+// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully\n+// implemented). Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3\n+// or newer.\n+#    if _MSVC_LANG >= 201402L\n+#        define PYBIND11_CPP14\n+#        if _MSVC_LANG > 201402L\n+#            define PYBIND11_CPP17\n+#            if _MSVC_LANG >= 202002L\n+#                define PYBIND11_CPP20\n+#            endif\n+#        endif\n+#    endif\n+#endif\n+\n+// Compiler version assertions\n+#if defined(__INTEL_COMPILER)\n+#    if __INTEL_COMPILER < 1800\n+#        error pybind11 requires Intel C++ compiler v18 or newer\n+#    elif __INTEL_COMPILER < 1900 && defined(PYBIND11_CPP14)\n+#        error pybind11 supports only C++11 with Intel C++ compiler v18. Use v19 or newer for C++14.\n+#    endif\n+/* The following pragma cannot be pop'ed:\n+   https://community.intel.com/t5/Intel-C-Compiler/Inline-and-no-inline-warning/td-p/1216764 */\n+#    pragma warning disable 2196 // warning #2196: routine is both \"inline\" and \"noinline\"\n+#elif defined(__clang__) && !defined(__apple_build_version__)\n+#    if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)\n+#        error pybind11 requires clang 3.3 or newer\n+#    endif\n+#elif defined(__clang__)\n+// Apple changes clang version macros to its Xcode version; the first Xcode release based on\n+// (upstream) clang 3.3 was Xcode 5:\n+#    if __clang_major__ < 5\n+#        error pybind11 requires Xcode/clang 5.0 or newer\n+#    endif\n+#elif defined(__GNUG__)\n+#    if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)\n+#        error pybind11 requires gcc 4.8 or newer\n+#    endif\n+#elif defined(_MSC_VER)\n+#    if _MSC_VER < 1910\n+#        error pybind11 2.10+ requires MSVC 2017 or newer\n+#    endif\n+#endif\n+\n+#if !defined(PYBIND11_EXPORT)\n+#    if defined(WIN32) || defined(_WIN32)\n+#        define PYBIND11_EXPORT __declspec(dllexport)\n+#    else\n+#        define PYBIND11_EXPORT __attribute__((visibility(\"default\")))\n+#    endif\n+#endif\n+\n+#if !defined(PYBIND11_EXPORT_EXCEPTION)\n+#    ifdef __MINGW32__\n+// workaround for:\n+// error: 'dllexport' implies default visibility, but xxx has already been declared with a\n+// different visibility\n+#        define PYBIND11_EXPORT_EXCEPTION\n+#    else\n+#        define PYBIND11_EXPORT_EXCEPTION PYBIND11_EXPORT\n+#    endif\n+#endif\n+\n+// For CUDA, GCC7, GCC8:\n+// PYBIND11_NOINLINE_FORCED is incompatible with `-Wattributes -Werror`.\n+// When defining PYBIND11_NOINLINE_FORCED, it is best to also use `-Wno-attributes`.\n+// However, the measured shared-library size saving when using noinline are only\n+// 1.7% for CUDA, -0.2% for GCC7, and 0.0% for GCC8 (using -DCMAKE_BUILD_TYPE=MinSizeRel,\n+// the default under pybind11/tests).\n+#if !defined(PYBIND11_NOINLINE_FORCED)                                                            \\\n+    && (defined(__CUDACC__) || (defined(__GNUC__) && (__GNUC__ == 7 || __GNUC__ == 8)))\n+#    define PYBIND11_NOINLINE_DISABLED\n+#endif\n+\n+// The PYBIND11_NOINLINE macro is for function DEFINITIONS.\n+// In contrast, FORWARD DECLARATIONS should never use this macro:\n+// https://stackoverflow.com/questions/9317473/forward-declaration-of-inline-functions\n+#if defined(PYBIND11_NOINLINE_DISABLED) // Option for maximum portability and experimentation.\n+#    define PYBIND11_NOINLINE inline\n+#elif defined(_MSC_VER)\n+#    define PYBIND11_NOINLINE __declspec(noinline) inline\n+#else\n+#    define PYBIND11_NOINLINE __attribute__((noinline)) inline\n+#endif\n+\n+#if defined(__MINGW32__)\n+// For unknown reasons all PYBIND11_DEPRECATED member trigger a warning when declared\n+// whether it is used or not\n+#    define PYBIND11_DEPRECATED(reason)\n+#elif defined(PYBIND11_CPP14)\n+#    define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]\n+#else\n+#    define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))\n+#endif\n+\n+#if defined(PYBIND11_CPP17)\n+#    define PYBIND11_MAYBE_UNUSED [[maybe_unused]]\n+#elif defined(_MSC_VER) && !defined(__clang__)\n+#    define PYBIND11_MAYBE_UNUSED\n+#else\n+#    define PYBIND11_MAYBE_UNUSED __attribute__((__unused__))\n+#endif\n+\n+/* Don't let Python.h #define (v)snprintf as macro because they are implemented\n+   properly in Visual Studio since 2015. */\n+#if defined(_MSC_VER)\n+#    define HAVE_SNPRINTF 1\n+#endif\n+\n+/// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode\n+#if defined(_MSC_VER)\n+#    pragma warning(push)\n+// C4505: 'PySlice_GetIndicesEx': unreferenced local function has been removed (PyPy only)\n+#    pragma warning(disable : 4505)\n+#    if defined(_DEBUG) && !defined(Py_DEBUG)\n+// Workaround for a VS 2022 issue.\n+// NOTE: This workaround knowingly violates the Python.h include order requirement:\n+// https://docs.python.org/3/c-api/intro.html#include-files\n+// See https://github.com/pybind/pybind11/pull/3497 for full context.\n+#        include <yvals.h>\n+#        if _MSVC_STL_VERSION >= 143\n+#            include <crtdefs.h>\n+#        endif\n+#        define PYBIND11_DEBUG_MARKER\n+#        undef _DEBUG\n+#    endif\n+#endif\n+\n+// https://en.cppreference.com/w/c/chrono/localtime\n+#if defined(__STDC_LIB_EXT1__) && !defined(__STDC_WANT_LIB_EXT1__)\n+#    define __STDC_WANT_LIB_EXT1__\n+#endif\n+\n+#ifdef __has_include\n+// std::optional (but including it in c++14 mode isn't allowed)\n+#    if defined(PYBIND11_CPP17) && __has_include(<optional>)\n+#        define PYBIND11_HAS_OPTIONAL 1\n+#    endif\n+// std::experimental::optional (but not allowed in c++11 mode)\n+#    if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \\\n+                                 !__has_include(<optional>))\n+#        define PYBIND11_HAS_EXP_OPTIONAL 1\n+#    endif\n+// std::variant\n+#    if defined(PYBIND11_CPP17) && __has_include(<variant>)\n+#        define PYBIND11_HAS_VARIANT 1\n+#    endif\n+#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)\n+#    define PYBIND11_HAS_OPTIONAL 1\n+#    define PYBIND11_HAS_VARIANT 1\n+#endif\n+\n+#if defined(PYBIND11_CPP17)\n+#    if defined(__has_include)\n+#        if __has_include(<string_view>)\n+#            define PYBIND11_HAS_STRING_VIEW\n+#        endif\n+#    elif defined(_MSC_VER)\n+#        define PYBIND11_HAS_STRING_VIEW\n+#    endif\n+#endif\n+\n+#if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L\n+#    define PYBIND11_HAS_U8STRING\n+#endif\n+\n+#include <Python.h>\n+#if PY_VERSION_HEX < 0x03060000\n+#    error \"PYTHON < 3.6 IS UNSUPPORTED. pybind11 v2.9 was the last to support Python 2 and 3.5.\"\n+#endif\n+#include <frameobject.h>\n+#include <pythread.h>\n+\n+/* Python #defines overrides on all sorts of core functions, which\n+   tends to weak havok in C++ codebases that expect these to work\n+   like regular functions (potentially with several overloads) */\n+#if defined(isalnum)\n+#    undef isalnum\n+#    undef isalpha\n+#    undef islower\n+#    undef isspace\n+#    undef isupper\n+#    undef tolower\n+#    undef toupper\n+#endif\n+\n+#if defined(copysign)\n+#    undef copysign\n+#endif\n+\n+#if defined(_MSC_VER)\n+#    if defined(PYBIND11_DEBUG_MARKER)\n+#        define _DEBUG\n+#        undef PYBIND11_DEBUG_MARKER\n+#    endif\n+#    pragma warning(pop)\n+#endif\n+\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n+#include <forward_list>\n+#include <memory>\n+#include <stdexcept>\n+#include <string>\n+#include <type_traits>\n+#include <typeindex>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+#if defined(__has_include)\n+#    if __has_include(<version>)\n+#        include <version>\n+#    endif\n+#endif\n+\n+// #define PYBIND11_STR_LEGACY_PERMISSIVE\n+// If DEFINED, pybind11::str can hold PyUnicodeObject or PyBytesObject\n+//             (probably surprising and never documented, but this was the\n+//             legacy behavior until and including v2.6.x). As a side-effect,\n+//             pybind11::isinstance<str>() is true for both pybind11::str and\n+//             pybind11::bytes.\n+// If UNDEFINED, pybind11::str can only hold PyUnicodeObject, and\n+//               pybind11::isinstance<str>() is true only for pybind11::str.\n+//               However, for Python 2 only (!), the pybind11::str caster\n+//               implicitly decoded bytes to PyUnicodeObject. This was to ease\n+//               the transition from the legacy behavior to the non-permissive\n+//               behavior.\n+\n+/// Compatibility macros for Python 2 / Python 3 versions TODO: remove\n+#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)\n+#define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check\n+#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION\n+#define PYBIND11_BYTES_CHECK PyBytes_Check\n+#define PYBIND11_BYTES_FROM_STRING PyBytes_FromString\n+#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize\n+#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize\n+#define PYBIND11_BYTES_AS_STRING PyBytes_AsString\n+#define PYBIND11_BYTES_SIZE PyBytes_Size\n+#define PYBIND11_LONG_CHECK(o) PyLong_Check(o)\n+#define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)\n+#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) (o))\n+#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) (o))\n+#define PYBIND11_BYTES_NAME \"bytes\"\n+#define PYBIND11_STRING_NAME \"str\"\n+#define PYBIND11_SLICE_OBJECT PyObject\n+#define PYBIND11_FROM_STRING PyUnicode_FromString\n+#define PYBIND11_STR_TYPE ::pybind11::str\n+#define PYBIND11_BOOL_ATTR \"__bool__\"\n+#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)\n+#define PYBIND11_BUILTINS_MODULE \"builtins\"\n+// Providing a separate declaration to make Clang's -Wmissing-prototypes happy.\n+// See comment for PYBIND11_MODULE below for why this is marked \"maybe unused\".\n+#define PYBIND11_PLUGIN_IMPL(name)                                                                \\\n+    extern \"C\" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT PyObject *PyInit_##name();                   \\\n+    extern \"C\" PYBIND11_EXPORT PyObject *PyInit_##name()\n+\n+#define PYBIND11_TRY_NEXT_OVERLOAD ((PyObject *) 1) // special failure return code\n+#define PYBIND11_STRINGIFY(x) #x\n+#define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)\n+#define PYBIND11_CONCAT(first, second) first##second\n+#define PYBIND11_ENSURE_INTERNALS_READY pybind11::detail::get_internals();\n+\n+#define PYBIND11_CHECK_PYTHON_VERSION                                                             \\\n+    {                                                                                             \\\n+        const char *compiled_ver                                                                  \\\n+            = PYBIND11_TOSTRING(PY_MAJOR_VERSION) \".\" PYBIND11_TOSTRING(PY_MINOR_VERSION);        \\\n+        const char *runtime_ver = Py_GetVersion();                                                \\\n+        size_t len = std::strlen(compiled_ver);                                                   \\\n+        if (std::strncmp(runtime_ver, compiled_ver, len) != 0                                     \\\n+            || (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {                            \\\n+            PyErr_Format(PyExc_ImportError,                                                       \\\n+                         \"Python version mismatch: module was compiled for Python %s, \"           \\\n+                         \"but the interpreter version is incompatible: %s.\",                      \\\n+                         compiled_ver,                                                            \\\n+                         runtime_ver);                                                            \\\n+            return nullptr;                                                                       \\\n+        }                                                                                         \\\n+    }\n+\n+#define PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \\\n+    catch (pybind11::error_already_set & e) {                                                     \\\n+        pybind11::raise_from(e, PyExc_ImportError, \"initialization failed\");                      \\\n+        return nullptr;                                                                           \\\n+    }                                                                                             \\\n+    catch (const std::exception &e) {                                                             \\\n+        PyErr_SetString(PyExc_ImportError, e.what());                                             \\\n+        return nullptr;                                                                           \\\n+    }\n+\n+/** \\rst\n+    ***Deprecated in favor of PYBIND11_MODULE***\n+\n+    This macro creates the entry point that will be invoked when the Python interpreter\n+    imports a plugin library. Please create a `module_` in the function body and return\n+    the pointer to its underlying Python object at the end.\n+\n+    .. code-block:: cpp\n+\n+        PYBIND11_PLUGIN(example) {\n+            pybind11::module_ m(\"example\", \"pybind11 example plugin\");\n+            /// Set up bindings here\n+            return m.ptr();\n+        }\n+\\endrst */\n+#define PYBIND11_PLUGIN(name)                                                                     \\\n+    PYBIND11_DEPRECATED(\"PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE\")                     \\\n+    static PyObject *pybind11_init();                                                             \\\n+    PYBIND11_PLUGIN_IMPL(name) {                                                                  \\\n+        PYBIND11_CHECK_PYTHON_VERSION                                                             \\\n+        PYBIND11_ENSURE_INTERNALS_READY                                                           \\\n+        try {                                                                                     \\\n+            return pybind11_init();                                                               \\\n+        }                                                                                         \\\n+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \\\n+    }                                                                                             \\\n+    PyObject *pybind11_init()\n+\n+/** \\rst\n+    This macro creates the entry point that will be invoked when the Python interpreter\n+    imports an extension module. The module name is given as the fist argument and it\n+    should not be in quotes. The second macro argument defines a variable of type\n+    `py::module_` which can be used to initialize the module.\n+\n+    The entry point is marked as \"maybe unused\" to aid dead-code detection analysis:\n+    since the entry point is typically only looked up at runtime and not referenced\n+    during translation, it would otherwise appear as unused (\"dead\") code.\n+\n+    .. code-block:: cpp\n+\n+        PYBIND11_MODULE(example, m) {\n+            m.doc() = \"pybind11 example module\";\n+\n+            // Add bindings here\n+            m.def(\"foo\", []() {\n+                return \"Hello, World!\";\n+            });\n+        }\n+\\endrst */\n+#define PYBIND11_MODULE(name, variable)                                                           \\\n+    static ::pybind11::module_::module_def PYBIND11_CONCAT(pybind11_module_def_, name)            \\\n+        PYBIND11_MAYBE_UNUSED;                                                                    \\\n+    PYBIND11_MAYBE_UNUSED                                                                         \\\n+    static void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ &);                     \\\n+    PYBIND11_PLUGIN_IMPL(name) {                                                                  \\\n+        PYBIND11_CHECK_PYTHON_VERSION                                                             \\\n+        PYBIND11_ENSURE_INTERNALS_READY                                                           \\\n+        auto m = ::pybind11::module_::create_extension_module(                                    \\\n+            PYBIND11_TOSTRING(name), nullptr, &PYBIND11_CONCAT(pybind11_module_def_, name));      \\\n+        try {                                                                                     \\\n+            PYBIND11_CONCAT(pybind11_init_, name)(m);                                             \\\n+            return m.ptr();                                                                       \\\n+        }                                                                                         \\\n+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \\\n+    }                                                                                             \\\n+    void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ & (variable))\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+using ssize_t = Py_ssize_t;\n+using size_t = std::size_t;\n+\n+template <typename IntType>\n+inline ssize_t ssize_t_cast(const IntType &val) {\n+    static_assert(sizeof(IntType) <= sizeof(ssize_t), \"Implicit narrowing is not permitted.\");\n+    return static_cast<ssize_t>(val);\n+}\n+\n+/// Approach used to cast a previously unknown C++ instance into a Python object\n+enum class return_value_policy : uint8_t {\n+    /** This is the default return value policy, which falls back to the policy\n+        return_value_policy::take_ownership when the return value is a pointer.\n+        Otherwise, it uses return_value::move or return_value::copy for rvalue\n+        and lvalue references, respectively. See below for a description of what\n+        all of these different policies do. */\n+    automatic = 0,\n+\n+    /** As above, but use policy return_value_policy::reference when the return\n+        value is a pointer. This is the default conversion policy for function\n+        arguments when calling Python functions manually from C++ code (i.e. via\n+        handle::operator()). You probably won't need to use this. */\n+    automatic_reference,\n+\n+    /** Reference an existing object (i.e. do not create a new copy) and take\n+        ownership. Python will call the destructor and delete operator when the\n+        object's reference count reaches zero. Undefined behavior ensues when\n+        the C++ side does the same.. */\n+    take_ownership,\n+\n+    /** Create a new copy of the returned object, which will be owned by\n+        Python. This policy is comparably safe because the lifetimes of the two\n+        instances are decoupled. */\n+    copy,\n+\n+    /** Use std::move to move the return value contents into a new instance\n+        that will be owned by Python. This policy is comparably safe because the\n+        lifetimes of the two instances (move source and destination) are\n+        decoupled. */\n+    move,\n+\n+    /** Reference an existing object, but do not take ownership. The C++ side\n+        is responsible for managing the object's lifetime and deallocating it\n+        when it is no longer used. Warning: undefined behavior will ensue when\n+        the C++ side deletes an object that is still referenced and used by\n+        Python. */\n+    reference,\n+\n+    /** This policy only applies to methods and properties. It references the\n+        object without taking ownership similar to the above\n+        return_value_policy::reference policy. In contrast to that policy, the\n+        function or property's implicit this argument (called the parent) is\n+        considered to be the the owner of the return value (the child).\n+        pybind11 then couples the lifetime of the parent to the child via a\n+        reference relationship that ensures that the parent cannot be garbage\n+        collected while Python is still using the child. More advanced\n+        variations of this scheme are also possible using combinations of\n+        return_value_policy::reference and the keep_alive call policy */\n+    reference_internal\n+};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+inline static constexpr int log2(size_t n, int k = 0) {\n+    return (n <= 1) ? k : log2(n >> 1, k + 1);\n+}\n+\n+// Returns the size as a multiple of sizeof(void *), rounded up.\n+inline static constexpr size_t size_in_ptrs(size_t s) {\n+    return 1 + ((s - 1) >> log2(sizeof(void *)));\n+}\n+\n+/**\n+ * The space to allocate for simple layout instance holders (see below) in multiple of the size of\n+ * a pointer (e.g.  2 means 16 bytes on 64-bit architectures).  The default is the minimum required\n+ * to holder either a std::unique_ptr or std::shared_ptr (which is almost always\n+ * sizeof(std::shared_ptr<T>)).\n+ */\n+constexpr size_t instance_simple_holder_in_ptrs() {\n+    static_assert(sizeof(std::shared_ptr<int>) >= sizeof(std::unique_ptr<int>),\n+                  \"pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs\");\n+    return size_in_ptrs(sizeof(std::shared_ptr<int>));\n+}\n+\n+// Forward declarations\n+struct type_info;\n+struct value_and_holder;\n+\n+struct nonsimple_values_and_holders {\n+    void **values_and_holders;\n+    uint8_t *status;\n+};\n+\n+/// The 'instance' type which needs to be standard layout (need to be able to use 'offsetof')\n+struct instance {\n+    PyObject_HEAD\n+    /// Storage for pointers and holder; see simple_layout, below, for a description\n+    union {\n+        void *simple_value_holder[1 + instance_simple_holder_in_ptrs()];\n+        nonsimple_values_and_holders nonsimple;\n+    };\n+    /// Weak references\n+    PyObject *weakrefs;\n+    /// If true, the pointer is owned which means we're free to manage it with a holder.\n+    bool owned : 1;\n+    /**\n+     * An instance has two possible value/holder layouts.\n+     *\n+     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a\n+     * pointer and the holder object governing that pointer, i.e. [val1*][holder].  This layout is\n+     * applied whenever there is no python-side multiple inheritance of bound C++ types *and* the\n+     * type's holder will fit in the default space (which is large enough to hold either a\n+     * std::unique_ptr or std::shared_ptr).\n+     *\n+     * Non-simple layout applies when using custom holders that require more space than\n+     * `shared_ptr` (which is typically the size of two pointers), or when multiple inheritance is\n+     * used on the python side.  Non-simple layout allocates the required amount of memory to have\n+     * multiple bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is\n+     * set to a pointer to allocated space of the required space to hold a sequence of value\n+     * pointers and holders followed `status`, a set of bit flags (1 byte each), i.e.\n+     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple\n+     * of `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the beginning of\n+     * the [bb...] block (but not independently allocated).\n+     *\n+     * Status bits indicate whether the associated holder is constructed (&\n+     * status_holder_constructed) and whether the value pointer is registered (&\n+     * status_instance_registered) in `registered_instances`.\n+     */\n+    bool simple_layout : 1;\n+    /// For simple layout, tracks whether the holder has been constructed\n+    bool simple_holder_constructed : 1;\n+    /// For simple layout, tracks whether the instance is registered in `registered_instances`\n+    bool simple_instance_registered : 1;\n+    /// If true, get_internals().patients has an entry for this object\n+    bool has_patients : 1;\n+\n+    /// Initializes all of the above type/values/holders data (but not the instance values\n+    /// themselves)\n+    void allocate_layout();\n+\n+    /// Destroys/deallocates all of the above\n+    void deallocate_layout();\n+\n+    /// Returns the value_and_holder wrapper for the given type (or the first, if `find_type`\n+    /// omitted).  Returns a default-constructed (with `.inst = nullptr`) object on failure if\n+    /// `throw_if_missing` is false.\n+    value_and_holder get_value_and_holder(const type_info *find_type = nullptr,\n+                                          bool throw_if_missing = true);\n+\n+    /// Bit values for the non-simple status flags\n+    static constexpr uint8_t status_holder_constructed = 1;\n+    static constexpr uint8_t status_instance_registered = 2;\n+};\n+\n+static_assert(std::is_standard_layout<instance>::value,\n+              \"Internal error: `pybind11::detail::instance` is not standard layout!\");\n+\n+/// from __cpp_future__ import (convenient aliases from C++14/17)\n+#if defined(PYBIND11_CPP14)\n+using std::conditional_t;\n+using std::enable_if_t;\n+using std::remove_cv_t;\n+using std::remove_reference_t;\n+#else\n+template <bool B, typename T = void>\n+using enable_if_t = typename std::enable_if<B, T>::type;\n+template <bool B, typename T, typename F>\n+using conditional_t = typename std::conditional<B, T, F>::type;\n+template <typename T>\n+using remove_cv_t = typename std::remove_cv<T>::type;\n+template <typename T>\n+using remove_reference_t = typename std::remove_reference<T>::type;\n+#endif\n+\n+#if defined(PYBIND11_CPP20)\n+using std::remove_cvref;\n+using std::remove_cvref_t;\n+#else\n+template <class T>\n+struct remove_cvref {\n+    using type = remove_cv_t<remove_reference_t<T>>;\n+};\n+template <class T>\n+using remove_cvref_t = typename remove_cvref<T>::type;\n+#endif\n+\n+/// Index sequences\n+#if defined(PYBIND11_CPP14)\n+using std::index_sequence;\n+using std::make_index_sequence;\n+#else\n+template <size_t...>\n+struct index_sequence {};\n+template <size_t N, size_t... S>\n+struct make_index_sequence_impl : make_index_sequence_impl<N - 1, N - 1, S...> {};\n+template <size_t... S>\n+struct make_index_sequence_impl<0, S...> {\n+    using type = index_sequence<S...>;\n+};\n+template <size_t N>\n+using make_index_sequence = typename make_index_sequence_impl<N>::type;\n+#endif\n+\n+/// Make an index sequence of the indices of true arguments\n+template <typename ISeq, size_t, bool...>\n+struct select_indices_impl {\n+    using type = ISeq;\n+};\n+template <size_t... IPrev, size_t I, bool B, bool... Bs>\n+struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>\n+    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>,\n+                          I + 1,\n+                          Bs...> {};\n+template <bool... Bs>\n+using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;\n+\n+/// Backports of std::bool_constant and std::negation to accommodate older compilers\n+template <bool B>\n+using bool_constant = std::integral_constant<bool, B>;\n+template <typename T>\n+struct negation : bool_constant<!T::value> {};\n+\n+// PGI/Intel cannot detect operator delete with the \"compatible\" void_t impl, so\n+// using the new one (C++14 defect, so generally works on newer compilers, even\n+// if not in C++17 mode)\n+#if defined(__PGIC__) || defined(__INTEL_COMPILER)\n+template <typename...>\n+using void_t = void;\n+#else\n+template <typename...>\n+struct void_t_impl {\n+    using type = void;\n+};\n+template <typename... Ts>\n+using void_t = typename void_t_impl<Ts...>::type;\n+#endif\n+\n+/// Compile-time all/any/none of that check the boolean value of all template types\n+#if defined(__cpp_fold_expressions) && !(defined(_MSC_VER) && (_MSC_VER < 1916))\n+template <class... Ts>\n+using all_of = bool_constant<(Ts::value && ...)>;\n+template <class... Ts>\n+using any_of = bool_constant<(Ts::value || ...)>;\n+#elif !defined(_MSC_VER)\n+template <bool...>\n+struct bools {};\n+template <class... Ts>\n+using all_of = std::is_same<bools<Ts::value..., true>, bools<true, Ts::value...>>;\n+template <class... Ts>\n+using any_of = negation<all_of<negation<Ts>...>>;\n+#else\n+// MSVC has trouble with the above, but supports std::conjunction, which we can use instead (albeit\n+// at a slight loss of compilation efficiency).\n+template <class... Ts>\n+using all_of = std::conjunction<Ts...>;\n+template <class... Ts>\n+using any_of = std::disjunction<Ts...>;\n+#endif\n+template <class... Ts>\n+using none_of = negation<any_of<Ts...>>;\n+\n+template <class T, template <class> class... Predicates>\n+using satisfies_all_of = all_of<Predicates<T>...>;\n+template <class T, template <class> class... Predicates>\n+using satisfies_any_of = any_of<Predicates<T>...>;\n+template <class T, template <class> class... Predicates>\n+using satisfies_none_of = none_of<Predicates<T>...>;\n+\n+/// Strip the class from a method type\n+template <typename T>\n+struct remove_class {};\n+template <typename C, typename R, typename... A>\n+struct remove_class<R (C::*)(A...)> {\n+    using type = R(A...);\n+};\n+template <typename C, typename R, typename... A>\n+struct remove_class<R (C::*)(A...) const> {\n+    using type = R(A...);\n+};\n+\n+/// Helper template to strip away type modifiers\n+template <typename T>\n+struct intrinsic_type {\n+    using type = T;\n+};\n+template <typename T>\n+struct intrinsic_type<const T> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T>\n+struct intrinsic_type<T *> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T>\n+struct intrinsic_type<T &> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T>\n+struct intrinsic_type<T &&> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T, size_t N>\n+struct intrinsic_type<const T[N]> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T, size_t N>\n+struct intrinsic_type<T[N]> {\n+    using type = typename intrinsic_type<T>::type;\n+};\n+template <typename T>\n+using intrinsic_t = typename intrinsic_type<T>::type;\n+\n+/// Helper type to replace 'void' in some expressions\n+struct void_type {};\n+\n+/// Helper template which holds a list of types\n+template <typename...>\n+struct type_list {};\n+\n+/// Compile-time integer sum\n+#ifdef __cpp_fold_expressions\n+template <typename... Ts>\n+constexpr size_t constexpr_sum(Ts... ns) {\n+    return (0 + ... + size_t{ns});\n+}\n+#else\n+constexpr size_t constexpr_sum() { return 0; }\n+template <typename T, typename... Ts>\n+constexpr size_t constexpr_sum(T n, Ts... ns) {\n+    return size_t{n} + constexpr_sum(ns...);\n+}\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(constexpr_impl)\n+/// Implementation details for constexpr functions\n+constexpr int first(int i) { return i; }\n+template <typename T, typename... Ts>\n+constexpr int first(int i, T v, Ts... vs) {\n+    return v ? i : first(i + 1, vs...);\n+}\n+\n+constexpr int last(int /*i*/, int result) { return result; }\n+template <typename T, typename... Ts>\n+constexpr int last(int i, int result, T v, Ts... vs) {\n+    return last(i + 1, v ? i : result, vs...);\n+}\n+PYBIND11_NAMESPACE_END(constexpr_impl)\n+\n+/// Return the index of the first type in Ts which satisfies Predicate<T>.\n+/// Returns sizeof...(Ts) if none match.\n+template <template <typename> class Predicate, typename... Ts>\n+constexpr int constexpr_first() {\n+    return constexpr_impl::first(0, Predicate<Ts>::value...);\n+}\n+\n+/// Return the index of the last type in Ts which satisfies Predicate<T>, or -1 if none match.\n+template <template <typename> class Predicate, typename... Ts>\n+constexpr int constexpr_last() {\n+    return constexpr_impl::last(0, -1, Predicate<Ts>::value...);\n+}\n+\n+/// Return the Nth element from the parameter pack\n+template <size_t N, typename T, typename... Ts>\n+struct pack_element {\n+    using type = typename pack_element<N - 1, Ts...>::type;\n+};\n+template <typename T, typename... Ts>\n+struct pack_element<0, T, Ts...> {\n+    using type = T;\n+};\n+\n+/// Return the one and only type which matches the predicate, or Default if none match.\n+/// If more than one type matches the predicate, fail at compile-time.\n+template <template <typename> class Predicate, typename Default, typename... Ts>\n+struct exactly_one {\n+    static constexpr auto found = constexpr_sum(Predicate<Ts>::value...);\n+    static_assert(found <= 1, \"Found more than one type matching the predicate\");\n+\n+    static constexpr auto index = found ? constexpr_first<Predicate, Ts...>() : 0;\n+    using type = conditional_t<found, typename pack_element<index, Ts...>::type, Default>;\n+};\n+template <template <typename> class P, typename Default>\n+struct exactly_one<P, Default> {\n+    using type = Default;\n+};\n+\n+template <template <typename> class Predicate, typename Default, typename... Ts>\n+using exactly_one_t = typename exactly_one<Predicate, Default, Ts...>::type;\n+\n+/// Defer the evaluation of type T until types Us are instantiated\n+template <typename T, typename... /*Us*/>\n+struct deferred_type {\n+    using type = T;\n+};\n+template <typename T, typename... Us>\n+using deferred_t = typename deferred_type<T, Us...>::type;\n+\n+/// Like is_base_of, but requires a strict base (i.e. `is_strict_base_of<T, T>::value == false`,\n+/// unlike `std::is_base_of`)\n+template <typename Base, typename Derived>\n+using is_strict_base_of\n+    = bool_constant<std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;\n+\n+/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived\n+/// pointer can be converted to a Base pointer) For unions, `is_base_of<T, T>::value` is False, so\n+/// we need to check `is_same` as well.\n+template <typename Base, typename Derived>\n+using is_accessible_base_of\n+    = bool_constant<(std::is_same<Base, Derived>::value || std::is_base_of<Base, Derived>::value)\n+                    && std::is_convertible<Derived *, Base *>::value>;\n+\n+template <template <typename...> class Base>\n+struct is_template_base_of_impl {\n+    template <typename... Us>\n+    static std::true_type check(Base<Us...> *);\n+    static std::false_type check(...);\n+};\n+\n+/// Check if a template is the base of a type. For example:\n+/// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U can be anything\n+template <template <typename...> class Base, typename T>\n+// Sadly, all MSVC versions incl. 2022 need the workaround, even in C++20 mode.\n+// See also: https://github.com/pybind/pybind11/pull/3741\n+#if !defined(_MSC_VER)\n+using is_template_base_of\n+    = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr));\n+#else\n+struct is_template_base_of\n+    : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr)) {\n+};\n+#endif\n+\n+/// Check if T is an instantiation of the template `Class`. For example:\n+/// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U can be anything.\n+template <template <typename...> class Class, typename T>\n+struct is_instantiation : std::false_type {};\n+template <template <typename...> class Class, typename... Us>\n+struct is_instantiation<Class, Class<Us...>> : std::true_type {};\n+\n+/// Check if T is std::shared_ptr<U> where U can be anything\n+template <typename T>\n+using is_shared_ptr = is_instantiation<std::shared_ptr, T>;\n+\n+/// Check if T looks like an input iterator\n+template <typename T, typename = void>\n+struct is_input_iterator : std::false_type {};\n+template <typename T>\n+struct is_input_iterator<T,\n+                         void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>\n+    : std::true_type {};\n+\n+template <typename T>\n+using is_function_pointer\n+    = bool_constant<std::is_pointer<T>::value\n+                    && std::is_function<typename std::remove_pointer<T>::type>::value>;\n+\n+template <typename F>\n+struct strip_function_object {\n+    // If you are encountering an\n+    // 'error: name followed by \"::\" must be a class or namespace name'\n+    // with the Intel compiler and a noexcept function here,\n+    // try to use noexcept(true) instead of plain noexcept.\n+    using type = typename remove_class<decltype(&F::operator())>::type;\n+};\n+\n+// Extracts the function signature from a function, function pointer or lambda.\n+template <typename Function, typename F = remove_reference_t<Function>>\n+using function_signature_t = conditional_t<\n+    std::is_function<F>::value,\n+    F,\n+    typename conditional_t<std::is_pointer<F>::value || std::is_member_pointer<F>::value,\n+                           std::remove_pointer<F>,\n+                           strip_function_object<F>>::type>;\n+\n+/// Returns true if the type looks like a lambda: that is, isn't a function, pointer or member\n+/// pointer.  Note that this can catch all sorts of other things, too; this is intended to be used\n+/// in a place where passing a lambda makes sense.\n+template <typename T>\n+using is_lambda = satisfies_none_of<remove_reference_t<T>,\n+                                    std::is_function,\n+                                    std::is_pointer,\n+                                    std::is_member_pointer>;\n+\n+// [workaround(intel)] Internal error on fold expression\n+/// Apply a function over each element of a parameter pack\n+#if defined(__cpp_fold_expressions) && !defined(__INTEL_COMPILER)\n+// Intel compiler produces an internal error on this fold expression (tested with ICC 19.0.2)\n+#    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)\n+#else\n+using expand_side_effects = bool[];\n+#    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN)                                                 \\\n+        (void) pybind11::detail::expand_side_effects { ((PATTERN), void(), false)..., false }\n+#endif\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+#if defined(_MSC_VER)\n+#    pragma warning(push)\n+#    pragma warning(disable : 4275)\n+//     warning C4275: An exported class was derived from a class that wasn't exported.\n+//     Can be ignored when derived from a STL class.\n+#endif\n+/// C++ bindings of builtin Python exceptions\n+class PYBIND11_EXPORT_EXCEPTION builtin_exception : public std::runtime_error {\n+public:\n+    using std::runtime_error::runtime_error;\n+    /// Set the error using the Python C API\n+    virtual void set_error() const = 0;\n+};\n+#if defined(_MSC_VER)\n+#    pragma warning(pop)\n+#endif\n+\n+#define PYBIND11_RUNTIME_EXCEPTION(name, type)                                                    \\\n+    class PYBIND11_EXPORT_EXCEPTION name : public builtin_exception {                             \\\n+    public:                                                                                       \\\n+        using builtin_exception::builtin_exception;                                               \\\n+        name() : name(\"\") {}                                                                      \\\n+        void set_error() const override { PyErr_SetString(type, what()); }                        \\\n+    };\n+\n+PYBIND11_RUNTIME_EXCEPTION(stop_iteration, PyExc_StopIteration)\n+PYBIND11_RUNTIME_EXCEPTION(index_error, PyExc_IndexError)\n+PYBIND11_RUNTIME_EXCEPTION(key_error, PyExc_KeyError)\n+PYBIND11_RUNTIME_EXCEPTION(value_error, PyExc_ValueError)\n+PYBIND11_RUNTIME_EXCEPTION(type_error, PyExc_TypeError)\n+PYBIND11_RUNTIME_EXCEPTION(buffer_error, PyExc_BufferError)\n+PYBIND11_RUNTIME_EXCEPTION(import_error, PyExc_ImportError)\n+PYBIND11_RUNTIME_EXCEPTION(attribute_error, PyExc_AttributeError)\n+PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or\n+                                                           /// handle::call fail due to a type\n+                                                           /// casting error\n+PYBIND11_RUNTIME_EXCEPTION(reference_cast_error, PyExc_RuntimeError) /// Used internally\n+\n+[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const char *reason) {\n+    assert(!PyErr_Occurred());\n+    throw std::runtime_error(reason);\n+}\n+[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const std::string &reason) {\n+    assert(!PyErr_Occurred());\n+    throw std::runtime_error(reason);\n+}\n+\n+template <typename T, typename SFINAE = void>\n+struct format_descriptor {};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+// Returns the index of the given type in the type char array below, and in the list in numpy.h\n+// The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;\n+// complex float,double,long double.  Note that the long double types only participate when long\n+// double is actually longer than double (it isn't under MSVC).\n+// NB: not only the string below but also complex.h and numpy.h rely on this order.\n+template <typename T, typename SFINAE = void>\n+struct is_fmt_numeric {\n+    static constexpr bool value = false;\n+};\n+template <typename T>\n+struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {\n+    static constexpr bool value = true;\n+    static constexpr int index\n+        = std::is_same<T, bool>::value\n+              ? 0\n+              : 1\n+                    + (std::is_integral<T>::value\n+                           ? detail::log2(sizeof(T)) * 2 + std::is_unsigned<T>::value\n+                           : 8\n+                                 + (std::is_same<T, double>::value        ? 1\n+                                    : std::is_same<T, long double>::value ? 2\n+                                                                          : 0));\n+};\n+PYBIND11_NAMESPACE_END(detail)\n+\n+template <typename T>\n+struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {\n+    static constexpr const char c = \"?bBhHiIqQfdg\"[detail::is_fmt_numeric<T>::index];\n+    static constexpr const char value[2] = {c, '\\0'};\n+    static std::string format() { return std::string(1, c); }\n+};\n+\n+#if !defined(PYBIND11_CPP17)\n+\n+template <typename T>\n+constexpr const char\n+    format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];\n+\n+#endif\n+\n+/// RAII wrapper that temporarily clears any Python error state\n+struct error_scope {\n+    PyObject *type, *value, *trace;\n+    error_scope() { PyErr_Fetch(&type, &value, &trace); }\n+    error_scope(const error_scope &) = delete;\n+    error_scope &operator=(const error_scope &) = delete;\n+    ~error_scope() { PyErr_Restore(type, value, trace); }\n+};\n+\n+/// Dummy destructor wrapper that can be used to expose classes with a private destructor\n+struct nodelete {\n+    template <typename T>\n+    void operator()(T *) {}\n+};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+template <typename... Args>\n+struct overload_cast_impl {\n+    template <typename Return>\n+    constexpr auto operator()(Return (*pf)(Args...)) const noexcept -> decltype(pf) {\n+        return pf;\n+    }\n+\n+    template <typename Return, typename Class>\n+    constexpr auto operator()(Return (Class::*pmf)(Args...), std::false_type = {}) const noexcept\n+        -> decltype(pmf) {\n+        return pmf;\n+    }\n+\n+    template <typename Return, typename Class>\n+    constexpr auto operator()(Return (Class::*pmf)(Args...) const, std::true_type) const noexcept\n+        -> decltype(pmf) {\n+        return pmf;\n+    }\n+};\n+PYBIND11_NAMESPACE_END(detail)\n+\n+// overload_cast requires variable templates: C++14\n+#if defined(PYBIND11_CPP14)\n+#    define PYBIND11_OVERLOAD_CAST 1\n+/// Syntax sugar for resolving overloaded function pointers:\n+///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)\n+///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)\n+template <typename... Args>\n+#    if (defined(_MSC_VER) && _MSC_VER < 1920) /* MSVC 2017 */                                    \\\n+        || (defined(__clang__) && __clang_major__ == 5)\n+static constexpr detail::overload_cast_impl<Args...> overload_cast = {};\n+#    else\n+static constexpr detail::overload_cast_impl<Args...> overload_cast;\n+#    endif\n+#endif\n+\n+/// Const member function selector for overload_cast\n+///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)\n+///  - sweet:   overload_cast<Arg>(&Class::func, const_)\n+static constexpr auto const_ = std::true_type{};\n+\n+#if !defined(PYBIND11_CPP14) // no overload_cast: providing something that static_assert-fails:\n+template <typename... Args>\n+struct overload_cast {\n+    static_assert(detail::deferred_t<std::false_type, Args...>::value,\n+                  \"pybind11::overload_cast<...> requires compiling in C++14 mode\");\n+};\n+#endif // overload_cast\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// Adaptor for converting arbitrary container arguments into a vector; implicitly convertible from\n+// any standard container (or C-style array) supporting std::begin/std::end, any singleton\n+// arithmetic type (if T is arithmetic), or explicitly constructible from an iterator pair.\n+template <typename T>\n+class any_container {\n+    std::vector<T> v;\n+\n+public:\n+    any_container() = default;\n+\n+    // Can construct from a pair of iterators\n+    template <typename It, typename = enable_if_t<is_input_iterator<It>::value>>\n+    any_container(It first, It last) : v(first, last) {}\n+\n+    // Implicit conversion constructor from any arbitrary container type\n+    // with values convertible to T\n+    template <typename Container,\n+              typename = enable_if_t<\n+                  std::is_convertible<decltype(*std::begin(std::declval<const Container &>())),\n+                                      T>::value>>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) {}\n+\n+    // initializer_list's aren't deducible, so don't get matched by the above template;\n+    // we need this to explicitly allow implicit conversion from one:\n+    template <typename TIn, typename = enable_if_t<std::is_convertible<TIn, T>::value>>\n+    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) {}\n+\n+    // Avoid copying if given an rvalue vector of the correct type.\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    any_container(std::vector<T> &&v) : v(std::move(v)) {}\n+\n+    // Moves the vector out of an rvalue any_container\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator std::vector<T> &&() && { return std::move(v); }\n+\n+    // Dereferencing obtains a reference to the underlying vector\n+    std::vector<T> &operator*() { return v; }\n+    const std::vector<T> &operator*() const { return v; }\n+\n+    // -> lets you call methods on the underlying vector\n+    std::vector<T> *operator->() { return &v; }\n+    const std::vector<T> *operator->() const { return &v; }\n+};\n+\n+// Forward-declaration; see detail/class.h\n+std::string get_fully_qualified_tp_name(PyTypeObject *);\n+\n+template <typename T>\n+inline static std::shared_ptr<T>\n+try_get_shared_from_this(std::enable_shared_from_this<T> *holder_value_ptr) {\n+// Pre C++17, this code path exploits undefined behavior, but is known to work on many platforms.\n+// Use at your own risk!\n+// See also https://en.cppreference.com/w/cpp/memory/enable_shared_from_this, and in particular\n+// the `std::shared_ptr<Good> gp1 = not_so_good.getptr();` and `try`-`catch` parts of the example.\n+#if defined(__cpp_lib_enable_shared_from_this) && (!defined(_MSC_VER) || _MSC_VER >= 1912)\n+    return holder_value_ptr->weak_from_this().lock();\n+#else\n+    try {\n+        return holder_value_ptr->shared_from_this();\n+    } catch (const std::bad_weak_ptr &) {\n+        return nullptr;\n+    }\n+#endif\n+}\n+\n+// For silencing \"unused\" compiler warnings in special situations.\n+template <typename... Args>\n+#if defined(_MSC_VER) && _MSC_VER < 1920 // MSVC 2017\n+constexpr\n+#endif\n+    inline void\n+    silence_unused_warnings(Args &&...) {\n+}\n+\n+// MSVC warning C4100: Unreferenced formal parameter\n+#if defined(_MSC_VER) && _MSC_VER <= 1916\n+#    define PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(...)                                         \\\n+        detail::silence_unused_warnings(__VA_ARGS__)\n+#else\n+#    define PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(...)\n+#endif\n+\n+// GCC -Wunused-but-set-parameter  All GCC versions (as of July 2021).\n+#if defined(__GNUG__) && !defined(__clang__) && !defined(__INTEL_COMPILER)\n+#    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)                       \\\n+        detail::silence_unused_warnings(__VA_ARGS__)\n+#else\n+#    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)\n+#endif\n+\n+#if defined(_MSC_VER) // All versions (as of July 2021).\n+\n+// warning C4127: Conditional expression is constant\n+constexpr inline bool silence_msvc_c4127(bool cond) { return cond; }\n+\n+#    define PYBIND11_SILENCE_MSVC_C4127(...) ::pybind11::detail::silence_msvc_c4127(__VA_ARGS__)\n+\n+#else\n+#    define PYBIND11_SILENCE_MSVC_C4127(...) __VA_ARGS__\n+#endif\n+\n+// Pybind offers detailed error messages by default for all builts that are debug (through the\n+// negation of ndebug). This can also be manually enabled by users, for any builds, through\n+// defining PYBIND11_DETAILED_ERROR_MESSAGES.\n+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES) && !defined(NDEBUG)\n+#    define PYBIND11_DETAILED_ERROR_MESSAGES\n+#endif\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/descr.h", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "file_content_changes": "@@ -0,0 +1,158 @@\n+/*\n+    pybind11/detail/descr.h: Helper type for concatenating type signatures at compile time\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"common.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+#if !defined(_MSC_VER)\n+#    define PYBIND11_DESCR_CONSTEXPR static constexpr\n+#else\n+#    define PYBIND11_DESCR_CONSTEXPR const\n+#endif\n+\n+/* Concatenate type signatures at compile time */\n+template <size_t N, typename... Ts>\n+struct descr {\n+    char text[N + 1]{'\\0'};\n+\n+    constexpr descr() = default;\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    constexpr descr(char const (&s)[N + 1]) : descr(s, make_index_sequence<N>()) {}\n+\n+    template <size_t... Is>\n+    constexpr descr(char const (&s)[N + 1], index_sequence<Is...>) : text{s[Is]..., '\\0'} {}\n+\n+    template <typename... Chars>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    constexpr descr(char c, Chars... cs) : text{c, static_cast<char>(cs)..., '\\0'} {}\n+\n+    static constexpr std::array<const std::type_info *, sizeof...(Ts) + 1> types() {\n+        return {{&typeid(Ts)..., nullptr}};\n+    }\n+};\n+\n+template <size_t N1, size_t N2, typename... Ts1, typename... Ts2, size_t... Is1, size_t... Is2>\n+constexpr descr<N1 + N2, Ts1..., Ts2...> plus_impl(const descr<N1, Ts1...> &a,\n+                                                   const descr<N2, Ts2...> &b,\n+                                                   index_sequence<Is1...>,\n+                                                   index_sequence<Is2...>) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(b);\n+    return {a.text[Is1]..., b.text[Is2]...};\n+}\n+\n+template <size_t N1, size_t N2, typename... Ts1, typename... Ts2>\n+constexpr descr<N1 + N2, Ts1..., Ts2...> operator+(const descr<N1, Ts1...> &a,\n+                                                   const descr<N2, Ts2...> &b) {\n+    return plus_impl(a, b, make_index_sequence<N1>(), make_index_sequence<N2>());\n+}\n+\n+template <size_t N>\n+constexpr descr<N - 1> const_name(char const (&text)[N]) {\n+    return descr<N - 1>(text);\n+}\n+constexpr descr<0> const_name(char const (&)[1]) { return {}; }\n+\n+template <size_t Rem, size_t... Digits>\n+struct int_to_str : int_to_str<Rem / 10, Rem % 10, Digits...> {};\n+template <size_t... Digits>\n+struct int_to_str<0, Digits...> {\n+    // WARNING: This only works with C++17 or higher.\n+    static constexpr auto digits = descr<sizeof...(Digits)>(('0' + Digits)...);\n+};\n+\n+// Ternary description (like std::conditional)\n+template <bool B, size_t N1, size_t N2>\n+constexpr enable_if_t<B, descr<N1 - 1>> const_name(char const (&text1)[N1], char const (&)[N2]) {\n+    return const_name(text1);\n+}\n+template <bool B, size_t N1, size_t N2>\n+constexpr enable_if_t<!B, descr<N2 - 1>> const_name(char const (&)[N1], char const (&text2)[N2]) {\n+    return const_name(text2);\n+}\n+\n+template <bool B, typename T1, typename T2>\n+constexpr enable_if_t<B, T1> const_name(const T1 &d, const T2 &) {\n+    return d;\n+}\n+template <bool B, typename T1, typename T2>\n+constexpr enable_if_t<!B, T2> const_name(const T1 &, const T2 &d) {\n+    return d;\n+}\n+\n+template <size_t Size>\n+auto constexpr const_name() -> remove_cv_t<decltype(int_to_str<Size / 10, Size % 10>::digits)> {\n+    return int_to_str<Size / 10, Size % 10>::digits;\n+}\n+\n+template <typename Type>\n+constexpr descr<1, Type> const_name() {\n+    return {'%'};\n+}\n+\n+// If \"_\" is defined as a macro, py::detail::_ cannot be provided.\n+// It is therefore best to use py::detail::const_name universally.\n+// This block is for backward compatibility only.\n+// (The const_name code is repeated to avoid introducing a \"_\" #define ourselves.)\n+#ifndef _\n+#    define PYBIND11_DETAIL_UNDERSCORE_BACKWARD_COMPATIBILITY\n+template <size_t N>\n+constexpr descr<N - 1> _(char const (&text)[N]) {\n+    return const_name<N>(text);\n+}\n+template <bool B, size_t N1, size_t N2>\n+constexpr enable_if_t<B, descr<N1 - 1>> _(char const (&text1)[N1], char const (&text2)[N2]) {\n+    return const_name<B, N1, N2>(text1, text2);\n+}\n+template <bool B, size_t N1, size_t N2>\n+constexpr enable_if_t<!B, descr<N2 - 1>> _(char const (&text1)[N1], char const (&text2)[N2]) {\n+    return const_name<B, N1, N2>(text1, text2);\n+}\n+template <bool B, typename T1, typename T2>\n+constexpr enable_if_t<B, T1> _(const T1 &d1, const T2 &d2) {\n+    return const_name<B, T1, T2>(d1, d2);\n+}\n+template <bool B, typename T1, typename T2>\n+constexpr enable_if_t<!B, T2> _(const T1 &d1, const T2 &d2) {\n+    return const_name<B, T1, T2>(d1, d2);\n+}\n+\n+template <size_t Size>\n+auto constexpr _() -> remove_cv_t<decltype(int_to_str<Size / 10, Size % 10>::digits)> {\n+    return const_name<Size>();\n+}\n+template <typename Type>\n+constexpr descr<1, Type> _() {\n+    return const_name<Type>();\n+}\n+#endif // #ifndef _\n+\n+constexpr descr<0> concat() { return {}; }\n+\n+template <size_t N, typename... Ts>\n+constexpr descr<N, Ts...> concat(const descr<N, Ts...> &descr) {\n+    return descr;\n+}\n+\n+template <size_t N, typename... Ts, typename... Args>\n+constexpr auto concat(const descr<N, Ts...> &d, const Args &...args)\n+    -> decltype(std::declval<descr<N + 2, Ts...>>() + concat(args...)) {\n+    return d + const_name(\", \") + concat(args...);\n+}\n+\n+template <size_t N, typename... Ts>\n+constexpr descr<N + 2, Ts...> type_descr(const descr<N, Ts...> &descr) {\n+    return const_name(\"{\") + descr + const_name(\"}\");\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/init.h", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "file_content_changes": "@@ -0,0 +1,428 @@\n+/*\n+    pybind11/detail/init.h: init factory function implementation and support code.\n+\n+    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"class.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+template <>\n+class type_caster<value_and_holder> {\n+public:\n+    bool load(handle h, bool) {\n+        value = reinterpret_cast<value_and_holder *>(h.ptr());\n+        return true;\n+    }\n+\n+    template <typename>\n+    using cast_op_type = value_and_holder &;\n+    explicit operator value_and_holder &() { return *value; }\n+    static constexpr auto name = const_name<value_and_holder>();\n+\n+private:\n+    value_and_holder *value = nullptr;\n+};\n+\n+PYBIND11_NAMESPACE_BEGIN(initimpl)\n+\n+inline void no_nullptr(void *ptr) {\n+    if (!ptr) {\n+        throw type_error(\"pybind11::init(): factory function returned nullptr\");\n+    }\n+}\n+\n+// Implementing functions for all forms of py::init<...> and py::init(...)\n+template <typename Class>\n+using Cpp = typename Class::type;\n+template <typename Class>\n+using Alias = typename Class::type_alias;\n+template <typename Class>\n+using Holder = typename Class::holder_type;\n+\n+template <typename Class>\n+using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;\n+\n+// Takes a Cpp pointer and returns true if it actually is a polymorphic Alias instance.\n+template <typename Class, enable_if_t<Class::has_alias, int> = 0>\n+bool is_alias(Cpp<Class> *ptr) {\n+    return dynamic_cast<Alias<Class> *>(ptr) != nullptr;\n+}\n+// Failing fallback version of the above for a no-alias class (always returns false)\n+template <typename /*Class*/>\n+constexpr bool is_alias(void *) {\n+    return false;\n+}\n+\n+// Constructs and returns a new object; if the given arguments don't map to a constructor, we fall\n+// back to brace aggregate initiailization so that for aggregate initialization can be used with\n+// py::init, e.g.  `py::init<int, int>` to initialize a `struct T { int a; int b; }`.  For\n+// non-aggregate types, we need to use an ordinary T(...) constructor (invoking as `T{...}` usually\n+// works, but will not do the expected thing when `T` has an `initializer_list<T>` constructor).\n+template <typename Class,\n+          typename... Args,\n+          detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>\n+inline Class *construct_or_initialize(Args &&...args) {\n+    return new Class(std::forward<Args>(args)...);\n+}\n+template <typename Class,\n+          typename... Args,\n+          detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>\n+inline Class *construct_or_initialize(Args &&...args) {\n+    return new Class{std::forward<Args>(args)...};\n+}\n+\n+// Attempts to constructs an alias using a `Alias(Cpp &&)` constructor.  This allows types with\n+// an alias to provide only a single Cpp factory function as long as the Alias can be\n+// constructed from an rvalue reference of the base Cpp type.  This means that Alias classes\n+// can, when appropriate, simply define a `Alias(Cpp &&)` constructor rather than needing to\n+// inherit all the base class constructors.\n+template <typename Class>\n+void construct_alias_from_cpp(std::true_type /*is_alias_constructible*/,\n+                              value_and_holder &v_h,\n+                              Cpp<Class> &&base) {\n+    v_h.value_ptr() = new Alias<Class>(std::move(base));\n+}\n+template <typename Class>\n+[[noreturn]] void construct_alias_from_cpp(std::false_type /*!is_alias_constructible*/,\n+                                           value_and_holder &,\n+                                           Cpp<Class> &&) {\n+    throw type_error(\"pybind11::init(): unable to convert returned instance to required \"\n+                     \"alias class: no `Alias<Class>(Class &&)` constructor available\");\n+}\n+\n+// Error-generating fallback for factories that don't match one of the below construction\n+// mechanisms.\n+template <typename Class>\n+void construct(...) {\n+    static_assert(!std::is_same<Class, Class>::value /* always false */,\n+                  \"pybind11::init(): init function must return a compatible pointer, \"\n+                  \"holder, or value\");\n+}\n+\n+// Pointer return v1: the factory function returns a class pointer for a registered class.\n+// If we don't need an alias (because this class doesn't have one, or because the final type is\n+// inherited on the Python side) we can simply take over ownership.  Otherwise we need to try to\n+// construct an Alias from the returned base instance.\n+template <typename Class>\n+void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);\n+    no_nullptr(ptr);\n+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias && !is_alias<Class>(ptr)) {\n+        // We're going to try to construct an alias by moving the cpp type.  Whether or not\n+        // that succeeds, we still need to destroy the original cpp pointer (either the\n+        // moved away leftover, if the alias construction works, or the value itself if we\n+        // throw an error), but we can't just call `delete ptr`: it might have a special\n+        // deleter, or might be shared_from_this.  So we construct a holder around it as if\n+        // it was a normal instance, then steal the holder away into a local variable; thus\n+        // the holder and destruction happens when we leave the C++ scope, and the holder\n+        // class gets to handle the destruction however it likes.\n+        v_h.value_ptr() = ptr;\n+        v_h.set_instance_registered(true);          // To prevent init_instance from registering it\n+        v_h.type->init_instance(v_h.inst, nullptr); // Set up the holder\n+        Holder<Class> temp_holder(std::move(v_h.holder<Holder<Class>>())); // Steal the holder\n+        v_h.type->dealloc(v_h); // Destroys the moved-out holder remains, resets value ptr to null\n+        v_h.set_instance_registered(false);\n+\n+        construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(*ptr));\n+    } else {\n+        // Otherwise the type isn't inherited, so we don't need an Alias\n+        v_h.value_ptr() = ptr;\n+    }\n+}\n+\n+// Pointer return v2: a factory that always returns an alias instance ptr.  We simply take over\n+// ownership of the pointer.\n+template <typename Class, enable_if_t<Class::has_alias, int> = 0>\n+void construct(value_and_holder &v_h, Alias<Class> *alias_ptr, bool) {\n+    no_nullptr(alias_ptr);\n+    v_h.value_ptr() = static_cast<Cpp<Class> *>(alias_ptr);\n+}\n+\n+// Holder return: copy its pointer, and move or copy the returned holder into the new instance's\n+// holder.  This also handles types like std::shared_ptr<T> and std::unique_ptr<T> where T is a\n+// derived type (through those holder's implicit conversion from derived class holder\n+// constructors).\n+template <typename Class>\n+void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);\n+    auto *ptr = holder_helper<Holder<Class>>::get(holder);\n+    no_nullptr(ptr);\n+    // If we need an alias, check that the held pointer is actually an alias instance\n+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias && !is_alias<Class>(ptr)) {\n+        throw type_error(\"pybind11::init(): construction failed: returned holder-wrapped instance \"\n+                         \"is not an alias instance\");\n+    }\n+\n+    v_h.value_ptr() = ptr;\n+    v_h.type->init_instance(v_h.inst, &holder);\n+}\n+\n+// return-by-value version 1: returning a cpp class by value.  If the class has an alias and an\n+// alias is required the alias must have an `Alias(Cpp &&)` constructor so that we can construct\n+// the alias from the base when needed (i.e. because of Python-side inheritance).  When we don't\n+// need it, we simply move-construct the cpp value into a new instance.\n+template <typename Class>\n+void construct(value_and_holder &v_h, Cpp<Class> &&result, bool need_alias) {\n+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);\n+    static_assert(std::is_move_constructible<Cpp<Class>>::value,\n+                  \"pybind11::init() return-by-value factory function requires a movable class\");\n+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias) {\n+        construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(result));\n+    } else {\n+        v_h.value_ptr() = new Cpp<Class>(std::move(result));\n+    }\n+}\n+\n+// return-by-value version 2: returning a value of the alias type itself.  We move-construct an\n+// Alias instance (even if no the python-side inheritance is involved).  The is intended for\n+// cases where Alias initialization is always desired.\n+template <typename Class>\n+void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {\n+    static_assert(\n+        std::is_move_constructible<Alias<Class>>::value,\n+        \"pybind11::init() return-by-alias-value factory function requires a movable alias class\");\n+    v_h.value_ptr() = new Alias<Class>(std::move(result));\n+}\n+\n+// Implementing class for py::init<...>()\n+template <typename... Args>\n+struct constructor {\n+    template <typename Class, typename... Extra, enable_if_t<!Class::has_alias, int> = 0>\n+    static void execute(Class &cl, const Extra &...extra) {\n+        cl.def(\n+            \"__init__\",\n+            [](value_and_holder &v_h, Args... args) {\n+                v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n+    }\n+\n+    template <typename Class,\n+              typename... Extra,\n+              enable_if_t<Class::has_alias && std::is_constructible<Cpp<Class>, Args...>::value,\n+                          int> = 0>\n+    static void execute(Class &cl, const Extra &...extra) {\n+        cl.def(\n+            \"__init__\",\n+            [](value_and_holder &v_h, Args... args) {\n+                if (Py_TYPE(v_h.inst) == v_h.type->type) {\n+                    v_h.value_ptr()\n+                        = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);\n+                } else {\n+                    v_h.value_ptr()\n+                        = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n+                }\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n+    }\n+\n+    template <typename Class,\n+              typename... Extra,\n+              enable_if_t<Class::has_alias && !std::is_constructible<Cpp<Class>, Args...>::value,\n+                          int> = 0>\n+    static void execute(Class &cl, const Extra &...extra) {\n+        cl.def(\n+            \"__init__\",\n+            [](value_and_holder &v_h, Args... args) {\n+                v_h.value_ptr()\n+                    = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n+    }\n+};\n+\n+// Implementing class for py::init_alias<...>()\n+template <typename... Args>\n+struct alias_constructor {\n+    template <typename Class,\n+              typename... Extra,\n+              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value,\n+                          int> = 0>\n+    static void execute(Class &cl, const Extra &...extra) {\n+        cl.def(\n+            \"__init__\",\n+            [](value_and_holder &v_h, Args... args) {\n+                v_h.value_ptr()\n+                    = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n+    }\n+};\n+\n+// Implementation class for py::init(Func) and py::init(Func, AliasFunc)\n+template <typename CFunc,\n+          typename AFunc = void_type (*)(),\n+          typename = function_signature_t<CFunc>,\n+          typename = function_signature_t<AFunc>>\n+struct factory;\n+\n+// Specialization for py::init(Func)\n+template <typename Func, typename Return, typename... Args>\n+struct factory<Func, void_type (*)(), Return(Args...)> {\n+    remove_reference_t<Func> class_factory;\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    factory(Func &&f) : class_factory(std::forward<Func>(f)) {}\n+\n+    // The given class either has no alias or has no separate alias factory;\n+    // this always constructs the class itself.  If the class is registered with an alias\n+    // type and an alias instance is needed (i.e. because the final type is a Python class\n+    // inheriting from the C++ type) the returned value needs to either already be an alias\n+    // instance, or the alias needs to be constructible from a `Class &&` argument.\n+    template <typename Class, typename... Extra>\n+    void execute(Class &cl, const Extra &...extra) && {\n+#if defined(PYBIND11_CPP14)\n+        cl.def(\n+            \"__init__\",\n+            [func = std::move(class_factory)]\n+#else\n+        auto &func = class_factory;\n+        cl.def(\n+            \"__init__\",\n+            [func]\n+#endif\n+            (value_and_holder &v_h, Args... args) {\n+                construct<Class>(\n+                    v_h, func(std::forward<Args>(args)...), Py_TYPE(v_h.inst) != v_h.type->type);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n+    }\n+};\n+\n+// Specialization for py::init(Func, AliasFunc)\n+template <typename CFunc,\n+          typename AFunc,\n+          typename CReturn,\n+          typename... CArgs,\n+          typename AReturn,\n+          typename... AArgs>\n+struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {\n+    static_assert(sizeof...(CArgs) == sizeof...(AArgs),\n+                  \"pybind11::init(class_factory, alias_factory): class and alias factories \"\n+                  \"must have identical argument signatures\");\n+    static_assert(all_of<std::is_same<CArgs, AArgs>...>::value,\n+                  \"pybind11::init(class_factory, alias_factory): class and alias factories \"\n+                  \"must have identical argument signatures\");\n+\n+    remove_reference_t<CFunc> class_factory;\n+    remove_reference_t<AFunc> alias_factory;\n+\n+    factory(CFunc &&c, AFunc &&a)\n+        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) {}\n+\n+    // The class factory is called when the `self` type passed to `__init__` is the direct\n+    // class (i.e. not inherited), the alias factory when `self` is a Python-side subtype.\n+    template <typename Class, typename... Extra>\n+    void execute(Class &cl, const Extra &...extra) && {\n+        static_assert(Class::has_alias,\n+                      \"The two-argument version of `py::init()` can \"\n+                      \"only be used if the class has an alias\");\n+#if defined(PYBIND11_CPP14)\n+        cl.def(\n+            \"__init__\",\n+            [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]\n+#else\n+        auto &class_func = class_factory;\n+        auto &alias_func = alias_factory;\n+        cl.def(\n+            \"__init__\",\n+            [class_func, alias_func]\n+#endif\n+            (value_and_holder &v_h, CArgs... args) {\n+                if (Py_TYPE(v_h.inst) == v_h.type->type) {\n+                    // If the instance type equals the registered type we don't have inheritance,\n+                    // so don't need the alias and can construct using the class function:\n+                    construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);\n+                } else {\n+                    construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);\n+                }\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n+    }\n+};\n+\n+/// Set just the C++ state. Same as `__init__`.\n+template <typename Class, typename T>\n+void setstate(value_and_holder &v_h, T &&result, bool need_alias) {\n+    construct<Class>(v_h, std::forward<T>(result), need_alias);\n+}\n+\n+/// Set both the C++ and Python states\n+template <typename Class,\n+          typename T,\n+          typename O,\n+          enable_if_t<std::is_convertible<O, handle>::value, int> = 0>\n+void setstate(value_and_holder &v_h, std::pair<T, O> &&result, bool need_alias) {\n+    construct<Class>(v_h, std::move(result.first), need_alias);\n+    auto d = handle(result.second);\n+    if (PyDict_Check(d.ptr()) && PyDict_Size(d.ptr()) == 0) {\n+        // Skipping setattr below, to not force use of py::dynamic_attr() for Class unnecessarily.\n+        // See PR #2972 for details.\n+        return;\n+    }\n+    setattr((PyObject *) v_h.inst, \"__dict__\", d);\n+}\n+\n+/// Implementation for py::pickle(GetState, SetState)\n+template <typename Get,\n+          typename Set,\n+          typename = function_signature_t<Get>,\n+          typename = function_signature_t<Set>>\n+struct pickle_factory;\n+\n+template <typename Get,\n+          typename Set,\n+          typename RetState,\n+          typename Self,\n+          typename NewInstance,\n+          typename ArgState>\n+struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {\n+    static_assert(std::is_same<intrinsic_t<RetState>, intrinsic_t<ArgState>>::value,\n+                  \"The type returned by `__getstate__` must be the same \"\n+                  \"as the argument accepted by `__setstate__`\");\n+\n+    remove_reference_t<Get> get;\n+    remove_reference_t<Set> set;\n+\n+    pickle_factory(Get get, Set set) : get(std::forward<Get>(get)), set(std::forward<Set>(set)) {}\n+\n+    template <typename Class, typename... Extra>\n+    void execute(Class &cl, const Extra &...extra) && {\n+        cl.def(\"__getstate__\", std::move(get));\n+\n+#if defined(PYBIND11_CPP14)\n+        cl.def(\n+            \"__setstate__\",\n+            [func = std::move(set)]\n+#else\n+        auto &func = set;\n+        cl.def(\n+            \"__setstate__\",\n+            [func]\n+#endif\n+            (value_and_holder &v_h, ArgState state) {\n+                setstate<Class>(\n+                    v_h, func(std::forward<ArgState>(state)), Py_TYPE(v_h.inst) != v_h.type->type);\n+            },\n+            is_new_style_constructor(),\n+            extra...);\n+    }\n+};\n+\n+PYBIND11_NAMESPACE_END(initimpl)\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/internals.h", "status": "added", "additions": 562, "deletions": 0, "changes": 562, "file_content_changes": "@@ -0,0 +1,562 @@\n+/*\n+    pybind11/detail/internals.h: Internal data structure and related functions\n+\n+    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"../pytypes.h\"\n+\n+#include <exception>\n+\n+/// Tracks the `internals` and `type_info` ABI version independent of the main library version.\n+///\n+/// Some portions of the code use an ABI that is conditional depending on this\n+/// version number.  That allows ABI-breaking changes to be \"pre-implemented\".\n+/// Once the default version number is incremented, the conditional logic that\n+/// no longer applies can be removed.  Additionally, users that need not\n+/// maintain ABI compatibility can increase the version number in order to take\n+/// advantage of any functionality/efficiency improvements that depend on the\n+/// newer ABI.\n+///\n+/// WARNING: If you choose to manually increase the ABI version, note that\n+/// pybind11 may not be tested as thoroughly with a non-default ABI version, and\n+/// further ABI-incompatible changes may be made before the ABI is officially\n+/// changed to the new version.\n+#ifndef PYBIND11_INTERNALS_VERSION\n+#    define PYBIND11_INTERNALS_VERSION 4\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+using ExceptionTranslator = void (*)(std::exception_ptr);\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// Forward declarations\n+inline PyTypeObject *make_static_property_type();\n+inline PyTypeObject *make_default_metaclass();\n+inline PyObject *make_object_base_type(PyTypeObject *metaclass);\n+\n+// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new\n+// Thread Specific Storage (TSS) API.\n+#if PY_VERSION_HEX >= 0x03070000\n+// Avoid unnecessary allocation of `Py_tss_t`, since we cannot use\n+// `Py_LIMITED_API` anyway.\n+#    if PYBIND11_INTERNALS_VERSION > 4\n+#        define PYBIND11_TLS_KEY_REF Py_tss_t &\n+#        ifdef __GNUC__\n+// Clang on macOS warns due to `Py_tss_NEEDS_INIT` not specifying an initializer\n+// for every field.\n+#            define PYBIND11_TLS_KEY_INIT(var)                                                    \\\n+                _Pragma(\"GCC diagnostic push\")                                         /**/       \\\n+                    _Pragma(\"GCC diagnostic ignored \\\"-Wmissing-field-initializers\\\"\") /**/       \\\n+                    Py_tss_t var                                                                  \\\n+                    = Py_tss_NEEDS_INIT;                                                          \\\n+                _Pragma(\"GCC diagnostic pop\")\n+#        else\n+#            define PYBIND11_TLS_KEY_INIT(var) Py_tss_t var = Py_tss_NEEDS_INIT;\n+#        endif\n+#        define PYBIND11_TLS_KEY_CREATE(var) (PyThread_tss_create(&(var)) == 0)\n+#        define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get(&(key))\n+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set(&(key), (value))\n+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set(&(key), nullptr)\n+#        define PYBIND11_TLS_FREE(key) PyThread_tss_delete(&(key))\n+#    else\n+#        define PYBIND11_TLS_KEY_REF Py_tss_t *\n+#        define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr;\n+#        define PYBIND11_TLS_KEY_CREATE(var)                                                      \\\n+            (((var) = PyThread_tss_alloc()) != nullptr && (PyThread_tss_create((var)) == 0))\n+#        define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))\n+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n+#        define PYBIND11_TLS_FREE(key) PyThread_tss_free(key)\n+#    endif\n+#else\n+// Usually an int but a long on Cygwin64 with Python 3.x\n+#    define PYBIND11_TLS_KEY_REF decltype(PyThread_create_key())\n+#    define PYBIND11_TLS_KEY_INIT(var) PYBIND11_TLS_KEY_REF var = 0;\n+#    define PYBIND11_TLS_KEY_CREATE(var) (((var) = PyThread_create_key()) != -1)\n+#    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n+#    if defined(PYPY_VERSION)\n+// On CPython < 3.4 and on PyPy, `PyThread_set_key_value` strangely does not set\n+// the value if it has already been set.  Instead, it must first be deleted and\n+// then set again.\n+inline void tls_replace_value(PYBIND11_TLS_KEY_REF key, void *value) {\n+    PyThread_delete_key_value(key);\n+    PyThread_set_key_value(key, value);\n+}\n+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_delete_key_value(key)\n+#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                                            \\\n+            ::pybind11::detail::tls_replace_value((key), (value))\n+#    else\n+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_set_key_value((key), nullptr)\n+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_set_key_value((key), (value))\n+#    endif\n+#    define PYBIND11_TLS_FREE(key) (void) key\n+#endif\n+\n+// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly\n+// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module\n+// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under\n+// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,\n+// which works.  If not under a known-good stl, provide our own name-based hash and equality\n+// functions that use the type name.\n+#if defined(__GLIBCXX__)\n+inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }\n+using type_hash = std::hash<std::type_index>;\n+using type_equal_to = std::equal_to<std::type_index>;\n+#else\n+inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n+    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n+}\n+\n+struct type_hash {\n+    size_t operator()(const std::type_index &t) const {\n+        size_t hash = 5381;\n+        const char *ptr = t.name();\n+        while (auto c = static_cast<unsigned char>(*ptr++)) {\n+            hash = (hash * 33) ^ c;\n+        }\n+        return hash;\n+    }\n+};\n+\n+struct type_equal_to {\n+    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {\n+        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n+    }\n+};\n+#endif\n+\n+template <typename value_type>\n+using type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n+\n+struct override_hash {\n+    inline size_t operator()(const std::pair<const PyObject *, const char *> &v) const {\n+        size_t value = std::hash<const void *>()(v.first);\n+        value ^= std::hash<const void *>()(v.second) + 0x9e3779b9 + (value << 6) + (value >> 2);\n+        return value;\n+    }\n+};\n+\n+/// Internal data structure used to track registered instances and types.\n+/// Whenever binary incompatible changes are made to this structure,\n+/// `PYBIND11_INTERNALS_VERSION` must be incremented.\n+struct internals {\n+    // std::type_index -> pybind11's type information\n+    type_map<type_info *> registered_types_cpp;\n+    // PyTypeObject* -> base type_info(s)\n+    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py;\n+    std::unordered_multimap<const void *, instance *> registered_instances; // void * -> instance*\n+    std::unordered_set<std::pair<const PyObject *, const char *>, override_hash>\n+        inactive_override_cache;\n+    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n+    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n+    std::forward_list<ExceptionTranslator> registered_exception_translators;\n+    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across\n+                                                         // extensions\n+#if PYBIND11_INTERNALS_VERSION == 4\n+    std::vector<PyObject *> unused_loader_patient_stack_remove_at_v5;\n+#endif\n+    std::forward_list<std::string> static_strings; // Stores the std::strings backing\n+                                                   // detail::c_str()\n+    PyTypeObject *static_property_type;\n+    PyTypeObject *default_metaclass;\n+    PyObject *instance_base;\n+#if defined(WITH_THREAD)\n+    PYBIND11_TLS_KEY_INIT(tstate)\n+#    if PYBIND11_INTERNALS_VERSION > 4\n+    PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)\n+#    endif // PYBIND11_INTERNALS_VERSION > 4\n+    PyInterpreterState *istate = nullptr;\n+    ~internals() {\n+#    if PYBIND11_INTERNALS_VERSION > 4\n+        PYBIND11_TLS_FREE(loader_life_support_tls_key);\n+#    endif // PYBIND11_INTERNALS_VERSION > 4\n+\n+        // This destructor is called *after* Py_Finalize() in finalize_interpreter().\n+        // That *SHOULD BE* fine. The following details what happens when PyThread_tss_free is\n+        // called. PYBIND11_TLS_FREE is PyThread_tss_free on python 3.7+. On older python, it does\n+        // nothing. PyThread_tss_free calls PyThread_tss_delete and PyMem_RawFree.\n+        // PyThread_tss_delete just calls TlsFree (on Windows) or pthread_key_delete (on *NIX).\n+        // Neither of those have anything to do with CPython internals. PyMem_RawFree *requires*\n+        // that the `tstate` be allocated with the CPython allocator.\n+        PYBIND11_TLS_FREE(tstate);\n+    }\n+#endif\n+};\n+\n+/// Additional type information which does not fit into the PyTypeObject.\n+/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.\n+struct type_info {\n+    PyTypeObject *type;\n+    const std::type_info *cpptype;\n+    size_t type_size, type_align, holder_size_in_ptrs;\n+    void *(*operator_new)(size_t);\n+    void (*init_instance)(instance *, const void *);\n+    void (*dealloc)(value_and_holder &v_h);\n+    std::vector<PyObject *(*) (PyObject *, PyTypeObject *)> implicit_conversions;\n+    std::vector<std::pair<const std::type_info *, void *(*) (void *)>> implicit_casts;\n+    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n+    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n+    void *get_buffer_data = nullptr;\n+    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n+    /* A simple type never occurs as a (direct or indirect) parent\n+     * of a class that makes use of multiple inheritance.\n+     * A type can be simple even if it has non-simple ancestors as long as it has no descendants.\n+     */\n+    bool simple_type : 1;\n+    /* True if there is no multiple inheritance in this type's inheritance tree */\n+    bool simple_ancestors : 1;\n+    /* for base vs derived holder_type checks */\n+    bool default_holder : 1;\n+    /* true if this is a type registered with py::module_local */\n+    bool module_local : 1;\n+};\n+\n+/// On MSVC, debug and release builds are not ABI-compatible!\n+#if defined(_MSC_VER) && defined(_DEBUG)\n+#    define PYBIND11_BUILD_TYPE \"_debug\"\n+#else\n+#    define PYBIND11_BUILD_TYPE \"\"\n+#endif\n+\n+/// Let's assume that different compilers are ABI-incompatible.\n+/// A user can manually set this string if they know their\n+/// compiler is compatible.\n+#ifndef PYBIND11_COMPILER_TYPE\n+#    if defined(_MSC_VER)\n+#        define PYBIND11_COMPILER_TYPE \"_msvc\"\n+#    elif defined(__INTEL_COMPILER)\n+#        define PYBIND11_COMPILER_TYPE \"_icc\"\n+#    elif defined(__clang__)\n+#        define PYBIND11_COMPILER_TYPE \"_clang\"\n+#    elif defined(__PGI)\n+#        define PYBIND11_COMPILER_TYPE \"_pgi\"\n+#    elif defined(__MINGW32__)\n+#        define PYBIND11_COMPILER_TYPE \"_mingw\"\n+#    elif defined(__CYGWIN__)\n+#        define PYBIND11_COMPILER_TYPE \"_gcc_cygwin\"\n+#    elif defined(__GNUC__)\n+#        define PYBIND11_COMPILER_TYPE \"_gcc\"\n+#    else\n+#        define PYBIND11_COMPILER_TYPE \"_unknown\"\n+#    endif\n+#endif\n+\n+/// Also standard libs\n+#ifndef PYBIND11_STDLIB\n+#    if defined(_LIBCPP_VERSION)\n+#        define PYBIND11_STDLIB \"_libcpp\"\n+#    elif defined(__GLIBCXX__) || defined(__GLIBCPP__)\n+#        define PYBIND11_STDLIB \"_libstdcpp\"\n+#    else\n+#        define PYBIND11_STDLIB \"\"\n+#    endif\n+#endif\n+\n+/// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.\n+#ifndef PYBIND11_BUILD_ABI\n+#    if defined(__GXX_ABI_VERSION)\n+#        define PYBIND11_BUILD_ABI \"_cxxabi\" PYBIND11_TOSTRING(__GXX_ABI_VERSION)\n+#    else\n+#        define PYBIND11_BUILD_ABI \"\"\n+#    endif\n+#endif\n+\n+#ifndef PYBIND11_INTERNALS_KIND\n+#    if defined(WITH_THREAD)\n+#        define PYBIND11_INTERNALS_KIND \"\"\n+#    else\n+#        define PYBIND11_INTERNALS_KIND \"_without_thread\"\n+#    endif\n+#endif\n+\n+#define PYBIND11_INTERNALS_ID                                                                     \\\n+    \"__pybind11_internals_v\" PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION)                        \\\n+        PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI         \\\n+            PYBIND11_BUILD_TYPE \"__\"\n+\n+#define PYBIND11_MODULE_LOCAL_ID                                                                  \\\n+    \"__pybind11_module_local_v\" PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION)                     \\\n+        PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI         \\\n+            PYBIND11_BUILD_TYPE \"__\"\n+\n+/// Each module locally stores a pointer to the `internals` data. The data\n+/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\n+inline internals **&get_internals_pp() {\n+    static internals **internals_pp = nullptr;\n+    return internals_pp;\n+}\n+\n+// forward decl\n+inline void translate_exception(std::exception_ptr);\n+\n+template <class T,\n+          enable_if_t<std::is_same<std::nested_exception, remove_cvref_t<T>>::value, int> = 0>\n+bool handle_nested_exception(const T &exc, const std::exception_ptr &p) {\n+    std::exception_ptr nested = exc.nested_ptr();\n+    if (nested != nullptr && nested != p) {\n+        translate_exception(nested);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+template <class T,\n+          enable_if_t<!std::is_same<std::nested_exception, remove_cvref_t<T>>::value, int> = 0>\n+bool handle_nested_exception(const T &exc, const std::exception_ptr &p) {\n+    if (const auto *nep = dynamic_cast<const std::nested_exception *>(std::addressof(exc))) {\n+        return handle_nested_exception(*nep, p);\n+    }\n+    return false;\n+}\n+\n+inline bool raise_err(PyObject *exc_type, const char *msg) {\n+    if (PyErr_Occurred()) {\n+        raise_from(exc_type, msg);\n+        return true;\n+    }\n+    PyErr_SetString(exc_type, msg);\n+    return false;\n+}\n+\n+inline void translate_exception(std::exception_ptr p) {\n+    if (!p) {\n+        return;\n+    }\n+    try {\n+        std::rethrow_exception(p);\n+    } catch (error_already_set &e) {\n+        handle_nested_exception(e, p);\n+        e.restore();\n+        return;\n+    } catch (const builtin_exception &e) {\n+        // Could not use template since it's an abstract class.\n+        if (const auto *nep = dynamic_cast<const std::nested_exception *>(std::addressof(e))) {\n+            handle_nested_exception(*nep, p);\n+        }\n+        e.set_error();\n+        return;\n+    } catch (const std::bad_alloc &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_MemoryError, e.what());\n+        return;\n+    } catch (const std::domain_error &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_ValueError, e.what());\n+        return;\n+    } catch (const std::invalid_argument &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_ValueError, e.what());\n+        return;\n+    } catch (const std::length_error &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_ValueError, e.what());\n+        return;\n+    } catch (const std::out_of_range &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_IndexError, e.what());\n+        return;\n+    } catch (const std::range_error &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_ValueError, e.what());\n+        return;\n+    } catch (const std::overflow_error &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_OverflowError, e.what());\n+        return;\n+    } catch (const std::exception &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_RuntimeError, e.what());\n+        return;\n+    } catch (const std::nested_exception &e) {\n+        handle_nested_exception(e, p);\n+        raise_err(PyExc_RuntimeError, \"Caught an unknown nested exception!\");\n+        return;\n+    } catch (...) {\n+        raise_err(PyExc_RuntimeError, \"Caught an unknown exception!\");\n+        return;\n+    }\n+}\n+\n+#if !defined(__GLIBCXX__)\n+inline void translate_local_exception(std::exception_ptr p) {\n+    try {\n+        if (p) {\n+            std::rethrow_exception(p);\n+        }\n+    } catch (error_already_set &e) {\n+        e.restore();\n+        return;\n+    } catch (const builtin_exception &e) {\n+        e.set_error();\n+        return;\n+    }\n+}\n+#endif\n+\n+/// Return a reference to the current `internals` data\n+PYBIND11_NOINLINE internals &get_internals() {\n+    auto **&internals_pp = get_internals_pp();\n+    if (internals_pp && *internals_pp) {\n+        return **internals_pp;\n+    }\n+\n+    // Ensure that the GIL is held since we will need to make Python calls.\n+    // Cannot use py::gil_scoped_acquire here since that constructor calls get_internals.\n+    struct gil_scoped_acquire_local {\n+        gil_scoped_acquire_local() : state(PyGILState_Ensure()) {}\n+        ~gil_scoped_acquire_local() { PyGILState_Release(state); }\n+        const PyGILState_STATE state;\n+    } gil;\n+    error_scope err_scope;\n+\n+    PYBIND11_STR_TYPE id(PYBIND11_INTERNALS_ID);\n+    auto builtins = handle(PyEval_GetBuiltins());\n+    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n+        internals_pp = static_cast<internals **>(capsule(builtins[id]));\n+\n+        // We loaded builtins through python's builtins, which means that our `error_already_set`\n+        // and `builtin_exception` may be different local classes than the ones set up in the\n+        // initial exception translator, below, so add another for our local exception classes.\n+        //\n+        // libstdc++ doesn't require this (types there are identified only by name)\n+        // libc++ with CPython doesn't require this (types are explicitly exported)\n+        // libc++ with PyPy still need it, awaiting further investigation\n+#if !defined(__GLIBCXX__)\n+        (*internals_pp)->registered_exception_translators.push_front(&translate_local_exception);\n+#endif\n+    } else {\n+        if (!internals_pp) {\n+            internals_pp = new internals *();\n+        }\n+        auto *&internals_ptr = *internals_pp;\n+        internals_ptr = new internals();\n+#if defined(WITH_THREAD)\n+\n+#    if PY_VERSION_HEX < 0x03090000\n+        PyEval_InitThreads();\n+#    endif\n+        PyThreadState *tstate = PyThreadState_Get();\n+        if (!PYBIND11_TLS_KEY_CREATE(internals_ptr->tstate)) {\n+            pybind11_fail(\"get_internals: could not successfully initialize the tstate TSS key!\");\n+        }\n+        PYBIND11_TLS_REPLACE_VALUE(internals_ptr->tstate, tstate);\n+\n+#    if PYBIND11_INTERNALS_VERSION > 4\n+        if (!PYBIND11_TLS_KEY_CREATE(internals_ptr->loader_life_support_tls_key)) {\n+            pybind11_fail(\"get_internals: could not successfully initialize the \"\n+                          \"loader_life_support TSS key!\");\n+        }\n+#    endif\n+        internals_ptr->istate = tstate->interp;\n+#endif\n+        builtins[id] = capsule(internals_pp);\n+        internals_ptr->registered_exception_translators.push_front(&translate_exception);\n+        internals_ptr->static_property_type = make_static_property_type();\n+        internals_ptr->default_metaclass = make_default_metaclass();\n+        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);\n+    }\n+    return **internals_pp;\n+}\n+\n+// the internals struct (above) is shared between all the modules. local_internals are only\n+// for a single module. Any changes made to internals may require an update to\n+// PYBIND11_INTERNALS_VERSION, breaking backwards compatibility. local_internals is, by design,\n+// restricted to a single module. Whether a module has local internals or not should not\n+// impact any other modules, because the only things accessing the local internals is the\n+// module that contains them.\n+struct local_internals {\n+    type_map<type_info *> registered_types_cpp;\n+    std::forward_list<ExceptionTranslator> registered_exception_translators;\n+#if defined(WITH_THREAD) && PYBIND11_INTERNALS_VERSION == 4\n+\n+    // For ABI compatibility, we can't store the loader_life_support TLS key in\n+    // the `internals` struct directly.  Instead, we store it in `shared_data` and\n+    // cache a copy in `local_internals`.  If we allocated a separate TLS key for\n+    // each instance of `local_internals`, we could end up allocating hundreds of\n+    // TLS keys if hundreds of different pybind11 modules are loaded (which is a\n+    // plausible number).\n+    PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)\n+\n+    // Holds the shared TLS key for the loader_life_support stack.\n+    struct shared_loader_life_support_data {\n+        PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)\n+        shared_loader_life_support_data() {\n+            if (!PYBIND11_TLS_KEY_CREATE(loader_life_support_tls_key)) {\n+                pybind11_fail(\"local_internals: could not successfully initialize the \"\n+                              \"loader_life_support TLS key!\");\n+            }\n+        }\n+        // We can't help but leak the TLS key, because Python never unloads extension modules.\n+    };\n+\n+    local_internals() {\n+        auto &internals = get_internals();\n+        // Get or create the `loader_life_support_stack_key`.\n+        auto &ptr = internals.shared_data[\"_life_support\"];\n+        if (!ptr) {\n+            ptr = new shared_loader_life_support_data;\n+        }\n+        loader_life_support_tls_key\n+            = static_cast<shared_loader_life_support_data *>(ptr)->loader_life_support_tls_key;\n+    }\n+#endif //  defined(WITH_THREAD) && PYBIND11_INTERNALS_VERSION == 4\n+};\n+\n+/// Works like `get_internals`, but for things which are locally registered.\n+inline local_internals &get_local_internals() {\n+    static local_internals locals;\n+    return locals;\n+}\n+\n+/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its\n+/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only\n+/// cleared when the program exits or after interpreter shutdown (when embedding), and so are\n+/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).\n+template <typename... Args>\n+const char *c_str(Args &&...args) {\n+    auto &strings = get_internals().static_strings;\n+    strings.emplace_front(std::forward<Args>(args)...);\n+    return strings.front().c_str();\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+/// Returns a named pointer that is shared among all extension modules (using the same\n+/// pybind11 version) running in the current interpreter. Names starting with underscores\n+/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.\n+PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n+    auto &internals = detail::get_internals();\n+    auto it = internals.shared_data.find(name);\n+    return it != internals.shared_data.end() ? it->second : nullptr;\n+}\n+\n+/// Set the shared data that can be later recovered by `get_shared_data()`.\n+PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n+    detail::get_internals().shared_data[name] = data;\n+    return data;\n+}\n+\n+/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if\n+/// such entry exists. Otherwise, a new object of default-constructible type `T` is\n+/// added to the shared data under the given name and a reference to it is returned.\n+template <typename T>\n+T &get_or_create_shared_data(const std::string &name) {\n+    auto &internals = detail::get_internals();\n+    auto it = internals.shared_data.find(name);\n+    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);\n+    if (!ptr) {\n+        ptr = new T();\n+        internals.shared_data[name] = ptr;\n+    }\n+    return *ptr;\n+}\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/type_caster_base.h", "status": "added", "additions": 1010, "deletions": 0, "changes": 1010, "file_content_changes": "@@ -0,0 +1,1010 @@\n+/*\n+    pybind11/detail/type_caster_base.h (originally first part of pybind11/cast.h)\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"../pytypes.h\"\n+#include \"common.h\"\n+#include \"descr.h\"\n+#include \"internals.h\"\n+#include \"typeid.h\"\n+\n+#include <cstdint>\n+#include <iterator>\n+#include <new>\n+#include <string>\n+#include <type_traits>\n+#include <typeindex>\n+#include <typeinfo>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/// A life support system for temporary objects created by `type_caster::load()`.\n+/// Adding a patient will keep it alive up until the enclosing function returns.\n+class loader_life_support {\n+private:\n+    loader_life_support *parent = nullptr;\n+    std::unordered_set<PyObject *> keep_alive;\n+\n+#if defined(WITH_THREAD)\n+    // Store stack pointer in thread-local storage.\n+    static PYBIND11_TLS_KEY_REF get_stack_tls_key() {\n+#    if PYBIND11_INTERNALS_VERSION == 4\n+        return get_local_internals().loader_life_support_tls_key;\n+#    else\n+        return get_internals().loader_life_support_tls_key;\n+#    endif\n+    }\n+    static loader_life_support *get_stack_top() {\n+        return static_cast<loader_life_support *>(PYBIND11_TLS_GET_VALUE(get_stack_tls_key()));\n+    }\n+    static void set_stack_top(loader_life_support *value) {\n+        PYBIND11_TLS_REPLACE_VALUE(get_stack_tls_key(), value);\n+    }\n+#else\n+    // Use single global variable for stack.\n+    static loader_life_support **get_stack_pp() {\n+        static loader_life_support *global_stack = nullptr;\n+        return global_stack;\n+    }\n+    static loader_life_support *get_stack_top() { return *get_stack_pp(); }\n+    static void set_stack_top(loader_life_support *value) { *get_stack_pp() = value; }\n+#endif\n+\n+public:\n+    /// A new patient frame is created when a function is entered\n+    loader_life_support() : parent{get_stack_top()} { set_stack_top(this); }\n+\n+    /// ... and destroyed after it returns\n+    ~loader_life_support() {\n+        if (get_stack_top() != this) {\n+            pybind11_fail(\"loader_life_support: internal error\");\n+        }\n+        set_stack_top(parent);\n+        for (auto *item : keep_alive) {\n+            Py_DECREF(item);\n+        }\n+    }\n+\n+    /// This can only be used inside a pybind11-bound function, either by `argument_loader`\n+    /// at argument preparation time or by `py::cast()` at execution time.\n+    PYBIND11_NOINLINE static void add_patient(handle h) {\n+        loader_life_support *frame = get_stack_top();\n+        if (!frame) {\n+            // NOTE: It would be nice to include the stack frames here, as this indicates\n+            // use of pybind11::cast<> outside the normal call framework, finding such\n+            // a location is challenging. Developers could consider printing out\n+            // stack frame addresses here using something like __builtin_frame_address(0)\n+            throw cast_error(\"When called outside a bound function, py::cast() cannot \"\n+                             \"do Python -> C++ conversions which require the creation \"\n+                             \"of temporary values\");\n+        }\n+\n+        if (frame->keep_alive.insert(h.ptr()).second) {\n+            Py_INCREF(h.ptr());\n+        }\n+    }\n+};\n+\n+// Gets the cache entry for the given type, creating it if necessary.  The return value is the pair\n+// returned by emplace, i.e. an iterator for the entry and a bool set to `true` if the entry was\n+// just created.\n+inline std::pair<decltype(internals::registered_types_py)::iterator, bool>\n+all_type_info_get_cache(PyTypeObject *type);\n+\n+// Populates a just-created cache entry.\n+PYBIND11_NOINLINE void all_type_info_populate(PyTypeObject *t, std::vector<type_info *> &bases) {\n+    std::vector<PyTypeObject *> check;\n+    for (handle parent : reinterpret_borrow<tuple>(t->tp_bases)) {\n+        check.push_back((PyTypeObject *) parent.ptr());\n+    }\n+\n+    auto const &type_dict = get_internals().registered_types_py;\n+    for (size_t i = 0; i < check.size(); i++) {\n+        auto *type = check[i];\n+        // Ignore Python2 old-style class super type:\n+        if (!PyType_Check((PyObject *) type)) {\n+            continue;\n+        }\n+\n+        // Check `type` in the current set of registered python types:\n+        auto it = type_dict.find(type);\n+        if (it != type_dict.end()) {\n+            // We found a cache entry for it, so it's either pybind-registered or has pre-computed\n+            // pybind bases, but we have to make sure we haven't already seen the type(s) before:\n+            // we want to follow Python/virtual C++ rules that there should only be one instance of\n+            // a common base.\n+            for (auto *tinfo : it->second) {\n+                // NB: Could use a second set here, rather than doing a linear search, but since\n+                // having a large number of immediate pybind11-registered types seems fairly\n+                // unlikely, that probably isn't worthwhile.\n+                bool found = false;\n+                for (auto *known : bases) {\n+                    if (known == tinfo) {\n+                        found = true;\n+                        break;\n+                    }\n+                }\n+                if (!found) {\n+                    bases.push_back(tinfo);\n+                }\n+            }\n+        } else if (type->tp_bases) {\n+            // It's some python type, so keep follow its bases classes to look for one or more\n+            // registered types\n+            if (i + 1 == check.size()) {\n+                // When we're at the end, we can pop off the current element to avoid growing\n+                // `check` when adding just one base (which is typical--i.e. when there is no\n+                // multiple inheritance)\n+                check.pop_back();\n+                i--;\n+            }\n+            for (handle parent : reinterpret_borrow<tuple>(type->tp_bases)) {\n+                check.push_back((PyTypeObject *) parent.ptr());\n+            }\n+        }\n+    }\n+}\n+\n+/**\n+ * Extracts vector of type_info pointers of pybind-registered roots of the given Python type.  Will\n+ * be just 1 pybind type for the Python type of a pybind-registered class, or for any Python-side\n+ * derived class that uses single inheritance.  Will contain as many types as required for a Python\n+ * class that uses multiple inheritance to inherit (directly or indirectly) from multiple\n+ * pybind-registered classes.  Will be empty if neither the type nor any base classes are\n+ * pybind-registered.\n+ *\n+ * The value is cached for the lifetime of the Python type.\n+ */\n+inline const std::vector<detail::type_info *> &all_type_info(PyTypeObject *type) {\n+    auto ins = all_type_info_get_cache(type);\n+    if (ins.second) {\n+        // New cache entry: populate it\n+        all_type_info_populate(type, ins.first->second);\n+    }\n+\n+    return ins.first->second;\n+}\n+\n+/**\n+ * Gets a single pybind11 type info for a python type.  Returns nullptr if neither the type nor any\n+ * ancestors are pybind11-registered.  Throws an exception if there are multiple bases--use\n+ * `all_type_info` instead if you want to support multiple bases.\n+ */\n+PYBIND11_NOINLINE detail::type_info *get_type_info(PyTypeObject *type) {\n+    const auto &bases = all_type_info(type);\n+    if (bases.empty()) {\n+        return nullptr;\n+    }\n+    if (bases.size() > 1) {\n+        pybind11_fail(\n+            \"pybind11::detail::get_type_info: type has multiple pybind11-registered bases\");\n+    }\n+    return bases.front();\n+}\n+\n+inline detail::type_info *get_local_type_info(const std::type_index &tp) {\n+    auto &locals = get_local_internals().registered_types_cpp;\n+    auto it = locals.find(tp);\n+    if (it != locals.end()) {\n+        return it->second;\n+    }\n+    return nullptr;\n+}\n+\n+inline detail::type_info *get_global_type_info(const std::type_index &tp) {\n+    auto &types = get_internals().registered_types_cpp;\n+    auto it = types.find(tp);\n+    if (it != types.end()) {\n+        return it->second;\n+    }\n+    return nullptr;\n+}\n+\n+/// Return the type info for a given C++ type; on lookup failure can either throw or return\n+/// nullptr.\n+PYBIND11_NOINLINE detail::type_info *get_type_info(const std::type_index &tp,\n+                                                   bool throw_if_missing = false) {\n+    if (auto *ltype = get_local_type_info(tp)) {\n+        return ltype;\n+    }\n+    if (auto *gtype = get_global_type_info(tp)) {\n+        return gtype;\n+    }\n+\n+    if (throw_if_missing) {\n+        std::string tname = tp.name();\n+        detail::clean_type_id(tname);\n+        pybind11_fail(\"pybind11::detail::get_type_info: unable to find type info for \\\"\"\n+                      + std::move(tname) + '\"');\n+    }\n+    return nullptr;\n+}\n+\n+PYBIND11_NOINLINE handle get_type_handle(const std::type_info &tp, bool throw_if_missing) {\n+    detail::type_info *type_info = get_type_info(tp, throw_if_missing);\n+    return handle(type_info ? ((PyObject *) type_info->type) : nullptr);\n+}\n+\n+// Searches the inheritance graph for a registered Python instance, using all_type_info().\n+PYBIND11_NOINLINE handle find_registered_python_instance(void *src,\n+                                                         const detail::type_info *tinfo) {\n+    auto it_instances = get_internals().registered_instances.equal_range(src);\n+    for (auto it_i = it_instances.first; it_i != it_instances.second; ++it_i) {\n+        for (auto *instance_type : detail::all_type_info(Py_TYPE(it_i->second))) {\n+            if (instance_type && same_type(*instance_type->cpptype, *tinfo->cpptype)) {\n+                return handle((PyObject *) it_i->second).inc_ref();\n+            }\n+        }\n+    }\n+    return handle();\n+}\n+\n+struct value_and_holder {\n+    instance *inst = nullptr;\n+    size_t index = 0u;\n+    const detail::type_info *type = nullptr;\n+    void **vh = nullptr;\n+\n+    // Main constructor for a found value/holder:\n+    value_and_holder(instance *i, const detail::type_info *type, size_t vpos, size_t index)\n+        : inst{i}, index{index}, type{type}, vh{inst->simple_layout\n+                                                    ? inst->simple_value_holder\n+                                                    : &inst->nonsimple.values_and_holders[vpos]} {}\n+\n+    // Default constructor (used to signal a value-and-holder not found by get_value_and_holder())\n+    value_and_holder() = default;\n+\n+    // Used for past-the-end iterator\n+    explicit value_and_holder(size_t index) : index{index} {}\n+\n+    template <typename V = void>\n+    V *&value_ptr() const {\n+        return reinterpret_cast<V *&>(vh[0]);\n+    }\n+    // True if this `value_and_holder` has a non-null value pointer\n+    explicit operator bool() const { return value_ptr() != nullptr; }\n+\n+    template <typename H>\n+    H &holder() const {\n+        return reinterpret_cast<H &>(vh[1]);\n+    }\n+    bool holder_constructed() const {\n+        return inst->simple_layout\n+                   ? inst->simple_holder_constructed\n+                   : (inst->nonsimple.status[index] & instance::status_holder_constructed) != 0u;\n+    }\n+    // NOLINTNEXTLINE(readability-make-member-function-const)\n+    void set_holder_constructed(bool v = true) {\n+        if (inst->simple_layout) {\n+            inst->simple_holder_constructed = v;\n+        } else if (v) {\n+            inst->nonsimple.status[index] |= instance::status_holder_constructed;\n+        } else {\n+            inst->nonsimple.status[index] &= (std::uint8_t) ~instance::status_holder_constructed;\n+        }\n+    }\n+    bool instance_registered() const {\n+        return inst->simple_layout\n+                   ? inst->simple_instance_registered\n+                   : ((inst->nonsimple.status[index] & instance::status_instance_registered) != 0);\n+    }\n+    // NOLINTNEXTLINE(readability-make-member-function-const)\n+    void set_instance_registered(bool v = true) {\n+        if (inst->simple_layout) {\n+            inst->simple_instance_registered = v;\n+        } else if (v) {\n+            inst->nonsimple.status[index] |= instance::status_instance_registered;\n+        } else {\n+            inst->nonsimple.status[index] &= (std::uint8_t) ~instance::status_instance_registered;\n+        }\n+    }\n+};\n+\n+// Container for accessing and iterating over an instance's values/holders\n+struct values_and_holders {\n+private:\n+    instance *inst;\n+    using type_vec = std::vector<detail::type_info *>;\n+    const type_vec &tinfo;\n+\n+public:\n+    explicit values_and_holders(instance *inst)\n+        : inst{inst}, tinfo(all_type_info(Py_TYPE(inst))) {}\n+\n+    struct iterator {\n+    private:\n+        instance *inst = nullptr;\n+        const type_vec *types = nullptr;\n+        value_and_holder curr;\n+        friend struct values_and_holders;\n+        iterator(instance *inst, const type_vec *tinfo)\n+            : inst{inst}, types{tinfo},\n+              curr(inst /* instance */,\n+                   types->empty() ? nullptr : (*types)[0] /* type info */,\n+                   0, /* vpos: (non-simple types only): the first vptr comes first */\n+                   0 /* index */) {}\n+        // Past-the-end iterator:\n+        explicit iterator(size_t end) : curr(end) {}\n+\n+    public:\n+        bool operator==(const iterator &other) const { return curr.index == other.curr.index; }\n+        bool operator!=(const iterator &other) const { return curr.index != other.curr.index; }\n+        iterator &operator++() {\n+            if (!inst->simple_layout) {\n+                curr.vh += 1 + (*types)[curr.index]->holder_size_in_ptrs;\n+            }\n+            ++curr.index;\n+            curr.type = curr.index < types->size() ? (*types)[curr.index] : nullptr;\n+            return *this;\n+        }\n+        value_and_holder &operator*() { return curr; }\n+        value_and_holder *operator->() { return &curr; }\n+    };\n+\n+    iterator begin() { return iterator(inst, &tinfo); }\n+    iterator end() { return iterator(tinfo.size()); }\n+\n+    iterator find(const type_info *find_type) {\n+        auto it = begin(), endit = end();\n+        while (it != endit && it->type != find_type) {\n+            ++it;\n+        }\n+        return it;\n+    }\n+\n+    size_t size() { return tinfo.size(); }\n+};\n+\n+/**\n+ * Extracts C++ value and holder pointer references from an instance (which may contain multiple\n+ * values/holders for python-side multiple inheritance) that match the given type.  Throws an error\n+ * if the given type (or ValueType, if omitted) is not a pybind11 base of the given instance.  If\n+ * `find_type` is omitted (or explicitly specified as nullptr) the first value/holder are returned,\n+ * regardless of type (and the resulting .type will be nullptr).\n+ *\n+ * The returned object should be short-lived: in particular, it must not outlive the called-upon\n+ * instance.\n+ */\n+PYBIND11_NOINLINE value_and_holder\n+instance::get_value_and_holder(const type_info *find_type /*= nullptr default in common.h*/,\n+                               bool throw_if_missing /*= true in common.h*/) {\n+    // Optimize common case:\n+    if (!find_type || Py_TYPE(this) == find_type->type) {\n+        return value_and_holder(this, find_type, 0, 0);\n+    }\n+\n+    detail::values_and_holders vhs(this);\n+    auto it = vhs.find(find_type);\n+    if (it != vhs.end()) {\n+        return *it;\n+    }\n+\n+    if (!throw_if_missing) {\n+        return value_and_holder();\n+    }\n+\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+    pybind11_fail(\"pybind11::detail::instance::get_value_and_holder: `\"\n+                  + get_fully_qualified_tp_name(find_type->type)\n+                  + \"' is not a pybind11 base of the given `\"\n+                  + get_fully_qualified_tp_name(Py_TYPE(this)) + \"' instance\");\n+#else\n+    pybind11_fail(\n+        \"pybind11::detail::instance::get_value_and_holder: \"\n+        \"type is not a pybind11 base of the given instance \"\n+        \"(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for type details)\");\n+#endif\n+}\n+\n+PYBIND11_NOINLINE void instance::allocate_layout() {\n+    const auto &tinfo = all_type_info(Py_TYPE(this));\n+\n+    const size_t n_types = tinfo.size();\n+\n+    if (n_types == 0) {\n+        pybind11_fail(\n+            \"instance allocation failed: new instance has no pybind11-registered base types\");\n+    }\n+\n+    simple_layout\n+        = n_types == 1 && tinfo.front()->holder_size_in_ptrs <= instance_simple_holder_in_ptrs();\n+\n+    // Simple path: no python-side multiple inheritance, and a small-enough holder\n+    if (simple_layout) {\n+        simple_value_holder[0] = nullptr;\n+        simple_holder_constructed = false;\n+        simple_instance_registered = false;\n+    } else { // multiple base types or a too-large holder\n+        // Allocate space to hold: [v1*][h1][v2*][h2]...[bb...] where [vN*] is a value pointer,\n+        // [hN] is the (uninitialized) holder instance for value N, and [bb...] is a set of bool\n+        // values that tracks whether each associated holder has been initialized.  Each [block] is\n+        // padded, if necessary, to an integer multiple of sizeof(void *).\n+        size_t space = 0;\n+        for (auto *t : tinfo) {\n+            space += 1;                      // value pointer\n+            space += t->holder_size_in_ptrs; // holder instance\n+        }\n+        size_t flags_at = space;\n+        space += size_in_ptrs(n_types); // status bytes (holder_constructed and\n+                                        // instance_registered)\n+\n+        // Allocate space for flags, values, and holders, and initialize it to 0 (flags and values,\n+        // in particular, need to be 0).  Use Python's memory allocation\n+        // functions: Python is using pymalloc, which is designed to be\n+        // efficient for small allocations like the one we're doing here;\n+        // for larger allocations they are just wrappers around malloc.\n+        // TODO: is this still true for pure Python 3.6?\n+        nonsimple.values_and_holders = (void **) PyMem_Calloc(space, sizeof(void *));\n+        if (!nonsimple.values_and_holders) {\n+            throw std::bad_alloc();\n+        }\n+        nonsimple.status\n+            = reinterpret_cast<std::uint8_t *>(&nonsimple.values_and_holders[flags_at]);\n+    }\n+    owned = true;\n+}\n+\n+// NOLINTNEXTLINE(readability-make-member-function-const)\n+PYBIND11_NOINLINE void instance::deallocate_layout() {\n+    if (!simple_layout) {\n+        PyMem_Free(nonsimple.values_and_holders);\n+    }\n+}\n+\n+PYBIND11_NOINLINE bool isinstance_generic(handle obj, const std::type_info &tp) {\n+    handle type = detail::get_type_handle(tp, false);\n+    if (!type) {\n+        return false;\n+    }\n+    return isinstance(obj, type);\n+}\n+\n+PYBIND11_NOINLINE handle get_object_handle(const void *ptr, const detail::type_info *type) {\n+    auto &instances = get_internals().registered_instances;\n+    auto range = instances.equal_range(ptr);\n+    for (auto it = range.first; it != range.second; ++it) {\n+        for (const auto &vh : values_and_holders(it->second)) {\n+            if (vh.type == type) {\n+                return handle((PyObject *) it->second);\n+            }\n+        }\n+    }\n+    return handle();\n+}\n+\n+inline PyThreadState *get_thread_state_unchecked() {\n+#if defined(PYPY_VERSION)\n+    return PyThreadState_GET();\n+#else\n+    return _PyThreadState_UncheckedGet();\n+#endif\n+}\n+\n+// Forward declarations\n+void keep_alive_impl(handle nurse, handle patient);\n+inline PyObject *make_new_instance(PyTypeObject *type);\n+\n+class type_caster_generic {\n+public:\n+    PYBIND11_NOINLINE explicit type_caster_generic(const std::type_info &type_info)\n+        : typeinfo(get_type_info(type_info)), cpptype(&type_info) {}\n+\n+    explicit type_caster_generic(const type_info *typeinfo)\n+        : typeinfo(typeinfo), cpptype(typeinfo ? typeinfo->cpptype : nullptr) {}\n+\n+    bool load(handle src, bool convert) { return load_impl<type_caster_generic>(src, convert); }\n+\n+    PYBIND11_NOINLINE static handle cast(const void *_src,\n+                                         return_value_policy policy,\n+                                         handle parent,\n+                                         const detail::type_info *tinfo,\n+                                         void *(*copy_constructor)(const void *),\n+                                         void *(*move_constructor)(const void *),\n+                                         const void *existing_holder = nullptr) {\n+        if (!tinfo) { // no type info: error will be set already\n+            return handle();\n+        }\n+\n+        void *src = const_cast<void *>(_src);\n+        if (src == nullptr) {\n+            return none().release();\n+        }\n+\n+        if (handle registered_inst = find_registered_python_instance(src, tinfo)) {\n+            return registered_inst;\n+        }\n+\n+        auto inst = reinterpret_steal<object>(make_new_instance(tinfo->type));\n+        auto *wrapper = reinterpret_cast<instance *>(inst.ptr());\n+        wrapper->owned = false;\n+        void *&valueptr = values_and_holders(wrapper).begin()->value_ptr();\n+\n+        switch (policy) {\n+            case return_value_policy::automatic:\n+            case return_value_policy::take_ownership:\n+                valueptr = src;\n+                wrapper->owned = true;\n+                break;\n+\n+            case return_value_policy::automatic_reference:\n+            case return_value_policy::reference:\n+                valueptr = src;\n+                wrapper->owned = false;\n+                break;\n+\n+            case return_value_policy::copy:\n+                if (copy_constructor) {\n+                    valueptr = copy_constructor(src);\n+                } else {\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+                    std::string type_name(tinfo->cpptype->name());\n+                    detail::clean_type_id(type_name);\n+                    throw cast_error(\"return_value_policy = copy, but type \" + type_name\n+                                     + \" is non-copyable!\");\n+#else\n+                    throw cast_error(\"return_value_policy = copy, but type is \"\n+                                     \"non-copyable! (#define PYBIND11_DETAILED_ERROR_MESSAGES or \"\n+                                     \"compile in debug mode for details)\");\n+#endif\n+                }\n+                wrapper->owned = true;\n+                break;\n+\n+            case return_value_policy::move:\n+                if (move_constructor) {\n+                    valueptr = move_constructor(src);\n+                } else if (copy_constructor) {\n+                    valueptr = copy_constructor(src);\n+                } else {\n+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+                    std::string type_name(tinfo->cpptype->name());\n+                    detail::clean_type_id(type_name);\n+                    throw cast_error(\"return_value_policy = move, but type \" + type_name\n+                                     + \" is neither movable nor copyable!\");\n+#else\n+                    throw cast_error(\"return_value_policy = move, but type is neither \"\n+                                     \"movable nor copyable! \"\n+                                     \"(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in \"\n+                                     \"debug mode for details)\");\n+#endif\n+                }\n+                wrapper->owned = true;\n+                break;\n+\n+            case return_value_policy::reference_internal:\n+                valueptr = src;\n+                wrapper->owned = false;\n+                keep_alive_impl(inst, parent);\n+                break;\n+\n+            default:\n+                throw cast_error(\"unhandled return_value_policy: should not happen!\");\n+        }\n+\n+        tinfo->init_instance(wrapper, existing_holder);\n+\n+        return inst.release();\n+    }\n+\n+    // Base methods for generic caster; there are overridden in copyable_holder_caster\n+    void load_value(value_and_holder &&v_h) {\n+        auto *&vptr = v_h.value_ptr();\n+        // Lazy allocation for unallocated values:\n+        if (vptr == nullptr) {\n+            const auto *type = v_h.type ? v_h.type : typeinfo;\n+            if (type->operator_new) {\n+                vptr = type->operator_new(type->type_size);\n+            } else {\n+#if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)\n+                if (type->type_align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {\n+                    vptr = ::operator new(type->type_size, std::align_val_t(type->type_align));\n+                } else {\n+                    vptr = ::operator new(type->type_size);\n+                }\n+#else\n+                vptr = ::operator new(type->type_size);\n+#endif\n+            }\n+        }\n+        value = vptr;\n+    }\n+    bool try_implicit_casts(handle src, bool convert) {\n+        for (const auto &cast : typeinfo->implicit_casts) {\n+            type_caster_generic sub_caster(*cast.first);\n+            if (sub_caster.load(src, convert)) {\n+                value = cast.second(sub_caster.value);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    bool try_direct_conversions(handle src) {\n+        for (auto &converter : *typeinfo->direct_conversions) {\n+            if (converter(src.ptr(), value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    void check_holder_compat() {}\n+\n+    PYBIND11_NOINLINE static void *local_load(PyObject *src, const type_info *ti) {\n+        auto caster = type_caster_generic(ti);\n+        if (caster.load(src, false)) {\n+            return caster.value;\n+        }\n+        return nullptr;\n+    }\n+\n+    /// Try to load with foreign typeinfo, if available. Used when there is no\n+    /// native typeinfo, or when the native one wasn't able to produce a value.\n+    PYBIND11_NOINLINE bool try_load_foreign_module_local(handle src) {\n+        constexpr auto *local_key = PYBIND11_MODULE_LOCAL_ID;\n+        const auto pytype = type::handle_of(src);\n+        if (!hasattr(pytype, local_key)) {\n+            return false;\n+        }\n+\n+        type_info *foreign_typeinfo = reinterpret_borrow<capsule>(getattr(pytype, local_key));\n+        // Only consider this foreign loader if actually foreign and is a loader of the correct cpp\n+        // type\n+        if (foreign_typeinfo->module_local_load == &local_load\n+            || (cpptype && !same_type(*cpptype, *foreign_typeinfo->cpptype))) {\n+            return false;\n+        }\n+\n+        if (auto *result = foreign_typeinfo->module_local_load(src.ptr(), foreign_typeinfo)) {\n+            value = result;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    // Implementation of `load`; this takes the type of `this` so that it can dispatch the relevant\n+    // bits of code between here and copyable_holder_caster where the two classes need different\n+    // logic (without having to resort to virtual inheritance).\n+    template <typename ThisT>\n+    PYBIND11_NOINLINE bool load_impl(handle src, bool convert) {\n+        if (!src) {\n+            return false;\n+        }\n+        if (!typeinfo) {\n+            return try_load_foreign_module_local(src);\n+        }\n+\n+        auto &this_ = static_cast<ThisT &>(*this);\n+        this_.check_holder_compat();\n+\n+        PyTypeObject *srctype = Py_TYPE(src.ptr());\n+\n+        // Case 1: If src is an exact type match for the target type then we can reinterpret_cast\n+        // the instance's value pointer to the target type:\n+        if (srctype == typeinfo->type) {\n+            this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());\n+            return true;\n+        }\n+        // Case 2: We have a derived class\n+        if (PyType_IsSubtype(srctype, typeinfo->type)) {\n+            const auto &bases = all_type_info(srctype);\n+            bool no_cpp_mi = typeinfo->simple_type;\n+\n+            // Case 2a: the python type is a Python-inherited derived class that inherits from just\n+            // one simple (no MI) pybind11 class, or is an exact match, so the C++ instance is of\n+            // the right type and we can use reinterpret_cast.\n+            // (This is essentially the same as case 2b, but because not using multiple inheritance\n+            // is extremely common, we handle it specially to avoid the loop iterator and type\n+            // pointer lookup overhead)\n+            if (bases.size() == 1 && (no_cpp_mi || bases.front()->type == typeinfo->type)) {\n+                this_.load_value(reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());\n+                return true;\n+            }\n+            // Case 2b: the python type inherits from multiple C++ bases.  Check the bases to see\n+            // if we can find an exact match (or, for a simple C++ type, an inherited match); if\n+            // so, we can safely reinterpret_cast to the relevant pointer.\n+            if (bases.size() > 1) {\n+                for (auto *base : bases) {\n+                    if (no_cpp_mi ? PyType_IsSubtype(base->type, typeinfo->type)\n+                                  : base->type == typeinfo->type) {\n+                        this_.load_value(\n+                            reinterpret_cast<instance *>(src.ptr())->get_value_and_holder(base));\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            // Case 2c: C++ multiple inheritance is involved and we couldn't find an exact type\n+            // match in the registered bases, above, so try implicit casting (needed for proper C++\n+            // casting when MI is involved).\n+            if (this_.try_implicit_casts(src, convert)) {\n+                return true;\n+            }\n+        }\n+\n+        // Perform an implicit conversion\n+        if (convert) {\n+            for (const auto &converter : typeinfo->implicit_conversions) {\n+                auto temp = reinterpret_steal<object>(converter(src.ptr(), typeinfo->type));\n+                if (load_impl<ThisT>(temp, false)) {\n+                    loader_life_support::add_patient(temp);\n+                    return true;\n+                }\n+            }\n+            if (this_.try_direct_conversions(src)) {\n+                return true;\n+            }\n+        }\n+\n+        // Failed to match local typeinfo. Try again with global.\n+        if (typeinfo->module_local) {\n+            if (auto *gtype = get_global_type_info(*typeinfo->cpptype)) {\n+                typeinfo = gtype;\n+                return load(src, false);\n+            }\n+        }\n+\n+        // Global typeinfo has precedence over foreign module_local\n+        if (try_load_foreign_module_local(src)) {\n+            return true;\n+        }\n+\n+        // Custom converters didn't take None, now we convert None to nullptr.\n+        if (src.is_none()) {\n+            // Defer accepting None to other overloads (if we aren't in convert mode):\n+            if (!convert) {\n+                return false;\n+            }\n+            value = nullptr;\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    // Called to do type lookup and wrap the pointer and type in a pair when a dynamic_cast\n+    // isn't needed or can't be used.  If the type is unknown, sets the error and returns a pair\n+    // with .second = nullptr.  (p.first = nullptr is not an error: it becomes None).\n+    PYBIND11_NOINLINE static std::pair<const void *, const type_info *>\n+    src_and_type(const void *src,\n+                 const std::type_info &cast_type,\n+                 const std::type_info *rtti_type = nullptr) {\n+        if (auto *tpi = get_type_info(cast_type)) {\n+            return {src, const_cast<const type_info *>(tpi)};\n+        }\n+\n+        // Not found, set error:\n+        std::string tname = rtti_type ? rtti_type->name() : cast_type.name();\n+        detail::clean_type_id(tname);\n+        std::string msg = \"Unregistered type : \" + tname;\n+        PyErr_SetString(PyExc_TypeError, msg.c_str());\n+        return {nullptr, nullptr};\n+    }\n+\n+    const type_info *typeinfo = nullptr;\n+    const std::type_info *cpptype = nullptr;\n+    void *value = nullptr;\n+};\n+\n+/**\n+ * Determine suitable casting operator for pointer-or-lvalue-casting type casters.  The type caster\n+ * needs to provide `operator T*()` and `operator T&()` operators.\n+ *\n+ * If the type supports moving the value away via an `operator T&&() &&` method, it should use\n+ * `movable_cast_op_type` instead.\n+ */\n+template <typename T>\n+using cast_op_type = conditional_t<std::is_pointer<remove_reference_t<T>>::value,\n+                                   typename std::add_pointer<intrinsic_t<T>>::type,\n+                                   typename std::add_lvalue_reference<intrinsic_t<T>>::type>;\n+\n+/**\n+ * Determine suitable casting operator for a type caster with a movable value.  Such a type caster\n+ * needs to provide `operator T*()`, `operator T&()`, and `operator T&&() &&`.  The latter will be\n+ * called in appropriate contexts where the value can be moved rather than copied.\n+ *\n+ * These operator are automatically provided when using the PYBIND11_TYPE_CASTER macro.\n+ */\n+template <typename T>\n+using movable_cast_op_type\n+    = conditional_t<std::is_pointer<typename std::remove_reference<T>::type>::value,\n+                    typename std::add_pointer<intrinsic_t<T>>::type,\n+                    conditional_t<std::is_rvalue_reference<T>::value,\n+                                  typename std::add_rvalue_reference<intrinsic_t<T>>::type,\n+                                  typename std::add_lvalue_reference<intrinsic_t<T>>::type>>;\n+\n+// std::is_copy_constructible isn't quite enough: it lets std::vector<T> (and similar) through when\n+// T is non-copyable, but code containing such a copy constructor fails to actually compile.\n+template <typename T, typename SFINAE = void>\n+struct is_copy_constructible : std::is_copy_constructible<T> {};\n+\n+// Specialization for types that appear to be copy constructible but also look like stl containers\n+// (we specifically check for: has `value_type` and `reference` with `reference = value_type&`): if\n+// so, copy constructability depends on whether the value_type is copy constructible.\n+template <typename Container>\n+struct is_copy_constructible<\n+    Container,\n+    enable_if_t<\n+        all_of<std::is_copy_constructible<Container>,\n+               std::is_same<typename Container::value_type &, typename Container::reference>,\n+               // Avoid infinite recursion\n+               negation<std::is_same<Container, typename Container::value_type>>>::value>>\n+    : is_copy_constructible<typename Container::value_type> {};\n+\n+// Likewise for std::pair\n+// (after C++17 it is mandatory that the copy constructor not exist when the two types aren't\n+// themselves copy constructible, but this can not be relied upon when T1 or T2 are themselves\n+// containers).\n+template <typename T1, typename T2>\n+struct is_copy_constructible<std::pair<T1, T2>>\n+    : all_of<is_copy_constructible<T1>, is_copy_constructible<T2>> {};\n+\n+// The same problems arise with std::is_copy_assignable, so we use the same workaround.\n+template <typename T, typename SFINAE = void>\n+struct is_copy_assignable : std::is_copy_assignable<T> {};\n+template <typename Container>\n+struct is_copy_assignable<Container,\n+                          enable_if_t<all_of<std::is_copy_assignable<Container>,\n+                                             std::is_same<typename Container::value_type &,\n+                                                          typename Container::reference>>::value>>\n+    : is_copy_assignable<typename Container::value_type> {};\n+template <typename T1, typename T2>\n+struct is_copy_assignable<std::pair<T1, T2>>\n+    : all_of<is_copy_assignable<T1>, is_copy_assignable<T2>> {};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+// polymorphic_type_hook<itype>::get(src, tinfo) determines whether the object pointed\n+// to by `src` actually is an instance of some class derived from `itype`.\n+// If so, it sets `tinfo` to point to the std::type_info representing that derived\n+// type, and returns a pointer to the start of the most-derived object of that type\n+// (in which `src` is a subobject; this will be the same address as `src` in most\n+// single inheritance cases). If not, or if `src` is nullptr, it simply returns `src`\n+// and leaves `tinfo` at its default value of nullptr.\n+//\n+// The default polymorphic_type_hook just returns src. A specialization for polymorphic\n+// types determines the runtime type of the passed object and adjusts the this-pointer\n+// appropriately via dynamic_cast<void*>. This is what enables a C++ Animal* to appear\n+// to Python as a Dog (if Dog inherits from Animal, Animal is polymorphic, Dog is\n+// registered with pybind11, and this Animal is in fact a Dog).\n+//\n+// You may specialize polymorphic_type_hook yourself for types that want to appear\n+// polymorphic to Python but do not use C++ RTTI. (This is a not uncommon pattern\n+// in performance-sensitive applications, used most notably in LLVM.)\n+//\n+// polymorphic_type_hook_base allows users to specialize polymorphic_type_hook with\n+// std::enable_if. User provided specializations will always have higher priority than\n+// the default implementation and specialization provided in polymorphic_type_hook_base.\n+template <typename itype, typename SFINAE = void>\n+struct polymorphic_type_hook_base {\n+    static const void *get(const itype *src, const std::type_info *&) { return src; }\n+};\n+template <typename itype>\n+struct polymorphic_type_hook_base<itype, detail::enable_if_t<std::is_polymorphic<itype>::value>> {\n+    static const void *get(const itype *src, const std::type_info *&type) {\n+        type = src ? &typeid(*src) : nullptr;\n+        return dynamic_cast<const void *>(src);\n+    }\n+};\n+template <typename itype, typename SFINAE = void>\n+struct polymorphic_type_hook : public polymorphic_type_hook_base<itype> {};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/// Generic type caster for objects stored on the heap\n+template <typename type>\n+class type_caster_base : public type_caster_generic {\n+    using itype = intrinsic_t<type>;\n+\n+public:\n+    static constexpr auto name = const_name<type>();\n+\n+    type_caster_base() : type_caster_base(typeid(type)) {}\n+    explicit type_caster_base(const std::type_info &info) : type_caster_generic(info) {}\n+\n+    static handle cast(const itype &src, return_value_policy policy, handle parent) {\n+        if (policy == return_value_policy::automatic\n+            || policy == return_value_policy::automatic_reference) {\n+            policy = return_value_policy::copy;\n+        }\n+        return cast(&src, policy, parent);\n+    }\n+\n+    static handle cast(itype &&src, return_value_policy, handle parent) {\n+        return cast(&src, return_value_policy::move, parent);\n+    }\n+\n+    // Returns a (pointer, type_info) pair taking care of necessary type lookup for a\n+    // polymorphic type (using RTTI by default, but can be overridden by specializing\n+    // polymorphic_type_hook). If the instance isn't derived, returns the base version.\n+    static std::pair<const void *, const type_info *> src_and_type(const itype *src) {\n+        const auto &cast_type = typeid(itype);\n+        const std::type_info *instance_type = nullptr;\n+        const void *vsrc = polymorphic_type_hook<itype>::get(src, instance_type);\n+        if (instance_type && !same_type(cast_type, *instance_type)) {\n+            // This is a base pointer to a derived type. If the derived type is registered\n+            // with pybind11, we want to make the full derived object available.\n+            // In the typical case where itype is polymorphic, we get the correct\n+            // derived pointer (which may be != base pointer) by a dynamic_cast to\n+            // most derived type. If itype is not polymorphic, we won't get here\n+            // except via a user-provided specialization of polymorphic_type_hook,\n+            // and the user has promised that no this-pointer adjustment is\n+            // required in that case, so it's OK to use static_cast.\n+            if (const auto *tpi = get_type_info(*instance_type)) {\n+                return {vsrc, tpi};\n+            }\n+        }\n+        // Otherwise we have either a nullptr, an `itype` pointer, or an unknown derived pointer,\n+        // so don't do a cast\n+        return type_caster_generic::src_and_type(src, cast_type, instance_type);\n+    }\n+\n+    static handle cast(const itype *src, return_value_policy policy, handle parent) {\n+        auto st = src_and_type(src);\n+        return type_caster_generic::cast(st.first,\n+                                         policy,\n+                                         parent,\n+                                         st.second,\n+                                         make_copy_constructor(src),\n+                                         make_move_constructor(src));\n+    }\n+\n+    static handle cast_holder(const itype *src, const void *holder) {\n+        auto st = src_and_type(src);\n+        return type_caster_generic::cast(st.first,\n+                                         return_value_policy::take_ownership,\n+                                         {},\n+                                         st.second,\n+                                         nullptr,\n+                                         nullptr,\n+                                         holder);\n+    }\n+\n+    template <typename T>\n+    using cast_op_type = detail::cast_op_type<T>;\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator itype *() { return (type *) value; }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator itype &() {\n+        if (!value) {\n+            throw reference_cast_error();\n+        }\n+        return *((itype *) value);\n+    }\n+\n+protected:\n+    using Constructor = void *(*) (const void *);\n+\n+    /* Only enabled when the types are {copy,move}-constructible *and* when the type\n+       does not have a private operator new implementation. A comma operator is used in the\n+       decltype argument to apply SFINAE to the public copy/move constructors.*/\n+    template <typename T, typename = enable_if_t<is_copy_constructible<T>::value>>\n+    static auto make_copy_constructor(const T *)\n+        -> decltype(new T(std::declval<const T>()), Constructor{}) {\n+        return [](const void *arg) -> void * { return new T(*reinterpret_cast<const T *>(arg)); };\n+    }\n+\n+    template <typename T, typename = enable_if_t<std::is_move_constructible<T>::value>>\n+    static auto make_move_constructor(const T *)\n+        -> decltype(new T(std::declval<T &&>()), Constructor{}) {\n+        return [](const void *arg) -> void * {\n+            return new T(std::move(*const_cast<T *>(reinterpret_cast<const T *>(arg))));\n+        };\n+    }\n+\n+    static Constructor make_copy_constructor(...) { return nullptr; }\n+    static Constructor make_move_constructor(...) { return nullptr; }\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/typeid.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "file_content_changes": "@@ -0,0 +1,65 @@\n+/*\n+    pybind11/detail/typeid.h: Compiler-independent access to type identifiers\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include <cstdio>\n+#include <cstdlib>\n+\n+#if defined(__GNUG__)\n+#    include <cxxabi.h>\n+#endif\n+\n+#include \"common.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/// Erase all occurrences of a substring\n+inline void erase_all(std::string &string, const std::string &search) {\n+    for (size_t pos = 0;;) {\n+        pos = string.find(search, pos);\n+        if (pos == std::string::npos) {\n+            break;\n+        }\n+        string.erase(pos, search.length());\n+    }\n+}\n+\n+PYBIND11_NOINLINE void clean_type_id(std::string &name) {\n+#if defined(__GNUG__)\n+    int status = 0;\n+    std::unique_ptr<char, void (*)(void *)> res{\n+        abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free};\n+    if (status == 0) {\n+        name = res.get();\n+    }\n+#else\n+    detail::erase_all(name, \"class \");\n+    detail::erase_all(name, \"struct \");\n+    detail::erase_all(name, \"enum \");\n+#endif\n+    detail::erase_all(name, \"pybind11::\");\n+}\n+\n+inline std::string clean_type_id(const char *typeid_name) {\n+    std::string name(typeid_name);\n+    detail::clean_type_id(name);\n+    return name;\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+/// Return a string representation of a C++ type\n+template <typename T>\n+static std::string type_id() {\n+    return detail::clean_type_id(typeid(T).name());\n+}\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/eigen.h", "status": "added", "additions": 708, "deletions": 0, "changes": 708, "file_content_changes": "@@ -0,0 +1,708 @@\n+/*\n+    pybind11/eigen.h: Transparent conversion for dense and sparse Eigen matrices\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+/* HINT: To suppress warnings originating from the Eigen headers, use -isystem.\n+   See also:\n+       https://stackoverflow.com/questions/2579576/i-dir-vs-isystem-dir\n+       https://stackoverflow.com/questions/1741816/isystem-for-ms-visual-studio-c-compiler\n+*/\n+\n+#include \"numpy.h\"\n+\n+// The C4127 suppression was introduced for Eigen 3.4.0. In theory we could\n+// make it version specific, or even remove it later, but considering that\n+// 1. C4127 is generally far more distracting than useful for modern template code, and\n+// 2. we definitely want to ignore any MSVC warnings originating from Eigen code,\n+//    it is probably best to keep this around indefinitely.\n+#if defined(_MSC_VER)\n+#    pragma warning(push)\n+#    pragma warning(disable : 4127) // C4127: conditional expression is constant\n+#    pragma warning(disable : 5054) // https://github.com/pybind/pybind11/pull/3741\n+//       C5054: operator '&': deprecated between enumerations of different types\n+#endif\n+\n+#include <Eigen/Core>\n+#include <Eigen/SparseCore>\n+\n+#if defined(_MSC_VER)\n+#    pragma warning(pop)\n+#endif\n+\n+// Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit\n+// move constructors that break things.  We could detect this an explicitly copy, but an extra copy\n+// of matrices seems highly undesirable.\n+static_assert(EIGEN_VERSION_AT_LEAST(3, 2, 7),\n+              \"Eigen support in pybind11 requires Eigen >= 3.2.7\");\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+// Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:\n+using EigenDStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;\n+template <typename MatrixType>\n+using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;\n+template <typename MatrixType>\n+using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+#if EIGEN_VERSION_AT_LEAST(3, 3, 0)\n+using EigenIndex = Eigen::Index;\n+template <typename Scalar, int Flags, typename StorageIndex>\n+using EigenMapSparseMatrix = Eigen::Map<Eigen::SparseMatrix<Scalar, Flags, StorageIndex>>;\n+#else\n+using EigenIndex = EIGEN_DEFAULT_DENSE_INDEX_TYPE;\n+template <typename Scalar, int Flags, typename StorageIndex>\n+using EigenMapSparseMatrix = Eigen::MappedSparseMatrix<Scalar, Flags, StorageIndex>;\n+#endif\n+\n+// Matches Eigen::Map, Eigen::Ref, blocks, etc:\n+template <typename T>\n+using is_eigen_dense_map = all_of<is_template_base_of<Eigen::DenseBase, T>,\n+                                  std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;\n+template <typename T>\n+using is_eigen_mutable_map = std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;\n+template <typename T>\n+using is_eigen_dense_plain\n+    = all_of<negation<is_eigen_dense_map<T>>, is_template_base_of<Eigen::PlainObjectBase, T>>;\n+template <typename T>\n+using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;\n+// Test for objects inheriting from EigenBase<Derived> that aren't captured by the above.  This\n+// basically covers anything that can be assigned to a dense matrix but that don't have a typical\n+// matrix data layout that can be copied from their .data().  For example, DiagonalMatrix and\n+// SelfAdjointView fall into this category.\n+template <typename T>\n+using is_eigen_other\n+    = all_of<is_template_base_of<Eigen::EigenBase, T>,\n+             negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>, is_eigen_sparse<T>>>>;\n+\n+// Captures numpy/eigen conformability status (returned by EigenProps::conformable()):\n+template <bool EigenRowMajor>\n+struct EigenConformable {\n+    bool conformable = false;\n+    EigenIndex rows = 0, cols = 0;\n+    EigenDStride stride{0, 0};    // Only valid if negativestrides is false!\n+    bool negativestrides = false; // If true, do not use stride!\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    EigenConformable(bool fits = false) : conformable{fits} {}\n+    // Matrix type:\n+    EigenConformable(EigenIndex r, EigenIndex c, EigenIndex rstride, EigenIndex cstride)\n+        : conformable{true}, rows{r}, cols{c},\n+          // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity.\n+          // http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747\n+          stride{EigenRowMajor ? (rstride > 0 ? rstride : 0)\n+                               : (cstride > 0 ? cstride : 0) /* outer stride */,\n+                 EigenRowMajor ? (cstride > 0 ? cstride : 0)\n+                               : (rstride > 0 ? rstride : 0) /* inner stride */},\n+          negativestrides{rstride < 0 || cstride < 0} {}\n+    // Vector type:\n+    EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)\n+        : EigenConformable(r, c, r == 1 ? c * stride : stride, c == 1 ? r : r * stride) {}\n+\n+    template <typename props>\n+    bool stride_compatible() const {\n+        // To have compatible strides, we need (on both dimensions) one of fully dynamic strides,\n+        // matching strides, or a dimension size of 1 (in which case the stride value is\n+        // irrelevant). Alternatively, if any dimension size is 0, the strides are not relevant\n+        // (and numpy \u2265 1.23 sets the strides to 0 in that case, so we need to check explicitly).\n+        if (negativestrides) {\n+            return false;\n+        }\n+        if (rows == 0 || cols == 0) {\n+            return true;\n+        }\n+        return (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner()\n+                || (EigenRowMajor ? cols : rows) == 1)\n+               && (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer()\n+                   || (EigenRowMajor ? rows : cols) == 1);\n+    }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator bool() const { return conformable; }\n+};\n+\n+template <typename Type>\n+struct eigen_extract_stride {\n+    using type = Type;\n+};\n+template <typename PlainObjectType, int MapOptions, typename StrideType>\n+struct eigen_extract_stride<Eigen::Map<PlainObjectType, MapOptions, StrideType>> {\n+    using type = StrideType;\n+};\n+template <typename PlainObjectType, int Options, typename StrideType>\n+struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> {\n+    using type = StrideType;\n+};\n+\n+// Helper struct for extracting information from an Eigen type\n+template <typename Type_>\n+struct EigenProps {\n+    using Type = Type_;\n+    using Scalar = typename Type::Scalar;\n+    using StrideType = typename eigen_extract_stride<Type>::type;\n+    static constexpr EigenIndex rows = Type::RowsAtCompileTime, cols = Type::ColsAtCompileTime,\n+                                size = Type::SizeAtCompileTime;\n+    static constexpr bool row_major = Type::IsRowMajor,\n+                          vector\n+                          = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1\n+        fixed_rows = rows != Eigen::Dynamic, fixed_cols = cols != Eigen::Dynamic,\n+                          fixed = size != Eigen::Dynamic, // Fully-fixed size\n+        dynamic = !fixed_rows && !fixed_cols;             // Fully-dynamic size\n+\n+    template <EigenIndex i, EigenIndex ifzero>\n+    using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;\n+    static constexpr EigenIndex inner_stride\n+        = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,\n+        outer_stride = if_zero < StrideType::OuterStrideAtCompileTime,\n+        vector      ? size\n+        : row_major ? cols\n+                    : rows > ::value;\n+    static constexpr bool dynamic_stride\n+        = inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;\n+    static constexpr bool requires_row_major\n+        = !dynamic_stride && !vector && (row_major ? inner_stride : outer_stride) == 1;\n+    static constexpr bool requires_col_major\n+        = !dynamic_stride && !vector && (row_major ? outer_stride : inner_stride) == 1;\n+\n+    // Takes an input array and determines whether we can make it fit into the Eigen type.  If\n+    // the array is a vector, we attempt to fit it into either an Eigen 1xN or Nx1 vector\n+    // (preferring the latter if it will fit in either, i.e. for a fully dynamic matrix type).\n+    static EigenConformable<row_major> conformable(const array &a) {\n+        const auto dims = a.ndim();\n+        if (dims < 1 || dims > 2) {\n+            return false;\n+        }\n+\n+        if (dims == 2) { // Matrix type: require exact match (or dynamic)\n+\n+            EigenIndex np_rows = a.shape(0), np_cols = a.shape(1),\n+                       np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),\n+                       np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));\n+            if ((PYBIND11_SILENCE_MSVC_C4127(fixed_rows) && np_rows != rows)\n+                || (PYBIND11_SILENCE_MSVC_C4127(fixed_cols) && np_cols != cols)) {\n+                return false;\n+            }\n+\n+            return {np_rows, np_cols, np_rstride, np_cstride};\n+        }\n+\n+        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but\n+        // whichever is used, we want the (single) numpy stride value.\n+        const EigenIndex n = a.shape(0),\n+                         stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));\n+\n+        if (vector) { // Eigen type is a compile-time vector\n+            if (PYBIND11_SILENCE_MSVC_C4127(fixed) && size != n) {\n+                return false; // Vector size mismatch\n+            }\n+            return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};\n+        }\n+        if (fixed) {\n+            // The type has a fixed size, but is not a vector: abort\n+            return false;\n+        }\n+        if (fixed_cols) {\n+            // Since this isn't a vector, cols must be != 1.  We allow this only if it exactly\n+            // equals the number of elements (rows is Dynamic, and so 1 row is allowed).\n+            if (cols != n) {\n+                return false;\n+            }\n+            return {1, n, stride};\n+        } // Otherwise it's either fully dynamic, or column dynamic; both become a column vector\n+        if (PYBIND11_SILENCE_MSVC_C4127(fixed_rows) && rows != n) {\n+            return false;\n+        }\n+        return {n, 1, stride};\n+    }\n+\n+    static constexpr bool show_writeable\n+        = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;\n+    static constexpr bool show_order = is_eigen_dense_map<Type>::value;\n+    static constexpr bool show_c_contiguous = show_order && requires_row_major;\n+    static constexpr bool show_f_contiguous\n+        = !show_c_contiguous && show_order && requires_col_major;\n+\n+    static constexpr auto descriptor\n+        = const_name(\"numpy.ndarray[\") + npy_format_descriptor<Scalar>::name + const_name(\"[\")\n+          + const_name<fixed_rows>(const_name<(size_t) rows>(), const_name(\"m\")) + const_name(\", \")\n+          + const_name<fixed_cols>(const_name<(size_t) cols>(), const_name(\"n\")) + const_name(\"]\")\n+          +\n+          // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to\n+          // be satisfied: writeable=True (for a mutable reference), and, depending on the map's\n+          // stride options, possibly f_contiguous or c_contiguous.  We include them in the\n+          // descriptor output to provide some hint as to why a TypeError is occurring (otherwise\n+          // it can be confusing to see that a function accepts a 'numpy.ndarray[float64[3,2]]' and\n+          // an error message that you *gave* a numpy.ndarray of the right type and dimensions.\n+          const_name<show_writeable>(\", flags.writeable\", \"\")\n+          + const_name<show_c_contiguous>(\", flags.c_contiguous\", \"\")\n+          + const_name<show_f_contiguous>(\", flags.f_contiguous\", \"\") + const_name(\"]\");\n+};\n+\n+// Casts an Eigen type to numpy array.  If given a base, the numpy array references the src data,\n+// otherwise it'll make a copy.  writeable lets you turn off the writeable flag for the array.\n+template <typename props>\n+handle\n+eigen_array_cast(typename props::Type const &src, handle base = handle(), bool writeable = true) {\n+    constexpr ssize_t elem_size = sizeof(typename props::Scalar);\n+    array a;\n+    if (props::vector) {\n+        a = array({src.size()}, {elem_size * src.innerStride()}, src.data(), base);\n+    } else {\n+        a = array({src.rows(), src.cols()},\n+                  {elem_size * src.rowStride(), elem_size * src.colStride()},\n+                  src.data(),\n+                  base);\n+    }\n+\n+    if (!writeable) {\n+        array_proxy(a.ptr())->flags &= ~detail::npy_api::NPY_ARRAY_WRITEABLE_;\n+    }\n+\n+    return a.release();\n+}\n+\n+// Takes an lvalue ref to some Eigen type and a (python) base object, creating a numpy array that\n+// reference the Eigen object's data with `base` as the python-registered base class (if omitted,\n+// the base will be set to None, and lifetime management is up to the caller).  The numpy array is\n+// non-writeable if the given type is const.\n+template <typename props, typename Type>\n+handle eigen_ref_array(Type &src, handle parent = none()) {\n+    // none here is to get past array's should-we-copy detection, which currently always\n+    // copies when there is no base.  Setting the base to None should be harmless.\n+    return eigen_array_cast<props>(src, parent, !std::is_const<Type>::value);\n+}\n+\n+// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a\n+// numpy array that references the encapsulated data with a python-side reference to the capsule to\n+// tie its destruction to that of any dependent python objects.  Const-ness is determined by\n+// whether or not the Type of the pointer given is const.\n+template <typename props, typename Type, typename = enable_if_t<is_eigen_dense_plain<Type>::value>>\n+handle eigen_encapsulate(Type *src) {\n+    capsule base(src, [](void *o) { delete static_cast<Type *>(o); });\n+    return eigen_ref_array<props>(*src, base);\n+}\n+\n+// Type caster for regular, dense matrix types (e.g. MatrixXd), but not maps/refs/etc. of dense\n+// types.\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {\n+    using Scalar = typename Type::Scalar;\n+    using props = EigenProps<Type>;\n+\n+    bool load(handle src, bool convert) {\n+        // If we're in no-convert mode, only load if given an array of the correct type\n+        if (!convert && !isinstance<array_t<Scalar>>(src)) {\n+            return false;\n+        }\n+\n+        // Coerce into an array, but don't do type conversion yet; the copy below handles it.\n+        auto buf = array::ensure(src);\n+\n+        if (!buf) {\n+            return false;\n+        }\n+\n+        auto dims = buf.ndim();\n+        if (dims < 1 || dims > 2) {\n+            return false;\n+        }\n+\n+        auto fits = props::conformable(buf);\n+        if (!fits) {\n+            return false;\n+        }\n+\n+        // Allocate the new type, then build a numpy reference into it\n+        value = Type(fits.rows, fits.cols);\n+        auto ref = reinterpret_steal<array>(eigen_ref_array<props>(value));\n+        if (dims == 1) {\n+            ref = ref.squeeze();\n+        } else if (ref.ndim() == 1) {\n+            buf = buf.squeeze();\n+        }\n+\n+        int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());\n+\n+        if (result < 0) { // Copy failed!\n+            PyErr_Clear();\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+private:\n+    // Cast implementation\n+    template <typename CType>\n+    static handle cast_impl(CType *src, return_value_policy policy, handle parent) {\n+        switch (policy) {\n+            case return_value_policy::take_ownership:\n+            case return_value_policy::automatic:\n+                return eigen_encapsulate<props>(src);\n+            case return_value_policy::move:\n+                return eigen_encapsulate<props>(new CType(std::move(*src)));\n+            case return_value_policy::copy:\n+                return eigen_array_cast<props>(*src);\n+            case return_value_policy::reference:\n+            case return_value_policy::automatic_reference:\n+                return eigen_ref_array<props>(*src);\n+            case return_value_policy::reference_internal:\n+                return eigen_ref_array<props>(*src, parent);\n+            default:\n+                throw cast_error(\"unhandled return_value_policy: should not happen!\");\n+        };\n+    }\n+\n+public:\n+    // Normal returned non-reference, non-const value:\n+    static handle cast(Type &&src, return_value_policy /* policy */, handle parent) {\n+        return cast_impl(&src, return_value_policy::move, parent);\n+    }\n+    // If you return a non-reference const, we mark the numpy array readonly:\n+    static handle cast(const Type &&src, return_value_policy /* policy */, handle parent) {\n+        return cast_impl(&src, return_value_policy::move, parent);\n+    }\n+    // lvalue reference return; default (automatic) becomes copy\n+    static handle cast(Type &src, return_value_policy policy, handle parent) {\n+        if (policy == return_value_policy::automatic\n+            || policy == return_value_policy::automatic_reference) {\n+            policy = return_value_policy::copy;\n+        }\n+        return cast_impl(&src, policy, parent);\n+    }\n+    // const lvalue reference return; default (automatic) becomes copy\n+    static handle cast(const Type &src, return_value_policy policy, handle parent) {\n+        if (policy == return_value_policy::automatic\n+            || policy == return_value_policy::automatic_reference) {\n+            policy = return_value_policy::copy;\n+        }\n+        return cast(&src, policy, parent);\n+    }\n+    // non-const pointer return\n+    static handle cast(Type *src, return_value_policy policy, handle parent) {\n+        return cast_impl(src, policy, parent);\n+    }\n+    // const pointer return\n+    static handle cast(const Type *src, return_value_policy policy, handle parent) {\n+        return cast_impl(src, policy, parent);\n+    }\n+\n+    static constexpr auto name = props::descriptor;\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type *() { return &value; }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type &() { return value; }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type &&() && { return std::move(value); }\n+    template <typename T>\n+    using cast_op_type = movable_cast_op_type<T>;\n+\n+private:\n+    Type value;\n+};\n+\n+// Base class for casting reference/map/block/etc. objects back to python.\n+template <typename MapType>\n+struct eigen_map_caster {\n+private:\n+    using props = EigenProps<MapType>;\n+\n+public:\n+    // Directly referencing a ref/map's data is a bit dangerous (whatever the map/ref points to has\n+    // to stay around), but we'll allow it under the assumption that you know what you're doing\n+    // (and have an appropriate keep_alive in place).  We return a numpy array pointing directly at\n+    // the ref's data (The numpy array ends up read-only if the ref was to a const matrix type.)\n+    // Note that this means you need to ensure you don't destroy the object in some other way (e.g.\n+    // with an appropriate keep_alive, or with a reference to a statically allocated matrix).\n+    static handle cast(const MapType &src, return_value_policy policy, handle parent) {\n+        switch (policy) {\n+            case return_value_policy::copy:\n+                return eigen_array_cast<props>(src);\n+            case return_value_policy::reference_internal:\n+                return eigen_array_cast<props>(src, parent, is_eigen_mutable_map<MapType>::value);\n+            case return_value_policy::reference:\n+            case return_value_policy::automatic:\n+            case return_value_policy::automatic_reference:\n+                return eigen_array_cast<props>(src, none(), is_eigen_mutable_map<MapType>::value);\n+            default:\n+                // move, take_ownership don't make any sense for a ref/map:\n+                pybind11_fail(\"Invalid return_value_policy for Eigen Map/Ref/Block type\");\n+        }\n+    }\n+\n+    static constexpr auto name = props::descriptor;\n+\n+    // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return\n+    // types but not bound arguments).  We still provide them (with an explicitly delete) so that\n+    // you end up here if you try anyway.\n+    bool load(handle, bool) = delete;\n+    operator MapType() = delete;\n+    template <typename>\n+    using cast_op_type = MapType;\n+};\n+\n+// We can return any map-like object (but can only load Refs, specialized next):\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>> : eigen_map_caster<Type> {};\n+\n+// Loader for Ref<...> arguments.  See the documentation for info on how to make this work without\n+// copying (it requires some extra effort in many cases).\n+template <typename PlainObjectType, typename StrideType>\n+struct type_caster<\n+    Eigen::Ref<PlainObjectType, 0, StrideType>,\n+    enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>>\n+    : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {\n+private:\n+    using Type = Eigen::Ref<PlainObjectType, 0, StrideType>;\n+    using props = EigenProps<Type>;\n+    using Scalar = typename props::Scalar;\n+    using MapType = Eigen::Map<PlainObjectType, 0, StrideType>;\n+    using Array\n+        = array_t<Scalar,\n+                  array::forcecast\n+                      | ((props::row_major ? props::inner_stride : props::outer_stride) == 1\n+                             ? array::c_style\n+                         : (props::row_major ? props::outer_stride : props::inner_stride) == 1\n+                             ? array::f_style\n+                             : 0)>;\n+    static constexpr bool need_writeable = is_eigen_mutable_map<Type>::value;\n+    // Delay construction (these have no default constructor)\n+    std::unique_ptr<MapType> map;\n+    std::unique_ptr<Type> ref;\n+    // Our array.  When possible, this is just a numpy array pointing to the source data, but\n+    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an\n+    // incompatible layout, or is an array of a type that needs to be converted).  Using a numpy\n+    // temporary (rather than an Eigen temporary) saves an extra copy when we need both type\n+    // conversion and storage order conversion.  (Note that we refuse to use this temporary copy\n+    // when loading an argument for a Ref<M> with M non-const, i.e. a read-write reference).\n+    Array copy_or_ref;\n+\n+public:\n+    bool load(handle src, bool convert) {\n+        // First check whether what we have is already an array of the right type.  If not, we\n+        // can't avoid a copy (because the copy is also going to do type conversion).\n+        bool need_copy = !isinstance<Array>(src);\n+\n+        EigenConformable<props::row_major> fits;\n+        if (!need_copy) {\n+            // We don't need a converting copy, but we also need to check whether the strides are\n+            // compatible with the Ref's stride requirements\n+            auto aref = reinterpret_borrow<Array>(src);\n+\n+            if (aref && (!need_writeable || aref.writeable())) {\n+                fits = props::conformable(aref);\n+                if (!fits) {\n+                    return false; // Incompatible dimensions\n+                }\n+                if (!fits.template stride_compatible<props>()) {\n+                    need_copy = true;\n+                } else {\n+                    copy_or_ref = std::move(aref);\n+                }\n+            } else {\n+                need_copy = true;\n+            }\n+        }\n+\n+        if (need_copy) {\n+            // We need to copy: If we need a mutable reference, or we're not supposed to convert\n+            // (either because we're in the no-convert overload pass, or because we're explicitly\n+            // instructed not to copy (via `py::arg().noconvert()`) we have to fail loading.\n+            if (!convert || need_writeable) {\n+                return false;\n+            }\n+\n+            Array copy = Array::ensure(src);\n+            if (!copy) {\n+                return false;\n+            }\n+            fits = props::conformable(copy);\n+            if (!fits || !fits.template stride_compatible<props>()) {\n+                return false;\n+            }\n+            copy_or_ref = std::move(copy);\n+            loader_life_support::add_patient(copy_or_ref);\n+        }\n+\n+        ref.reset();\n+        map.reset(new MapType(data(copy_or_ref),\n+                              fits.rows,\n+                              fits.cols,\n+                              make_stride(fits.stride.outer(), fits.stride.inner())));\n+        ref.reset(new Type(*map));\n+\n+        return true;\n+    }\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type *() { return ref.get(); }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator Type &() { return *ref; }\n+    template <typename _T>\n+    using cast_op_type = pybind11::detail::cast_op_type<_T>;\n+\n+private:\n+    template <typename T = Type, enable_if_t<is_eigen_mutable_map<T>::value, int> = 0>\n+    Scalar *data(Array &a) {\n+        return a.mutable_data();\n+    }\n+\n+    template <typename T = Type, enable_if_t<!is_eigen_mutable_map<T>::value, int> = 0>\n+    const Scalar *data(Array &a) {\n+        return a.data();\n+    }\n+\n+    // Attempt to figure out a constructor of `Stride` that will work.\n+    // If both strides are fixed, use a default constructor:\n+    template <typename S>\n+    using stride_ctor_default = bool_constant<S::InnerStrideAtCompileTime != Eigen::Dynamic\n+                                              && S::OuterStrideAtCompileTime != Eigen::Dynamic\n+                                              && std::is_default_constructible<S>::value>;\n+    // Otherwise, if there is a two-index constructor, assume it is (outer,inner) like\n+    // Eigen::Stride, and use it:\n+    template <typename S>\n+    using stride_ctor_dual\n+        = bool_constant<!stride_ctor_default<S>::value\n+                        && std::is_constructible<S, EigenIndex, EigenIndex>::value>;\n+    // Otherwise, if there is a one-index constructor, and just one of the strides is dynamic, use\n+    // it (passing whichever stride is dynamic).\n+    template <typename S>\n+    using stride_ctor_outer\n+        = bool_constant<!any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value\n+                        && S::OuterStrideAtCompileTime == Eigen::Dynamic\n+                        && S::InnerStrideAtCompileTime != Eigen::Dynamic\n+                        && std::is_constructible<S, EigenIndex>::value>;\n+    template <typename S>\n+    using stride_ctor_inner\n+        = bool_constant<!any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value\n+                        && S::InnerStrideAtCompileTime == Eigen::Dynamic\n+                        && S::OuterStrideAtCompileTime != Eigen::Dynamic\n+                        && std::is_constructible<S, EigenIndex>::value>;\n+\n+    template <typename S = StrideType, enable_if_t<stride_ctor_default<S>::value, int> = 0>\n+    static S make_stride(EigenIndex, EigenIndex) {\n+        return S();\n+    }\n+    template <typename S = StrideType, enable_if_t<stride_ctor_dual<S>::value, int> = 0>\n+    static S make_stride(EigenIndex outer, EigenIndex inner) {\n+        return S(outer, inner);\n+    }\n+    template <typename S = StrideType, enable_if_t<stride_ctor_outer<S>::value, int> = 0>\n+    static S make_stride(EigenIndex outer, EigenIndex) {\n+        return S(outer);\n+    }\n+    template <typename S = StrideType, enable_if_t<stride_ctor_inner<S>::value, int> = 0>\n+    static S make_stride(EigenIndex, EigenIndex inner) {\n+        return S(inner);\n+    }\n+};\n+\n+// type_caster for special matrix types (e.g. DiagonalMatrix), which are EigenBase, but not\n+// EigenDense (i.e. they don't have a data(), at least not with the usual matrix layout).\n+// load() is not supported, but we can cast them into the python domain by first copying to a\n+// regular Eigen::Matrix, then casting that.\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_other<Type>::value>> {\n+protected:\n+    using Matrix\n+        = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;\n+    using props = EigenProps<Matrix>;\n+\n+public:\n+    static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {\n+        handle h = eigen_encapsulate<props>(new Matrix(src));\n+        return h;\n+    }\n+    static handle cast(const Type *src, return_value_policy policy, handle parent) {\n+        return cast(*src, policy, parent);\n+    }\n+\n+    static constexpr auto name = props::descriptor;\n+\n+    // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return\n+    // types but not bound arguments).  We still provide them (with an explicitly delete) so that\n+    // you end up here if you try anyway.\n+    bool load(handle, bool) = delete;\n+    operator Type() = delete;\n+    template <typename>\n+    using cast_op_type = Type;\n+};\n+\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {\n+    using Scalar = typename Type::Scalar;\n+    using StorageIndex = remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())>;\n+    using Index = typename Type::Index;\n+    static constexpr bool rowMajor = Type::IsRowMajor;\n+\n+    bool load(handle src, bool) {\n+        if (!src) {\n+            return false;\n+        }\n+\n+        auto obj = reinterpret_borrow<object>(src);\n+        object sparse_module = module_::import(\"scipy.sparse\");\n+        object matrix_type = sparse_module.attr(rowMajor ? \"csr_matrix\" : \"csc_matrix\");\n+\n+        if (!type::handle_of(obj).is(matrix_type)) {\n+            try {\n+                obj = matrix_type(obj);\n+            } catch (const error_already_set &) {\n+                return false;\n+            }\n+        }\n+\n+        auto values = array_t<Scalar>((object) obj.attr(\"data\"));\n+        auto innerIndices = array_t<StorageIndex>((object) obj.attr(\"indices\"));\n+        auto outerIndices = array_t<StorageIndex>((object) obj.attr(\"indptr\"));\n+        auto shape = pybind11::tuple((pybind11::object) obj.attr(\"shape\"));\n+        auto nnz = obj.attr(\"nnz\").cast<Index>();\n+\n+        if (!values || !innerIndices || !outerIndices) {\n+            return false;\n+        }\n+\n+        value = EigenMapSparseMatrix<Scalar,\n+                                     Type::Flags &(Eigen::RowMajor | Eigen::ColMajor),\n+                                     StorageIndex>(shape[0].cast<Index>(),\n+                                                   shape[1].cast<Index>(),\n+                                                   std::move(nnz),\n+                                                   outerIndices.mutable_data(),\n+                                                   innerIndices.mutable_data(),\n+                                                   values.mutable_data());\n+\n+        return true;\n+    }\n+\n+    static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {\n+        const_cast<Type &>(src).makeCompressed();\n+\n+        object matrix_type\n+            = module_::import(\"scipy.sparse\").attr(rowMajor ? \"csr_matrix\" : \"csc_matrix\");\n+\n+        array data(src.nonZeros(), src.valuePtr());\n+        array outerIndices((rowMajor ? src.rows() : src.cols()) + 1, src.outerIndexPtr());\n+        array innerIndices(src.nonZeros(), src.innerIndexPtr());\n+\n+        return matrix_type(pybind11::make_tuple(\n+                               std::move(data), std::move(innerIndices), std::move(outerIndices)),\n+                           pybind11::make_tuple(src.rows(), src.cols()))\n+            .release();\n+    }\n+\n+    PYBIND11_TYPE_CASTER(Type,\n+                         const_name<(Type::IsRowMajor) != 0>(\"scipy.sparse.csr_matrix[\",\n+                                                             \"scipy.sparse.csc_matrix[\")\n+                             + npy_format_descriptor<Scalar>::name + const_name(\"]\"));\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/embed.h", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "file_content_changes": "@@ -0,0 +1,277 @@\n+/*\n+    pybind11/embed.h: Support for embedding the interpreter\n+\n+    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+#include \"eval.h\"\n+\n+#include <memory>\n+#include <vector>\n+\n+#if defined(PYPY_VERSION)\n+#    error Embedding the interpreter is not supported with PyPy\n+#endif\n+\n+#define PYBIND11_EMBEDDED_MODULE_IMPL(name)                                                       \\\n+    extern \"C\" PyObject *pybind11_init_impl_##name();                                             \\\n+    extern \"C\" PyObject *pybind11_init_impl_##name() { return pybind11_init_wrapper_##name(); }\n+\n+/** \\rst\n+    Add a new module to the table of builtins for the interpreter. Must be\n+    defined in global scope. The first macro parameter is the name of the\n+    module (without quotes). The second parameter is the variable which will\n+    be used as the interface to add functions and classes to the module.\n+\n+    .. code-block:: cpp\n+\n+        PYBIND11_EMBEDDED_MODULE(example, m) {\n+            // ... initialize functions and classes here\n+            m.def(\"foo\", []() {\n+                return \"Hello, World!\";\n+            });\n+        }\n+ \\endrst */\n+#define PYBIND11_EMBEDDED_MODULE(name, variable)                                                  \\\n+    static ::pybind11::module_::module_def PYBIND11_CONCAT(pybind11_module_def_, name);           \\\n+    static void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ &);                     \\\n+    static PyObject PYBIND11_CONCAT(*pybind11_init_wrapper_, name)() {                            \\\n+        auto m = ::pybind11::module_::create_extension_module(                                    \\\n+            PYBIND11_TOSTRING(name), nullptr, &PYBIND11_CONCAT(pybind11_module_def_, name));      \\\n+        try {                                                                                     \\\n+            PYBIND11_CONCAT(pybind11_init_, name)(m);                                             \\\n+            return m.ptr();                                                                       \\\n+        }                                                                                         \\\n+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \\\n+    }                                                                                             \\\n+    PYBIND11_EMBEDDED_MODULE_IMPL(name)                                                           \\\n+    ::pybind11::detail::embedded_module PYBIND11_CONCAT(pybind11_module_, name)(                  \\\n+        PYBIND11_TOSTRING(name), PYBIND11_CONCAT(pybind11_init_impl_, name));                     \\\n+    void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_                                \\\n+                                               & variable) // NOLINT(bugprone-macro-parentheses)\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/// Python 2.7/3.x compatible version of `PyImport_AppendInittab` and error checks.\n+struct embedded_module {\n+    using init_t = PyObject *(*) ();\n+    embedded_module(const char *name, init_t init) {\n+        if (Py_IsInitialized() != 0) {\n+            pybind11_fail(\"Can't add new modules after the interpreter has been initialized\");\n+        }\n+\n+        auto result = PyImport_AppendInittab(name, init);\n+        if (result == -1) {\n+            pybind11_fail(\"Insufficient memory to add a new module\");\n+        }\n+    }\n+};\n+\n+struct wide_char_arg_deleter {\n+    void operator()(wchar_t *ptr) const {\n+        // API docs: https://docs.python.org/3/c-api/sys.html#c.Py_DecodeLocale\n+        PyMem_RawFree(ptr);\n+    }\n+};\n+\n+inline wchar_t *widen_chars(const char *safe_arg) {\n+    wchar_t *widened_arg = Py_DecodeLocale(safe_arg, nullptr);\n+    return widened_arg;\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+/** \\rst\n+    Initialize the Python interpreter. No other pybind11 or CPython API functions can be\n+    called before this is done; with the exception of `PYBIND11_EMBEDDED_MODULE`. The\n+    optional `init_signal_handlers` parameter can be used to skip the registration of\n+    signal handlers (see the `Python documentation`_ for details). Calling this function\n+    again after the interpreter has already been initialized is a fatal error.\n+\n+    If initializing the Python interpreter fails, then the program is terminated.  (This\n+    is controlled by the CPython runtime and is an exception to pybind11's normal behavior\n+    of throwing exceptions on errors.)\n+\n+    The remaining optional parameters, `argc`, `argv`, and `add_program_dir_to_path` are\n+    used to populate ``sys.argv`` and ``sys.path``.\n+    See the |PySys_SetArgvEx documentation|_ for details.\n+\n+    .. _Python documentation: https://docs.python.org/3/c-api/init.html#c.Py_InitializeEx\n+    .. |PySys_SetArgvEx documentation| replace:: ``PySys_SetArgvEx`` documentation\n+    .. _PySys_SetArgvEx documentation: https://docs.python.org/3/c-api/init.html#c.PySys_SetArgvEx\n+ \\endrst */\n+inline void initialize_interpreter(bool init_signal_handlers = true,\n+                                   int argc = 0,\n+                                   const char *const *argv = nullptr,\n+                                   bool add_program_dir_to_path = true) {\n+    if (Py_IsInitialized() != 0) {\n+        pybind11_fail(\"The interpreter is already running\");\n+    }\n+\n+#if PY_VERSION_HEX < 0x030B0000\n+\n+    Py_InitializeEx(init_signal_handlers ? 1 : 0);\n+\n+    // Before it was special-cased in python 3.8, passing an empty or null argv\n+    // caused a segfault, so we have to reimplement the special case ourselves.\n+    bool special_case = (argv == nullptr || argc <= 0);\n+\n+    const char *const empty_argv[]{\"\\0\"};\n+    const char *const *safe_argv = special_case ? empty_argv : argv;\n+    if (special_case) {\n+        argc = 1;\n+    }\n+\n+    auto argv_size = static_cast<size_t>(argc);\n+    // SetArgv* on python 3 takes wchar_t, so we have to convert.\n+    std::unique_ptr<wchar_t *[]> widened_argv(new wchar_t *[argv_size]);\n+    std::vector<std::unique_ptr<wchar_t[], detail::wide_char_arg_deleter>> widened_argv_entries;\n+    widened_argv_entries.reserve(argv_size);\n+    for (size_t ii = 0; ii < argv_size; ++ii) {\n+        widened_argv_entries.emplace_back(detail::widen_chars(safe_argv[ii]));\n+        if (!widened_argv_entries.back()) {\n+            // A null here indicates a character-encoding failure or the python\n+            // interpreter out of memory. Give up.\n+            return;\n+        }\n+        widened_argv[ii] = widened_argv_entries.back().get();\n+    }\n+\n+    auto *pysys_argv = widened_argv.get();\n+\n+    PySys_SetArgvEx(argc, pysys_argv, static_cast<int>(add_program_dir_to_path));\n+#else\n+    PyConfig config;\n+    PyConfig_InitIsolatedConfig(&config);\n+    config.install_signal_handlers = init_signal_handlers ? 1 : 0;\n+\n+    PyStatus status = PyConfig_SetBytesArgv(&config, argc, const_cast<char *const *>(argv));\n+    if (PyStatus_Exception(status)) {\n+        // A failure here indicates a character-encoding failure or the python\n+        // interpreter out of memory. Give up.\n+        PyConfig_Clear(&config);\n+        throw std::runtime_error(PyStatus_IsError(status) ? status.err_msg\n+                                                          : \"Failed to prepare CPython\");\n+    }\n+    status = Py_InitializeFromConfig(&config);\n+    PyConfig_Clear(&config);\n+    if (PyStatus_Exception(status)) {\n+        throw std::runtime_error(PyStatus_IsError(status) ? status.err_msg\n+                                                          : \"Failed to init CPython\");\n+    }\n+    if (add_program_dir_to_path) {\n+        PyRun_SimpleString(\"import sys, os.path; \"\n+                           \"sys.path.insert(0, \"\n+                           \"os.path.abspath(os.path.dirname(sys.argv[0])) \"\n+                           \"if sys.argv and os.path.exists(sys.argv[0]) else '')\");\n+    }\n+#endif\n+}\n+\n+/** \\rst\n+    Shut down the Python interpreter. No pybind11 or CPython API functions can be called\n+    after this. In addition, pybind11 objects must not outlive the interpreter:\n+\n+    .. code-block:: cpp\n+\n+        { // BAD\n+            py::initialize_interpreter();\n+            auto hello = py::str(\"Hello, World!\");\n+            py::finalize_interpreter();\n+        } // <-- BOOM, hello's destructor is called after interpreter shutdown\n+\n+        { // GOOD\n+            py::initialize_interpreter();\n+            { // scoped\n+                auto hello = py::str(\"Hello, World!\");\n+            } // <-- OK, hello is cleaned up properly\n+            py::finalize_interpreter();\n+        }\n+\n+        { // BETTER\n+            py::scoped_interpreter guard{};\n+            auto hello = py::str(\"Hello, World!\");\n+        }\n+\n+    .. warning::\n+\n+        The interpreter can be restarted by calling `initialize_interpreter` again.\n+        Modules created using pybind11 can be safely re-initialized. However, Python\n+        itself cannot completely unload binary extension modules and there are several\n+        caveats with regard to interpreter restarting. All the details can be found\n+        in the CPython documentation. In short, not all interpreter memory may be\n+        freed, either due to reference cycles or user-created global data.\n+\n+ \\endrst */\n+inline void finalize_interpreter() {\n+    handle builtins(PyEval_GetBuiltins());\n+    const char *id = PYBIND11_INTERNALS_ID;\n+\n+    // Get the internals pointer (without creating it if it doesn't exist).  It's possible for the\n+    // internals to be created during Py_Finalize() (e.g. if a py::capsule calls `get_internals()`\n+    // during destruction), so we get the pointer-pointer here and check it after Py_Finalize().\n+    detail::internals **internals_ptr_ptr = detail::get_internals_pp();\n+    // It could also be stashed in builtins, so look there too:\n+    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n+        internals_ptr_ptr = capsule(builtins[id]);\n+    }\n+    // Local internals contains data managed by the current interpreter, so we must clear them to\n+    // avoid undefined behaviors when initializing another interpreter\n+    detail::get_local_internals().registered_types_cpp.clear();\n+    detail::get_local_internals().registered_exception_translators.clear();\n+\n+    Py_Finalize();\n+\n+    if (internals_ptr_ptr) {\n+        delete *internals_ptr_ptr;\n+        *internals_ptr_ptr = nullptr;\n+    }\n+}\n+\n+/** \\rst\n+    Scope guard version of `initialize_interpreter` and `finalize_interpreter`.\n+    This a move-only guard and only a single instance can exist.\n+\n+    See `initialize_interpreter` for a discussion of its constructor arguments.\n+\n+    .. code-block:: cpp\n+\n+        #include <pybind11/embed.h>\n+\n+        int main() {\n+            py::scoped_interpreter guard{};\n+            py::print(Hello, World!);\n+        } // <-- interpreter shutdown\n+ \\endrst */\n+class scoped_interpreter {\n+public:\n+    explicit scoped_interpreter(bool init_signal_handlers = true,\n+                                int argc = 0,\n+                                const char *const *argv = nullptr,\n+                                bool add_program_dir_to_path = true) {\n+        initialize_interpreter(init_signal_handlers, argc, argv, add_program_dir_to_path);\n+    }\n+\n+    scoped_interpreter(const scoped_interpreter &) = delete;\n+    scoped_interpreter(scoped_interpreter &&other) noexcept { other.is_valid = false; }\n+    scoped_interpreter &operator=(const scoped_interpreter &) = delete;\n+    scoped_interpreter &operator=(scoped_interpreter &&) = delete;\n+\n+    ~scoped_interpreter() {\n+        if (is_valid) {\n+            finalize_interpreter();\n+        }\n+    }\n+\n+private:\n+    bool is_valid = true;\n+};\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/eval.h", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "file_content_changes": "@@ -0,0 +1,156 @@\n+/*\n+    pybind11/eval.h: Support for evaluating Python expressions and statements\n+    from strings and files\n+\n+    Copyright (c) 2016 Klemens Morgenstern <klemens.morgenstern@ed-chemnitz.de> and\n+                       Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+#include <utility>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+inline void ensure_builtins_in_globals(object &global) {\n+#if defined(PYPY_VERSION) || PY_VERSION_HEX < 0x03080000\n+    // Running exec and eval adds `builtins` module under `__builtins__` key to\n+    // globals if not yet present.  Python 3.8 made PyRun_String behave\n+    // similarly. Let's also do that for older versions, for consistency. This\n+    // was missing from PyPy3.8 7.3.7.\n+    if (!global.contains(\"__builtins__\"))\n+        global[\"__builtins__\"] = module_::import(PYBIND11_BUILTINS_MODULE);\n+#else\n+    (void) global;\n+#endif\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+enum eval_mode {\n+    /// Evaluate a string containing an isolated expression\n+    eval_expr,\n+\n+    /// Evaluate a string containing a single statement. Returns \\c none\n+    eval_single_statement,\n+\n+    /// Evaluate a string containing a sequence of statement. Returns \\c none\n+    eval_statements\n+};\n+\n+template <eval_mode mode = eval_expr>\n+object eval(const str &expr, object global = globals(), object local = object()) {\n+    if (!local) {\n+        local = global;\n+    }\n+\n+    detail::ensure_builtins_in_globals(global);\n+\n+    /* PyRun_String does not accept a PyObject / encoding specifier,\n+       this seems to be the only alternative */\n+    std::string buffer = \"# -*- coding: utf-8 -*-\\n\" + (std::string) expr;\n+\n+    int start = 0;\n+    switch (mode) {\n+        case eval_expr:\n+            start = Py_eval_input;\n+            break;\n+        case eval_single_statement:\n+            start = Py_single_input;\n+            break;\n+        case eval_statements:\n+            start = Py_file_input;\n+            break;\n+        default:\n+            pybind11_fail(\"invalid evaluation mode\");\n+    }\n+\n+    PyObject *result = PyRun_String(buffer.c_str(), start, global.ptr(), local.ptr());\n+    if (!result) {\n+        throw error_already_set();\n+    }\n+    return reinterpret_steal<object>(result);\n+}\n+\n+template <eval_mode mode = eval_expr, size_t N>\n+object eval(const char (&s)[N], object global = globals(), object local = object()) {\n+    /* Support raw string literals by removing common leading whitespace */\n+    auto expr = (s[0] == '\\n') ? str(module_::import(\"textwrap\").attr(\"dedent\")(s)) : str(s);\n+    return eval<mode>(expr, std::move(global), std::move(local));\n+}\n+\n+inline void exec(const str &expr, object global = globals(), object local = object()) {\n+    eval<eval_statements>(expr, std::move(global), std::move(local));\n+}\n+\n+template <size_t N>\n+void exec(const char (&s)[N], object global = globals(), object local = object()) {\n+    eval<eval_statements>(s, std::move(global), std::move(local));\n+}\n+\n+#if defined(PYPY_VERSION)\n+template <eval_mode mode = eval_statements>\n+object eval_file(str, object, object) {\n+    pybind11_fail(\"eval_file not supported in PyPy3. Use eval\");\n+}\n+template <eval_mode mode = eval_statements>\n+object eval_file(str, object) {\n+    pybind11_fail(\"eval_file not supported in PyPy3. Use eval\");\n+}\n+template <eval_mode mode = eval_statements>\n+object eval_file(str) {\n+    pybind11_fail(\"eval_file not supported in PyPy3. Use eval\");\n+}\n+#else\n+template <eval_mode mode = eval_statements>\n+object eval_file(str fname, object global = globals(), object local = object()) {\n+    if (!local) {\n+        local = global;\n+    }\n+\n+    detail::ensure_builtins_in_globals(global);\n+\n+    int start = 0;\n+    switch (mode) {\n+        case eval_expr:\n+            start = Py_eval_input;\n+            break;\n+        case eval_single_statement:\n+            start = Py_single_input;\n+            break;\n+        case eval_statements:\n+            start = Py_file_input;\n+            break;\n+        default:\n+            pybind11_fail(\"invalid evaluation mode\");\n+    }\n+\n+    int closeFile = 1;\n+    std::string fname_str = (std::string) fname;\n+    FILE *f = _Py_fopen_obj(fname.ptr(), \"r\");\n+    if (!f) {\n+        PyErr_Clear();\n+        pybind11_fail(\"File \\\"\" + fname_str + \"\\\" could not be opened!\");\n+    }\n+\n+    if (!global.contains(\"__file__\")) {\n+        global[\"__file__\"] = std::move(fname);\n+    }\n+\n+    PyObject *result\n+        = PyRun_FileEx(f, fname_str.c_str(), start, global.ptr(), local.ptr(), closeFile);\n+\n+    if (!result) {\n+        throw error_already_set();\n+    }\n+    return reinterpret_steal<object>(result);\n+}\n+#endif\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/functional.h", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "file_content_changes": "@@ -0,0 +1,130 @@\n+/*\n+    pybind11/functional.h: std::function<> support\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+#include <functional>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+template <typename Return, typename... Args>\n+struct type_caster<std::function<Return(Args...)>> {\n+    using type = std::function<Return(Args...)>;\n+    using retval_type = conditional_t<std::is_same<Return, void>::value, void_type, Return>;\n+    using function_type = Return (*)(Args...);\n+\n+public:\n+    bool load(handle src, bool convert) {\n+        if (src.is_none()) {\n+            // Defer accepting None to other overloads (if we aren't in convert mode):\n+            if (!convert) {\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        if (!isinstance<function>(src)) {\n+            return false;\n+        }\n+\n+        auto func = reinterpret_borrow<function>(src);\n+\n+        /*\n+           When passing a C++ function as an argument to another C++\n+           function via Python, every function call would normally involve\n+           a full C++ -> Python -> C++ roundtrip, which can be prohibitive.\n+           Here, we try to at least detect the case where the function is\n+           stateless (i.e. function pointer or lambda function without\n+           captured variables), in which case the roundtrip can be avoided.\n+         */\n+        if (auto cfunc = func.cpp_function()) {\n+            auto *cfunc_self = PyCFunction_GET_SELF(cfunc.ptr());\n+            if (isinstance<capsule>(cfunc_self)) {\n+                auto c = reinterpret_borrow<capsule>(cfunc_self);\n+                auto *rec = (function_record *) c;\n+\n+                while (rec != nullptr) {\n+                    if (rec->is_stateless\n+                        && same_type(typeid(function_type),\n+                                     *reinterpret_cast<const std::type_info *>(rec->data[1]))) {\n+                        struct capture {\n+                            function_type f;\n+                        };\n+                        value = ((capture *) &rec->data)->f;\n+                        return true;\n+                    }\n+                    rec = rec->next;\n+                }\n+            }\n+            // PYPY segfaults here when passing builtin function like sum.\n+            // Raising an fail exception here works to prevent the segfault, but only on gcc.\n+            // See PR #1413 for full details\n+        }\n+\n+        // ensure GIL is held during functor destruction\n+        struct func_handle {\n+            function f;\n+#if !(defined(_MSC_VER) && _MSC_VER == 1916 && defined(PYBIND11_CPP17))\n+            // This triggers a syntax error under very special conditions (very weird indeed).\n+            explicit\n+#endif\n+                func_handle(function &&f_) noexcept\n+                : f(std::move(f_)) {\n+            }\n+            func_handle(const func_handle &f_) { operator=(f_); }\n+            func_handle &operator=(const func_handle &f_) {\n+                gil_scoped_acquire acq;\n+                f = f_.f;\n+                return *this;\n+            }\n+            ~func_handle() {\n+                gil_scoped_acquire acq;\n+                function kill_f(std::move(f));\n+            }\n+        };\n+\n+        // to emulate 'move initialization capture' in C++11\n+        struct func_wrapper {\n+            func_handle hfunc;\n+            explicit func_wrapper(func_handle &&hf) noexcept : hfunc(std::move(hf)) {}\n+            Return operator()(Args... args) const {\n+                gil_scoped_acquire acq;\n+                // casts the returned object as a rvalue to the return type\n+                return hfunc.f(std::forward<Args>(args)...).template cast<Return>();\n+            }\n+        };\n+\n+        value = func_wrapper(func_handle(std::move(func)));\n+        return true;\n+    }\n+\n+    template <typename Func>\n+    static handle cast(Func &&f_, return_value_policy policy, handle /* parent */) {\n+        if (!f_) {\n+            return none().inc_ref();\n+        }\n+\n+        auto result = f_.template target<function_type>();\n+        if (result) {\n+            return cpp_function(*result, policy).release();\n+        }\n+        return cpp_function(std::forward<Func>(f_), policy).release();\n+    }\n+\n+    PYBIND11_TYPE_CASTER(type,\n+                         const_name(\"Callable[[\") + concat(make_caster<Args>::name...)\n+                             + const_name(\"], \") + make_caster<retval_type>::name\n+                             + const_name(\"]\"));\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/gil.h", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "file_content_changes": "@@ -0,0 +1,202 @@\n+/*\n+    pybind11/gil.h: RAII helpers for managing the GIL\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+#include \"detail/internals.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// forward declarations\n+PyThreadState *get_thread_state_unchecked();\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+#if defined(WITH_THREAD) && !defined(PYPY_VERSION)\n+\n+/* The functions below essentially reproduce the PyGILState_* API using a RAII\n+ * pattern, but there are a few important differences:\n+ *\n+ * 1. When acquiring the GIL from an non-main thread during the finalization\n+ *    phase, the GILState API blindly terminates the calling thread, which\n+ *    is often not what is wanted. This API does not do this.\n+ *\n+ * 2. The gil_scoped_release function can optionally cut the relationship\n+ *    of a PyThreadState and its associated thread, which allows moving it to\n+ *    another thread (this is a fairly rare/advanced use case).\n+ *\n+ * 3. The reference count of an acquired thread state can be controlled. This\n+ *    can be handy to prevent cases where callbacks issued from an external\n+ *    thread would otherwise constantly construct and destroy thread state data\n+ *    structures.\n+ *\n+ * See the Python bindings of NanoGUI (http://github.com/wjakob/nanogui) for an\n+ * example which uses features 2 and 3 to migrate the Python thread of\n+ * execution to another thread (to run the event loop on the original thread,\n+ * in this case).\n+ */\n+\n+class gil_scoped_acquire {\n+public:\n+    PYBIND11_NOINLINE gil_scoped_acquire() {\n+        auto &internals = detail::get_internals();\n+        tstate = (PyThreadState *) PYBIND11_TLS_GET_VALUE(internals.tstate);\n+\n+        if (!tstate) {\n+            /* Check if the GIL was acquired using the PyGILState_* API instead (e.g. if\n+               calling from a Python thread). Since we use a different key, this ensures\n+               we don't create a new thread state and deadlock in PyEval_AcquireThread\n+               below. Note we don't save this state with internals.tstate, since we don't\n+               create it we would fail to clear it (its reference count should be > 0). */\n+            tstate = PyGILState_GetThisThreadState();\n+        }\n+\n+        if (!tstate) {\n+            tstate = PyThreadState_New(internals.istate);\n+#    if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            if (!tstate) {\n+                pybind11_fail(\"scoped_acquire: could not create thread state!\");\n+            }\n+#    endif\n+            tstate->gilstate_counter = 0;\n+            PYBIND11_TLS_REPLACE_VALUE(internals.tstate, tstate);\n+        } else {\n+            release = detail::get_thread_state_unchecked() != tstate;\n+        }\n+\n+        if (release) {\n+            PyEval_AcquireThread(tstate);\n+        }\n+\n+        inc_ref();\n+    }\n+\n+    void inc_ref() { ++tstate->gilstate_counter; }\n+\n+    PYBIND11_NOINLINE void dec_ref() {\n+        --tstate->gilstate_counter;\n+#    if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+        if (detail::get_thread_state_unchecked() != tstate) {\n+            pybind11_fail(\"scoped_acquire::dec_ref(): thread state must be current!\");\n+        }\n+        if (tstate->gilstate_counter < 0) {\n+            pybind11_fail(\"scoped_acquire::dec_ref(): reference count underflow!\");\n+        }\n+#    endif\n+        if (tstate->gilstate_counter == 0) {\n+#    if defined(PYBIND11_DETAILED_ERROR_MESSAGES)\n+            if (!release) {\n+                pybind11_fail(\"scoped_acquire::dec_ref(): internal error!\");\n+            }\n+#    endif\n+            PyThreadState_Clear(tstate);\n+            if (active) {\n+                PyThreadState_DeleteCurrent();\n+            }\n+            PYBIND11_TLS_DELETE_VALUE(detail::get_internals().tstate);\n+            release = false;\n+        }\n+    }\n+\n+    /// This method will disable the PyThreadState_DeleteCurrent call and the\n+    /// GIL won't be acquired. This method should be used if the interpreter\n+    /// could be shutting down when this is called, as thread deletion is not\n+    /// allowed during shutdown. Check _Py_IsFinalizing() on Python 3.7+, and\n+    /// protect subsequent code.\n+    PYBIND11_NOINLINE void disarm() { active = false; }\n+\n+    PYBIND11_NOINLINE ~gil_scoped_acquire() {\n+        dec_ref();\n+        if (release) {\n+            PyEval_SaveThread();\n+        }\n+    }\n+\n+private:\n+    PyThreadState *tstate = nullptr;\n+    bool release = true;\n+    bool active = true;\n+};\n+\n+class gil_scoped_release {\n+public:\n+    explicit gil_scoped_release(bool disassoc = false) : disassoc(disassoc) {\n+        // `get_internals()` must be called here unconditionally in order to initialize\n+        // `internals.tstate` for subsequent `gil_scoped_acquire` calls. Otherwise, an\n+        // initialization race could occur as multiple threads try `gil_scoped_acquire`.\n+        auto &internals = detail::get_internals();\n+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)\n+        tstate = PyEval_SaveThread();\n+        if (disassoc) {\n+            // Python >= 3.7 can remove this, it's an int before 3.7\n+            // NOLINTNEXTLINE(readability-qualified-auto)\n+            auto key = internals.tstate;\n+            PYBIND11_TLS_DELETE_VALUE(key);\n+        }\n+    }\n+\n+    /// This method will disable the PyThreadState_DeleteCurrent call and the\n+    /// GIL won't be acquired. This method should be used if the interpreter\n+    /// could be shutting down when this is called, as thread deletion is not\n+    /// allowed during shutdown. Check _Py_IsFinalizing() on Python 3.7+, and\n+    /// protect subsequent code.\n+    PYBIND11_NOINLINE void disarm() { active = false; }\n+\n+    ~gil_scoped_release() {\n+        if (!tstate) {\n+            return;\n+        }\n+        // `PyEval_RestoreThread()` should not be called if runtime is finalizing\n+        if (active) {\n+            PyEval_RestoreThread(tstate);\n+        }\n+        if (disassoc) {\n+            // Python >= 3.7 can remove this, it's an int before 3.7\n+            // NOLINTNEXTLINE(readability-qualified-auto)\n+            auto key = detail::get_internals().tstate;\n+            PYBIND11_TLS_REPLACE_VALUE(key, tstate);\n+        }\n+    }\n+\n+private:\n+    PyThreadState *tstate;\n+    bool disassoc;\n+    bool active = true;\n+};\n+#elif defined(PYPY_VERSION)\n+class gil_scoped_acquire {\n+    PyGILState_STATE state;\n+\n+public:\n+    gil_scoped_acquire() { state = PyGILState_Ensure(); }\n+    ~gil_scoped_acquire() { PyGILState_Release(state); }\n+    void disarm() {}\n+};\n+\n+class gil_scoped_release {\n+    PyThreadState *state;\n+\n+public:\n+    gil_scoped_release() { state = PyEval_SaveThread(); }\n+    ~gil_scoped_release() { PyEval_RestoreThread(state); }\n+    void disarm() {}\n+};\n+#else\n+class gil_scoped_acquire {\n+    void disarm() {}\n+};\n+class gil_scoped_release {\n+    void disarm() {}\n+};\n+#endif\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/iostream.h", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "file_content_changes": "@@ -0,0 +1,265 @@\n+/*\n+    pybind11/iostream.h -- Tools to assist with redirecting cout and cerr to Python\n+\n+    Copyright (c) 2017 Henry F. Schreiner\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+\n+    WARNING: The implementation in this file is NOT thread safe. Multiple\n+    threads writing to a redirected ostream concurrently cause data races\n+    and potentially buffer overflows. Therefore it is currently a requirement\n+    that all (possibly) concurrent redirected ostream writes are protected by\n+    a mutex.\n+    #HelpAppreciated: Work on iostream.h thread safety.\n+    For more background see the discussions under\n+    https://github.com/pybind/pybind11/pull/2982 and\n+    https://github.com/pybind/pybind11/pull/2995.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <iostream>\n+#include <iterator>\n+#include <memory>\n+#include <ostream>\n+#include <streambuf>\n+#include <string>\n+#include <utility>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// Buffer that writes to Python instead of C++\n+class pythonbuf : public std::streambuf {\n+private:\n+    using traits_type = std::streambuf::traits_type;\n+\n+    const size_t buf_size;\n+    std::unique_ptr<char[]> d_buffer;\n+    object pywrite;\n+    object pyflush;\n+\n+    int overflow(int c) override {\n+        if (!traits_type::eq_int_type(c, traits_type::eof())) {\n+            *pptr() = traits_type::to_char_type(c);\n+            pbump(1);\n+        }\n+        return sync() == 0 ? traits_type::not_eof(c) : traits_type::eof();\n+    }\n+\n+    // Computes how many bytes at the end of the buffer are part of an\n+    // incomplete sequence of UTF-8 bytes.\n+    // Precondition: pbase() < pptr()\n+    size_t utf8_remainder() const {\n+        const auto rbase = std::reverse_iterator<char *>(pbase());\n+        const auto rpptr = std::reverse_iterator<char *>(pptr());\n+        auto is_ascii = [](char c) { return (static_cast<unsigned char>(c) & 0x80) == 0x00; };\n+        auto is_leading = [](char c) { return (static_cast<unsigned char>(c) & 0xC0) == 0xC0; };\n+        auto is_leading_2b = [](char c) { return static_cast<unsigned char>(c) <= 0xDF; };\n+        auto is_leading_3b = [](char c) { return static_cast<unsigned char>(c) <= 0xEF; };\n+        // If the last character is ASCII, there are no incomplete code points\n+        if (is_ascii(*rpptr)) {\n+            return 0;\n+        }\n+        // Otherwise, work back from the end of the buffer and find the first\n+        // UTF-8 leading byte\n+        const auto rpend = rbase - rpptr >= 3 ? rpptr + 3 : rbase;\n+        const auto leading = std::find_if(rpptr, rpend, is_leading);\n+        if (leading == rbase) {\n+            return 0;\n+        }\n+        const auto dist = static_cast<size_t>(leading - rpptr);\n+        size_t remainder = 0;\n+\n+        if (dist == 0) {\n+            remainder = 1; // 1-byte code point is impossible\n+        } else if (dist == 1) {\n+            remainder = is_leading_2b(*leading) ? 0 : dist + 1;\n+        } else if (dist == 2) {\n+            remainder = is_leading_3b(*leading) ? 0 : dist + 1;\n+        }\n+        // else if (dist >= 3), at least 4 bytes before encountering an UTF-8\n+        // leading byte, either no remainder or invalid UTF-8.\n+        // Invalid UTF-8 will cause an exception later when converting\n+        // to a Python string, so that's not handled here.\n+        return remainder;\n+    }\n+\n+    // This function must be non-virtual to be called in a destructor.\n+    int _sync() {\n+        if (pbase() != pptr()) { // If buffer is not empty\n+            gil_scoped_acquire tmp;\n+            // This subtraction cannot be negative, so dropping the sign.\n+            auto size = static_cast<size_t>(pptr() - pbase());\n+            size_t remainder = utf8_remainder();\n+\n+            if (size > remainder) {\n+                str line(pbase(), size - remainder);\n+                pywrite(std::move(line));\n+                pyflush();\n+            }\n+\n+            // Copy the remainder at the end of the buffer to the beginning:\n+            if (remainder > 0) {\n+                std::memmove(pbase(), pptr() - remainder, remainder);\n+            }\n+            setp(pbase(), epptr());\n+            pbump(static_cast<int>(remainder));\n+        }\n+        return 0;\n+    }\n+\n+    int sync() override { return _sync(); }\n+\n+public:\n+    explicit pythonbuf(const object &pyostream, size_t buffer_size = 1024)\n+        : buf_size(buffer_size), d_buffer(new char[buf_size]), pywrite(pyostream.attr(\"write\")),\n+          pyflush(pyostream.attr(\"flush\")) {\n+        setp(d_buffer.get(), d_buffer.get() + buf_size - 1);\n+    }\n+\n+    pythonbuf(pythonbuf &&) = default;\n+\n+    /// Sync before destroy\n+    ~pythonbuf() override { _sync(); }\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+/** \\rst\n+    This a move-only guard that redirects output.\n+\n+    .. code-block:: cpp\n+\n+        #include <pybind11/iostream.h>\n+\n+        ...\n+\n+        {\n+            py::scoped_ostream_redirect output;\n+            std::cout << \"Hello, World!\"; // Python stdout\n+        } // <-- return std::cout to normal\n+\n+    You can explicitly pass the c++ stream and the python object,\n+    for example to guard stderr instead.\n+\n+    .. code-block:: cpp\n+\n+        {\n+            py::scoped_ostream_redirect output{\n+                std::cerr, py::module::import(\"sys\").attr(\"stderr\")};\n+            std::cout << \"Hello, World!\";\n+        }\n+ \\endrst */\n+class scoped_ostream_redirect {\n+protected:\n+    std::streambuf *old;\n+    std::ostream &costream;\n+    detail::pythonbuf buffer;\n+\n+public:\n+    explicit scoped_ostream_redirect(std::ostream &costream = std::cout,\n+                                     const object &pyostream\n+                                     = module_::import(\"sys\").attr(\"stdout\"))\n+        : costream(costream), buffer(pyostream) {\n+        old = costream.rdbuf(&buffer);\n+    }\n+\n+    ~scoped_ostream_redirect() { costream.rdbuf(old); }\n+\n+    scoped_ostream_redirect(const scoped_ostream_redirect &) = delete;\n+    scoped_ostream_redirect(scoped_ostream_redirect &&other) = default;\n+    scoped_ostream_redirect &operator=(const scoped_ostream_redirect &) = delete;\n+    scoped_ostream_redirect &operator=(scoped_ostream_redirect &&) = delete;\n+};\n+\n+/** \\rst\n+    Like `scoped_ostream_redirect`, but redirects cerr by default. This class\n+    is provided primary to make ``py::call_guard`` easier to make.\n+\n+    .. code-block:: cpp\n+\n+     m.def(\"noisy_func\", &noisy_func,\n+           py::call_guard<scoped_ostream_redirect,\n+                          scoped_estream_redirect>());\n+\n+\\endrst */\n+class scoped_estream_redirect : public scoped_ostream_redirect {\n+public:\n+    explicit scoped_estream_redirect(std::ostream &costream = std::cerr,\n+                                     const object &pyostream\n+                                     = module_::import(\"sys\").attr(\"stderr\"))\n+        : scoped_ostream_redirect(costream, pyostream) {}\n+};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// Class to redirect output as a context manager. C++ backend.\n+class OstreamRedirect {\n+    bool do_stdout_;\n+    bool do_stderr_;\n+    std::unique_ptr<scoped_ostream_redirect> redirect_stdout;\n+    std::unique_ptr<scoped_estream_redirect> redirect_stderr;\n+\n+public:\n+    explicit OstreamRedirect(bool do_stdout = true, bool do_stderr = true)\n+        : do_stdout_(do_stdout), do_stderr_(do_stderr) {}\n+\n+    void enter() {\n+        if (do_stdout_) {\n+            redirect_stdout.reset(new scoped_ostream_redirect());\n+        }\n+        if (do_stderr_) {\n+            redirect_stderr.reset(new scoped_estream_redirect());\n+        }\n+    }\n+\n+    void exit() {\n+        redirect_stdout.reset();\n+        redirect_stderr.reset();\n+    }\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+/** \\rst\n+    This is a helper function to add a C++ redirect context manager to Python\n+    instead of using a C++ guard. To use it, add the following to your binding code:\n+\n+    .. code-block:: cpp\n+\n+        #include <pybind11/iostream.h>\n+\n+        ...\n+\n+        py::add_ostream_redirect(m, \"ostream_redirect\");\n+\n+    You now have a Python context manager that redirects your output:\n+\n+    .. code-block:: python\n+\n+        with m.ostream_redirect():\n+            m.print_to_cout_function()\n+\n+    This manager can optionally be told which streams to operate on:\n+\n+    .. code-block:: python\n+\n+        with m.ostream_redirect(stdout=true, stderr=true):\n+            m.noisy_function_with_error_printing()\n+\n+ \\endrst */\n+inline class_<detail::OstreamRedirect>\n+add_ostream_redirect(module_ m, const std::string &name = \"ostream_redirect\") {\n+    return class_<detail::OstreamRedirect>(std::move(m), name.c_str(), module_local())\n+        .def(init<bool, bool>(), arg(\"stdout\") = true, arg(\"stderr\") = true)\n+        .def(\"__enter__\", &detail::OstreamRedirect::enter)\n+        .def(\"__exit__\", [](detail::OstreamRedirect &self_, const args &) { self_.exit(); });\n+}\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/numpy.h", "status": "added", "additions": 1984, "deletions": 0, "changes": 1984, "file_content_changes": "@@ -0,0 +1,1984 @@\n+/*\n+    pybind11/numpy.h: Basic NumPy support, vectorize() wrapper\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+#include \"complex.h\"\n+\n+#include <algorithm>\n+#include <array>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <cstring>\n+#include <functional>\n+#include <numeric>\n+#include <sstream>\n+#include <string>\n+#include <type_traits>\n+#include <typeindex>\n+#include <utility>\n+#include <vector>\n+\n+/* This will be true on all flat address space platforms and allows us to reduce the\n+   whole npy_intp / ssize_t / Py_intptr_t business down to just ssize_t for all size\n+   and dimension types (e.g. shape, strides, indexing), instead of inflicting this\n+   upon the library user. */\n+static_assert(sizeof(::pybind11::ssize_t) == sizeof(Py_intptr_t), \"ssize_t != Py_intptr_t\");\n+static_assert(std::is_signed<Py_intptr_t>::value, \"Py_intptr_t must be signed\");\n+// We now can reinterpret_cast between py::ssize_t and Py_intptr_t (MSVC + PyPy cares)\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+class array; // Forward declaration\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+template <>\n+struct handle_type_name<array> {\n+    static constexpr auto name = const_name(\"numpy.ndarray\");\n+};\n+\n+template <typename type, typename SFINAE = void>\n+struct npy_format_descriptor;\n+\n+struct PyArrayDescr_Proxy {\n+    PyObject_HEAD\n+    PyObject *typeobj;\n+    char kind;\n+    char type;\n+    char byteorder;\n+    char flags;\n+    int type_num;\n+    int elsize;\n+    int alignment;\n+    char *subarray;\n+    PyObject *fields;\n+    PyObject *names;\n+};\n+\n+struct PyArray_Proxy {\n+    PyObject_HEAD\n+    char *data;\n+    int nd;\n+    ssize_t *dimensions;\n+    ssize_t *strides;\n+    PyObject *base;\n+    PyObject *descr;\n+    int flags;\n+};\n+\n+struct PyVoidScalarObject_Proxy {\n+    PyObject_VAR_HEAD char *obval;\n+    PyArrayDescr_Proxy *descr;\n+    int flags;\n+    PyObject *base;\n+};\n+\n+struct numpy_type_info {\n+    PyObject *dtype_ptr;\n+    std::string format_str;\n+};\n+\n+struct numpy_internals {\n+    std::unordered_map<std::type_index, numpy_type_info> registered_dtypes;\n+\n+    numpy_type_info *get_type_info(const std::type_info &tinfo, bool throw_if_missing = true) {\n+        auto it = registered_dtypes.find(std::type_index(tinfo));\n+        if (it != registered_dtypes.end()) {\n+            return &(it->second);\n+        }\n+        if (throw_if_missing) {\n+            pybind11_fail(std::string(\"NumPy type info missing for \") + tinfo.name());\n+        }\n+        return nullptr;\n+    }\n+\n+    template <typename T>\n+    numpy_type_info *get_type_info(bool throw_if_missing = true) {\n+        return get_type_info(typeid(typename std::remove_cv<T>::type), throw_if_missing);\n+    }\n+};\n+\n+PYBIND11_NOINLINE void load_numpy_internals(numpy_internals *&ptr) {\n+    ptr = &get_or_create_shared_data<numpy_internals>(\"_numpy_internals\");\n+}\n+\n+inline numpy_internals &get_numpy_internals() {\n+    static numpy_internals *ptr = nullptr;\n+    if (!ptr) {\n+        load_numpy_internals(ptr);\n+    }\n+    return *ptr;\n+}\n+\n+template <typename T>\n+struct same_size {\n+    template <typename U>\n+    using as = bool_constant<sizeof(T) == sizeof(U)>;\n+};\n+\n+template <typename Concrete>\n+constexpr int platform_lookup() {\n+    return -1;\n+}\n+\n+// Lookup a type according to its size, and return a value corresponding to the NumPy typenum.\n+template <typename Concrete, typename T, typename... Ts, typename... Ints>\n+constexpr int platform_lookup(int I, Ints... Is) {\n+    return sizeof(Concrete) == sizeof(T) ? I : platform_lookup<Concrete, Ts...>(Is...);\n+}\n+\n+struct npy_api {\n+    enum constants {\n+        NPY_ARRAY_C_CONTIGUOUS_ = 0x0001,\n+        NPY_ARRAY_F_CONTIGUOUS_ = 0x0002,\n+        NPY_ARRAY_OWNDATA_ = 0x0004,\n+        NPY_ARRAY_FORCECAST_ = 0x0010,\n+        NPY_ARRAY_ENSUREARRAY_ = 0x0040,\n+        NPY_ARRAY_ALIGNED_ = 0x0100,\n+        NPY_ARRAY_WRITEABLE_ = 0x0400,\n+        NPY_BOOL_ = 0,\n+        NPY_BYTE_,\n+        NPY_UBYTE_,\n+        NPY_SHORT_,\n+        NPY_USHORT_,\n+        NPY_INT_,\n+        NPY_UINT_,\n+        NPY_LONG_,\n+        NPY_ULONG_,\n+        NPY_LONGLONG_,\n+        NPY_ULONGLONG_,\n+        NPY_FLOAT_,\n+        NPY_DOUBLE_,\n+        NPY_LONGDOUBLE_,\n+        NPY_CFLOAT_,\n+        NPY_CDOUBLE_,\n+        NPY_CLONGDOUBLE_,\n+        NPY_OBJECT_ = 17,\n+        NPY_STRING_,\n+        NPY_UNICODE_,\n+        NPY_VOID_,\n+        // Platform-dependent normalization\n+        NPY_INT8_ = NPY_BYTE_,\n+        NPY_UINT8_ = NPY_UBYTE_,\n+        NPY_INT16_ = NPY_SHORT_,\n+        NPY_UINT16_ = NPY_USHORT_,\n+        // `npy_common.h` defines the integer aliases. In order, it checks:\n+        // NPY_BITSOF_LONG, NPY_BITSOF_LONGLONG, NPY_BITSOF_INT, NPY_BITSOF_SHORT, NPY_BITSOF_CHAR\n+        // and assigns the alias to the first matching size, so we should check in this order.\n+        NPY_INT32_\n+        = platform_lookup<std::int32_t, long, int, short>(NPY_LONG_, NPY_INT_, NPY_SHORT_),\n+        NPY_UINT32_ = platform_lookup<std::uint32_t, unsigned long, unsigned int, unsigned short>(\n+            NPY_ULONG_, NPY_UINT_, NPY_USHORT_),\n+        NPY_INT64_\n+        = platform_lookup<std::int64_t, long, long long, int>(NPY_LONG_, NPY_LONGLONG_, NPY_INT_),\n+        NPY_UINT64_\n+        = platform_lookup<std::uint64_t, unsigned long, unsigned long long, unsigned int>(\n+            NPY_ULONG_, NPY_ULONGLONG_, NPY_UINT_),\n+    };\n+\n+    struct PyArray_Dims {\n+        Py_intptr_t *ptr;\n+        int len;\n+    };\n+\n+    static npy_api &get() {\n+        static npy_api api = lookup();\n+        return api;\n+    }\n+\n+    bool PyArray_Check_(PyObject *obj) const {\n+        return PyObject_TypeCheck(obj, PyArray_Type_) != 0;\n+    }\n+    bool PyArrayDescr_Check_(PyObject *obj) const {\n+        return PyObject_TypeCheck(obj, PyArrayDescr_Type_) != 0;\n+    }\n+\n+    unsigned int (*PyArray_GetNDArrayCFeatureVersion_)();\n+    PyObject *(*PyArray_DescrFromType_)(int);\n+    PyObject *(*PyArray_NewFromDescr_)(PyTypeObject *,\n+                                       PyObject *,\n+                                       int,\n+                                       Py_intptr_t const *,\n+                                       Py_intptr_t const *,\n+                                       void *,\n+                                       int,\n+                                       PyObject *);\n+    // Unused. Not removed because that affects ABI of the class.\n+    PyObject *(*PyArray_DescrNewFromType_)(int);\n+    int (*PyArray_CopyInto_)(PyObject *, PyObject *);\n+    PyObject *(*PyArray_NewCopy_)(PyObject *, int);\n+    PyTypeObject *PyArray_Type_;\n+    PyTypeObject *PyVoidArrType_Type_;\n+    PyTypeObject *PyArrayDescr_Type_;\n+    PyObject *(*PyArray_DescrFromScalar_)(PyObject *);\n+    PyObject *(*PyArray_FromAny_)(PyObject *, PyObject *, int, int, int, PyObject *);\n+    int (*PyArray_DescrConverter_)(PyObject *, PyObject **);\n+    bool (*PyArray_EquivTypes_)(PyObject *, PyObject *);\n+    int (*PyArray_GetArrayParamsFromObject_)(PyObject *,\n+                                             PyObject *,\n+                                             unsigned char,\n+                                             PyObject **,\n+                                             int *,\n+                                             Py_intptr_t *,\n+                                             PyObject **,\n+                                             PyObject *);\n+    PyObject *(*PyArray_Squeeze_)(PyObject *);\n+    // Unused. Not removed because that affects ABI of the class.\n+    int (*PyArray_SetBaseObject_)(PyObject *, PyObject *);\n+    PyObject *(*PyArray_Resize_)(PyObject *, PyArray_Dims *, int, int);\n+    PyObject *(*PyArray_Newshape_)(PyObject *, PyArray_Dims *, int);\n+    PyObject *(*PyArray_View_)(PyObject *, PyObject *, PyObject *);\n+\n+private:\n+    enum functions {\n+        API_PyArray_GetNDArrayCFeatureVersion = 211,\n+        API_PyArray_Type = 2,\n+        API_PyArrayDescr_Type = 3,\n+        API_PyVoidArrType_Type = 39,\n+        API_PyArray_DescrFromType = 45,\n+        API_PyArray_DescrFromScalar = 57,\n+        API_PyArray_FromAny = 69,\n+        API_PyArray_Resize = 80,\n+        API_PyArray_CopyInto = 82,\n+        API_PyArray_NewCopy = 85,\n+        API_PyArray_NewFromDescr = 94,\n+        API_PyArray_DescrNewFromType = 96,\n+        API_PyArray_Newshape = 135,\n+        API_PyArray_Squeeze = 136,\n+        API_PyArray_View = 137,\n+        API_PyArray_DescrConverter = 174,\n+        API_PyArray_EquivTypes = 182,\n+        API_PyArray_GetArrayParamsFromObject = 278,\n+        API_PyArray_SetBaseObject = 282\n+    };\n+\n+    static npy_api lookup() {\n+        module_ m = module_::import(\"numpy.core.multiarray\");\n+        auto c = m.attr(\"_ARRAY_API\");\n+        void **api_ptr = (void **) PyCapsule_GetPointer(c.ptr(), nullptr);\n+        npy_api api;\n+#define DECL_NPY_API(Func) api.Func##_ = (decltype(api.Func##_)) api_ptr[API_##Func];\n+        DECL_NPY_API(PyArray_GetNDArrayCFeatureVersion);\n+        if (api.PyArray_GetNDArrayCFeatureVersion_() < 0x7) {\n+            pybind11_fail(\"pybind11 numpy support requires numpy >= 1.7.0\");\n+        }\n+        DECL_NPY_API(PyArray_Type);\n+        DECL_NPY_API(PyVoidArrType_Type);\n+        DECL_NPY_API(PyArrayDescr_Type);\n+        DECL_NPY_API(PyArray_DescrFromType);\n+        DECL_NPY_API(PyArray_DescrFromScalar);\n+        DECL_NPY_API(PyArray_FromAny);\n+        DECL_NPY_API(PyArray_Resize);\n+        DECL_NPY_API(PyArray_CopyInto);\n+        DECL_NPY_API(PyArray_NewCopy);\n+        DECL_NPY_API(PyArray_NewFromDescr);\n+        DECL_NPY_API(PyArray_DescrNewFromType);\n+        DECL_NPY_API(PyArray_Newshape);\n+        DECL_NPY_API(PyArray_Squeeze);\n+        DECL_NPY_API(PyArray_View);\n+        DECL_NPY_API(PyArray_DescrConverter);\n+        DECL_NPY_API(PyArray_EquivTypes);\n+        DECL_NPY_API(PyArray_GetArrayParamsFromObject);\n+        DECL_NPY_API(PyArray_SetBaseObject);\n+\n+#undef DECL_NPY_API\n+        return api;\n+    }\n+};\n+\n+inline PyArray_Proxy *array_proxy(void *ptr) { return reinterpret_cast<PyArray_Proxy *>(ptr); }\n+\n+inline const PyArray_Proxy *array_proxy(const void *ptr) {\n+    return reinterpret_cast<const PyArray_Proxy *>(ptr);\n+}\n+\n+inline PyArrayDescr_Proxy *array_descriptor_proxy(PyObject *ptr) {\n+    return reinterpret_cast<PyArrayDescr_Proxy *>(ptr);\n+}\n+\n+inline const PyArrayDescr_Proxy *array_descriptor_proxy(const PyObject *ptr) {\n+    return reinterpret_cast<const PyArrayDescr_Proxy *>(ptr);\n+}\n+\n+inline bool check_flags(const void *ptr, int flag) {\n+    return (flag == (array_proxy(ptr)->flags & flag));\n+}\n+\n+template <typename T>\n+struct is_std_array : std::false_type {};\n+template <typename T, size_t N>\n+struct is_std_array<std::array<T, N>> : std::true_type {};\n+template <typename T>\n+struct is_complex : std::false_type {};\n+template <typename T>\n+struct is_complex<std::complex<T>> : std::true_type {};\n+\n+template <typename T>\n+struct array_info_scalar {\n+    using type = T;\n+    static constexpr bool is_array = false;\n+    static constexpr bool is_empty = false;\n+    static constexpr auto extents = const_name(\"\");\n+    static void append_extents(list & /* shape */) {}\n+};\n+// Computes underlying type and a comma-separated list of extents for array\n+// types (any mix of std::array and built-in arrays). An array of char is\n+// treated as scalar because it gets special handling.\n+template <typename T>\n+struct array_info : array_info_scalar<T> {};\n+template <typename T, size_t N>\n+struct array_info<std::array<T, N>> {\n+    using type = typename array_info<T>::type;\n+    static constexpr bool is_array = true;\n+    static constexpr bool is_empty = (N == 0) || array_info<T>::is_empty;\n+    static constexpr size_t extent = N;\n+\n+    // appends the extents to shape\n+    static void append_extents(list &shape) {\n+        shape.append(N);\n+        array_info<T>::append_extents(shape);\n+    }\n+\n+    static constexpr auto extents = const_name<array_info<T>::is_array>(\n+        concat(const_name<N>(), array_info<T>::extents), const_name<N>());\n+};\n+// For numpy we have special handling for arrays of characters, so we don't include\n+// the size in the array extents.\n+template <size_t N>\n+struct array_info<char[N]> : array_info_scalar<char[N]> {};\n+template <size_t N>\n+struct array_info<std::array<char, N>> : array_info_scalar<std::array<char, N>> {};\n+template <typename T, size_t N>\n+struct array_info<T[N]> : array_info<std::array<T, N>> {};\n+template <typename T>\n+using remove_all_extents_t = typename array_info<T>::type;\n+\n+template <typename T>\n+using is_pod_struct\n+    = all_of<std::is_standard_layout<T>, // since we're accessing directly in memory\n+                                         // we need a standard layout type\n+#if defined(__GLIBCXX__)                                                                          \\\n+    && (__GLIBCXX__ < 20150422 || __GLIBCXX__ == 20150426 || __GLIBCXX__ == 20150623              \\\n+        || __GLIBCXX__ == 20150626 || __GLIBCXX__ == 20160803)\n+             // libstdc++ < 5 (including versions 4.8.5, 4.9.3 and 4.9.4 which were released after\n+             // 5) don't implement is_trivially_copyable, so approximate it\n+             std::is_trivially_destructible<T>,\n+             satisfies_any_of<T, std::has_trivial_copy_constructor, std::has_trivial_copy_assign>,\n+#else\n+             std::is_trivially_copyable<T>,\n+#endif\n+             satisfies_none_of<T,\n+                               std::is_reference,\n+                               std::is_array,\n+                               is_std_array,\n+                               std::is_arithmetic,\n+                               is_complex,\n+                               std::is_enum>>;\n+\n+// Replacement for std::is_pod (deprecated in C++20)\n+template <typename T>\n+using is_pod = all_of<std::is_standard_layout<T>, std::is_trivial<T>>;\n+\n+template <ssize_t Dim = 0, typename Strides>\n+ssize_t byte_offset_unsafe(const Strides &) {\n+    return 0;\n+}\n+template <ssize_t Dim = 0, typename Strides, typename... Ix>\n+ssize_t byte_offset_unsafe(const Strides &strides, ssize_t i, Ix... index) {\n+    return i * strides[Dim] + byte_offset_unsafe<Dim + 1>(strides, index...);\n+}\n+\n+/**\n+ * Proxy class providing unsafe, unchecked const access to array data.  This is constructed through\n+ * the `unchecked<T, N>()` method of `array` or the `unchecked<N>()` method of `array_t<T>`. `Dims`\n+ * will be -1 for dimensions determined at runtime.\n+ */\n+template <typename T, ssize_t Dims>\n+class unchecked_reference {\n+protected:\n+    static constexpr bool Dynamic = Dims < 0;\n+    const unsigned char *data_;\n+    // Storing the shape & strides in local variables (i.e. these arrays) allows the compiler to\n+    // make large performance gains on big, nested loops, but requires compile-time dimensions\n+    conditional_t<Dynamic, const ssize_t *, std::array<ssize_t, (size_t) Dims>> shape_, strides_;\n+    const ssize_t dims_;\n+\n+    friend class pybind11::array;\n+    // Constructor for compile-time dimensions:\n+    template <bool Dyn = Dynamic>\n+    unchecked_reference(const void *data,\n+                        const ssize_t *shape,\n+                        const ssize_t *strides,\n+                        enable_if_t<!Dyn, ssize_t>)\n+        : data_{reinterpret_cast<const unsigned char *>(data)}, dims_{Dims} {\n+        for (size_t i = 0; i < (size_t) dims_; i++) {\n+            shape_[i] = shape[i];\n+            strides_[i] = strides[i];\n+        }\n+    }\n+    // Constructor for runtime dimensions:\n+    template <bool Dyn = Dynamic>\n+    unchecked_reference(const void *data,\n+                        const ssize_t *shape,\n+                        const ssize_t *strides,\n+                        enable_if_t<Dyn, ssize_t> dims)\n+        : data_{reinterpret_cast<const unsigned char *>(data)}, shape_{shape}, strides_{strides},\n+          dims_{dims} {}\n+\n+public:\n+    /**\n+     * Unchecked const reference access to data at the given indices.  For a compile-time known\n+     * number of dimensions, this requires the correct number of arguments; for run-time\n+     * dimensionality, this is not checked (and so is up to the caller to use safely).\n+     */\n+    template <typename... Ix>\n+    const T &operator()(Ix... index) const {\n+        static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,\n+                      \"Invalid number of indices for unchecked array reference\");\n+        return *reinterpret_cast<const T *>(data_\n+                                            + byte_offset_unsafe(strides_, ssize_t(index)...));\n+    }\n+    /**\n+     * Unchecked const reference access to data; this operator only participates if the reference\n+     * is to a 1-dimensional array.  When present, this is exactly equivalent to `obj(index)`.\n+     */\n+    template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>\n+    const T &operator[](ssize_t index) const {\n+        return operator()(index);\n+    }\n+\n+    /// Pointer access to the data at the given indices.\n+    template <typename... Ix>\n+    const T *data(Ix... ix) const {\n+        return &operator()(ssize_t(ix)...);\n+    }\n+\n+    /// Returns the item size, i.e. sizeof(T)\n+    constexpr static ssize_t itemsize() { return sizeof(T); }\n+\n+    /// Returns the shape (i.e. size) of dimension `dim`\n+    ssize_t shape(ssize_t dim) const { return shape_[(size_t) dim]; }\n+\n+    /// Returns the number of dimensions of the array\n+    ssize_t ndim() const { return dims_; }\n+\n+    /// Returns the total number of elements in the referenced array, i.e. the product of the\n+    /// shapes\n+    template <bool Dyn = Dynamic>\n+    enable_if_t<!Dyn, ssize_t> size() const {\n+        return std::accumulate(\n+            shape_.begin(), shape_.end(), (ssize_t) 1, std::multiplies<ssize_t>());\n+    }\n+    template <bool Dyn = Dynamic>\n+    enable_if_t<Dyn, ssize_t> size() const {\n+        return std::accumulate(shape_, shape_ + ndim(), (ssize_t) 1, std::multiplies<ssize_t>());\n+    }\n+\n+    /// Returns the total number of bytes used by the referenced data.  Note that the actual span\n+    /// in memory may be larger if the referenced array has non-contiguous strides (e.g. for a\n+    /// slice).\n+    ssize_t nbytes() const { return size() * itemsize(); }\n+};\n+\n+template <typename T, ssize_t Dims>\n+class unchecked_mutable_reference : public unchecked_reference<T, Dims> {\n+    friend class pybind11::array;\n+    using ConstBase = unchecked_reference<T, Dims>;\n+    using ConstBase::ConstBase;\n+    using ConstBase::Dynamic;\n+\n+public:\n+    // Bring in const-qualified versions from base class\n+    using ConstBase::operator();\n+    using ConstBase::operator[];\n+\n+    /// Mutable, unchecked access to data at the given indices.\n+    template <typename... Ix>\n+    T &operator()(Ix... index) {\n+        static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,\n+                      \"Invalid number of indices for unchecked array reference\");\n+        return const_cast<T &>(ConstBase::operator()(index...));\n+    }\n+    /**\n+     * Mutable, unchecked access data at the given index; this operator only participates if the\n+     * reference is to a 1-dimensional array (or has runtime dimensions).  When present, this is\n+     * exactly equivalent to `obj(index)`.\n+     */\n+    template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>\n+    T &operator[](ssize_t index) {\n+        return operator()(index);\n+    }\n+\n+    /// Mutable pointer access to the data at the given indices.\n+    template <typename... Ix>\n+    T *mutable_data(Ix... ix) {\n+        return &operator()(ssize_t(ix)...);\n+    }\n+};\n+\n+template <typename T, ssize_t Dim>\n+struct type_caster<unchecked_reference<T, Dim>> {\n+    static_assert(Dim == 0 && Dim > 0 /* always fail */,\n+                  \"unchecked array proxy object is not castable\");\n+};\n+template <typename T, ssize_t Dim>\n+struct type_caster<unchecked_mutable_reference<T, Dim>>\n+    : type_caster<unchecked_reference<T, Dim>> {};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+class dtype : public object {\n+public:\n+    PYBIND11_OBJECT_DEFAULT(dtype, object, detail::npy_api::get().PyArrayDescr_Check_);\n+\n+    explicit dtype(const buffer_info &info) {\n+        dtype descr(_dtype_from_pep3118()(pybind11::str(info.format)));\n+        // If info.itemsize == 0, use the value calculated from the format string\n+        m_ptr = descr.strip_padding(info.itemsize != 0 ? info.itemsize : descr.itemsize())\n+                    .release()\n+                    .ptr();\n+    }\n+\n+    explicit dtype(const pybind11::str &format) : dtype(from_args(format)) {}\n+\n+    explicit dtype(const std::string &format) : dtype(pybind11::str(format)) {}\n+\n+    explicit dtype(const char *format) : dtype(pybind11::str(format)) {}\n+\n+    dtype(list names, list formats, list offsets, ssize_t itemsize) {\n+        dict args;\n+        args[\"names\"] = std::move(names);\n+        args[\"formats\"] = std::move(formats);\n+        args[\"offsets\"] = std::move(offsets);\n+        args[\"itemsize\"] = pybind11::int_(itemsize);\n+        m_ptr = from_args(args).release().ptr();\n+    }\n+\n+    explicit dtype(int typenum)\n+        : object(detail::npy_api::get().PyArray_DescrFromType_(typenum), stolen_t{}) {\n+        if (m_ptr == nullptr) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+    /// This is essentially the same as calling numpy.dtype(args) in Python.\n+    static dtype from_args(const object &args) {\n+        PyObject *ptr = nullptr;\n+        if ((detail::npy_api::get().PyArray_DescrConverter_(args.ptr(), &ptr) == 0) || !ptr) {\n+            throw error_already_set();\n+        }\n+        return reinterpret_steal<dtype>(ptr);\n+    }\n+\n+    /// Return dtype associated with a C++ type.\n+    template <typename T>\n+    static dtype of() {\n+        return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::dtype();\n+    }\n+\n+    /// Size of the data type in bytes.\n+    ssize_t itemsize() const { return detail::array_descriptor_proxy(m_ptr)->elsize; }\n+\n+    /// Returns true for structured data types.\n+    bool has_fields() const { return detail::array_descriptor_proxy(m_ptr)->names != nullptr; }\n+\n+    /// Single-character code for dtype's kind.\n+    /// For example, floating point types are 'f' and integral types are 'i'.\n+    char kind() const { return detail::array_descriptor_proxy(m_ptr)->kind; }\n+\n+    /// Single-character for dtype's type.\n+    /// For example, ``float`` is 'f', ``double`` 'd', ``int`` 'i', and ``long`` 'l'.\n+    char char_() const {\n+        // Note: The signature, `dtype::char_` follows the naming of NumPy's\n+        // public Python API (i.e., ``dtype.char``), rather than its internal\n+        // C API (``PyArray_Descr::type``).\n+        return detail::array_descriptor_proxy(m_ptr)->type;\n+    }\n+\n+    /// type number of dtype.\n+    int num() const {\n+        // Note: The signature, `dtype::num` follows the naming of NumPy's public\n+        // Python API (i.e., ``dtype.num``), rather than its internal\n+        // C API (``PyArray_Descr::type_num``).\n+        return detail::array_descriptor_proxy(m_ptr)->type_num;\n+    }\n+\n+    /// Single character for byteorder\n+    char byteorder() const { return detail::array_descriptor_proxy(m_ptr)->byteorder; }\n+\n+    /// Alignment of the data type\n+    int alignment() const { return detail::array_descriptor_proxy(m_ptr)->alignment; }\n+\n+    /// Flags for the array descriptor\n+    char flags() const { return detail::array_descriptor_proxy(m_ptr)->flags; }\n+\n+private:\n+    static object _dtype_from_pep3118() {\n+        static PyObject *obj = module_::import(\"numpy.core._internal\")\n+                                   .attr(\"_dtype_from_pep3118\")\n+                                   .cast<object>()\n+                                   .release()\n+                                   .ptr();\n+        return reinterpret_borrow<object>(obj);\n+    }\n+\n+    dtype strip_padding(ssize_t itemsize) {\n+        // Recursively strip all void fields with empty names that are generated for\n+        // padding fields (as of NumPy v1.11).\n+        if (!has_fields()) {\n+            return *this;\n+        }\n+\n+        struct field_descr {\n+            pybind11::str name;\n+            object format;\n+            pybind11::int_ offset;\n+            field_descr(pybind11::str &&name, object &&format, pybind11::int_ &&offset)\n+                : name{std::move(name)}, format{std::move(format)}, offset{std::move(offset)} {};\n+        };\n+        auto field_dict = attr(\"fields\").cast<dict>();\n+        std::vector<field_descr> field_descriptors;\n+        field_descriptors.reserve(field_dict.size());\n+\n+        for (auto field : field_dict.attr(\"items\")()) {\n+            auto spec = field.cast<tuple>();\n+            auto name = spec[0].cast<pybind11::str>();\n+            auto spec_fo = spec[1].cast<tuple>();\n+            auto format = spec_fo[0].cast<dtype>();\n+            auto offset = spec_fo[1].cast<pybind11::int_>();\n+            if ((len(name) == 0u) && format.kind() == 'V') {\n+                continue;\n+            }\n+            field_descriptors.emplace_back(\n+                std::move(name), format.strip_padding(format.itemsize()), std::move(offset));\n+        }\n+\n+        std::sort(field_descriptors.begin(),\n+                  field_descriptors.end(),\n+                  [](const field_descr &a, const field_descr &b) {\n+                      return a.offset.cast<int>() < b.offset.cast<int>();\n+                  });\n+\n+        list names, formats, offsets;\n+        for (auto &descr : field_descriptors) {\n+            names.append(std::move(descr.name));\n+            formats.append(std::move(descr.format));\n+            offsets.append(std::move(descr.offset));\n+        }\n+        return dtype(std::move(names), std::move(formats), std::move(offsets), itemsize);\n+    }\n+};\n+\n+class array : public buffer {\n+public:\n+    PYBIND11_OBJECT_CVT(array, buffer, detail::npy_api::get().PyArray_Check_, raw_array)\n+\n+    enum {\n+        c_style = detail::npy_api::NPY_ARRAY_C_CONTIGUOUS_,\n+        f_style = detail::npy_api::NPY_ARRAY_F_CONTIGUOUS_,\n+        forcecast = detail::npy_api::NPY_ARRAY_FORCECAST_\n+    };\n+\n+    array() : array(0, static_cast<const double *>(nullptr)) {}\n+\n+    using ShapeContainer = detail::any_container<ssize_t>;\n+    using StridesContainer = detail::any_container<ssize_t>;\n+\n+    // Constructs an array taking shape/strides from arbitrary container types\n+    array(const pybind11::dtype &dt,\n+          ShapeContainer shape,\n+          StridesContainer strides,\n+          const void *ptr = nullptr,\n+          handle base = handle()) {\n+\n+        if (strides->empty()) {\n+            *strides = detail::c_strides(*shape, dt.itemsize());\n+        }\n+\n+        auto ndim = shape->size();\n+        if (ndim != strides->size()) {\n+            pybind11_fail(\"NumPy: shape ndim doesn't match strides ndim\");\n+        }\n+        auto descr = dt;\n+\n+        int flags = 0;\n+        if (base && ptr) {\n+            if (isinstance<array>(base)) {\n+                /* Copy flags from base (except ownership bit) */\n+                flags = reinterpret_borrow<array>(base).flags()\n+                        & ~detail::npy_api::NPY_ARRAY_OWNDATA_;\n+            } else {\n+                /* Writable by default, easy to downgrade later on if needed */\n+                flags = detail::npy_api::NPY_ARRAY_WRITEABLE_;\n+            }\n+        }\n+\n+        auto &api = detail::npy_api::get();\n+        auto tmp = reinterpret_steal<object>(api.PyArray_NewFromDescr_(\n+            api.PyArray_Type_,\n+            descr.release().ptr(),\n+            (int) ndim,\n+            // Use reinterpret_cast for PyPy on Windows (remove if fixed, checked on 7.3.1)\n+            reinterpret_cast<Py_intptr_t *>(shape->data()),\n+            reinterpret_cast<Py_intptr_t *>(strides->data()),\n+            const_cast<void *>(ptr),\n+            flags,\n+            nullptr));\n+        if (!tmp) {\n+            throw error_already_set();\n+        }\n+        if (ptr) {\n+            if (base) {\n+                api.PyArray_SetBaseObject_(tmp.ptr(), base.inc_ref().ptr());\n+            } else {\n+                tmp = reinterpret_steal<object>(\n+                    api.PyArray_NewCopy_(tmp.ptr(), -1 /* any order */));\n+            }\n+        }\n+        m_ptr = tmp.release().ptr();\n+    }\n+\n+    array(const pybind11::dtype &dt,\n+          ShapeContainer shape,\n+          const void *ptr = nullptr,\n+          handle base = handle())\n+        : array(dt, std::move(shape), {}, ptr, base) {}\n+\n+    template <typename T,\n+              typename\n+              = detail::enable_if_t<std::is_integral<T>::value && !std::is_same<bool, T>::value>>\n+    array(const pybind11::dtype &dt, T count, const void *ptr = nullptr, handle base = handle())\n+        : array(dt, {{count}}, ptr, base) {}\n+\n+    template <typename T>\n+    array(ShapeContainer shape, StridesContainer strides, const T *ptr, handle base = handle())\n+        : array(pybind11::dtype::of<T>(), std::move(shape), std::move(strides), ptr, base) {}\n+\n+    template <typename T>\n+    array(ShapeContainer shape, const T *ptr, handle base = handle())\n+        : array(std::move(shape), {}, ptr, base) {}\n+\n+    template <typename T>\n+    explicit array(ssize_t count, const T *ptr, handle base = handle())\n+        : array({count}, {}, ptr, base) {}\n+\n+    explicit array(const buffer_info &info, handle base = handle())\n+        : array(pybind11::dtype(info), info.shape, info.strides, info.ptr, base) {}\n+\n+    /// Array descriptor (dtype)\n+    pybind11::dtype dtype() const {\n+        return reinterpret_borrow<pybind11::dtype>(detail::array_proxy(m_ptr)->descr);\n+    }\n+\n+    /// Total number of elements\n+    ssize_t size() const {\n+        return std::accumulate(shape(), shape() + ndim(), (ssize_t) 1, std::multiplies<ssize_t>());\n+    }\n+\n+    /// Byte size of a single element\n+    ssize_t itemsize() const {\n+        return detail::array_descriptor_proxy(detail::array_proxy(m_ptr)->descr)->elsize;\n+    }\n+\n+    /// Total number of bytes\n+    ssize_t nbytes() const { return size() * itemsize(); }\n+\n+    /// Number of dimensions\n+    ssize_t ndim() const { return detail::array_proxy(m_ptr)->nd; }\n+\n+    /// Base object\n+    object base() const { return reinterpret_borrow<object>(detail::array_proxy(m_ptr)->base); }\n+\n+    /// Dimensions of the array\n+    const ssize_t *shape() const { return detail::array_proxy(m_ptr)->dimensions; }\n+\n+    /// Dimension along a given axis\n+    ssize_t shape(ssize_t dim) const {\n+        if (dim >= ndim()) {\n+            fail_dim_check(dim, \"invalid axis\");\n+        }\n+        return shape()[dim];\n+    }\n+\n+    /// Strides of the array\n+    const ssize_t *strides() const { return detail::array_proxy(m_ptr)->strides; }\n+\n+    /// Stride along a given axis\n+    ssize_t strides(ssize_t dim) const {\n+        if (dim >= ndim()) {\n+            fail_dim_check(dim, \"invalid axis\");\n+        }\n+        return strides()[dim];\n+    }\n+\n+    /// Return the NumPy array flags\n+    int flags() const { return detail::array_proxy(m_ptr)->flags; }\n+\n+    /// If set, the array is writeable (otherwise the buffer is read-only)\n+    bool writeable() const {\n+        return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_WRITEABLE_);\n+    }\n+\n+    /// If set, the array owns the data (will be freed when the array is deleted)\n+    bool owndata() const {\n+        return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_OWNDATA_);\n+    }\n+\n+    /// Pointer to the contained data. If index is not provided, points to the\n+    /// beginning of the buffer. May throw if the index would lead to out of bounds access.\n+    template <typename... Ix>\n+    const void *data(Ix... index) const {\n+        return static_cast<const void *>(detail::array_proxy(m_ptr)->data + offset_at(index...));\n+    }\n+\n+    /// Mutable pointer to the contained data. If index is not provided, points to the\n+    /// beginning of the buffer. May throw if the index would lead to out of bounds access.\n+    /// May throw if the array is not writeable.\n+    template <typename... Ix>\n+    void *mutable_data(Ix... index) {\n+        check_writeable();\n+        return static_cast<void *>(detail::array_proxy(m_ptr)->data + offset_at(index...));\n+    }\n+\n+    /// Byte offset from beginning of the array to a given index (full or partial).\n+    /// May throw if the index would lead to out of bounds access.\n+    template <typename... Ix>\n+    ssize_t offset_at(Ix... index) const {\n+        if ((ssize_t) sizeof...(index) > ndim()) {\n+            fail_dim_check(sizeof...(index), \"too many indices for an array\");\n+        }\n+        return byte_offset(ssize_t(index)...);\n+    }\n+\n+    ssize_t offset_at() const { return 0; }\n+\n+    /// Item count from beginning of the array to a given index (full or partial).\n+    /// May throw if the index would lead to out of bounds access.\n+    template <typename... Ix>\n+    ssize_t index_at(Ix... index) const {\n+        return offset_at(index...) / itemsize();\n+    }\n+\n+    /**\n+     * Returns a proxy object that provides access to the array's data without bounds or\n+     * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with\n+     * care: the array must not be destroyed or reshaped for the duration of the returned object,\n+     * and the caller must take care not to access invalid dimensions or dimension indices.\n+     */\n+    template <typename T, ssize_t Dims = -1>\n+    detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {\n+        if (PYBIND11_SILENCE_MSVC_C4127(Dims >= 0) && ndim() != Dims) {\n+            throw std::domain_error(\"array has incorrect number of dimensions: \"\n+                                    + std::to_string(ndim()) + \"; expected \"\n+                                    + std::to_string(Dims));\n+        }\n+        return detail::unchecked_mutable_reference<T, Dims>(\n+            mutable_data(), shape(), strides(), ndim());\n+    }\n+\n+    /**\n+     * Returns a proxy object that provides const access to the array's data without bounds or\n+     * dimensionality checking.  Unlike `mutable_unchecked()`, this does not require that the\n+     * underlying array have the `writable` flag.  Use with care: the array must not be destroyed\n+     * or reshaped for the duration of the returned object, and the caller must take care not to\n+     * access invalid dimensions or dimension indices.\n+     */\n+    template <typename T, ssize_t Dims = -1>\n+    detail::unchecked_reference<T, Dims> unchecked() const & {\n+        if (PYBIND11_SILENCE_MSVC_C4127(Dims >= 0) && ndim() != Dims) {\n+            throw std::domain_error(\"array has incorrect number of dimensions: \"\n+                                    + std::to_string(ndim()) + \"; expected \"\n+                                    + std::to_string(Dims));\n+        }\n+        return detail::unchecked_reference<T, Dims>(data(), shape(), strides(), ndim());\n+    }\n+\n+    /// Return a new view with all of the dimensions of length 1 removed\n+    array squeeze() {\n+        auto &api = detail::npy_api::get();\n+        return reinterpret_steal<array>(api.PyArray_Squeeze_(m_ptr));\n+    }\n+\n+    /// Resize array to given shape\n+    /// If refcheck is true and more that one reference exist to this array\n+    /// then resize will succeed only if it makes a reshape, i.e. original size doesn't change\n+    void resize(ShapeContainer new_shape, bool refcheck = true) {\n+        detail::npy_api::PyArray_Dims d\n+            = {// Use reinterpret_cast for PyPy on Windows (remove if fixed, checked on 7.3.1)\n+               reinterpret_cast<Py_intptr_t *>(new_shape->data()),\n+               int(new_shape->size())};\n+        // try to resize, set ordering param to -1 cause it's not used anyway\n+        auto new_array = reinterpret_steal<object>(\n+            detail::npy_api::get().PyArray_Resize_(m_ptr, &d, int(refcheck), -1));\n+        if (!new_array) {\n+            throw error_already_set();\n+        }\n+        if (isinstance<array>(new_array)) {\n+            *this = std::move(new_array);\n+        }\n+    }\n+\n+    /// Optional `order` parameter omitted, to be added as needed.\n+    array reshape(ShapeContainer new_shape) {\n+        detail::npy_api::PyArray_Dims d\n+            = {reinterpret_cast<Py_intptr_t *>(new_shape->data()), int(new_shape->size())};\n+        auto new_array\n+            = reinterpret_steal<array>(detail::npy_api::get().PyArray_Newshape_(m_ptr, &d, 0));\n+        if (!new_array) {\n+            throw error_already_set();\n+        }\n+        return new_array;\n+    }\n+\n+    /// Create a view of an array in a different data type.\n+    /// This function may fundamentally reinterpret the data in the array.\n+    /// It is the responsibility of the caller to ensure that this is safe.\n+    /// Only supports the `dtype` argument, the `type` argument is omitted,\n+    /// to be added as needed.\n+    array view(const std::string &dtype) {\n+        auto &api = detail::npy_api::get();\n+        auto new_view = reinterpret_steal<array>(api.PyArray_View_(\n+            m_ptr, dtype::from_args(pybind11::str(dtype)).release().ptr(), nullptr));\n+        if (!new_view) {\n+            throw error_already_set();\n+        }\n+        return new_view;\n+    }\n+\n+    /// Ensure that the argument is a NumPy array\n+    /// In case of an error, nullptr is returned and the Python error is cleared.\n+    static array ensure(handle h, int ExtraFlags = 0) {\n+        auto result = reinterpret_steal<array>(raw_array(h.ptr(), ExtraFlags));\n+        if (!result) {\n+            PyErr_Clear();\n+        }\n+        return result;\n+    }\n+\n+protected:\n+    template <typename, typename>\n+    friend struct detail::npy_format_descriptor;\n+\n+    void fail_dim_check(ssize_t dim, const std::string &msg) const {\n+        throw index_error(msg + \": \" + std::to_string(dim) + \" (ndim = \" + std::to_string(ndim())\n+                          + ')');\n+    }\n+\n+    template <typename... Ix>\n+    ssize_t byte_offset(Ix... index) const {\n+        check_dimensions(index...);\n+        return detail::byte_offset_unsafe(strides(), ssize_t(index)...);\n+    }\n+\n+    void check_writeable() const {\n+        if (!writeable()) {\n+            throw std::domain_error(\"array is not writeable\");\n+        }\n+    }\n+\n+    template <typename... Ix>\n+    void check_dimensions(Ix... index) const {\n+        check_dimensions_impl(ssize_t(0), shape(), ssize_t(index)...);\n+    }\n+\n+    void check_dimensions_impl(ssize_t, const ssize_t *) const {}\n+\n+    template <typename... Ix>\n+    void check_dimensions_impl(ssize_t axis, const ssize_t *shape, ssize_t i, Ix... index) const {\n+        if (i >= *shape) {\n+            throw index_error(std::string(\"index \") + std::to_string(i)\n+                              + \" is out of bounds for axis \" + std::to_string(axis)\n+                              + \" with size \" + std::to_string(*shape));\n+        }\n+        check_dimensions_impl(axis + 1, shape + 1, index...);\n+    }\n+\n+    /// Create array from any object -- always returns a new reference\n+    static PyObject *raw_array(PyObject *ptr, int ExtraFlags = 0) {\n+        if (ptr == nullptr) {\n+            PyErr_SetString(PyExc_ValueError, \"cannot create a pybind11::array from a nullptr\");\n+            return nullptr;\n+        }\n+        return detail::npy_api::get().PyArray_FromAny_(\n+            ptr, nullptr, 0, 0, detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);\n+    }\n+};\n+\n+template <typename T, int ExtraFlags = array::forcecast>\n+class array_t : public array {\n+private:\n+    struct private_ctor {};\n+    // Delegating constructor needed when both moving and accessing in the same constructor\n+    array_t(private_ctor,\n+            ShapeContainer &&shape,\n+            StridesContainer &&strides,\n+            const T *ptr,\n+            handle base)\n+        : array(std::move(shape), std::move(strides), ptr, base) {}\n+\n+public:\n+    static_assert(!detail::array_info<T>::is_array, \"Array types cannot be used with array_t\");\n+\n+    using value_type = T;\n+\n+    array_t() : array(0, static_cast<const T *>(nullptr)) {}\n+    array_t(handle h, borrowed_t) : array(h, borrowed_t{}) {}\n+    array_t(handle h, stolen_t) : array(h, stolen_t{}) {}\n+\n+    PYBIND11_DEPRECATED(\"Use array_t<T>::ensure() instead\")\n+    array_t(handle h, bool is_borrowed) : array(raw_array_t(h.ptr()), stolen_t{}) {\n+        if (!m_ptr) {\n+            PyErr_Clear();\n+        }\n+        if (!is_borrowed) {\n+            Py_XDECREF(h.ptr());\n+        }\n+    }\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    array_t(const object &o) : array(raw_array_t(o.ptr()), stolen_t{}) {\n+        if (!m_ptr) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+    explicit array_t(const buffer_info &info, handle base = handle()) : array(info, base) {}\n+\n+    array_t(ShapeContainer shape,\n+            StridesContainer strides,\n+            const T *ptr = nullptr,\n+            handle base = handle())\n+        : array(std::move(shape), std::move(strides), ptr, base) {}\n+\n+    explicit array_t(ShapeContainer shape, const T *ptr = nullptr, handle base = handle())\n+        : array_t(private_ctor{},\n+                  std::move(shape),\n+                  (ExtraFlags & f_style) != 0 ? detail::f_strides(*shape, itemsize())\n+                                              : detail::c_strides(*shape, itemsize()),\n+                  ptr,\n+                  base) {}\n+\n+    explicit array_t(ssize_t count, const T *ptr = nullptr, handle base = handle())\n+        : array({count}, {}, ptr, base) {}\n+\n+    constexpr ssize_t itemsize() const { return sizeof(T); }\n+\n+    template <typename... Ix>\n+    ssize_t index_at(Ix... index) const {\n+        return offset_at(index...) / itemsize();\n+    }\n+\n+    template <typename... Ix>\n+    const T *data(Ix... index) const {\n+        return static_cast<const T *>(array::data(index...));\n+    }\n+\n+    template <typename... Ix>\n+    T *mutable_data(Ix... index) {\n+        return static_cast<T *>(array::mutable_data(index...));\n+    }\n+\n+    // Reference to element at a given index\n+    template <typename... Ix>\n+    const T &at(Ix... index) const {\n+        if ((ssize_t) sizeof...(index) != ndim()) {\n+            fail_dim_check(sizeof...(index), \"index dimension mismatch\");\n+        }\n+        return *(static_cast<const T *>(array::data())\n+                 + byte_offset(ssize_t(index)...) / itemsize());\n+    }\n+\n+    // Mutable reference to element at a given index\n+    template <typename... Ix>\n+    T &mutable_at(Ix... index) {\n+        if ((ssize_t) sizeof...(index) != ndim()) {\n+            fail_dim_check(sizeof...(index), \"index dimension mismatch\");\n+        }\n+        return *(static_cast<T *>(array::mutable_data())\n+                 + byte_offset(ssize_t(index)...) / itemsize());\n+    }\n+\n+    /**\n+     * Returns a proxy object that provides access to the array's data without bounds or\n+     * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with\n+     * care: the array must not be destroyed or reshaped for the duration of the returned object,\n+     * and the caller must take care not to access invalid dimensions or dimension indices.\n+     */\n+    template <ssize_t Dims = -1>\n+    detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {\n+        return array::mutable_unchecked<T, Dims>();\n+    }\n+\n+    /**\n+     * Returns a proxy object that provides const access to the array's data without bounds or\n+     * dimensionality checking.  Unlike `unchecked()`, this does not require that the underlying\n+     * array have the `writable` flag.  Use with care: the array must not be destroyed or reshaped\n+     * for the duration of the returned object, and the caller must take care not to access invalid\n+     * dimensions or dimension indices.\n+     */\n+    template <ssize_t Dims = -1>\n+    detail::unchecked_reference<T, Dims> unchecked() const & {\n+        return array::unchecked<T, Dims>();\n+    }\n+\n+    /// Ensure that the argument is a NumPy array of the correct dtype (and if not, try to convert\n+    /// it).  In case of an error, nullptr is returned and the Python error is cleared.\n+    static array_t ensure(handle h) {\n+        auto result = reinterpret_steal<array_t>(raw_array_t(h.ptr()));\n+        if (!result) {\n+            PyErr_Clear();\n+        }\n+        return result;\n+    }\n+\n+    static bool check_(handle h) {\n+        const auto &api = detail::npy_api::get();\n+        return api.PyArray_Check_(h.ptr())\n+               && api.PyArray_EquivTypes_(detail::array_proxy(h.ptr())->descr,\n+                                          dtype::of<T>().ptr())\n+               && detail::check_flags(h.ptr(), ExtraFlags & (array::c_style | array::f_style));\n+    }\n+\n+protected:\n+    /// Create array from any object -- always returns a new reference\n+    static PyObject *raw_array_t(PyObject *ptr) {\n+        if (ptr == nullptr) {\n+            PyErr_SetString(PyExc_ValueError, \"cannot create a pybind11::array_t from a nullptr\");\n+            return nullptr;\n+        }\n+        return detail::npy_api::get().PyArray_FromAny_(ptr,\n+                                                       dtype::of<T>().release().ptr(),\n+                                                       0,\n+                                                       0,\n+                                                       detail::npy_api::NPY_ARRAY_ENSUREARRAY_\n+                                                           | ExtraFlags,\n+                                                       nullptr);\n+    }\n+};\n+\n+template <typename T>\n+struct format_descriptor<T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {\n+    static std::string format() {\n+        return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::format();\n+    }\n+};\n+\n+template <size_t N>\n+struct format_descriptor<char[N]> {\n+    static std::string format() { return std::to_string(N) + 's'; }\n+};\n+template <size_t N>\n+struct format_descriptor<std::array<char, N>> {\n+    static std::string format() { return std::to_string(N) + 's'; }\n+};\n+\n+template <typename T>\n+struct format_descriptor<T, detail::enable_if_t<std::is_enum<T>::value>> {\n+    static std::string format() {\n+        return format_descriptor<\n+            typename std::remove_cv<typename std::underlying_type<T>::type>::type>::format();\n+    }\n+};\n+\n+template <typename T>\n+struct format_descriptor<T, detail::enable_if_t<detail::array_info<T>::is_array>> {\n+    static std::string format() {\n+        using namespace detail;\n+        static constexpr auto extents = const_name(\"(\") + array_info<T>::extents + const_name(\")\");\n+        return extents.text + format_descriptor<remove_all_extents_t<T>>::format();\n+    }\n+};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+template <typename T, int ExtraFlags>\n+struct pyobject_caster<array_t<T, ExtraFlags>> {\n+    using type = array_t<T, ExtraFlags>;\n+\n+    bool load(handle src, bool convert) {\n+        if (!convert && !type::check_(src)) {\n+            return false;\n+        }\n+        value = type::ensure(src);\n+        return static_cast<bool>(value);\n+    }\n+\n+    static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {\n+        return src.inc_ref();\n+    }\n+    PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name);\n+};\n+\n+template <typename T>\n+struct compare_buffer_info<T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {\n+    static bool compare(const buffer_info &b) {\n+        return npy_api::get().PyArray_EquivTypes_(dtype::of<T>().ptr(), dtype(b).ptr());\n+    }\n+};\n+\n+template <typename T, typename = void>\n+struct npy_format_descriptor_name;\n+\n+template <typename T>\n+struct npy_format_descriptor_name<T, enable_if_t<std::is_integral<T>::value>> {\n+    static constexpr auto name = const_name<std::is_same<T, bool>::value>(\n+        const_name(\"bool\"),\n+        const_name<std::is_signed<T>::value>(\"numpy.int\", \"numpy.uint\")\n+            + const_name<sizeof(T) * 8>());\n+};\n+\n+template <typename T>\n+struct npy_format_descriptor_name<T, enable_if_t<std::is_floating_point<T>::value>> {\n+    static constexpr auto name = const_name < std::is_same<T, float>::value\n+                                 || std::is_same<T, const float>::value\n+                                 || std::is_same<T, double>::value\n+                                 || std::is_same<T, const double>::value\n+                                        > (const_name(\"numpy.float\") + const_name<sizeof(T) * 8>(),\n+                                           const_name(\"numpy.longdouble\"));\n+};\n+\n+template <typename T>\n+struct npy_format_descriptor_name<T, enable_if_t<is_complex<T>::value>> {\n+    static constexpr auto name = const_name < std::is_same<typename T::value_type, float>::value\n+                                 || std::is_same<typename T::value_type, const float>::value\n+                                 || std::is_same<typename T::value_type, double>::value\n+                                 || std::is_same<typename T::value_type, const double>::value\n+                                        > (const_name(\"numpy.complex\")\n+                                               + const_name<sizeof(typename T::value_type) * 16>(),\n+                                           const_name(\"numpy.longcomplex\"));\n+};\n+\n+template <typename T>\n+struct npy_format_descriptor<\n+    T,\n+    enable_if_t<satisfies_any_of<T, std::is_arithmetic, is_complex>::value>>\n+    : npy_format_descriptor_name<T> {\n+private:\n+    // NB: the order here must match the one in common.h\n+    constexpr static const int values[15] = {npy_api::NPY_BOOL_,\n+                                             npy_api::NPY_BYTE_,\n+                                             npy_api::NPY_UBYTE_,\n+                                             npy_api::NPY_INT16_,\n+                                             npy_api::NPY_UINT16_,\n+                                             npy_api::NPY_INT32_,\n+                                             npy_api::NPY_UINT32_,\n+                                             npy_api::NPY_INT64_,\n+                                             npy_api::NPY_UINT64_,\n+                                             npy_api::NPY_FLOAT_,\n+                                             npy_api::NPY_DOUBLE_,\n+                                             npy_api::NPY_LONGDOUBLE_,\n+                                             npy_api::NPY_CFLOAT_,\n+                                             npy_api::NPY_CDOUBLE_,\n+                                             npy_api::NPY_CLONGDOUBLE_};\n+\n+public:\n+    static constexpr int value = values[detail::is_fmt_numeric<T>::index];\n+\n+    static pybind11::dtype dtype() {\n+        if (auto *ptr = npy_api::get().PyArray_DescrFromType_(value)) {\n+            return reinterpret_steal<pybind11::dtype>(ptr);\n+        }\n+        pybind11_fail(\"Unsupported buffer format!\");\n+    }\n+};\n+\n+#define PYBIND11_DECL_CHAR_FMT                                                                    \\\n+    static constexpr auto name = const_name(\"S\") + const_name<N>();                               \\\n+    static pybind11::dtype dtype() {                                                              \\\n+        return pybind11::dtype(std::string(\"S\") + std::to_string(N));                             \\\n+    }\n+template <size_t N>\n+struct npy_format_descriptor<char[N]> {\n+    PYBIND11_DECL_CHAR_FMT\n+};\n+template <size_t N>\n+struct npy_format_descriptor<std::array<char, N>> {\n+    PYBIND11_DECL_CHAR_FMT\n+};\n+#undef PYBIND11_DECL_CHAR_FMT\n+\n+template <typename T>\n+struct npy_format_descriptor<T, enable_if_t<array_info<T>::is_array>> {\n+private:\n+    using base_descr = npy_format_descriptor<typename array_info<T>::type>;\n+\n+public:\n+    static_assert(!array_info<T>::is_empty, \"Zero-sized arrays are not supported\");\n+\n+    static constexpr auto name\n+        = const_name(\"(\") + array_info<T>::extents + const_name(\")\") + base_descr::name;\n+    static pybind11::dtype dtype() {\n+        list shape;\n+        array_info<T>::append_extents(shape);\n+        return pybind11::dtype::from_args(\n+            pybind11::make_tuple(base_descr::dtype(), std::move(shape)));\n+    }\n+};\n+\n+template <typename T>\n+struct npy_format_descriptor<T, enable_if_t<std::is_enum<T>::value>> {\n+private:\n+    using base_descr = npy_format_descriptor<typename std::underlying_type<T>::type>;\n+\n+public:\n+    static constexpr auto name = base_descr::name;\n+    static pybind11::dtype dtype() { return base_descr::dtype(); }\n+};\n+\n+struct field_descriptor {\n+    const char *name;\n+    ssize_t offset;\n+    ssize_t size;\n+    std::string format;\n+    dtype descr;\n+};\n+\n+PYBIND11_NOINLINE void register_structured_dtype(any_container<field_descriptor> fields,\n+                                                 const std::type_info &tinfo,\n+                                                 ssize_t itemsize,\n+                                                 bool (*direct_converter)(PyObject *, void *&)) {\n+\n+    auto &numpy_internals = get_numpy_internals();\n+    if (numpy_internals.get_type_info(tinfo, false)) {\n+        pybind11_fail(\"NumPy: dtype is already registered\");\n+    }\n+\n+    // Use ordered fields because order matters as of NumPy 1.14:\n+    // https://docs.scipy.org/doc/numpy/release.html#multiple-field-indexing-assignment-of-structured-arrays\n+    std::vector<field_descriptor> ordered_fields(std::move(fields));\n+    std::sort(\n+        ordered_fields.begin(),\n+        ordered_fields.end(),\n+        [](const field_descriptor &a, const field_descriptor &b) { return a.offset < b.offset; });\n+\n+    list names, formats, offsets;\n+    for (auto &field : ordered_fields) {\n+        if (!field.descr) {\n+            pybind11_fail(std::string(\"NumPy: unsupported field dtype: `\") + field.name + \"` @ \"\n+                          + tinfo.name());\n+        }\n+        names.append(pybind11::str(field.name));\n+        formats.append(field.descr);\n+        offsets.append(pybind11::int_(field.offset));\n+    }\n+    auto *dtype_ptr\n+        = pybind11::dtype(std::move(names), std::move(formats), std::move(offsets), itemsize)\n+              .release()\n+              .ptr();\n+\n+    // There is an existing bug in NumPy (as of v1.11): trailing bytes are\n+    // not encoded explicitly into the format string. This will supposedly\n+    // get fixed in v1.12; for further details, see these:\n+    // - https://github.com/numpy/numpy/issues/7797\n+    // - https://github.com/numpy/numpy/pull/7798\n+    // Because of this, we won't use numpy's logic to generate buffer format\n+    // strings and will just do it ourselves.\n+    ssize_t offset = 0;\n+    std::ostringstream oss;\n+    // mark the structure as unaligned with '^', because numpy and C++ don't\n+    // always agree about alignment (particularly for complex), and we're\n+    // explicitly listing all our padding. This depends on none of the fields\n+    // overriding the endianness. Putting the ^ in front of individual fields\n+    // isn't guaranteed to work due to https://github.com/numpy/numpy/issues/9049\n+    oss << \"^T{\";\n+    for (auto &field : ordered_fields) {\n+        if (field.offset > offset) {\n+            oss << (field.offset - offset) << 'x';\n+        }\n+        oss << field.format << ':' << field.name << ':';\n+        offset = field.offset + field.size;\n+    }\n+    if (itemsize > offset) {\n+        oss << (itemsize - offset) << 'x';\n+    }\n+    oss << '}';\n+    auto format_str = oss.str();\n+\n+    // Sanity check: verify that NumPy properly parses our buffer format string\n+    auto &api = npy_api::get();\n+    auto arr = array(buffer_info(nullptr, itemsize, format_str, 1));\n+    if (!api.PyArray_EquivTypes_(dtype_ptr, arr.dtype().ptr())) {\n+        pybind11_fail(\"NumPy: invalid buffer descriptor!\");\n+    }\n+\n+    auto tindex = std::type_index(tinfo);\n+    numpy_internals.registered_dtypes[tindex] = {dtype_ptr, std::move(format_str)};\n+    get_internals().direct_conversions[tindex].push_back(direct_converter);\n+}\n+\n+template <typename T, typename SFINAE>\n+struct npy_format_descriptor {\n+    static_assert(is_pod_struct<T>::value,\n+                  \"Attempt to use a non-POD or unimplemented POD type as a numpy dtype\");\n+\n+    static constexpr auto name = make_caster<T>::name;\n+\n+    static pybind11::dtype dtype() { return reinterpret_borrow<pybind11::dtype>(dtype_ptr()); }\n+\n+    static std::string format() {\n+        static auto format_str = get_numpy_internals().get_type_info<T>(true)->format_str;\n+        return format_str;\n+    }\n+\n+    static void register_dtype(any_container<field_descriptor> fields) {\n+        register_structured_dtype(std::move(fields),\n+                                  typeid(typename std::remove_cv<T>::type),\n+                                  sizeof(T),\n+                                  &direct_converter);\n+    }\n+\n+private:\n+    static PyObject *dtype_ptr() {\n+        static PyObject *ptr = get_numpy_internals().get_type_info<T>(true)->dtype_ptr;\n+        return ptr;\n+    }\n+\n+    static bool direct_converter(PyObject *obj, void *&value) {\n+        auto &api = npy_api::get();\n+        if (!PyObject_TypeCheck(obj, api.PyVoidArrType_Type_)) {\n+            return false;\n+        }\n+        if (auto descr = reinterpret_steal<object>(api.PyArray_DescrFromScalar_(obj))) {\n+            if (api.PyArray_EquivTypes_(dtype_ptr(), descr.ptr())) {\n+                value = ((PyVoidScalarObject_Proxy *) obj)->obval;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+};\n+\n+#ifdef __CLION_IDE__ // replace heavy macro with dummy code for the IDE (doesn't affect code)\n+#    define PYBIND11_NUMPY_DTYPE(Type, ...) ((void) 0)\n+#    define PYBIND11_NUMPY_DTYPE_EX(Type, ...) ((void) 0)\n+#else\n+\n+#    define PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, Name)                                          \\\n+        ::pybind11::detail::field_descriptor {                                                    \\\n+            Name, offsetof(T, Field), sizeof(decltype(std::declval<T>().Field)),                  \\\n+                ::pybind11::format_descriptor<decltype(std::declval<T>().Field)>::format(),       \\\n+                ::pybind11::detail::npy_format_descriptor<                                        \\\n+                    decltype(std::declval<T>().Field)>::dtype()                                   \\\n+        }\n+\n+// Extract name, offset and format descriptor for a struct field\n+#    define PYBIND11_FIELD_DESCRIPTOR(T, Field) PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, #    Field)\n+\n+// The main idea of this macro is borrowed from https://github.com/swansontec/map-macro\n+// (C) William Swanson, Paul Fultz\n+#    define PYBIND11_EVAL0(...) __VA_ARGS__\n+#    define PYBIND11_EVAL1(...) PYBIND11_EVAL0(PYBIND11_EVAL0(PYBIND11_EVAL0(__VA_ARGS__)))\n+#    define PYBIND11_EVAL2(...) PYBIND11_EVAL1(PYBIND11_EVAL1(PYBIND11_EVAL1(__VA_ARGS__)))\n+#    define PYBIND11_EVAL3(...) PYBIND11_EVAL2(PYBIND11_EVAL2(PYBIND11_EVAL2(__VA_ARGS__)))\n+#    define PYBIND11_EVAL4(...) PYBIND11_EVAL3(PYBIND11_EVAL3(PYBIND11_EVAL3(__VA_ARGS__)))\n+#    define PYBIND11_EVAL(...) PYBIND11_EVAL4(PYBIND11_EVAL4(PYBIND11_EVAL4(__VA_ARGS__)))\n+#    define PYBIND11_MAP_END(...)\n+#    define PYBIND11_MAP_OUT\n+#    define PYBIND11_MAP_COMMA ,\n+#    define PYBIND11_MAP_GET_END() 0, PYBIND11_MAP_END\n+#    define PYBIND11_MAP_NEXT0(test, next, ...) next PYBIND11_MAP_OUT\n+#    define PYBIND11_MAP_NEXT1(test, next) PYBIND11_MAP_NEXT0(test, next, 0)\n+#    define PYBIND11_MAP_NEXT(test, next) PYBIND11_MAP_NEXT1(PYBIND11_MAP_GET_END test, next)\n+#    if defined(_MSC_VER)                                                                         \\\n+        && !defined(__clang__) // MSVC is not as eager to expand macros, hence this workaround\n+#        define PYBIND11_MAP_LIST_NEXT1(test, next)                                               \\\n+            PYBIND11_EVAL0(PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0))\n+#    else\n+#        define PYBIND11_MAP_LIST_NEXT1(test, next)                                               \\\n+            PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0)\n+#    endif\n+#    define PYBIND11_MAP_LIST_NEXT(test, next)                                                    \\\n+        PYBIND11_MAP_LIST_NEXT1(PYBIND11_MAP_GET_END test, next)\n+#    define PYBIND11_MAP_LIST0(f, t, x, peek, ...)                                                \\\n+        f(t, x) PYBIND11_MAP_LIST_NEXT(peek, PYBIND11_MAP_LIST1)(f, t, peek, __VA_ARGS__)\n+#    define PYBIND11_MAP_LIST1(f, t, x, peek, ...)                                                \\\n+        f(t, x) PYBIND11_MAP_LIST_NEXT(peek, PYBIND11_MAP_LIST0)(f, t, peek, __VA_ARGS__)\n+// PYBIND11_MAP_LIST(f, t, a1, a2, ...) expands to f(t, a1), f(t, a2), ...\n+#    define PYBIND11_MAP_LIST(f, t, ...)                                                          \\\n+        PYBIND11_EVAL(PYBIND11_MAP_LIST1(f, t, __VA_ARGS__, (), 0))\n+\n+#    define PYBIND11_NUMPY_DTYPE(Type, ...)                                                       \\\n+        ::pybind11::detail::npy_format_descriptor<Type>::register_dtype(                          \\\n+            ::std::vector<::pybind11::detail::field_descriptor>{                                  \\\n+                PYBIND11_MAP_LIST(PYBIND11_FIELD_DESCRIPTOR, Type, __VA_ARGS__)})\n+\n+#    if defined(_MSC_VER) && !defined(__clang__)\n+#        define PYBIND11_MAP2_LIST_NEXT1(test, next)                                              \\\n+            PYBIND11_EVAL0(PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0))\n+#    else\n+#        define PYBIND11_MAP2_LIST_NEXT1(test, next)                                              \\\n+            PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0)\n+#    endif\n+#    define PYBIND11_MAP2_LIST_NEXT(test, next)                                                   \\\n+        PYBIND11_MAP2_LIST_NEXT1(PYBIND11_MAP_GET_END test, next)\n+#    define PYBIND11_MAP2_LIST0(f, t, x1, x2, peek, ...)                                          \\\n+        f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT(peek, PYBIND11_MAP2_LIST1)(f, t, peek, __VA_ARGS__)\n+#    define PYBIND11_MAP2_LIST1(f, t, x1, x2, peek, ...)                                          \\\n+        f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT(peek, PYBIND11_MAP2_LIST0)(f, t, peek, __VA_ARGS__)\n+// PYBIND11_MAP2_LIST(f, t, a1, a2, ...) expands to f(t, a1, a2), f(t, a3, a4), ...\n+#    define PYBIND11_MAP2_LIST(f, t, ...)                                                         \\\n+        PYBIND11_EVAL(PYBIND11_MAP2_LIST1(f, t, __VA_ARGS__, (), 0))\n+\n+#    define PYBIND11_NUMPY_DTYPE_EX(Type, ...)                                                    \\\n+        ::pybind11::detail::npy_format_descriptor<Type>::register_dtype(                          \\\n+            ::std::vector<::pybind11::detail::field_descriptor>{                                  \\\n+                PYBIND11_MAP2_LIST(PYBIND11_FIELD_DESCRIPTOR_EX, Type, __VA_ARGS__)})\n+\n+#endif // __CLION_IDE__\n+\n+class common_iterator {\n+public:\n+    using container_type = std::vector<ssize_t>;\n+    using value_type = container_type::value_type;\n+    using size_type = container_type::size_type;\n+\n+    common_iterator() : m_strides() {}\n+\n+    common_iterator(void *ptr, const container_type &strides, const container_type &shape)\n+        : p_ptr(reinterpret_cast<char *>(ptr)), m_strides(strides.size()) {\n+        m_strides.back() = static_cast<value_type>(strides.back());\n+        for (size_type i = m_strides.size() - 1; i != 0; --i) {\n+            size_type j = i - 1;\n+            auto s = static_cast<value_type>(shape[i]);\n+            m_strides[j] = strides[j] + m_strides[i] - strides[i] * s;\n+        }\n+    }\n+\n+    void increment(size_type dim) { p_ptr += m_strides[dim]; }\n+\n+    void *data() const { return p_ptr; }\n+\n+private:\n+    char *p_ptr{nullptr};\n+    container_type m_strides;\n+};\n+\n+template <size_t N>\n+class multi_array_iterator {\n+public:\n+    using container_type = std::vector<ssize_t>;\n+\n+    multi_array_iterator(const std::array<buffer_info, N> &buffers, const container_type &shape)\n+        : m_shape(shape.size()), m_index(shape.size(), 0), m_common_iterator() {\n+\n+        // Manual copy to avoid conversion warning if using std::copy\n+        for (size_t i = 0; i < shape.size(); ++i) {\n+            m_shape[i] = shape[i];\n+        }\n+\n+        container_type strides(shape.size());\n+        for (size_t i = 0; i < N; ++i) {\n+            init_common_iterator(buffers[i], shape, m_common_iterator[i], strides);\n+        }\n+    }\n+\n+    multi_array_iterator &operator++() {\n+        for (size_t j = m_index.size(); j != 0; --j) {\n+            size_t i = j - 1;\n+            if (++m_index[i] != m_shape[i]) {\n+                increment_common_iterator(i);\n+                break;\n+            }\n+            m_index[i] = 0;\n+        }\n+        return *this;\n+    }\n+\n+    template <size_t K, class T = void>\n+    T *data() const {\n+        return reinterpret_cast<T *>(m_common_iterator[K].data());\n+    }\n+\n+private:\n+    using common_iter = common_iterator;\n+\n+    void init_common_iterator(const buffer_info &buffer,\n+                              const container_type &shape,\n+                              common_iter &iterator,\n+                              container_type &strides) {\n+        auto buffer_shape_iter = buffer.shape.rbegin();\n+        auto buffer_strides_iter = buffer.strides.rbegin();\n+        auto shape_iter = shape.rbegin();\n+        auto strides_iter = strides.rbegin();\n+\n+        while (buffer_shape_iter != buffer.shape.rend()) {\n+            if (*shape_iter == *buffer_shape_iter) {\n+                *strides_iter = *buffer_strides_iter;\n+            } else {\n+                *strides_iter = 0;\n+            }\n+\n+            ++buffer_shape_iter;\n+            ++buffer_strides_iter;\n+            ++shape_iter;\n+            ++strides_iter;\n+        }\n+\n+        std::fill(strides_iter, strides.rend(), 0);\n+        iterator = common_iter(buffer.ptr, strides, shape);\n+    }\n+\n+    void increment_common_iterator(size_t dim) {\n+        for (auto &iter : m_common_iterator) {\n+            iter.increment(dim);\n+        }\n+    }\n+\n+    container_type m_shape;\n+    container_type m_index;\n+    std::array<common_iter, N> m_common_iterator;\n+};\n+\n+enum class broadcast_trivial { non_trivial, c_trivial, f_trivial };\n+\n+// Populates the shape and number of dimensions for the set of buffers.  Returns a\n+// broadcast_trivial enum value indicating whether the broadcast is \"trivial\"--that is, has each\n+// buffer being either a singleton or a full-size, C-contiguous (`c_trivial`) or Fortran-contiguous\n+// (`f_trivial`) storage buffer; returns `non_trivial` otherwise.\n+template <size_t N>\n+broadcast_trivial\n+broadcast(const std::array<buffer_info, N> &buffers, ssize_t &ndim, std::vector<ssize_t> &shape) {\n+    ndim = std::accumulate(\n+        buffers.begin(), buffers.end(), ssize_t(0), [](ssize_t res, const buffer_info &buf) {\n+            return std::max(res, buf.ndim);\n+        });\n+\n+    shape.clear();\n+    shape.resize((size_t) ndim, 1);\n+\n+    // Figure out the output size, and make sure all input arrays conform (i.e. are either size 1\n+    // or the full size).\n+    for (size_t i = 0; i < N; ++i) {\n+        auto res_iter = shape.rbegin();\n+        auto end = buffers[i].shape.rend();\n+        for (auto shape_iter = buffers[i].shape.rbegin(); shape_iter != end;\n+             ++shape_iter, ++res_iter) {\n+            const auto &dim_size_in = *shape_iter;\n+            auto &dim_size_out = *res_iter;\n+\n+            // Each input dimension can either be 1 or `n`, but `n` values must match across\n+            // buffers\n+            if (dim_size_out == 1) {\n+                dim_size_out = dim_size_in;\n+            } else if (dim_size_in != 1 && dim_size_in != dim_size_out) {\n+                pybind11_fail(\"pybind11::vectorize: incompatible size/dimension of inputs!\");\n+            }\n+        }\n+    }\n+\n+    bool trivial_broadcast_c = true;\n+    bool trivial_broadcast_f = true;\n+    for (size_t i = 0; i < N && (trivial_broadcast_c || trivial_broadcast_f); ++i) {\n+        if (buffers[i].size == 1) {\n+            continue;\n+        }\n+\n+        // Require the same number of dimensions:\n+        if (buffers[i].ndim != ndim) {\n+            return broadcast_trivial::non_trivial;\n+        }\n+\n+        // Require all dimensions be full-size:\n+        if (!std::equal(buffers[i].shape.cbegin(), buffers[i].shape.cend(), shape.cbegin())) {\n+            return broadcast_trivial::non_trivial;\n+        }\n+\n+        // Check for C contiguity (but only if previous inputs were also C contiguous)\n+        if (trivial_broadcast_c) {\n+            ssize_t expect_stride = buffers[i].itemsize;\n+            auto end = buffers[i].shape.crend();\n+            for (auto shape_iter = buffers[i].shape.crbegin(),\n+                      stride_iter = buffers[i].strides.crbegin();\n+                 trivial_broadcast_c && shape_iter != end;\n+                 ++shape_iter, ++stride_iter) {\n+                if (expect_stride == *stride_iter) {\n+                    expect_stride *= *shape_iter;\n+                } else {\n+                    trivial_broadcast_c = false;\n+                }\n+            }\n+        }\n+\n+        // Check for Fortran contiguity (if previous inputs were also F contiguous)\n+        if (trivial_broadcast_f) {\n+            ssize_t expect_stride = buffers[i].itemsize;\n+            auto end = buffers[i].shape.cend();\n+            for (auto shape_iter = buffers[i].shape.cbegin(),\n+                      stride_iter = buffers[i].strides.cbegin();\n+                 trivial_broadcast_f && shape_iter != end;\n+                 ++shape_iter, ++stride_iter) {\n+                if (expect_stride == *stride_iter) {\n+                    expect_stride *= *shape_iter;\n+                } else {\n+                    trivial_broadcast_f = false;\n+                }\n+            }\n+        }\n+    }\n+\n+    return trivial_broadcast_c   ? broadcast_trivial::c_trivial\n+           : trivial_broadcast_f ? broadcast_trivial::f_trivial\n+                                 : broadcast_trivial::non_trivial;\n+}\n+\n+template <typename T>\n+struct vectorize_arg {\n+    static_assert(!std::is_rvalue_reference<T>::value,\n+                  \"Functions with rvalue reference arguments cannot be vectorized\");\n+    // The wrapped function gets called with this type:\n+    using call_type = remove_reference_t<T>;\n+    // Is this a vectorized argument?\n+    static constexpr bool vectorize\n+        = satisfies_any_of<call_type, std::is_arithmetic, is_complex, is_pod>::value\n+          && satisfies_none_of<call_type,\n+                               std::is_pointer,\n+                               std::is_array,\n+                               is_std_array,\n+                               std::is_enum>::value\n+          && (!std::is_reference<T>::value\n+              || (std::is_lvalue_reference<T>::value && std::is_const<call_type>::value));\n+    // Accept this type: an array for vectorized types, otherwise the type as-is:\n+    using type = conditional_t<vectorize, array_t<remove_cv_t<call_type>, array::forcecast>, T>;\n+};\n+\n+// py::vectorize when a return type is present\n+template <typename Func, typename Return, typename... Args>\n+struct vectorize_returned_array {\n+    using Type = array_t<Return>;\n+\n+    static Type create(broadcast_trivial trivial, const std::vector<ssize_t> &shape) {\n+        if (trivial == broadcast_trivial::f_trivial) {\n+            return array_t<Return, array::f_style>(shape);\n+        }\n+        return array_t<Return>(shape);\n+    }\n+\n+    static Return *mutable_data(Type &array) { return array.mutable_data(); }\n+\n+    static Return call(Func &f, Args &...args) { return f(args...); }\n+\n+    static void call(Return *out, size_t i, Func &f, Args &...args) { out[i] = f(args...); }\n+};\n+\n+// py::vectorize when a return type is not present\n+template <typename Func, typename... Args>\n+struct vectorize_returned_array<Func, void, Args...> {\n+    using Type = none;\n+\n+    static Type create(broadcast_trivial, const std::vector<ssize_t> &) { return none(); }\n+\n+    static void *mutable_data(Type &) { return nullptr; }\n+\n+    static detail::void_type call(Func &f, Args &...args) {\n+        f(args...);\n+        return {};\n+    }\n+\n+    static void call(void *, size_t, Func &f, Args &...args) { f(args...); }\n+};\n+\n+template <typename Func, typename Return, typename... Args>\n+struct vectorize_helper {\n+\n+// NVCC for some reason breaks if NVectorized is private\n+#ifdef __CUDACC__\n+public:\n+#else\n+private:\n+#endif\n+\n+    static constexpr size_t N = sizeof...(Args);\n+    static constexpr size_t NVectorized = constexpr_sum(vectorize_arg<Args>::vectorize...);\n+    static_assert(\n+        NVectorized >= 1,\n+        \"pybind11::vectorize(...) requires a function with at least one vectorizable argument\");\n+\n+public:\n+    template <typename T,\n+              // SFINAE to prevent shadowing the copy constructor.\n+              typename = detail::enable_if_t<\n+                  !std::is_same<vectorize_helper, typename std::decay<T>::type>::value>>\n+    explicit vectorize_helper(T &&f) : f(std::forward<T>(f)) {}\n+\n+    object operator()(typename vectorize_arg<Args>::type... args) {\n+        return run(args...,\n+                   make_index_sequence<N>(),\n+                   select_indices<vectorize_arg<Args>::vectorize...>(),\n+                   make_index_sequence<NVectorized>());\n+    }\n+\n+private:\n+    remove_reference_t<Func> f;\n+\n+    // Internal compiler error in MSVC 19.16.27025.1 (Visual Studio 2017 15.9.4), when compiling\n+    // with \"/permissive-\" flag when arg_call_types is manually inlined.\n+    using arg_call_types = std::tuple<typename vectorize_arg<Args>::call_type...>;\n+    template <size_t Index>\n+    using param_n_t = typename std::tuple_element<Index, arg_call_types>::type;\n+\n+    using returned_array = vectorize_returned_array<Func, Return, Args...>;\n+\n+    // Runs a vectorized function given arguments tuple and three index sequences:\n+    //     - Index is the full set of 0 ... (N-1) argument indices;\n+    //     - VIndex is the subset of argument indices with vectorized parameters, letting us access\n+    //       vectorized arguments (anything not in this sequence is passed through)\n+    //     - BIndex is a incremental sequence (beginning at 0) of the same size as VIndex, so that\n+    //       we can store vectorized buffer_infos in an array (argument VIndex has its buffer at\n+    //       index BIndex in the array).\n+    template <size_t... Index, size_t... VIndex, size_t... BIndex>\n+    object run(typename vectorize_arg<Args>::type &...args,\n+               index_sequence<Index...> i_seq,\n+               index_sequence<VIndex...> vi_seq,\n+               index_sequence<BIndex...> bi_seq) {\n+\n+        // Pointers to values the function was called with; the vectorized ones set here will start\n+        // out as array_t<T> pointers, but they will be changed them to T pointers before we make\n+        // call the wrapped function.  Non-vectorized pointers are left as-is.\n+        std::array<void *, N> params{{&args...}};\n+\n+        // The array of `buffer_info`s of vectorized arguments:\n+        std::array<buffer_info, NVectorized> buffers{\n+            {reinterpret_cast<array *>(params[VIndex])->request()...}};\n+\n+        /* Determine dimensions parameters of output array */\n+        ssize_t nd = 0;\n+        std::vector<ssize_t> shape(0);\n+        auto trivial = broadcast(buffers, nd, shape);\n+        auto ndim = (size_t) nd;\n+\n+        size_t size\n+            = std::accumulate(shape.begin(), shape.end(), (size_t) 1, std::multiplies<size_t>());\n+\n+        // If all arguments are 0-dimension arrays (i.e. single values) return a plain value (i.e.\n+        // not wrapped in an array).\n+        if (size == 1 && ndim == 0) {\n+            PYBIND11_EXPAND_SIDE_EFFECTS(params[VIndex] = buffers[BIndex].ptr);\n+            return cast(\n+                returned_array::call(f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...));\n+        }\n+\n+        auto result = returned_array::create(trivial, shape);\n+\n+        if (size == 0) {\n+            return std::move(result);\n+        }\n+\n+        /* Call the function */\n+        auto *mutable_data = returned_array::mutable_data(result);\n+        if (trivial == broadcast_trivial::non_trivial) {\n+            apply_broadcast(buffers, params, mutable_data, size, shape, i_seq, vi_seq, bi_seq);\n+        } else {\n+            apply_trivial(buffers, params, mutable_data, size, i_seq, vi_seq, bi_seq);\n+        }\n+\n+        return std::move(result);\n+    }\n+\n+    template <size_t... Index, size_t... VIndex, size_t... BIndex>\n+    void apply_trivial(std::array<buffer_info, NVectorized> &buffers,\n+                       std::array<void *, N> &params,\n+                       Return *out,\n+                       size_t size,\n+                       index_sequence<Index...>,\n+                       index_sequence<VIndex...>,\n+                       index_sequence<BIndex...>) {\n+\n+        // Initialize an array of mutable byte references and sizes with references set to the\n+        // appropriate pointer in `params`; as we iterate, we'll increment each pointer by its size\n+        // (except for singletons, which get an increment of 0).\n+        std::array<std::pair<unsigned char *&, const size_t>, NVectorized> vecparams{\n+            {std::pair<unsigned char *&, const size_t>(\n+                reinterpret_cast<unsigned char *&>(params[VIndex] = buffers[BIndex].ptr),\n+                buffers[BIndex].size == 1 ? 0 : sizeof(param_n_t<VIndex>))...}};\n+\n+        for (size_t i = 0; i < size; ++i) {\n+            returned_array::call(\n+                out, i, f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...);\n+            for (auto &x : vecparams) {\n+                x.first += x.second;\n+            }\n+        }\n+    }\n+\n+    template <size_t... Index, size_t... VIndex, size_t... BIndex>\n+    void apply_broadcast(std::array<buffer_info, NVectorized> &buffers,\n+                         std::array<void *, N> &params,\n+                         Return *out,\n+                         size_t size,\n+                         const std::vector<ssize_t> &output_shape,\n+                         index_sequence<Index...>,\n+                         index_sequence<VIndex...>,\n+                         index_sequence<BIndex...>) {\n+\n+        multi_array_iterator<NVectorized> input_iter(buffers, output_shape);\n+\n+        for (size_t i = 0; i < size; ++i, ++input_iter) {\n+            PYBIND11_EXPAND_SIDE_EFFECTS((params[VIndex] = input_iter.template data<BIndex>()));\n+            returned_array::call(\n+                out, i, f, *reinterpret_cast<param_n_t<Index> *>(std::get<Index>(params))...);\n+        }\n+    }\n+};\n+\n+template <typename Func, typename Return, typename... Args>\n+vectorize_helper<Func, Return, Args...> vectorize_extractor(const Func &f, Return (*)(Args...)) {\n+    return detail::vectorize_helper<Func, Return, Args...>(f);\n+}\n+\n+template <typename T, int Flags>\n+struct handle_type_name<array_t<T, Flags>> {\n+    static constexpr auto name\n+        = const_name(\"numpy.ndarray[\") + npy_format_descriptor<T>::name + const_name(\"]\");\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+// Vanilla pointer vectorizer:\n+template <typename Return, typename... Args>\n+detail::vectorize_helper<Return (*)(Args...), Return, Args...> vectorize(Return (*f)(Args...)) {\n+    return detail::vectorize_helper<Return (*)(Args...), Return, Args...>(f);\n+}\n+\n+// lambda vectorizer:\n+template <typename Func, detail::enable_if_t<detail::is_lambda<Func>::value, int> = 0>\n+auto vectorize(Func &&f)\n+    -> decltype(detail::vectorize_extractor(std::forward<Func>(f),\n+                                            (detail::function_signature_t<Func> *) nullptr)) {\n+    return detail::vectorize_extractor(std::forward<Func>(f),\n+                                       (detail::function_signature_t<Func> *) nullptr);\n+}\n+\n+// Vectorize a class method (non-const):\n+template <typename Return,\n+          typename Class,\n+          typename... Args,\n+          typename Helper = detail::vectorize_helper<\n+              decltype(std::mem_fn(std::declval<Return (Class::*)(Args...)>())),\n+              Return,\n+              Class *,\n+              Args...>>\n+Helper vectorize(Return (Class::*f)(Args...)) {\n+    return Helper(std::mem_fn(f));\n+}\n+\n+// Vectorize a class method (const):\n+template <typename Return,\n+          typename Class,\n+          typename... Args,\n+          typename Helper = detail::vectorize_helper<\n+              decltype(std::mem_fn(std::declval<Return (Class::*)(Args...) const>())),\n+              Return,\n+              const Class *,\n+              Args...>>\n+Helper vectorize(Return (Class::*f)(Args...) const) {\n+    return Helper(std::mem_fn(f));\n+}\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/operators.h", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "file_content_changes": "@@ -0,0 +1,201 @@\n+/*\n+    pybind11/operator.h: Metatemplates for operator overloading\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/// Enumeration with all supported operator types\n+enum op_id : int {\n+    op_add,\n+    op_sub,\n+    op_mul,\n+    op_div,\n+    op_mod,\n+    op_divmod,\n+    op_pow,\n+    op_lshift,\n+    op_rshift,\n+    op_and,\n+    op_xor,\n+    op_or,\n+    op_neg,\n+    op_pos,\n+    op_abs,\n+    op_invert,\n+    op_int,\n+    op_long,\n+    op_float,\n+    op_str,\n+    op_cmp,\n+    op_gt,\n+    op_ge,\n+    op_lt,\n+    op_le,\n+    op_eq,\n+    op_ne,\n+    op_iadd,\n+    op_isub,\n+    op_imul,\n+    op_idiv,\n+    op_imod,\n+    op_ilshift,\n+    op_irshift,\n+    op_iand,\n+    op_ixor,\n+    op_ior,\n+    op_complex,\n+    op_bool,\n+    op_nonzero,\n+    op_repr,\n+    op_truediv,\n+    op_itruediv,\n+    op_hash\n+};\n+\n+enum op_type : int {\n+    op_l, /* base type on left */\n+    op_r, /* base type on right */\n+    op_u  /* unary operator */\n+};\n+\n+struct self_t {};\n+static const self_t self = self_t();\n+\n+/// Type for an unused type slot\n+struct undefined_t {};\n+\n+/// Don't warn about an unused variable\n+inline self_t __self() { return self; }\n+\n+/// base template of operator implementations\n+template <op_id, op_type, typename B, typename L, typename R>\n+struct op_impl {};\n+\n+/// Operator implementation generator\n+template <op_id id, op_type ot, typename L, typename R>\n+struct op_ {\n+    template <typename Class, typename... Extra>\n+    void execute(Class &cl, const Extra &...extra) const {\n+        using Base = typename Class::type;\n+        using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;\n+        using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;\n+        using op = op_impl<id, ot, Base, L_type, R_type>;\n+        cl.def(op::name(), &op::execute, is_operator(), extra...);\n+    }\n+    template <typename Class, typename... Extra>\n+    void execute_cast(Class &cl, const Extra &...extra) const {\n+        using Base = typename Class::type;\n+        using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;\n+        using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;\n+        using op = op_impl<id, ot, Base, L_type, R_type>;\n+        cl.def(op::name(), &op::execute_cast, is_operator(), extra...);\n+    }\n+};\n+\n+#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                               \\\n+    template <typename B, typename L, typename R>                                                 \\\n+    struct op_impl<op_##id, op_l, B, L, R> {                                                      \\\n+        static char const *name() { return \"__\" #id \"__\"; }                                       \\\n+        static auto execute(const L &l, const R &r) -> decltype(expr) { return (expr); }          \\\n+        static B execute_cast(const L &l, const R &r) { return B(expr); }                         \\\n+    };                                                                                            \\\n+    template <typename B, typename L, typename R>                                                 \\\n+    struct op_impl<op_##id, op_r, B, L, R> {                                                      \\\n+        static char const *name() { return \"__\" #rid \"__\"; }                                      \\\n+        static auto execute(const R &r, const L &l) -> decltype(expr) { return (expr); }          \\\n+        static B execute_cast(const R &r, const L &l) { return B(expr); }                         \\\n+    };                                                                                            \\\n+    inline op_<op_##id, op_l, self_t, self_t> op(const self_t &, const self_t &) {                \\\n+        return op_<op_##id, op_l, self_t, self_t>();                                              \\\n+    }                                                                                             \\\n+    template <typename T>                                                                         \\\n+    op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                                 \\\n+        return op_<op_##id, op_l, self_t, T>();                                                   \\\n+    }                                                                                             \\\n+    template <typename T>                                                                         \\\n+    op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {                                 \\\n+        return op_<op_##id, op_r, T, self_t>();                                                   \\\n+    }\n+\n+#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                                   \\\n+    template <typename B, typename L, typename R>                                                 \\\n+    struct op_impl<op_##id, op_l, B, L, R> {                                                      \\\n+        static char const *name() { return \"__\" #id \"__\"; }                                       \\\n+        static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }                  \\\n+        static B execute_cast(L &l, const R &r) { return B(expr); }                               \\\n+    };                                                                                            \\\n+    template <typename T>                                                                         \\\n+    op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                                 \\\n+        return op_<op_##id, op_l, self_t, T>();                                                   \\\n+    }\n+\n+#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                                     \\\n+    template <typename B, typename L>                                                             \\\n+    struct op_impl<op_##id, op_u, B, L, undefined_t> {                                            \\\n+        static char const *name() { return \"__\" #id \"__\"; }                                       \\\n+        static auto execute(const L &l) -> decltype(expr) { return expr; }                        \\\n+        static B execute_cast(const L &l) { return B(expr); }                                     \\\n+    };                                                                                            \\\n+    inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {                           \\\n+        return op_<op_##id, op_u, self_t, undefined_t>();                                         \\\n+    }\n+\n+PYBIND11_BINARY_OPERATOR(sub, rsub, operator-, l - r)\n+PYBIND11_BINARY_OPERATOR(add, radd, operator+, l + r)\n+PYBIND11_BINARY_OPERATOR(mul, rmul, operator*, l *r)\n+PYBIND11_BINARY_OPERATOR(truediv, rtruediv, operator/, l / r)\n+PYBIND11_BINARY_OPERATOR(mod, rmod, operator%, l % r)\n+PYBIND11_BINARY_OPERATOR(lshift, rlshift, operator<<, l << r)\n+PYBIND11_BINARY_OPERATOR(rshift, rrshift, operator>>, l >> r)\n+PYBIND11_BINARY_OPERATOR(and, rand, operator&, l &r)\n+PYBIND11_BINARY_OPERATOR(xor, rxor, operator^, l ^ r)\n+PYBIND11_BINARY_OPERATOR(eq, eq, operator==, l == r)\n+PYBIND11_BINARY_OPERATOR(ne, ne, operator!=, l != r)\n+PYBIND11_BINARY_OPERATOR(or, ror, operator|, l | r)\n+PYBIND11_BINARY_OPERATOR(gt, lt, operator>, l > r)\n+PYBIND11_BINARY_OPERATOR(ge, le, operator>=, l >= r)\n+PYBIND11_BINARY_OPERATOR(lt, gt, operator<, l < r)\n+PYBIND11_BINARY_OPERATOR(le, ge, operator<=, l <= r)\n+// PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,  r))\n+PYBIND11_INPLACE_OPERATOR(iadd, operator+=, l += r)\n+PYBIND11_INPLACE_OPERATOR(isub, operator-=, l -= r)\n+PYBIND11_INPLACE_OPERATOR(imul, operator*=, l *= r)\n+PYBIND11_INPLACE_OPERATOR(itruediv, operator/=, l /= r)\n+PYBIND11_INPLACE_OPERATOR(imod, operator%=, l %= r)\n+PYBIND11_INPLACE_OPERATOR(ilshift, operator<<=, l <<= r)\n+PYBIND11_INPLACE_OPERATOR(irshift, operator>>=, l >>= r)\n+PYBIND11_INPLACE_OPERATOR(iand, operator&=, l &= r)\n+PYBIND11_INPLACE_OPERATOR(ixor, operator^=, l ^= r)\n+PYBIND11_INPLACE_OPERATOR(ior, operator|=, l |= r)\n+PYBIND11_UNARY_OPERATOR(neg, operator-, -l)\n+PYBIND11_UNARY_OPERATOR(pos, operator+, +l)\n+// WARNING: This usage of `abs` should only be done for existing STL overloads.\n+// Adding overloads directly in to the `std::` namespace is advised against:\n+// https://en.cppreference.com/w/cpp/language/extending_std\n+PYBIND11_UNARY_OPERATOR(abs, abs, std::abs(l))\n+PYBIND11_UNARY_OPERATOR(hash, hash, std::hash<L>()(l))\n+PYBIND11_UNARY_OPERATOR(invert, operator~, (~l))\n+PYBIND11_UNARY_OPERATOR(bool, operator!, !!l)\n+PYBIND11_UNARY_OPERATOR(int, int_, (int) l)\n+PYBIND11_UNARY_OPERATOR(float, float_, (double) l)\n+\n+#undef PYBIND11_BINARY_OPERATOR\n+#undef PYBIND11_INPLACE_OPERATOR\n+#undef PYBIND11_UNARY_OPERATOR\n+PYBIND11_NAMESPACE_END(detail)\n+\n+using detail::self;\n+// Add named operators so that they are accessible via `py::`.\n+using detail::hash;\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/options.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "file_content_changes": "@@ -0,0 +1,76 @@\n+/*\n+    pybind11/options.h: global settings that are configurable at runtime.\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+class options {\n+public:\n+    // Default RAII constructor, which leaves settings as they currently are.\n+    options() : previous_state(global_state()) {}\n+\n+    // Class is non-copyable.\n+    options(const options &) = delete;\n+    options &operator=(const options &) = delete;\n+\n+    // Destructor, which restores settings that were in effect before.\n+    ~options() { global_state() = previous_state; }\n+\n+    // Setter methods (affect the global state):\n+\n+    options &disable_user_defined_docstrings() & {\n+        global_state().show_user_defined_docstrings = false;\n+        return *this;\n+    }\n+\n+    options &enable_user_defined_docstrings() & {\n+        global_state().show_user_defined_docstrings = true;\n+        return *this;\n+    }\n+\n+    options &disable_function_signatures() & {\n+        global_state().show_function_signatures = false;\n+        return *this;\n+    }\n+\n+    options &enable_function_signatures() & {\n+        global_state().show_function_signatures = true;\n+        return *this;\n+    }\n+\n+    // Getter methods (return the global state):\n+\n+    static bool show_user_defined_docstrings() {\n+        return global_state().show_user_defined_docstrings;\n+    }\n+\n+    static bool show_function_signatures() { return global_state().show_function_signatures; }\n+\n+    // This type is not meant to be allocated on the heap.\n+    void *operator new(size_t) = delete;\n+\n+private:\n+    struct state {\n+        bool show_user_defined_docstrings = true; //< Include user-supplied texts in docstrings.\n+        bool show_function_signatures = true;     //< Include auto-generated function signatures\n+                                                  //  in docstrings.\n+    };\n+\n+    static state &global_state() {\n+        static state instance;\n+        return instance;\n+    }\n+\n+    state previous_state;\n+};\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/pybind11.h", "status": "added", "additions": 2864, "deletions": 0, "changes": 2864, "file_content_changes": "N/A"}, {"filename": "python/src/pybind11/pytypes.h", "status": "added", "additions": 2392, "deletions": 0, "changes": 2392, "file_content_changes": "@@ -0,0 +1,2392 @@\n+/*\n+    pybind11/pytypes.h: Convenience wrapper classes for basic Python types\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+#include \"buffer_info.h\"\n+\n+#include <assert.h>\n+#include <cstddef>\n+#include <exception>\n+#include <frameobject.h>\n+#include <iterator>\n+#include <memory>\n+#include <string>\n+#include <type_traits>\n+#include <typeinfo>\n+#include <utility>\n+\n+#if defined(PYBIND11_HAS_OPTIONAL)\n+#    include <optional>\n+#endif\n+\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+#    include <string_view>\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+/* A few forward declarations */\n+class handle;\n+class object;\n+class str;\n+class iterator;\n+class type;\n+struct arg;\n+struct arg_v;\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+class args_proxy;\n+bool isinstance_generic(handle obj, const std::type_info &tp);\n+\n+// Accessor forward declarations\n+template <typename Policy>\n+class accessor;\n+namespace accessor_policies {\n+struct obj_attr;\n+struct str_attr;\n+struct generic_item;\n+struct sequence_item;\n+struct list_item;\n+struct tuple_item;\n+} // namespace accessor_policies\n+using obj_attr_accessor = accessor<accessor_policies::obj_attr>;\n+using str_attr_accessor = accessor<accessor_policies::str_attr>;\n+using item_accessor = accessor<accessor_policies::generic_item>;\n+using sequence_accessor = accessor<accessor_policies::sequence_item>;\n+using list_accessor = accessor<accessor_policies::list_item>;\n+using tuple_accessor = accessor<accessor_policies::tuple_item>;\n+\n+/// Tag and check to identify a class which implements the Python object API\n+class pyobject_tag {};\n+template <typename T>\n+using is_pyobject = std::is_base_of<pyobject_tag, remove_reference_t<T>>;\n+\n+/** \\rst\n+    A mixin class which adds common functions to `handle`, `object` and various accessors.\n+    The only requirement for `Derived` is to implement ``PyObject *Derived::ptr() const``.\n+\\endrst */\n+template <typename Derived>\n+class object_api : public pyobject_tag {\n+    const Derived &derived() const { return static_cast<const Derived &>(*this); }\n+\n+public:\n+    /** \\rst\n+        Return an iterator equivalent to calling ``iter()`` in Python. The object\n+        must be a collection which supports the iteration protocol.\n+    \\endrst */\n+    iterator begin() const;\n+    /// Return a sentinel which ends iteration.\n+    iterator end() const;\n+\n+    /** \\rst\n+        Return an internal functor to invoke the object's sequence protocol. Casting\n+        the returned ``detail::item_accessor`` instance to a `handle` or `object`\n+        subclass causes a corresponding call to ``__getitem__``. Assigning a `handle`\n+        or `object` subclass causes a call to ``__setitem__``.\n+    \\endrst */\n+    item_accessor operator[](handle key) const;\n+    /// See above (the only difference is that the key's reference is stolen)\n+    item_accessor operator[](object &&key) const;\n+    /// See above (the only difference is that the key is provided as a string literal)\n+    item_accessor operator[](const char *key) const;\n+\n+    /** \\rst\n+        Return an internal functor to access the object's attributes. Casting the\n+        returned ``detail::obj_attr_accessor`` instance to a `handle` or `object`\n+        subclass causes a corresponding call to ``getattr``. Assigning a `handle`\n+        or `object` subclass causes a call to ``setattr``.\n+    \\endrst */\n+    obj_attr_accessor attr(handle key) const;\n+    /// See above (the only difference is that the key's reference is stolen)\n+    obj_attr_accessor attr(object &&key) const;\n+    /// See above (the only difference is that the key is provided as a string literal)\n+    str_attr_accessor attr(const char *key) const;\n+\n+    /** \\rst\n+        Matches * unpacking in Python, e.g. to unpack arguments out of a ``tuple``\n+        or ``list`` for a function call. Applying another * to the result yields\n+        ** unpacking, e.g. to unpack a dict as function keyword arguments.\n+        See :ref:`calling_python_functions`.\n+    \\endrst */\n+    args_proxy operator*() const;\n+\n+    /// Check if the given item is contained within this object, i.e. ``item in obj``.\n+    template <typename T>\n+    bool contains(T &&item) const;\n+\n+    /** \\rst\n+        Assuming the Python object is a function or implements the ``__call__``\n+        protocol, ``operator()`` invokes the underlying function, passing an\n+        arbitrary set of parameters. The result is returned as a `object` and\n+        may need to be converted back into a Python object using `handle::cast()`.\n+\n+        When some of the arguments cannot be converted to Python objects, the\n+        function will throw a `cast_error` exception. When the Python function\n+        call fails, a `error_already_set` exception is thrown.\n+    \\endrst */\n+    template <return_value_policy policy = return_value_policy::automatic_reference,\n+              typename... Args>\n+    object operator()(Args &&...args) const;\n+    template <return_value_policy policy = return_value_policy::automatic_reference,\n+              typename... Args>\n+    PYBIND11_DEPRECATED(\"call(...) was deprecated in favor of operator()(...)\")\n+    object call(Args &&...args) const;\n+\n+    /// Equivalent to ``obj is other`` in Python.\n+    bool is(object_api const &other) const { return derived().ptr() == other.derived().ptr(); }\n+    /// Equivalent to ``obj is None`` in Python.\n+    bool is_none() const { return derived().ptr() == Py_None; }\n+    /// Equivalent to obj == other in Python\n+    bool equal(object_api const &other) const { return rich_compare(other, Py_EQ); }\n+    bool not_equal(object_api const &other) const { return rich_compare(other, Py_NE); }\n+    bool operator<(object_api const &other) const { return rich_compare(other, Py_LT); }\n+    bool operator<=(object_api const &other) const { return rich_compare(other, Py_LE); }\n+    bool operator>(object_api const &other) const { return rich_compare(other, Py_GT); }\n+    bool operator>=(object_api const &other) const { return rich_compare(other, Py_GE); }\n+\n+    object operator-() const;\n+    object operator~() const;\n+    object operator+(object_api const &other) const;\n+    object operator+=(object_api const &other) const;\n+    object operator-(object_api const &other) const;\n+    object operator-=(object_api const &other) const;\n+    object operator*(object_api const &other) const;\n+    object operator*=(object_api const &other) const;\n+    object operator/(object_api const &other) const;\n+    object operator/=(object_api const &other) const;\n+    object operator|(object_api const &other) const;\n+    object operator|=(object_api const &other) const;\n+    object operator&(object_api const &other) const;\n+    object operator&=(object_api const &other) const;\n+    object operator^(object_api const &other) const;\n+    object operator^=(object_api const &other) const;\n+    object operator<<(object_api const &other) const;\n+    object operator<<=(object_api const &other) const;\n+    object operator>>(object_api const &other) const;\n+    object operator>>=(object_api const &other) const;\n+\n+    PYBIND11_DEPRECATED(\"Use py::str(obj) instead\")\n+    pybind11::str str() const;\n+\n+    /// Get or set the object's docstring, i.e. ``obj.__doc__``.\n+    str_attr_accessor doc() const;\n+\n+    /// Return the object's current reference count\n+    int ref_count() const { return static_cast<int>(Py_REFCNT(derived().ptr())); }\n+\n+    // TODO PYBIND11_DEPRECATED(\n+    //     \"Call py::type::handle_of(h) or py::type::of(h) instead of h.get_type()\")\n+    handle get_type() const;\n+\n+private:\n+    bool rich_compare(object_api const &other, int value) const;\n+};\n+\n+template <typename T>\n+using is_pyobj_ptr_or_nullptr_t = detail::any_of<std::is_same<T, PyObject *>,\n+                                                 std::is_same<T, PyObject *const>,\n+                                                 std::is_same<T, std::nullptr_t>>;\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+#if !defined(PYBIND11_HANDLE_REF_DEBUG) && !defined(NDEBUG)\n+#    define PYBIND11_HANDLE_REF_DEBUG\n+#endif\n+\n+/** \\rst\n+    Holds a reference to a Python object (no reference counting)\n+\n+    The `handle` class is a thin wrapper around an arbitrary Python object (i.e. a\n+    ``PyObject *`` in Python's C API). It does not perform any automatic reference\n+    counting and merely provides a basic C++ interface to various Python API functions.\n+\n+    .. seealso::\n+        The `object` class inherits from `handle` and adds automatic reference\n+        counting features.\n+\\endrst */\n+class handle : public detail::object_api<handle> {\n+public:\n+    /// The default constructor creates a handle with a ``nullptr``-valued pointer\n+    handle() = default;\n+\n+    /// Enable implicit conversion from ``PyObject *`` and ``nullptr``.\n+    /// Not using ``handle(PyObject *ptr)`` to avoid implicit conversion from ``0``.\n+    template <typename T,\n+              detail::enable_if_t<detail::is_pyobj_ptr_or_nullptr_t<T>::value, int> = 0>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    handle(T ptr) : m_ptr(ptr) {}\n+\n+    /// Enable implicit conversion through ``T::operator PyObject *()``.\n+    template <\n+        typename T,\n+        detail::enable_if_t<detail::all_of<detail::none_of<std::is_base_of<handle, T>,\n+                                                           detail::is_pyobj_ptr_or_nullptr_t<T>>,\n+                                           std::is_convertible<T, PyObject *>>::value,\n+                            int> = 0>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    handle(T &obj) : m_ptr(obj) {}\n+\n+    /// Return the underlying ``PyObject *`` pointer\n+    PyObject *ptr() const { return m_ptr; }\n+    PyObject *&ptr() { return m_ptr; }\n+\n+    /** \\rst\n+        Manually increase the reference count of the Python object. Usually, it is\n+        preferable to use the `object` class which derives from `handle` and calls\n+        this function automatically. Returns a reference to itself.\n+    \\endrst */\n+    const handle &inc_ref() const & {\n+#ifdef PYBIND11_HANDLE_REF_DEBUG\n+        inc_ref_counter(1);\n+#endif\n+        Py_XINCREF(m_ptr);\n+        return *this;\n+    }\n+\n+    /** \\rst\n+        Manually decrease the reference count of the Python object. Usually, it is\n+        preferable to use the `object` class which derives from `handle` and calls\n+        this function automatically. Returns a reference to itself.\n+    \\endrst */\n+    const handle &dec_ref() const & {\n+        Py_XDECREF(m_ptr);\n+        return *this;\n+    }\n+\n+    /** \\rst\n+        Attempt to cast the Python object into the given C++ type. A `cast_error`\n+        will be throw upon failure.\n+    \\endrst */\n+    template <typename T>\n+    T cast() const;\n+    /// Return ``true`` when the `handle` wraps a valid Python object\n+    explicit operator bool() const { return m_ptr != nullptr; }\n+    /** \\rst\n+        Deprecated: Check that the underlying pointers are the same.\n+        Equivalent to ``obj1 is obj2`` in Python.\n+    \\endrst */\n+    PYBIND11_DEPRECATED(\"Use obj1.is(obj2) instead\")\n+    bool operator==(const handle &h) const { return m_ptr == h.m_ptr; }\n+    PYBIND11_DEPRECATED(\"Use !obj1.is(obj2) instead\")\n+    bool operator!=(const handle &h) const { return m_ptr != h.m_ptr; }\n+    PYBIND11_DEPRECATED(\"Use handle::operator bool() instead\")\n+    bool check() const { return m_ptr != nullptr; }\n+\n+protected:\n+    PyObject *m_ptr = nullptr;\n+\n+#ifdef PYBIND11_HANDLE_REF_DEBUG\n+private:\n+    static std::size_t inc_ref_counter(std::size_t add) {\n+        thread_local std::size_t counter = 0;\n+        counter += add;\n+        return counter;\n+    }\n+\n+public:\n+    static std::size_t inc_ref_counter() { return inc_ref_counter(0); }\n+#endif\n+};\n+\n+/** \\rst\n+    Holds a reference to a Python object (with reference counting)\n+\n+    Like `handle`, the `object` class is a thin wrapper around an arbitrary Python\n+    object (i.e. a ``PyObject *`` in Python's C API). In contrast to `handle`, it\n+    optionally increases the object's reference count upon construction, and it\n+    *always* decreases the reference count when the `object` instance goes out of\n+    scope and is destructed. When using `object` instances consistently, it is much\n+    easier to get reference counting right at the first attempt.\n+\\endrst */\n+class object : public handle {\n+public:\n+    object() = default;\n+    PYBIND11_DEPRECATED(\"Use reinterpret_borrow<object>() or reinterpret_steal<object>()\")\n+    object(handle h, bool is_borrowed) : handle(h) {\n+        if (is_borrowed) {\n+            inc_ref();\n+        }\n+    }\n+    /// Copy constructor; always increases the reference count\n+    object(const object &o) : handle(o) { inc_ref(); }\n+    /// Move constructor; steals the object from ``other`` and preserves its reference count\n+    object(object &&other) noexcept : handle(other) { other.m_ptr = nullptr; }\n+    /// Destructor; automatically calls `handle::dec_ref()`\n+    ~object() { dec_ref(); }\n+\n+    /** \\rst\n+        Resets the internal pointer to ``nullptr`` without decreasing the\n+        object's reference count. The function returns a raw handle to the original\n+        Python object.\n+    \\endrst */\n+    handle release() {\n+        PyObject *tmp = m_ptr;\n+        m_ptr = nullptr;\n+        return handle(tmp);\n+    }\n+\n+    object &operator=(const object &other) {\n+        other.inc_ref();\n+        // Use temporary variable to ensure `*this` remains valid while\n+        // `Py_XDECREF` executes, in case `*this` is accessible from Python.\n+        handle temp(m_ptr);\n+        m_ptr = other.m_ptr;\n+        temp.dec_ref();\n+        return *this;\n+    }\n+\n+    object &operator=(object &&other) noexcept {\n+        if (this != &other) {\n+            handle temp(m_ptr);\n+            m_ptr = other.m_ptr;\n+            other.m_ptr = nullptr;\n+            temp.dec_ref();\n+        }\n+        return *this;\n+    }\n+\n+    // Calling cast() on an object lvalue just copies (via handle::cast)\n+    template <typename T>\n+    T cast() const &;\n+    // Calling on an object rvalue does a move, if needed and/or possible\n+    template <typename T>\n+    T cast() &&;\n+\n+protected:\n+    // Tags for choosing constructors from raw PyObject *\n+    struct borrowed_t {};\n+    struct stolen_t {};\n+\n+    /// @cond BROKEN\n+    template <typename T>\n+    friend T reinterpret_borrow(handle);\n+    template <typename T>\n+    friend T reinterpret_steal(handle);\n+    /// @endcond\n+\n+public:\n+    // Only accessible from derived classes and the reinterpret_* functions\n+    object(handle h, borrowed_t) : handle(h) { inc_ref(); }\n+    object(handle h, stolen_t) : handle(h) {}\n+};\n+\n+/** \\rst\n+    Declare that a `handle` or ``PyObject *`` is a certain type and borrow the reference.\n+    The target type ``T`` must be `object` or one of its derived classes. The function\n+    doesn't do any conversions or checks. It's up to the user to make sure that the\n+    target type is correct.\n+\n+    .. code-block:: cpp\n+\n+        PyObject *p = PyList_GetItem(obj, index);\n+        py::object o = reinterpret_borrow<py::object>(p);\n+        // or\n+        py::tuple t = reinterpret_borrow<py::tuple>(p); // <-- `p` must be already be a `tuple`\n+\\endrst */\n+template <typename T>\n+T reinterpret_borrow(handle h) {\n+    return {h, object::borrowed_t{}};\n+}\n+\n+/** \\rst\n+    Like `reinterpret_borrow`, but steals the reference.\n+\n+     .. code-block:: cpp\n+\n+        PyObject *p = PyObject_Str(obj);\n+        py::str s = reinterpret_steal<py::str>(p); // <-- `p` must be already be a `str`\n+\\endrst */\n+template <typename T>\n+T reinterpret_steal(handle h) {\n+    return {h, object::stolen_t{}};\n+}\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+// Equivalent to obj.__class__.__name__ (or obj.__name__ if obj is a class).\n+inline const char *obj_class_name(PyObject *obj) {\n+    if (Py_TYPE(obj) == &PyType_Type) {\n+        return reinterpret_cast<PyTypeObject *>(obj)->tp_name;\n+    }\n+    return Py_TYPE(obj)->tp_name;\n+}\n+\n+std::string error_string();\n+\n+struct error_fetch_and_normalize {\n+    // Immediate normalization is long-established behavior (starting with\n+    // https://github.com/pybind/pybind11/commit/135ba8deafb8bf64a15b24d1513899eb600e2011\n+    // from Sep 2016) and safest. Normalization could be deferred, but this could mask\n+    // errors elsewhere, the performance gain is very minor in typical situations\n+    // (usually the dominant bottleneck is EH unwinding), and the implementation here\n+    // would be more complex.\n+    explicit error_fetch_and_normalize(const char *called) {\n+        PyErr_Fetch(&m_type.ptr(), &m_value.ptr(), &m_trace.ptr());\n+        if (!m_type) {\n+            pybind11_fail(\"Internal error: \" + std::string(called)\n+                          + \" called while \"\n+                            \"Python error indicator not set.\");\n+        }\n+        const char *exc_type_name_orig = detail::obj_class_name(m_type.ptr());\n+        if (exc_type_name_orig == nullptr) {\n+            pybind11_fail(\"Internal error: \" + std::string(called)\n+                          + \" failed to obtain the name \"\n+                            \"of the original active exception type.\");\n+        }\n+        m_lazy_error_string = exc_type_name_orig;\n+        // PyErr_NormalizeException() may change the exception type if there are cascading\n+        // failures. This can potentially be extremely confusing.\n+        PyErr_NormalizeException(&m_type.ptr(), &m_value.ptr(), &m_trace.ptr());\n+        if (m_type.ptr() == nullptr) {\n+            pybind11_fail(\"Internal error: \" + std::string(called)\n+                          + \" failed to normalize the \"\n+                            \"active exception.\");\n+        }\n+        const char *exc_type_name_norm = detail::obj_class_name(m_type.ptr());\n+        if (exc_type_name_orig == nullptr) {\n+            pybind11_fail(\"Internal error: \" + std::string(called)\n+                          + \" failed to obtain the name \"\n+                            \"of the normalized active exception type.\");\n+        }\n+        if (exc_type_name_norm != m_lazy_error_string) {\n+            std::string msg = std::string(called)\n+                              + \": MISMATCH of original and normalized \"\n+                                \"active exception types: \";\n+            msg += \"ORIGINAL \";\n+            msg += m_lazy_error_string;\n+            msg += \" REPLACED BY \";\n+            msg += exc_type_name_norm;\n+            msg += \": \" + format_value_and_trace();\n+            pybind11_fail(msg);\n+        }\n+    }\n+\n+    error_fetch_and_normalize(const error_fetch_and_normalize &) = delete;\n+    error_fetch_and_normalize(error_fetch_and_normalize &&) = delete;\n+\n+    std::string format_value_and_trace() const {\n+        std::string result;\n+        std::string message_error_string;\n+        if (m_value) {\n+            auto value_str = reinterpret_steal<object>(PyObject_Str(m_value.ptr()));\n+            if (!value_str) {\n+                message_error_string = detail::error_string();\n+                result = \"<MESSAGE UNAVAILABLE DUE TO ANOTHER EXCEPTION>\";\n+            } else {\n+                result = value_str.cast<std::string>();\n+            }\n+        } else {\n+            result = \"<MESSAGE UNAVAILABLE>\";\n+        }\n+        if (result.empty()) {\n+            result = \"<EMPTY MESSAGE>\";\n+        }\n+\n+        bool have_trace = false;\n+        if (m_trace) {\n+#if !defined(PYPY_VERSION)\n+            auto *tb = reinterpret_cast<PyTracebackObject *>(m_trace.ptr());\n+\n+            // Get the deepest trace possible.\n+            while (tb->tb_next) {\n+                tb = tb->tb_next;\n+            }\n+\n+            PyFrameObject *frame = tb->tb_frame;\n+            Py_XINCREF(frame);\n+            result += \"\\n\\nAt:\\n\";\n+            while (frame) {\n+#    if PY_VERSION_HEX >= 0x030900B1\n+                PyCodeObject *f_code = PyFrame_GetCode(frame);\n+#    else\n+                PyCodeObject *f_code = frame->f_code;\n+                Py_INCREF(f_code);\n+#    endif\n+                int lineno = PyFrame_GetLineNumber(frame);\n+                result += \"  \";\n+                result += handle(f_code->co_filename).cast<std::string>();\n+                result += '(';\n+                result += std::to_string(lineno);\n+                result += \"): \";\n+                result += handle(f_code->co_name).cast<std::string>();\n+                result += '\\n';\n+                Py_DECREF(f_code);\n+#    if PY_VERSION_HEX >= 0x030900B1\n+                auto *b_frame = PyFrame_GetBack(frame);\n+#    else\n+                auto *b_frame = frame->f_back;\n+                Py_XINCREF(b_frame);\n+#    endif\n+                Py_DECREF(frame);\n+                frame = b_frame;\n+            }\n+\n+            have_trace = true;\n+#endif //! defined(PYPY_VERSION)\n+        }\n+\n+        if (!message_error_string.empty()) {\n+            if (!have_trace) {\n+                result += '\\n';\n+            }\n+            result += \"\\nMESSAGE UNAVAILABLE DUE TO EXCEPTION: \" + message_error_string;\n+        }\n+\n+        return result;\n+    }\n+\n+    std::string const &error_string() const {\n+        if (!m_lazy_error_string_completed) {\n+            m_lazy_error_string += \": \" + format_value_and_trace();\n+            m_lazy_error_string_completed = true;\n+        }\n+        return m_lazy_error_string;\n+    }\n+\n+    void restore() {\n+        if (m_restore_called) {\n+            pybind11_fail(\"Internal error: pybind11::detail::error_fetch_and_normalize::restore() \"\n+                          \"called a second time. ORIGINAL ERROR: \"\n+                          + error_string());\n+        }\n+        PyErr_Restore(m_type.inc_ref().ptr(), m_value.inc_ref().ptr(), m_trace.inc_ref().ptr());\n+        m_restore_called = true;\n+    }\n+\n+    bool matches(handle exc) const {\n+        return (PyErr_GivenExceptionMatches(m_type.ptr(), exc.ptr()) != 0);\n+    }\n+\n+    // Not protecting these for simplicity.\n+    object m_type, m_value, m_trace;\n+\n+private:\n+    // Only protecting invariants.\n+    mutable std::string m_lazy_error_string;\n+    mutable bool m_lazy_error_string_completed = false;\n+    mutable bool m_restore_called = false;\n+};\n+\n+inline std::string error_string() {\n+    return error_fetch_and_normalize(\"pybind11::detail::error_string\").error_string();\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+#if defined(_MSC_VER)\n+#    pragma warning(push)\n+#    pragma warning(disable : 4275 4251)\n+//     warning C4275: An exported class was derived from a class that wasn't exported.\n+//     Can be ignored when derived from a STL class.\n+#endif\n+/// Fetch and hold an error which was already set in Python.  An instance of this is typically\n+/// thrown to propagate python-side errors back through C++ which can either be caught manually or\n+/// else falls back to the function dispatcher (which then raises the captured error back to\n+/// python).\n+class PYBIND11_EXPORT_EXCEPTION error_already_set : public std::exception {\n+public:\n+    /// Fetches the current Python exception (using PyErr_Fetch()), which will clear the\n+    /// current Python error indicator.\n+    error_already_set()\n+        : m_fetched_error{new detail::error_fetch_and_normalize(\"pybind11::error_already_set\"),\n+                          m_fetched_error_deleter} {}\n+\n+    /// The what() result is built lazily on demand.\n+    /// WARNING: This member function needs to acquire the Python GIL. This can lead to\n+    ///          crashes (undefined behavior) if the Python interpreter is finalizing.\n+    const char *what() const noexcept override;\n+\n+    /// Restores the currently-held Python error (which will clear the Python error indicator first\n+    /// if already set).\n+    /// NOTE: This member function will always restore the normalized exception, which may or may\n+    ///       not be the original Python exception.\n+    /// WARNING: The GIL must be held when this member function is called!\n+    void restore() { m_fetched_error->restore(); }\n+\n+    /// If it is impossible to raise the currently-held error, such as in a destructor, we can\n+    /// write it out using Python's unraisable hook (`sys.unraisablehook`). The error context\n+    /// should be some object whose `repr()` helps identify the location of the error. Python\n+    /// already knows the type and value of the error, so there is no need to repeat that.\n+    void discard_as_unraisable(object err_context) {\n+        restore();\n+        PyErr_WriteUnraisable(err_context.ptr());\n+    }\n+    /// An alternate version of `discard_as_unraisable()`, where a string provides information on\n+    /// the location of the error. For example, `__func__` could be helpful.\n+    /// WARNING: The GIL must be held when this member function is called!\n+    void discard_as_unraisable(const char *err_context) {\n+        discard_as_unraisable(reinterpret_steal<object>(PYBIND11_FROM_STRING(err_context)));\n+    }\n+\n+    // Does nothing; provided for backwards compatibility.\n+    PYBIND11_DEPRECATED(\"Use of error_already_set.clear() is deprecated\")\n+    void clear() {}\n+\n+    /// Check if the currently trapped error type matches the given Python exception class (or a\n+    /// subclass thereof).  May also be passed a tuple to search for any exception class matches in\n+    /// the given tuple.\n+    bool matches(handle exc) const { return m_fetched_error->matches(exc); }\n+\n+    const object &type() const { return m_fetched_error->m_type; }\n+    const object &value() const { return m_fetched_error->m_value; }\n+    const object &trace() const { return m_fetched_error->m_trace; }\n+\n+private:\n+    std::shared_ptr<detail::error_fetch_and_normalize> m_fetched_error;\n+\n+    /// WARNING: This custom deleter needs to acquire the Python GIL. This can lead to\n+    ///          crashes (undefined behavior) if the Python interpreter is finalizing.\n+    static void m_fetched_error_deleter(detail::error_fetch_and_normalize *raw_ptr);\n+};\n+#if defined(_MSC_VER)\n+#    pragma warning(pop)\n+#endif\n+\n+/// Replaces the current Python error indicator with the chosen error, performing a\n+/// 'raise from' to indicate that the chosen error was caused by the original error.\n+inline void raise_from(PyObject *type, const char *message) {\n+    // Based on _PyErr_FormatVFromCause:\n+    // https://github.com/python/cpython/blob/467ab194fc6189d9f7310c89937c51abeac56839/Python/errors.c#L405\n+    // See https://github.com/pybind/pybind11/pull/2112 for details.\n+    PyObject *exc = nullptr, *val = nullptr, *val2 = nullptr, *tb = nullptr;\n+\n+    assert(PyErr_Occurred());\n+    PyErr_Fetch(&exc, &val, &tb);\n+    PyErr_NormalizeException(&exc, &val, &tb);\n+    if (tb != nullptr) {\n+        PyException_SetTraceback(val, tb);\n+        Py_DECREF(tb);\n+    }\n+    Py_DECREF(exc);\n+    assert(!PyErr_Occurred());\n+\n+    PyErr_SetString(type, message);\n+\n+    PyErr_Fetch(&exc, &val2, &tb);\n+    PyErr_NormalizeException(&exc, &val2, &tb);\n+    Py_INCREF(val);\n+    PyException_SetCause(val2, val);\n+    PyException_SetContext(val2, val);\n+    PyErr_Restore(exc, val2, tb);\n+}\n+\n+/// Sets the current Python error indicator with the chosen error, performing a 'raise from'\n+/// from the error contained in error_already_set to indicate that the chosen error was\n+/// caused by the original error.\n+inline void raise_from(error_already_set &err, PyObject *type, const char *message) {\n+    err.restore();\n+    raise_from(type, message);\n+}\n+\n+/** \\defgroup python_builtins const_name\n+    Unless stated otherwise, the following C++ functions behave the same\n+    as their Python counterparts.\n+ */\n+\n+/** \\ingroup python_builtins\n+    \\rst\n+    Return true if ``obj`` is an instance of ``T``. Type ``T`` must be a subclass of\n+    `object` or a class which was exposed to Python as ``py::class_<T>``.\n+\\endrst */\n+template <typename T, detail::enable_if_t<std::is_base_of<object, T>::value, int> = 0>\n+bool isinstance(handle obj) {\n+    return T::check_(obj);\n+}\n+\n+template <typename T, detail::enable_if_t<!std::is_base_of<object, T>::value, int> = 0>\n+bool isinstance(handle obj) {\n+    return detail::isinstance_generic(obj, typeid(T));\n+}\n+\n+template <>\n+inline bool isinstance<handle>(handle) = delete;\n+template <>\n+inline bool isinstance<object>(handle obj) {\n+    return obj.ptr() != nullptr;\n+}\n+\n+/// \\ingroup python_builtins\n+/// Return true if ``obj`` is an instance of the ``type``.\n+inline bool isinstance(handle obj, handle type) {\n+    const auto result = PyObject_IsInstance(obj.ptr(), type.ptr());\n+    if (result == -1) {\n+        throw error_already_set();\n+    }\n+    return result != 0;\n+}\n+\n+/// \\addtogroup python_builtins\n+/// @{\n+inline bool hasattr(handle obj, handle name) {\n+    return PyObject_HasAttr(obj.ptr(), name.ptr()) == 1;\n+}\n+\n+inline bool hasattr(handle obj, const char *name) {\n+    return PyObject_HasAttrString(obj.ptr(), name) == 1;\n+}\n+\n+inline void delattr(handle obj, handle name) {\n+    if (PyObject_DelAttr(obj.ptr(), name.ptr()) != 0) {\n+        throw error_already_set();\n+    }\n+}\n+\n+inline void delattr(handle obj, const char *name) {\n+    if (PyObject_DelAttrString(obj.ptr(), name) != 0) {\n+        throw error_already_set();\n+    }\n+}\n+\n+inline object getattr(handle obj, handle name) {\n+    PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr());\n+    if (!result) {\n+        throw error_already_set();\n+    }\n+    return reinterpret_steal<object>(result);\n+}\n+\n+inline object getattr(handle obj, const char *name) {\n+    PyObject *result = PyObject_GetAttrString(obj.ptr(), name);\n+    if (!result) {\n+        throw error_already_set();\n+    }\n+    return reinterpret_steal<object>(result);\n+}\n+\n+inline object getattr(handle obj, handle name, handle default_) {\n+    if (PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr())) {\n+        return reinterpret_steal<object>(result);\n+    }\n+    PyErr_Clear();\n+    return reinterpret_borrow<object>(default_);\n+}\n+\n+inline object getattr(handle obj, const char *name, handle default_) {\n+    if (PyObject *result = PyObject_GetAttrString(obj.ptr(), name)) {\n+        return reinterpret_steal<object>(result);\n+    }\n+    PyErr_Clear();\n+    return reinterpret_borrow<object>(default_);\n+}\n+\n+inline void setattr(handle obj, handle name, handle value) {\n+    if (PyObject_SetAttr(obj.ptr(), name.ptr(), value.ptr()) != 0) {\n+        throw error_already_set();\n+    }\n+}\n+\n+inline void setattr(handle obj, const char *name, handle value) {\n+    if (PyObject_SetAttrString(obj.ptr(), name, value.ptr()) != 0) {\n+        throw error_already_set();\n+    }\n+}\n+\n+inline ssize_t hash(handle obj) {\n+    auto h = PyObject_Hash(obj.ptr());\n+    if (h == -1) {\n+        throw error_already_set();\n+    }\n+    return h;\n+}\n+\n+/// @} python_builtins\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+inline handle get_function(handle value) {\n+    if (value) {\n+        if (PyInstanceMethod_Check(value.ptr())) {\n+            value = PyInstanceMethod_GET_FUNCTION(value.ptr());\n+        } else if (PyMethod_Check(value.ptr())) {\n+            value = PyMethod_GET_FUNCTION(value.ptr());\n+        }\n+    }\n+    return value;\n+}\n+\n+// Reimplementation of python's dict helper functions to ensure that exceptions\n+// aren't swallowed (see #2862)\n+\n+// copied from cpython _PyDict_GetItemStringWithError\n+inline PyObject *dict_getitemstring(PyObject *v, const char *key) {\n+    PyObject *kv = nullptr, *rv = nullptr;\n+    kv = PyUnicode_FromString(key);\n+    if (kv == nullptr) {\n+        throw error_already_set();\n+    }\n+\n+    rv = PyDict_GetItemWithError(v, kv);\n+    Py_DECREF(kv);\n+    if (rv == nullptr && PyErr_Occurred()) {\n+        throw error_already_set();\n+    }\n+    return rv;\n+}\n+\n+inline PyObject *dict_getitem(PyObject *v, PyObject *key) {\n+    PyObject *rv = PyDict_GetItemWithError(v, key);\n+    if (rv == nullptr && PyErr_Occurred()) {\n+        throw error_already_set();\n+    }\n+    return rv;\n+}\n+\n+// Helper aliases/functions to support implicit casting of values given to python\n+// accessors/methods. When given a pyobject, this simply returns the pyobject as-is; for other C++\n+// type, the value goes through pybind11::cast(obj) to convert it to an `object`.\n+template <typename T, enable_if_t<is_pyobject<T>::value, int> = 0>\n+auto object_or_cast(T &&o) -> decltype(std::forward<T>(o)) {\n+    return std::forward<T>(o);\n+}\n+// The following casting version is implemented in cast.h:\n+template <typename T, enable_if_t<!is_pyobject<T>::value, int> = 0>\n+object object_or_cast(T &&o);\n+// Match a PyObject*, which we want to convert directly to handle via its converting constructor\n+inline handle object_or_cast(PyObject *ptr) { return ptr; }\n+\n+#if defined(_MSC_VER) && _MSC_VER < 1920\n+#    pragma warning(push)\n+#    pragma warning(disable : 4522) // warning C4522: multiple assignment operators specified\n+#endif\n+template <typename Policy>\n+class accessor : public object_api<accessor<Policy>> {\n+    using key_type = typename Policy::key_type;\n+\n+public:\n+    accessor(handle obj, key_type key) : obj(obj), key(std::move(key)) {}\n+    accessor(const accessor &) = default;\n+    accessor(accessor &&) noexcept = default;\n+\n+    // accessor overload required to override default assignment operator (templates are not\n+    // allowed to replace default compiler-generated assignments).\n+    void operator=(const accessor &a) && { std::move(*this).operator=(handle(a)); }\n+    void operator=(const accessor &a) & { operator=(handle(a)); }\n+\n+    template <typename T>\n+    void operator=(T &&value) && {\n+        Policy::set(obj, key, object_or_cast(std::forward<T>(value)));\n+    }\n+    template <typename T>\n+    void operator=(T &&value) & {\n+        get_cache() = ensure_object(object_or_cast(std::forward<T>(value)));\n+    }\n+\n+    template <typename T = Policy>\n+    PYBIND11_DEPRECATED(\n+        \"Use of obj.attr(...) as bool is deprecated in favor of pybind11::hasattr(obj, ...)\")\n+    explicit\n+    operator enable_if_t<std::is_same<T, accessor_policies::str_attr>::value\n+                             || std::is_same<T, accessor_policies::obj_attr>::value,\n+                         bool>() const {\n+        return hasattr(obj, key);\n+    }\n+    template <typename T = Policy>\n+    PYBIND11_DEPRECATED(\"Use of obj[key] as bool is deprecated in favor of obj.contains(key)\")\n+    explicit\n+    operator enable_if_t<std::is_same<T, accessor_policies::generic_item>::value, bool>() const {\n+        return obj.contains(key);\n+    }\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator object() const { return get_cache(); }\n+    PyObject *ptr() const { return get_cache().ptr(); }\n+    template <typename T>\n+    T cast() const {\n+        return get_cache().template cast<T>();\n+    }\n+\n+private:\n+    static object ensure_object(object &&o) { return std::move(o); }\n+    static object ensure_object(handle h) { return reinterpret_borrow<object>(h); }\n+\n+    object &get_cache() const {\n+        if (!cache) {\n+            cache = Policy::get(obj, key);\n+        }\n+        return cache;\n+    }\n+\n+private:\n+    handle obj;\n+    key_type key;\n+    mutable object cache;\n+};\n+#if defined(_MSC_VER) && _MSC_VER < 1920\n+#    pragma warning(pop)\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(accessor_policies)\n+struct obj_attr {\n+    using key_type = object;\n+    static object get(handle obj, handle key) { return getattr(obj, key); }\n+    static void set(handle obj, handle key, handle val) { setattr(obj, key, val); }\n+};\n+\n+struct str_attr {\n+    using key_type = const char *;\n+    static object get(handle obj, const char *key) { return getattr(obj, key); }\n+    static void set(handle obj, const char *key, handle val) { setattr(obj, key, val); }\n+};\n+\n+struct generic_item {\n+    using key_type = object;\n+\n+    static object get(handle obj, handle key) {\n+        PyObject *result = PyObject_GetItem(obj.ptr(), key.ptr());\n+        if (!result) {\n+            throw error_already_set();\n+        }\n+        return reinterpret_steal<object>(result);\n+    }\n+\n+    static void set(handle obj, handle key, handle val) {\n+        if (PyObject_SetItem(obj.ptr(), key.ptr(), val.ptr()) != 0) {\n+            throw error_already_set();\n+        }\n+    }\n+};\n+\n+struct sequence_item {\n+    using key_type = size_t;\n+\n+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>\n+    static object get(handle obj, const IdxType &index) {\n+        PyObject *result = PySequence_GetItem(obj.ptr(), ssize_t_cast(index));\n+        if (!result) {\n+            throw error_already_set();\n+        }\n+        return reinterpret_steal<object>(result);\n+    }\n+\n+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>\n+    static void set(handle obj, const IdxType &index, handle val) {\n+        // PySequence_SetItem does not steal a reference to 'val'\n+        if (PySequence_SetItem(obj.ptr(), ssize_t_cast(index), val.ptr()) != 0) {\n+            throw error_already_set();\n+        }\n+    }\n+};\n+\n+struct list_item {\n+    using key_type = size_t;\n+\n+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>\n+    static object get(handle obj, const IdxType &index) {\n+        PyObject *result = PyList_GetItem(obj.ptr(), ssize_t_cast(index));\n+        if (!result) {\n+            throw error_already_set();\n+        }\n+        return reinterpret_borrow<object>(result);\n+    }\n+\n+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>\n+    static void set(handle obj, const IdxType &index, handle val) {\n+        // PyList_SetItem steals a reference to 'val'\n+        if (PyList_SetItem(obj.ptr(), ssize_t_cast(index), val.inc_ref().ptr()) != 0) {\n+            throw error_already_set();\n+        }\n+    }\n+};\n+\n+struct tuple_item {\n+    using key_type = size_t;\n+\n+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>\n+    static object get(handle obj, const IdxType &index) {\n+        PyObject *result = PyTuple_GetItem(obj.ptr(), ssize_t_cast(index));\n+        if (!result) {\n+            throw error_already_set();\n+        }\n+        return reinterpret_borrow<object>(result);\n+    }\n+\n+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>\n+    static void set(handle obj, const IdxType &index, handle val) {\n+        // PyTuple_SetItem steals a reference to 'val'\n+        if (PyTuple_SetItem(obj.ptr(), ssize_t_cast(index), val.inc_ref().ptr()) != 0) {\n+            throw error_already_set();\n+        }\n+    }\n+};\n+PYBIND11_NAMESPACE_END(accessor_policies)\n+\n+/// STL iterator template used for tuple, list, sequence and dict\n+template <typename Policy>\n+class generic_iterator : public Policy {\n+    using It = generic_iterator;\n+\n+public:\n+    using difference_type = ssize_t;\n+    using iterator_category = typename Policy::iterator_category;\n+    using value_type = typename Policy::value_type;\n+    using reference = typename Policy::reference;\n+    using pointer = typename Policy::pointer;\n+\n+    generic_iterator() = default;\n+    generic_iterator(handle seq, ssize_t index) : Policy(seq, index) {}\n+\n+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263\n+    reference operator*() const { return Policy::dereference(); }\n+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263\n+    reference operator[](difference_type n) const { return *(*this + n); }\n+    pointer operator->() const { return **this; }\n+\n+    It &operator++() {\n+        Policy::increment();\n+        return *this;\n+    }\n+    It operator++(int) {\n+        auto copy = *this;\n+        Policy::increment();\n+        return copy;\n+    }\n+    It &operator--() {\n+        Policy::decrement();\n+        return *this;\n+    }\n+    It operator--(int) {\n+        auto copy = *this;\n+        Policy::decrement();\n+        return copy;\n+    }\n+    It &operator+=(difference_type n) {\n+        Policy::advance(n);\n+        return *this;\n+    }\n+    It &operator-=(difference_type n) {\n+        Policy::advance(-n);\n+        return *this;\n+    }\n+\n+    friend It operator+(const It &a, difference_type n) {\n+        auto copy = a;\n+        return copy += n;\n+    }\n+    friend It operator+(difference_type n, const It &b) { return b + n; }\n+    friend It operator-(const It &a, difference_type n) {\n+        auto copy = a;\n+        return copy -= n;\n+    }\n+    friend difference_type operator-(const It &a, const It &b) { return a.distance_to(b); }\n+\n+    friend bool operator==(const It &a, const It &b) { return a.equal(b); }\n+    friend bool operator!=(const It &a, const It &b) { return !(a == b); }\n+    friend bool operator<(const It &a, const It &b) { return b - a > 0; }\n+    friend bool operator>(const It &a, const It &b) { return b < a; }\n+    friend bool operator>=(const It &a, const It &b) { return !(a < b); }\n+    friend bool operator<=(const It &a, const It &b) { return !(a > b); }\n+};\n+\n+PYBIND11_NAMESPACE_BEGIN(iterator_policies)\n+/// Quick proxy class needed to implement ``operator->`` for iterators which can't return pointers\n+template <typename T>\n+struct arrow_proxy {\n+    T value;\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    arrow_proxy(T &&value) noexcept : value(std::move(value)) {}\n+    T *operator->() const { return &value; }\n+};\n+\n+/// Lightweight iterator policy using just a simple pointer: see ``PySequence_Fast_ITEMS``\n+class sequence_fast_readonly {\n+protected:\n+    using iterator_category = std::random_access_iterator_tag;\n+    using value_type = handle;\n+    using reference = const handle; // PR #3263\n+    using pointer = arrow_proxy<const handle>;\n+\n+    sequence_fast_readonly(handle obj, ssize_t n) : ptr(PySequence_Fast_ITEMS(obj.ptr()) + n) {}\n+\n+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263\n+    reference dereference() const { return *ptr; }\n+    void increment() { ++ptr; }\n+    void decrement() { --ptr; }\n+    void advance(ssize_t n) { ptr += n; }\n+    bool equal(const sequence_fast_readonly &b) const { return ptr == b.ptr; }\n+    ssize_t distance_to(const sequence_fast_readonly &b) const { return ptr - b.ptr; }\n+\n+private:\n+    PyObject **ptr;\n+};\n+\n+/// Full read and write access using the sequence protocol: see ``detail::sequence_accessor``\n+class sequence_slow_readwrite {\n+protected:\n+    using iterator_category = std::random_access_iterator_tag;\n+    using value_type = object;\n+    using reference = sequence_accessor;\n+    using pointer = arrow_proxy<const sequence_accessor>;\n+\n+    sequence_slow_readwrite(handle obj, ssize_t index) : obj(obj), index(index) {}\n+\n+    reference dereference() const { return {obj, static_cast<size_t>(index)}; }\n+    void increment() { ++index; }\n+    void decrement() { --index; }\n+    void advance(ssize_t n) { index += n; }\n+    bool equal(const sequence_slow_readwrite &b) const { return index == b.index; }\n+    ssize_t distance_to(const sequence_slow_readwrite &b) const { return index - b.index; }\n+\n+private:\n+    handle obj;\n+    ssize_t index;\n+};\n+\n+/// Python's dictionary protocol permits this to be a forward iterator\n+class dict_readonly {\n+protected:\n+    using iterator_category = std::forward_iterator_tag;\n+    using value_type = std::pair<handle, handle>;\n+    using reference = const value_type; // PR #3263\n+    using pointer = arrow_proxy<const value_type>;\n+\n+    dict_readonly() = default;\n+    dict_readonly(handle obj, ssize_t pos) : obj(obj), pos(pos) { increment(); }\n+\n+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263\n+    reference dereference() const { return {key, value}; }\n+    void increment() {\n+        if (PyDict_Next(obj.ptr(), &pos, &key, &value) == 0) {\n+            pos = -1;\n+        }\n+    }\n+    bool equal(const dict_readonly &b) const { return pos == b.pos; }\n+\n+private:\n+    handle obj;\n+    PyObject *key = nullptr, *value = nullptr;\n+    ssize_t pos = -1;\n+};\n+PYBIND11_NAMESPACE_END(iterator_policies)\n+\n+#if !defined(PYPY_VERSION)\n+using tuple_iterator = generic_iterator<iterator_policies::sequence_fast_readonly>;\n+using list_iterator = generic_iterator<iterator_policies::sequence_fast_readonly>;\n+#else\n+using tuple_iterator = generic_iterator<iterator_policies::sequence_slow_readwrite>;\n+using list_iterator = generic_iterator<iterator_policies::sequence_slow_readwrite>;\n+#endif\n+\n+using sequence_iterator = generic_iterator<iterator_policies::sequence_slow_readwrite>;\n+using dict_iterator = generic_iterator<iterator_policies::dict_readonly>;\n+\n+inline bool PyIterable_Check(PyObject *obj) {\n+    PyObject *iter = PyObject_GetIter(obj);\n+    if (iter) {\n+        Py_DECREF(iter);\n+        return true;\n+    }\n+    PyErr_Clear();\n+    return false;\n+}\n+\n+inline bool PyNone_Check(PyObject *o) { return o == Py_None; }\n+inline bool PyEllipsis_Check(PyObject *o) { return o == Py_Ellipsis; }\n+\n+#ifdef PYBIND11_STR_LEGACY_PERMISSIVE\n+inline bool PyUnicode_Check_Permissive(PyObject *o) {\n+    return PyUnicode_Check(o) || PYBIND11_BYTES_CHECK(o);\n+}\n+#    define PYBIND11_STR_CHECK_FUN detail::PyUnicode_Check_Permissive\n+#else\n+#    define PYBIND11_STR_CHECK_FUN PyUnicode_Check\n+#endif\n+\n+inline bool PyStaticMethod_Check(PyObject *o) { return o->ob_type == &PyStaticMethod_Type; }\n+\n+class kwargs_proxy : public handle {\n+public:\n+    explicit kwargs_proxy(handle h) : handle(h) {}\n+};\n+\n+class args_proxy : public handle {\n+public:\n+    explicit args_proxy(handle h) : handle(h) {}\n+    kwargs_proxy operator*() const { return kwargs_proxy(*this); }\n+};\n+\n+/// Python argument categories (using PEP 448 terms)\n+template <typename T>\n+using is_keyword = std::is_base_of<arg, T>;\n+template <typename T>\n+using is_s_unpacking = std::is_same<args_proxy, T>; // * unpacking\n+template <typename T>\n+using is_ds_unpacking = std::is_same<kwargs_proxy, T>; // ** unpacking\n+template <typename T>\n+using is_positional = satisfies_none_of<T, is_keyword, is_s_unpacking, is_ds_unpacking>;\n+template <typename T>\n+using is_keyword_or_ds = satisfies_any_of<T, is_keyword, is_ds_unpacking>;\n+\n+// Call argument collector forward declarations\n+template <return_value_policy policy = return_value_policy::automatic_reference>\n+class simple_collector;\n+template <return_value_policy policy = return_value_policy::automatic_reference>\n+class unpacking_collector;\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+// TODO: After the deprecated constructors are removed, this macro can be simplified by\n+//       inheriting ctors: `using Parent::Parent`. It's not an option right now because\n+//       the `using` statement triggers the parent deprecation warning even if the ctor\n+//       isn't even used.\n+#define PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                                            \\\n+public:                                                                                           \\\n+    PYBIND11_DEPRECATED(\"Use reinterpret_borrow<\" #Name \">() or reinterpret_steal<\" #Name \">()\")  \\\n+    Name(handle h, bool is_borrowed)                                                              \\\n+        : Parent(is_borrowed ? Parent(h, borrowed_t{}) : Parent(h, stolen_t{})) {}                \\\n+    Name(handle h, borrowed_t) : Parent(h, borrowed_t{}) {}                                       \\\n+    Name(handle h, stolen_t) : Parent(h, stolen_t{}) {}                                           \\\n+    PYBIND11_DEPRECATED(\"Use py::isinstance<py::python_type>(obj) instead\")                       \\\n+    bool check() const { return m_ptr != nullptr && (CheckFun(m_ptr) != 0); }                     \\\n+    static bool check_(handle h) { return h.ptr() != nullptr && CheckFun(h.ptr()); }              \\\n+    template <typename Policy_> /* NOLINTNEXTLINE(google-explicit-constructor) */                 \\\n+    Name(const ::pybind11::detail::accessor<Policy_> &a) : Name(object(a)) {}\n+\n+#define PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun)                                   \\\n+    PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                                                \\\n+    /* This is deliberately not 'explicit' to allow implicit conversion from object: */           \\\n+    /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \\\n+    Name(const object &o)                                                                         \\\n+        : Parent(check_(o) ? o.inc_ref().ptr() : ConvertFun(o.ptr()), stolen_t{}) {               \\\n+        if (!m_ptr)                                                                               \\\n+            throw ::pybind11::error_already_set();                                                \\\n+    }                                                                                             \\\n+    /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \\\n+    Name(object &&o) : Parent(check_(o) ? o.release().ptr() : ConvertFun(o.ptr()), stolen_t{}) {  \\\n+        if (!m_ptr)                                                                               \\\n+            throw ::pybind11::error_already_set();                                                \\\n+    }\n+\n+#define PYBIND11_OBJECT_CVT_DEFAULT(Name, Parent, CheckFun, ConvertFun)                           \\\n+    PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun)                                       \\\n+    Name() : Parent() {}\n+\n+#define PYBIND11_OBJECT_CHECK_FAILED(Name, o_ptr)                                                 \\\n+    ::pybind11::type_error(\"Object of type '\"                                                     \\\n+                           + ::pybind11::detail::get_fully_qualified_tp_name(Py_TYPE(o_ptr))      \\\n+                           + \"' is not an instance of '\" #Name \"'\")\n+\n+#define PYBIND11_OBJECT(Name, Parent, CheckFun)                                                   \\\n+    PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                                                \\\n+    /* This is deliberately not 'explicit' to allow implicit conversion from object: */           \\\n+    /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \\\n+    Name(const object &o) : Parent(o) {                                                           \\\n+        if (m_ptr && !check_(m_ptr))                                                              \\\n+            throw PYBIND11_OBJECT_CHECK_FAILED(Name, m_ptr);                                      \\\n+    }                                                                                             \\\n+    /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \\\n+    Name(object &&o) : Parent(std::move(o)) {                                                     \\\n+        if (m_ptr && !check_(m_ptr))                                                              \\\n+            throw PYBIND11_OBJECT_CHECK_FAILED(Name, m_ptr);                                      \\\n+    }\n+\n+#define PYBIND11_OBJECT_DEFAULT(Name, Parent, CheckFun)                                           \\\n+    PYBIND11_OBJECT(Name, Parent, CheckFun)                                                       \\\n+    Name() : Parent() {}\n+\n+/// \\addtogroup pytypes\n+/// @{\n+\n+/** \\rst\n+    Wraps a Python iterator so that it can also be used as a C++ input iterator\n+\n+    Caveat: copying an iterator does not (and cannot) clone the internal\n+    state of the Python iterable. This also applies to the post-increment\n+    operator. This iterator should only be used to retrieve the current\n+    value using ``operator*()``.\n+\\endrst */\n+class iterator : public object {\n+public:\n+    using iterator_category = std::input_iterator_tag;\n+    using difference_type = ssize_t;\n+    using value_type = handle;\n+    using reference = const handle; // PR #3263\n+    using pointer = const handle *;\n+\n+    PYBIND11_OBJECT_DEFAULT(iterator, object, PyIter_Check)\n+\n+    iterator &operator++() {\n+        advance();\n+        return *this;\n+    }\n+\n+    iterator operator++(int) {\n+        auto rv = *this;\n+        advance();\n+        return rv;\n+    }\n+\n+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263\n+    reference operator*() const {\n+        if (m_ptr && !value.ptr()) {\n+            auto &self = const_cast<iterator &>(*this);\n+            self.advance();\n+        }\n+        return value;\n+    }\n+\n+    pointer operator->() const {\n+        operator*();\n+        return &value;\n+    }\n+\n+    /** \\rst\n+         The value which marks the end of the iteration. ``it == iterator::sentinel()``\n+         is equivalent to catching ``StopIteration`` in Python.\n+\n+         .. code-block:: cpp\n+\n+             void foo(py::iterator it) {\n+                 while (it != py::iterator::sentinel()) {\n+                    // use `*it`\n+                    ++it;\n+                 }\n+             }\n+    \\endrst */\n+    static iterator sentinel() { return {}; }\n+\n+    friend bool operator==(const iterator &a, const iterator &b) { return a->ptr() == b->ptr(); }\n+    friend bool operator!=(const iterator &a, const iterator &b) { return a->ptr() != b->ptr(); }\n+\n+private:\n+    void advance() {\n+        value = reinterpret_steal<object>(PyIter_Next(m_ptr));\n+        if (PyErr_Occurred()) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+private:\n+    object value = {};\n+};\n+\n+class type : public object {\n+public:\n+    PYBIND11_OBJECT(type, object, PyType_Check)\n+\n+    /// Return a type handle from a handle or an object\n+    static handle handle_of(handle h) { return handle((PyObject *) Py_TYPE(h.ptr())); }\n+\n+    /// Return a type object from a handle or an object\n+    static type of(handle h) { return type(type::handle_of(h), borrowed_t{}); }\n+\n+    // Defined in pybind11/cast.h\n+    /// Convert C++ type to handle if previously registered. Does not convert\n+    /// standard types, like int, float. etc. yet.\n+    /// See https://github.com/pybind/pybind11/issues/2486\n+    template <typename T>\n+    static handle handle_of();\n+\n+    /// Convert C++ type to type if previously registered. Does not convert\n+    /// standard types, like int, float. etc. yet.\n+    /// See https://github.com/pybind/pybind11/issues/2486\n+    template <typename T>\n+    static type of() {\n+        return type(type::handle_of<T>(), borrowed_t{});\n+    }\n+};\n+\n+class iterable : public object {\n+public:\n+    PYBIND11_OBJECT_DEFAULT(iterable, object, detail::PyIterable_Check)\n+};\n+\n+class bytes;\n+\n+class str : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(str, object, PYBIND11_STR_CHECK_FUN, raw_str)\n+\n+    template <typename SzType, detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>\n+    str(const char *c, const SzType &n)\n+        : object(PyUnicode_FromStringAndSize(c, ssize_t_cast(n)), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate string object!\");\n+        }\n+    }\n+\n+    // 'explicit' is explicitly omitted from the following constructors to allow implicit\n+    // conversion to py::str from C++ string-like objects\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    str(const char *c = \"\") : object(PyUnicode_FromString(c), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate string object!\");\n+        }\n+    }\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    str(const std::string &s) : str(s.data(), s.size()) {}\n+\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+    // enable_if is needed to avoid \"ambiguous conversion\" errors (see PR #3521).\n+    template <typename T, detail::enable_if_t<std::is_same<T, std::string_view>::value, int> = 0>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    str(T s) : str(s.data(), s.size()) {}\n+\n+#    ifdef PYBIND11_HAS_U8STRING\n+    // reinterpret_cast here is safe (C++20 guarantees char8_t has the same size/alignment as char)\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    str(std::u8string_view s) : str(reinterpret_cast<const char *>(s.data()), s.size()) {}\n+#    endif\n+\n+#endif\n+\n+    explicit str(const bytes &b);\n+\n+    /** \\rst\n+        Return a string representation of the object. This is analogous to\n+        the ``str()`` function in Python.\n+    \\endrst */\n+    explicit str(handle h) : object(raw_str(h.ptr()), stolen_t{}) {\n+        if (!m_ptr) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator std::string() const {\n+        object temp = *this;\n+        if (PyUnicode_Check(m_ptr)) {\n+            temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(m_ptr));\n+            if (!temp) {\n+                throw error_already_set();\n+            }\n+        }\n+        char *buffer = nullptr;\n+        ssize_t length = 0;\n+        if (PyBytes_AsStringAndSize(temp.ptr(), &buffer, &length) != 0) {\n+            throw error_already_set();\n+        }\n+        return std::string(buffer, (size_t) length);\n+    }\n+\n+    template <typename... Args>\n+    str format(Args &&...args) const {\n+        return attr(\"format\")(std::forward<Args>(args)...);\n+    }\n+\n+private:\n+    /// Return string representation -- always returns a new reference, even if already a str\n+    static PyObject *raw_str(PyObject *op) {\n+        PyObject *str_value = PyObject_Str(op);\n+        return str_value;\n+    }\n+};\n+/// @} pytypes\n+\n+inline namespace literals {\n+/** \\rst\n+    String literal version of `str`\n+ \\endrst */\n+inline str operator\"\" _s(const char *s, size_t size) { return {s, size}; }\n+} // namespace literals\n+\n+/// \\addtogroup pytypes\n+/// @{\n+class bytes : public object {\n+public:\n+    PYBIND11_OBJECT(bytes, object, PYBIND11_BYTES_CHECK)\n+\n+    // Allow implicit conversion:\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    bytes(const char *c = \"\") : object(PYBIND11_BYTES_FROM_STRING(c), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate bytes object!\");\n+        }\n+    }\n+\n+    template <typename SzType, detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>\n+    bytes(const char *c, const SzType &n)\n+        : object(PYBIND11_BYTES_FROM_STRING_AND_SIZE(c, ssize_t_cast(n)), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate bytes object!\");\n+        }\n+    }\n+\n+    // Allow implicit conversion:\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    bytes(const std::string &s) : bytes(s.data(), s.size()) {}\n+\n+    explicit bytes(const pybind11::str &s);\n+\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator std::string() const { return string_op<std::string>(); }\n+\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+    // enable_if is needed to avoid \"ambiguous conversion\" errors (see PR #3521).\n+    template <typename T, detail::enable_if_t<std::is_same<T, std::string_view>::value, int> = 0>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    bytes(T s) : bytes(s.data(), s.size()) {}\n+\n+    // Obtain a string view that views the current `bytes` buffer value.  Note that this is only\n+    // valid so long as the `bytes` instance remains alive and so generally should not outlive the\n+    // lifetime of the `bytes` instance.\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator std::string_view() const { return string_op<std::string_view>(); }\n+#endif\n+private:\n+    template <typename T>\n+    T string_op() const {\n+        char *buffer = nullptr;\n+        ssize_t length = 0;\n+        if (PyBytes_AsStringAndSize(m_ptr, &buffer, &length) != 0) {\n+            throw error_already_set();\n+        }\n+        return {buffer, static_cast<size_t>(length)};\n+    }\n+};\n+// Note: breathe >= 4.17.0 will fail to build docs if the below two constructors\n+// are included in the doxygen group; close here and reopen after as a workaround\n+/// @} pytypes\n+\n+inline bytes::bytes(const pybind11::str &s) {\n+    object temp = s;\n+    if (PyUnicode_Check(s.ptr())) {\n+        temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(s.ptr()));\n+        if (!temp) {\n+            throw error_already_set();\n+        }\n+    }\n+    char *buffer = nullptr;\n+    ssize_t length = 0;\n+    if (PyBytes_AsStringAndSize(temp.ptr(), &buffer, &length) != 0) {\n+        throw error_already_set();\n+    }\n+    auto obj = reinterpret_steal<object>(PYBIND11_BYTES_FROM_STRING_AND_SIZE(buffer, length));\n+    if (!obj) {\n+        pybind11_fail(\"Could not allocate bytes object!\");\n+    }\n+    m_ptr = obj.release().ptr();\n+}\n+\n+inline str::str(const bytes &b) {\n+    char *buffer = nullptr;\n+    ssize_t length = 0;\n+    if (PyBytes_AsStringAndSize(b.ptr(), &buffer, &length) != 0) {\n+        throw error_already_set();\n+    }\n+    auto obj = reinterpret_steal<object>(PyUnicode_FromStringAndSize(buffer, length));\n+    if (!obj) {\n+        pybind11_fail(\"Could not allocate string object!\");\n+    }\n+    m_ptr = obj.release().ptr();\n+}\n+\n+/// \\addtogroup pytypes\n+/// @{\n+class bytearray : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(bytearray, object, PyByteArray_Check, PyByteArray_FromObject)\n+\n+    template <typename SzType, detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>\n+    bytearray(const char *c, const SzType &n)\n+        : object(PyByteArray_FromStringAndSize(c, ssize_t_cast(n)), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate bytearray object!\");\n+        }\n+    }\n+\n+    bytearray() : bytearray(\"\", 0) {}\n+\n+    explicit bytearray(const std::string &s) : bytearray(s.data(), s.size()) {}\n+\n+    size_t size() const { return static_cast<size_t>(PyByteArray_Size(m_ptr)); }\n+\n+    explicit operator std::string() const {\n+        char *buffer = PyByteArray_AS_STRING(m_ptr);\n+        ssize_t size = PyByteArray_GET_SIZE(m_ptr);\n+        return std::string(buffer, static_cast<size_t>(size));\n+    }\n+};\n+// Note: breathe >= 4.17.0 will fail to build docs if the below two constructors\n+// are included in the doxygen group; close here and reopen after as a workaround\n+/// @} pytypes\n+\n+/// \\addtogroup pytypes\n+/// @{\n+class none : public object {\n+public:\n+    PYBIND11_OBJECT(none, object, detail::PyNone_Check)\n+    none() : object(Py_None, borrowed_t{}) {}\n+};\n+\n+class ellipsis : public object {\n+public:\n+    PYBIND11_OBJECT(ellipsis, object, detail::PyEllipsis_Check)\n+    ellipsis() : object(Py_Ellipsis, borrowed_t{}) {}\n+};\n+\n+class bool_ : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(bool_, object, PyBool_Check, raw_bool)\n+    bool_() : object(Py_False, borrowed_t{}) {}\n+    // Allow implicit conversion from and to `bool`:\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    bool_(bool value) : object(value ? Py_True : Py_False, borrowed_t{}) {}\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator bool() const { return (m_ptr != nullptr) && PyLong_AsLong(m_ptr) != 0; }\n+\n+private:\n+    /// Return the truth value of an object -- always returns a new reference\n+    static PyObject *raw_bool(PyObject *op) {\n+        const auto value = PyObject_IsTrue(op);\n+        if (value == -1) {\n+            return nullptr;\n+        }\n+        return handle(value != 0 ? Py_True : Py_False).inc_ref().ptr();\n+    }\n+};\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+// Converts a value to the given unsigned type.  If an error occurs, you get back (Unsigned) -1;\n+// otherwise you get back the unsigned long or unsigned long long value cast to (Unsigned).\n+// (The distinction is critically important when casting a returned -1 error value to some other\n+// unsigned type: (A)-1 != (B)-1 when A and B are unsigned types of different sizes).\n+template <typename Unsigned>\n+Unsigned as_unsigned(PyObject *o) {\n+    if (PYBIND11_SILENCE_MSVC_C4127(sizeof(Unsigned) <= sizeof(unsigned long))) {\n+        unsigned long v = PyLong_AsUnsignedLong(o);\n+        return v == (unsigned long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;\n+    }\n+    unsigned long long v = PyLong_AsUnsignedLongLong(o);\n+    return v == (unsigned long long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;\n+}\n+PYBIND11_NAMESPACE_END(detail)\n+\n+class int_ : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(int_, object, PYBIND11_LONG_CHECK, PyNumber_Long)\n+    int_() : object(PyLong_FromLong(0), stolen_t{}) {}\n+    // Allow implicit conversion from C++ integral types:\n+    template <typename T, detail::enable_if_t<std::is_integral<T>::value, int> = 0>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    int_(T value) {\n+        if (PYBIND11_SILENCE_MSVC_C4127(sizeof(T) <= sizeof(long))) {\n+            if (std::is_signed<T>::value) {\n+                m_ptr = PyLong_FromLong((long) value);\n+            } else {\n+                m_ptr = PyLong_FromUnsignedLong((unsigned long) value);\n+            }\n+        } else {\n+            if (std::is_signed<T>::value) {\n+                m_ptr = PyLong_FromLongLong((long long) value);\n+            } else {\n+                m_ptr = PyLong_FromUnsignedLongLong((unsigned long long) value);\n+            }\n+        }\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate int object!\");\n+        }\n+    }\n+\n+    template <typename T, detail::enable_if_t<std::is_integral<T>::value, int> = 0>\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator T() const {\n+        return std::is_unsigned<T>::value  ? detail::as_unsigned<T>(m_ptr)\n+               : sizeof(T) <= sizeof(long) ? (T) PyLong_AsLong(m_ptr)\n+                                           : (T) PYBIND11_LONG_AS_LONGLONG(m_ptr);\n+    }\n+};\n+\n+class float_ : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(float_, object, PyFloat_Check, PyNumber_Float)\n+    // Allow implicit conversion from float/double:\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    float_(float value) : object(PyFloat_FromDouble((double) value), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate float object!\");\n+        }\n+    }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    float_(double value = .0) : object(PyFloat_FromDouble((double) value), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate float object!\");\n+        }\n+    }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator float() const { return (float) PyFloat_AsDouble(m_ptr); }\n+    // NOLINTNEXTLINE(google-explicit-constructor)\n+    operator double() const { return (double) PyFloat_AsDouble(m_ptr); }\n+};\n+\n+class weakref : public object {\n+public:\n+    PYBIND11_OBJECT_CVT_DEFAULT(weakref, object, PyWeakref_Check, raw_weakref)\n+    explicit weakref(handle obj, handle callback = {})\n+        : object(PyWeakref_NewRef(obj.ptr(), callback.ptr()), stolen_t{}) {\n+        if (!m_ptr) {\n+            if (PyErr_Occurred()) {\n+                throw error_already_set();\n+            }\n+            pybind11_fail(\"Could not allocate weak reference!\");\n+        }\n+    }\n+\n+private:\n+    static PyObject *raw_weakref(PyObject *o) { return PyWeakref_NewRef(o, nullptr); }\n+};\n+\n+class slice : public object {\n+public:\n+    PYBIND11_OBJECT_DEFAULT(slice, object, PySlice_Check)\n+    slice(handle start, handle stop, handle step)\n+        : object(PySlice_New(start.ptr(), stop.ptr(), step.ptr()), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate slice object!\");\n+        }\n+    }\n+\n+#ifdef PYBIND11_HAS_OPTIONAL\n+    slice(std::optional<ssize_t> start, std::optional<ssize_t> stop, std::optional<ssize_t> step)\n+        : slice(index_to_object(start), index_to_object(stop), index_to_object(step)) {}\n+#else\n+    slice(ssize_t start_, ssize_t stop_, ssize_t step_)\n+        : slice(int_(start_), int_(stop_), int_(step_)) {}\n+#endif\n+\n+    bool\n+    compute(size_t length, size_t *start, size_t *stop, size_t *step, size_t *slicelength) const {\n+        return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *) m_ptr,\n+                                    (ssize_t) length,\n+                                    (ssize_t *) start,\n+                                    (ssize_t *) stop,\n+                                    (ssize_t *) step,\n+                                    (ssize_t *) slicelength)\n+               == 0;\n+    }\n+    bool compute(\n+        ssize_t length, ssize_t *start, ssize_t *stop, ssize_t *step, ssize_t *slicelength) const {\n+        return PySlice_GetIndicesEx(\n+                   (PYBIND11_SLICE_OBJECT *) m_ptr, length, start, stop, step, slicelength)\n+               == 0;\n+    }\n+\n+private:\n+    template <typename T>\n+    static object index_to_object(T index) {\n+        return index ? object(int_(*index)) : object(none());\n+    }\n+};\n+\n+class capsule : public object {\n+public:\n+    PYBIND11_OBJECT_DEFAULT(capsule, object, PyCapsule_CheckExact)\n+    PYBIND11_DEPRECATED(\"Use reinterpret_borrow<capsule>() or reinterpret_steal<capsule>()\")\n+    capsule(PyObject *ptr, bool is_borrowed)\n+        : object(is_borrowed ? object(ptr, borrowed_t{}) : object(ptr, stolen_t{})) {}\n+\n+    explicit capsule(const void *value,\n+                     const char *name = nullptr,\n+                     void (*destructor)(PyObject *) = nullptr)\n+        : object(PyCapsule_New(const_cast<void *>(value), name, destructor), stolen_t{}) {\n+        if (!m_ptr) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+    PYBIND11_DEPRECATED(\"Please pass a destructor that takes a void pointer as input\")\n+    capsule(const void *value, void (*destruct)(PyObject *))\n+        : object(PyCapsule_New(const_cast<void *>(value), nullptr, destruct), stolen_t{}) {\n+        if (!m_ptr) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+    capsule(const void *value, void (*destructor)(void *)) {\n+        m_ptr = PyCapsule_New(const_cast<void *>(value), nullptr, [](PyObject *o) {\n+            // guard if destructor called while err indicator is set\n+            error_scope error_guard;\n+            auto destructor = reinterpret_cast<void (*)(void *)>(PyCapsule_GetContext(o));\n+            if (destructor == nullptr) {\n+                if (PyErr_Occurred()) {\n+                    throw error_already_set();\n+                }\n+                pybind11_fail(\"Unable to get capsule context\");\n+            }\n+            const char *name = get_name_in_error_scope(o);\n+            void *ptr = PyCapsule_GetPointer(o, name);\n+            if (ptr == nullptr) {\n+                throw error_already_set();\n+            }\n+            destructor(ptr);\n+        });\n+\n+        if (!m_ptr || PyCapsule_SetContext(m_ptr, (void *) destructor) != 0) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+    explicit capsule(void (*destructor)()) {\n+        m_ptr = PyCapsule_New(reinterpret_cast<void *>(destructor), nullptr, [](PyObject *o) {\n+            const char *name = get_name_in_error_scope(o);\n+            auto destructor = reinterpret_cast<void (*)()>(PyCapsule_GetPointer(o, name));\n+            if (destructor == nullptr) {\n+                throw error_already_set();\n+            }\n+            destructor();\n+        });\n+\n+        if (!m_ptr) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+    template <typename T>\n+    operator T *() const { // NOLINT(google-explicit-constructor)\n+        return get_pointer<T>();\n+    }\n+\n+    /// Get the pointer the capsule holds.\n+    template <typename T = void>\n+    T *get_pointer() const {\n+        const auto *name = this->name();\n+        T *result = static_cast<T *>(PyCapsule_GetPointer(m_ptr, name));\n+        if (!result) {\n+            throw error_already_set();\n+        }\n+        return result;\n+    }\n+\n+    /// Replaces a capsule's pointer *without* calling the destructor on the existing one.\n+    void set_pointer(const void *value) {\n+        if (PyCapsule_SetPointer(m_ptr, const_cast<void *>(value)) != 0) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+    const char *name() const {\n+        const char *name = PyCapsule_GetName(m_ptr);\n+        if ((name == nullptr) && PyErr_Occurred()) {\n+            throw error_already_set();\n+        }\n+        return name;\n+    }\n+\n+    /// Replaces a capsule's name *without* calling the destructor on the existing one.\n+    void set_name(const char *new_name) {\n+        if (PyCapsule_SetName(m_ptr, new_name) != 0) {\n+            throw error_already_set();\n+        }\n+    }\n+\n+private:\n+    static const char *get_name_in_error_scope(PyObject *o) {\n+        error_scope error_guard;\n+\n+        const char *name = PyCapsule_GetName(o);\n+        if ((name == nullptr) && PyErr_Occurred()) {\n+            // write out and consume error raised by call to PyCapsule_GetName\n+            PyErr_WriteUnraisable(o);\n+        }\n+\n+        return name;\n+    }\n+};\n+\n+class tuple : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(tuple, object, PyTuple_Check, PySequence_Tuple)\n+    template <typename SzType = ssize_t,\n+              detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>\n+    // Some compilers generate link errors when using `const SzType &` here:\n+    explicit tuple(SzType size = 0) : object(PyTuple_New(ssize_t_cast(size)), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate tuple object!\");\n+        }\n+    }\n+    size_t size() const { return (size_t) PyTuple_Size(m_ptr); }\n+    bool empty() const { return size() == 0; }\n+    detail::tuple_accessor operator[](size_t index) const { return {*this, index}; }\n+    template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>\n+    detail::item_accessor operator[](T &&o) const {\n+        return object::operator[](std::forward<T>(o));\n+    }\n+    detail::tuple_iterator begin() const { return {*this, 0}; }\n+    detail::tuple_iterator end() const { return {*this, PyTuple_GET_SIZE(m_ptr)}; }\n+};\n+\n+// We need to put this into a separate function because the Intel compiler\n+// fails to compile enable_if_t<all_of<is_keyword_or_ds<Args>...>::value> part below\n+// (tested with ICC 2021.1 Beta 20200827).\n+template <typename... Args>\n+constexpr bool args_are_all_keyword_or_ds() {\n+    return detail::all_of<detail::is_keyword_or_ds<Args>...>::value;\n+}\n+\n+class dict : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(dict, object, PyDict_Check, raw_dict)\n+    dict() : object(PyDict_New(), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate dict object!\");\n+        }\n+    }\n+    template <typename... Args,\n+              typename = detail::enable_if_t<args_are_all_keyword_or_ds<Args...>()>,\n+              // MSVC workaround: it can't compile an out-of-line definition, so defer the\n+              // collector\n+              typename collector = detail::deferred_t<detail::unpacking_collector<>, Args...>>\n+    explicit dict(Args &&...args) : dict(collector(std::forward<Args>(args)...).kwargs()) {}\n+\n+    size_t size() const { return (size_t) PyDict_Size(m_ptr); }\n+    bool empty() const { return size() == 0; }\n+    detail::dict_iterator begin() const { return {*this, 0}; }\n+    detail::dict_iterator end() const { return {}; }\n+    void clear() /* py-non-const */ { PyDict_Clear(ptr()); }\n+    template <typename T>\n+    bool contains(T &&key) const {\n+        return PyDict_Contains(m_ptr, detail::object_or_cast(std::forward<T>(key)).ptr()) == 1;\n+    }\n+\n+private:\n+    /// Call the `dict` Python type -- always returns a new reference\n+    static PyObject *raw_dict(PyObject *op) {\n+        if (PyDict_Check(op)) {\n+            return handle(op).inc_ref().ptr();\n+        }\n+        return PyObject_CallFunctionObjArgs((PyObject *) &PyDict_Type, op, nullptr);\n+    }\n+};\n+\n+class sequence : public object {\n+public:\n+    PYBIND11_OBJECT_DEFAULT(sequence, object, PySequence_Check)\n+    size_t size() const {\n+        ssize_t result = PySequence_Size(m_ptr);\n+        if (result == -1) {\n+            throw error_already_set();\n+        }\n+        return (size_t) result;\n+    }\n+    bool empty() const { return size() == 0; }\n+    detail::sequence_accessor operator[](size_t index) const { return {*this, index}; }\n+    template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>\n+    detail::item_accessor operator[](T &&o) const {\n+        return object::operator[](std::forward<T>(o));\n+    }\n+    detail::sequence_iterator begin() const { return {*this, 0}; }\n+    detail::sequence_iterator end() const { return {*this, PySequence_Size(m_ptr)}; }\n+};\n+\n+class list : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(list, object, PyList_Check, PySequence_List)\n+    template <typename SzType = ssize_t,\n+              detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>\n+    // Some compilers generate link errors when using `const SzType &` here:\n+    explicit list(SzType size = 0) : object(PyList_New(ssize_t_cast(size)), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate list object!\");\n+        }\n+    }\n+    size_t size() const { return (size_t) PyList_Size(m_ptr); }\n+    bool empty() const { return size() == 0; }\n+    detail::list_accessor operator[](size_t index) const { return {*this, index}; }\n+    template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>\n+    detail::item_accessor operator[](T &&o) const {\n+        return object::operator[](std::forward<T>(o));\n+    }\n+    detail::list_iterator begin() const { return {*this, 0}; }\n+    detail::list_iterator end() const { return {*this, PyList_GET_SIZE(m_ptr)}; }\n+    template <typename T>\n+    void append(T &&val) /* py-non-const */ {\n+        PyList_Append(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr());\n+    }\n+    template <typename IdxType,\n+              typename ValType,\n+              detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>\n+    void insert(const IdxType &index, ValType &&val) /* py-non-const */ {\n+        PyList_Insert(\n+            m_ptr, ssize_t_cast(index), detail::object_or_cast(std::forward<ValType>(val)).ptr());\n+    }\n+};\n+\n+class args : public tuple {\n+    PYBIND11_OBJECT_DEFAULT(args, tuple, PyTuple_Check)\n+};\n+class kwargs : public dict {\n+    PYBIND11_OBJECT_DEFAULT(kwargs, dict, PyDict_Check)\n+};\n+\n+class anyset : public object {\n+public:\n+    PYBIND11_OBJECT(anyset, object, PyAnySet_Check)\n+    size_t size() const { return static_cast<size_t>(PySet_Size(m_ptr)); }\n+    bool empty() const { return size() == 0; }\n+    template <typename T>\n+    bool contains(T &&val) const {\n+        return PySet_Contains(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 1;\n+    }\n+};\n+\n+class set : public anyset {\n+public:\n+    PYBIND11_OBJECT_CVT(set, anyset, PySet_Check, PySet_New)\n+    set() : anyset(PySet_New(nullptr), stolen_t{}) {\n+        if (!m_ptr) {\n+            pybind11_fail(\"Could not allocate set object!\");\n+        }\n+    }\n+    template <typename T>\n+    bool add(T &&val) /* py-non-const */ {\n+        return PySet_Add(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 0;\n+    }\n+    void clear() /* py-non-const */ { PySet_Clear(m_ptr); }\n+};\n+\n+class frozenset : public anyset {\n+public:\n+    PYBIND11_OBJECT_CVT(frozenset, anyset, PyFrozenSet_Check, PyFrozenSet_New)\n+};\n+\n+class function : public object {\n+public:\n+    PYBIND11_OBJECT_DEFAULT(function, object, PyCallable_Check)\n+    handle cpp_function() const {\n+        handle fun = detail::get_function(m_ptr);\n+        if (fun && PyCFunction_Check(fun.ptr())) {\n+            return fun;\n+        }\n+        return handle();\n+    }\n+    bool is_cpp_function() const { return (bool) cpp_function(); }\n+};\n+\n+class staticmethod : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(staticmethod, object, detail::PyStaticMethod_Check, PyStaticMethod_New)\n+};\n+\n+class buffer : public object {\n+public:\n+    PYBIND11_OBJECT_DEFAULT(buffer, object, PyObject_CheckBuffer)\n+\n+    buffer_info request(bool writable = false) const {\n+        int flags = PyBUF_STRIDES | PyBUF_FORMAT;\n+        if (writable) {\n+            flags |= PyBUF_WRITABLE;\n+        }\n+        auto *view = new Py_buffer();\n+        if (PyObject_GetBuffer(m_ptr, view, flags) != 0) {\n+            delete view;\n+            throw error_already_set();\n+        }\n+        return buffer_info(view);\n+    }\n+};\n+\n+class memoryview : public object {\n+public:\n+    PYBIND11_OBJECT_CVT(memoryview, object, PyMemoryView_Check, PyMemoryView_FromObject)\n+\n+    /** \\rst\n+        Creates ``memoryview`` from ``buffer_info``.\n+\n+        ``buffer_info`` must be created from ``buffer::request()``. Otherwise\n+        throws an exception.\n+\n+        For creating a ``memoryview`` from objects that support buffer protocol,\n+        use ``memoryview(const object& obj)`` instead of this constructor.\n+     \\endrst */\n+    explicit memoryview(const buffer_info &info) {\n+        if (!info.view()) {\n+            pybind11_fail(\"Prohibited to create memoryview without Py_buffer\");\n+        }\n+        // Note: PyMemoryView_FromBuffer never increments obj reference.\n+        m_ptr = (info.view()->obj) ? PyMemoryView_FromObject(info.view()->obj)\n+                                   : PyMemoryView_FromBuffer(info.view());\n+        if (!m_ptr) {\n+            pybind11_fail(\"Unable to create memoryview from buffer descriptor\");\n+        }\n+    }\n+\n+    /** \\rst\n+        Creates ``memoryview`` from static buffer.\n+\n+        This method is meant for providing a ``memoryview`` for C/C++ buffer not\n+        managed by Python. The caller is responsible for managing the lifetime\n+        of ``ptr`` and ``format``, which MUST outlive the memoryview constructed\n+        here.\n+\n+        See also: Python C API documentation for `PyMemoryView_FromBuffer`_.\n+\n+        .. _PyMemoryView_FromBuffer:\n+           https://docs.python.org/c-api/memoryview.html#c.PyMemoryView_FromBuffer\n+\n+        :param ptr: Pointer to the buffer.\n+        :param itemsize: Byte size of an element.\n+        :param format: Pointer to the null-terminated format string. For\n+            homogeneous Buffers, this should be set to\n+            ``format_descriptor<T>::value``.\n+        :param shape: Shape of the tensor (1 entry per dimension).\n+        :param strides: Number of bytes between adjacent entries (for each\n+            per dimension).\n+        :param readonly: Flag to indicate if the underlying storage may be\n+            written to.\n+     \\endrst */\n+    static memoryview from_buffer(void *ptr,\n+                                  ssize_t itemsize,\n+                                  const char *format,\n+                                  detail::any_container<ssize_t> shape,\n+                                  detail::any_container<ssize_t> strides,\n+                                  bool readonly = false);\n+\n+    static memoryview from_buffer(const void *ptr,\n+                                  ssize_t itemsize,\n+                                  const char *format,\n+                                  detail::any_container<ssize_t> shape,\n+                                  detail::any_container<ssize_t> strides) {\n+        return memoryview::from_buffer(\n+            const_cast<void *>(ptr), itemsize, format, std::move(shape), std::move(strides), true);\n+    }\n+\n+    template <typename T>\n+    static memoryview from_buffer(T *ptr,\n+                                  detail::any_container<ssize_t> shape,\n+                                  detail::any_container<ssize_t> strides,\n+                                  bool readonly = false) {\n+        return memoryview::from_buffer(reinterpret_cast<void *>(ptr),\n+                                       sizeof(T),\n+                                       format_descriptor<T>::value,\n+                                       std::move(shape),\n+                                       std::move(strides),\n+                                       readonly);\n+    }\n+\n+    template <typename T>\n+    static memoryview from_buffer(const T *ptr,\n+                                  detail::any_container<ssize_t> shape,\n+                                  detail::any_container<ssize_t> strides) {\n+        return memoryview::from_buffer(\n+            const_cast<T *>(ptr), std::move(shape), std::move(strides), true);\n+    }\n+\n+    /** \\rst\n+        Creates ``memoryview`` from static memory.\n+\n+        This method is meant for providing a ``memoryview`` for C/C++ buffer not\n+        managed by Python. The caller is responsible for managing the lifetime\n+        of ``mem``, which MUST outlive the memoryview constructed here.\n+\n+        See also: Python C API documentation for `PyMemoryView_FromBuffer`_.\n+\n+        .. _PyMemoryView_FromMemory:\n+           https://docs.python.org/c-api/memoryview.html#c.PyMemoryView_FromMemory\n+     \\endrst */\n+    static memoryview from_memory(void *mem, ssize_t size, bool readonly = false) {\n+        PyObject *ptr = PyMemoryView_FromMemory(\n+            reinterpret_cast<char *>(mem), size, (readonly) ? PyBUF_READ : PyBUF_WRITE);\n+        if (!ptr) {\n+            pybind11_fail(\"Could not allocate memoryview object!\");\n+        }\n+        return memoryview(object(ptr, stolen_t{}));\n+    }\n+\n+    static memoryview from_memory(const void *mem, ssize_t size) {\n+        return memoryview::from_memory(const_cast<void *>(mem), size, true);\n+    }\n+\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+    static memoryview from_memory(std::string_view mem) {\n+        return from_memory(const_cast<char *>(mem.data()), static_cast<ssize_t>(mem.size()), true);\n+    }\n+#endif\n+};\n+\n+/// @cond DUPLICATE\n+inline memoryview memoryview::from_buffer(void *ptr,\n+                                          ssize_t itemsize,\n+                                          const char *format,\n+                                          detail::any_container<ssize_t> shape,\n+                                          detail::any_container<ssize_t> strides,\n+                                          bool readonly) {\n+    size_t ndim = shape->size();\n+    if (ndim != strides->size()) {\n+        pybind11_fail(\"memoryview: shape length doesn't match strides length\");\n+    }\n+    ssize_t size = ndim != 0u ? 1 : 0;\n+    for (size_t i = 0; i < ndim; ++i) {\n+        size *= (*shape)[i];\n+    }\n+    Py_buffer view;\n+    view.buf = ptr;\n+    view.obj = nullptr;\n+    view.len = size * itemsize;\n+    view.readonly = static_cast<int>(readonly);\n+    view.itemsize = itemsize;\n+    view.format = const_cast<char *>(format);\n+    view.ndim = static_cast<int>(ndim);\n+    view.shape = shape->data();\n+    view.strides = strides->data();\n+    view.suboffsets = nullptr;\n+    view.internal = nullptr;\n+    PyObject *obj = PyMemoryView_FromBuffer(&view);\n+    if (!obj) {\n+        throw error_already_set();\n+    }\n+    return memoryview(object(obj, stolen_t{}));\n+}\n+/// @endcond\n+/// @} pytypes\n+\n+/// \\addtogroup python_builtins\n+/// @{\n+\n+/// Get the length of a Python object.\n+inline size_t len(handle h) {\n+    ssize_t result = PyObject_Length(h.ptr());\n+    if (result < 0) {\n+        throw error_already_set();\n+    }\n+    return (size_t) result;\n+}\n+\n+/// Get the length hint of a Python object.\n+/// Returns 0 when this cannot be determined.\n+inline size_t len_hint(handle h) {\n+    ssize_t result = PyObject_LengthHint(h.ptr(), 0);\n+    if (result < 0) {\n+        // Sometimes a length can't be determined at all (eg generators)\n+        // In which case simply return 0\n+        PyErr_Clear();\n+        return 0;\n+    }\n+    return (size_t) result;\n+}\n+\n+inline str repr(handle h) {\n+    PyObject *str_value = PyObject_Repr(h.ptr());\n+    if (!str_value) {\n+        throw error_already_set();\n+    }\n+    return reinterpret_steal<str>(str_value);\n+}\n+\n+inline iterator iter(handle obj) {\n+    PyObject *result = PyObject_GetIter(obj.ptr());\n+    if (!result) {\n+        throw error_already_set();\n+    }\n+    return reinterpret_steal<iterator>(result);\n+}\n+/// @} python_builtins\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+template <typename D>\n+iterator object_api<D>::begin() const {\n+    return iter(derived());\n+}\n+template <typename D>\n+iterator object_api<D>::end() const {\n+    return iterator::sentinel();\n+}\n+template <typename D>\n+item_accessor object_api<D>::operator[](handle key) const {\n+    return {derived(), reinterpret_borrow<object>(key)};\n+}\n+template <typename D>\n+item_accessor object_api<D>::operator[](object &&key) const {\n+    return {derived(), std::move(key)};\n+}\n+template <typename D>\n+item_accessor object_api<D>::operator[](const char *key) const {\n+    return {derived(), pybind11::str(key)};\n+}\n+template <typename D>\n+obj_attr_accessor object_api<D>::attr(handle key) const {\n+    return {derived(), reinterpret_borrow<object>(key)};\n+}\n+template <typename D>\n+obj_attr_accessor object_api<D>::attr(object &&key) const {\n+    return {derived(), std::move(key)};\n+}\n+template <typename D>\n+str_attr_accessor object_api<D>::attr(const char *key) const {\n+    return {derived(), key};\n+}\n+template <typename D>\n+args_proxy object_api<D>::operator*() const {\n+    return args_proxy(derived().ptr());\n+}\n+template <typename D>\n+template <typename T>\n+bool object_api<D>::contains(T &&item) const {\n+    return attr(\"__contains__\")(std::forward<T>(item)).template cast<bool>();\n+}\n+\n+template <typename D>\n+pybind11::str object_api<D>::str() const {\n+    return pybind11::str(derived());\n+}\n+\n+template <typename D>\n+str_attr_accessor object_api<D>::doc() const {\n+    return attr(\"__doc__\");\n+}\n+\n+template <typename D>\n+handle object_api<D>::get_type() const {\n+    return type::handle_of(derived());\n+}\n+\n+template <typename D>\n+bool object_api<D>::rich_compare(object_api const &other, int value) const {\n+    int rv = PyObject_RichCompareBool(derived().ptr(), other.derived().ptr(), value);\n+    if (rv == -1) {\n+        throw error_already_set();\n+    }\n+    return rv == 1;\n+}\n+\n+#define PYBIND11_MATH_OPERATOR_UNARY(op, fn)                                                      \\\n+    template <typename D>                                                                         \\\n+    object object_api<D>::op() const {                                                            \\\n+        object result = reinterpret_steal<object>(fn(derived().ptr()));                           \\\n+        if (!result.ptr())                                                                        \\\n+            throw error_already_set();                                                            \\\n+        return result;                                                                            \\\n+    }\n+\n+#define PYBIND11_MATH_OPERATOR_BINARY(op, fn)                                                     \\\n+    template <typename D>                                                                         \\\n+    object object_api<D>::op(object_api const &other) const {                                     \\\n+        object result = reinterpret_steal<object>(fn(derived().ptr(), other.derived().ptr()));    \\\n+        if (!result.ptr())                                                                        \\\n+            throw error_already_set();                                                            \\\n+        return result;                                                                            \\\n+    }\n+\n+PYBIND11_MATH_OPERATOR_UNARY(operator~, PyNumber_Invert)\n+PYBIND11_MATH_OPERATOR_UNARY(operator-, PyNumber_Negative)\n+PYBIND11_MATH_OPERATOR_BINARY(operator+, PyNumber_Add)\n+PYBIND11_MATH_OPERATOR_BINARY(operator+=, PyNumber_InPlaceAdd)\n+PYBIND11_MATH_OPERATOR_BINARY(operator-, PyNumber_Subtract)\n+PYBIND11_MATH_OPERATOR_BINARY(operator-=, PyNumber_InPlaceSubtract)\n+PYBIND11_MATH_OPERATOR_BINARY(operator*, PyNumber_Multiply)\n+PYBIND11_MATH_OPERATOR_BINARY(operator*=, PyNumber_InPlaceMultiply)\n+PYBIND11_MATH_OPERATOR_BINARY(operator/, PyNumber_TrueDivide)\n+PYBIND11_MATH_OPERATOR_BINARY(operator/=, PyNumber_InPlaceTrueDivide)\n+PYBIND11_MATH_OPERATOR_BINARY(operator|, PyNumber_Or)\n+PYBIND11_MATH_OPERATOR_BINARY(operator|=, PyNumber_InPlaceOr)\n+PYBIND11_MATH_OPERATOR_BINARY(operator&, PyNumber_And)\n+PYBIND11_MATH_OPERATOR_BINARY(operator&=, PyNumber_InPlaceAnd)\n+PYBIND11_MATH_OPERATOR_BINARY(operator^, PyNumber_Xor)\n+PYBIND11_MATH_OPERATOR_BINARY(operator^=, PyNumber_InPlaceXor)\n+PYBIND11_MATH_OPERATOR_BINARY(operator<<, PyNumber_Lshift)\n+PYBIND11_MATH_OPERATOR_BINARY(operator<<=, PyNumber_InPlaceLshift)\n+PYBIND11_MATH_OPERATOR_BINARY(operator>>, PyNumber_Rshift)\n+PYBIND11_MATH_OPERATOR_BINARY(operator>>=, PyNumber_InPlaceRshift)\n+\n+#undef PYBIND11_MATH_OPERATOR_UNARY\n+#undef PYBIND11_MATH_OPERATOR_BINARY\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/stl.h", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "file_content_changes": "@@ -0,0 +1,425 @@\n+/*\n+    pybind11/stl.h: Transparent conversion for STL data types\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+#include \"detail/common.h\"\n+\n+#include <deque>\n+#include <list>\n+#include <map>\n+#include <ostream>\n+#include <set>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <valarray>\n+\n+// See `detail/common.h` for implementation of these guards.\n+#if defined(PYBIND11_HAS_OPTIONAL)\n+#    include <optional>\n+#elif defined(PYBIND11_HAS_EXP_OPTIONAL)\n+#    include <experimental/optional>\n+#endif\n+\n+#if defined(PYBIND11_HAS_VARIANT)\n+#    include <variant>\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/// Extracts an const lvalue reference or rvalue reference for U based on the type of T (e.g. for\n+/// forwarding a container element).  Typically used indirect via forwarded_type(), below.\n+template <typename T, typename U>\n+using forwarded_type = conditional_t<std::is_lvalue_reference<T>::value,\n+                                     remove_reference_t<U> &,\n+                                     remove_reference_t<U> &&>;\n+\n+/// Forwards a value U as rvalue or lvalue according to whether T is rvalue or lvalue; typically\n+/// used for forwarding a container's elements.\n+template <typename T, typename U>\n+forwarded_type<T, U> forward_like(U &&u) {\n+    return std::forward<detail::forwarded_type<T, U>>(std::forward<U>(u));\n+}\n+\n+template <typename Type, typename Key>\n+struct set_caster {\n+    using type = Type;\n+    using key_conv = make_caster<Key>;\n+\n+    bool load(handle src, bool convert) {\n+        if (!isinstance<anyset>(src)) {\n+            return false;\n+        }\n+        auto s = reinterpret_borrow<anyset>(src);\n+        value.clear();\n+        for (auto entry : s) {\n+            key_conv conv;\n+            if (!conv.load(entry, convert)) {\n+                return false;\n+            }\n+            value.insert(cast_op<Key &&>(std::move(conv)));\n+        }\n+        return true;\n+    }\n+\n+    template <typename T>\n+    static handle cast(T &&src, return_value_policy policy, handle parent) {\n+        if (!std::is_lvalue_reference<T>::value) {\n+            policy = return_value_policy_override<Key>::policy(policy);\n+        }\n+        pybind11::set s;\n+        for (auto &&value : src) {\n+            auto value_ = reinterpret_steal<object>(\n+                key_conv::cast(forward_like<T>(value), policy, parent));\n+            if (!value_ || !s.add(std::move(value_))) {\n+                return handle();\n+            }\n+        }\n+        return s.release();\n+    }\n+\n+    PYBIND11_TYPE_CASTER(type, const_name(\"Set[\") + key_conv::name + const_name(\"]\"));\n+};\n+\n+template <typename Type, typename Key, typename Value>\n+struct map_caster {\n+    using key_conv = make_caster<Key>;\n+    using value_conv = make_caster<Value>;\n+\n+    bool load(handle src, bool convert) {\n+        if (!isinstance<dict>(src)) {\n+            return false;\n+        }\n+        auto d = reinterpret_borrow<dict>(src);\n+        value.clear();\n+        for (auto it : d) {\n+            key_conv kconv;\n+            value_conv vconv;\n+            if (!kconv.load(it.first.ptr(), convert) || !vconv.load(it.second.ptr(), convert)) {\n+                return false;\n+            }\n+            value.emplace(cast_op<Key &&>(std::move(kconv)), cast_op<Value &&>(std::move(vconv)));\n+        }\n+        return true;\n+    }\n+\n+    template <typename T>\n+    static handle cast(T &&src, return_value_policy policy, handle parent) {\n+        dict d;\n+        return_value_policy policy_key = policy;\n+        return_value_policy policy_value = policy;\n+        if (!std::is_lvalue_reference<T>::value) {\n+            policy_key = return_value_policy_override<Key>::policy(policy_key);\n+            policy_value = return_value_policy_override<Value>::policy(policy_value);\n+        }\n+        for (auto &&kv : src) {\n+            auto key = reinterpret_steal<object>(\n+                key_conv::cast(forward_like<T>(kv.first), policy_key, parent));\n+            auto value = reinterpret_steal<object>(\n+                value_conv::cast(forward_like<T>(kv.second), policy_value, parent));\n+            if (!key || !value) {\n+                return handle();\n+            }\n+            d[std::move(key)] = std::move(value);\n+        }\n+        return d.release();\n+    }\n+\n+    PYBIND11_TYPE_CASTER(Type,\n+                         const_name(\"Dict[\") + key_conv::name + const_name(\", \") + value_conv::name\n+                             + const_name(\"]\"));\n+};\n+\n+template <typename Type, typename Value>\n+struct list_caster {\n+    using value_conv = make_caster<Value>;\n+\n+    bool load(handle src, bool convert) {\n+        if (!isinstance<sequence>(src) || isinstance<bytes>(src) || isinstance<str>(src)) {\n+            return false;\n+        }\n+        auto s = reinterpret_borrow<sequence>(src);\n+        value.clear();\n+        reserve_maybe(s, &value);\n+        for (auto it : s) {\n+            value_conv conv;\n+            if (!conv.load(it, convert)) {\n+                return false;\n+            }\n+            value.push_back(cast_op<Value &&>(std::move(conv)));\n+        }\n+        return true;\n+    }\n+\n+private:\n+    template <\n+        typename T = Type,\n+        enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)), void>::value, int> = 0>\n+    void reserve_maybe(const sequence &s, Type *) {\n+        value.reserve(s.size());\n+    }\n+    void reserve_maybe(const sequence &, void *) {}\n+\n+public:\n+    template <typename T>\n+    static handle cast(T &&src, return_value_policy policy, handle parent) {\n+        if (!std::is_lvalue_reference<T>::value) {\n+            policy = return_value_policy_override<Value>::policy(policy);\n+        }\n+        list l(src.size());\n+        ssize_t index = 0;\n+        for (auto &&value : src) {\n+            auto value_ = reinterpret_steal<object>(\n+                value_conv::cast(forward_like<T>(value), policy, parent));\n+            if (!value_) {\n+                return handle();\n+            }\n+            PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference\n+        }\n+        return l.release();\n+    }\n+\n+    PYBIND11_TYPE_CASTER(Type, const_name(\"List[\") + value_conv::name + const_name(\"]\"));\n+};\n+\n+template <typename Type, typename Alloc>\n+struct type_caster<std::vector<Type, Alloc>> : list_caster<std::vector<Type, Alloc>, Type> {};\n+\n+template <typename Type, typename Alloc>\n+struct type_caster<std::deque<Type, Alloc>> : list_caster<std::deque<Type, Alloc>, Type> {};\n+\n+template <typename Type, typename Alloc>\n+struct type_caster<std::list<Type, Alloc>> : list_caster<std::list<Type, Alloc>, Type> {};\n+\n+template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0>\n+struct array_caster {\n+    using value_conv = make_caster<Value>;\n+\n+private:\n+    template <bool R = Resizable>\n+    bool require_size(enable_if_t<R, size_t> size) {\n+        if (value.size() != size) {\n+            value.resize(size);\n+        }\n+        return true;\n+    }\n+    template <bool R = Resizable>\n+    bool require_size(enable_if_t<!R, size_t> size) {\n+        return size == Size;\n+    }\n+\n+public:\n+    bool load(handle src, bool convert) {\n+        if (!isinstance<sequence>(src)) {\n+            return false;\n+        }\n+        auto l = reinterpret_borrow<sequence>(src);\n+        if (!require_size(l.size())) {\n+            return false;\n+        }\n+        size_t ctr = 0;\n+        for (auto it : l) {\n+            value_conv conv;\n+            if (!conv.load(it, convert)) {\n+                return false;\n+            }\n+            value[ctr++] = cast_op<Value &&>(std::move(conv));\n+        }\n+        return true;\n+    }\n+\n+    template <typename T>\n+    static handle cast(T &&src, return_value_policy policy, handle parent) {\n+        list l(src.size());\n+        ssize_t index = 0;\n+        for (auto &&value : src) {\n+            auto value_ = reinterpret_steal<object>(\n+                value_conv::cast(forward_like<T>(value), policy, parent));\n+            if (!value_) {\n+                return handle();\n+            }\n+            PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference\n+        }\n+        return l.release();\n+    }\n+\n+    PYBIND11_TYPE_CASTER(ArrayType,\n+                         const_name(\"List[\") + value_conv::name\n+                             + const_name<Resizable>(const_name(\"\"),\n+                                                     const_name(\"[\") + const_name<Size>()\n+                                                         + const_name(\"]\"))\n+                             + const_name(\"]\"));\n+};\n+\n+template <typename Type, size_t Size>\n+struct type_caster<std::array<Type, Size>>\n+    : array_caster<std::array<Type, Size>, Type, false, Size> {};\n+\n+template <typename Type>\n+struct type_caster<std::valarray<Type>> : array_caster<std::valarray<Type>, Type, true> {};\n+\n+template <typename Key, typename Compare, typename Alloc>\n+struct type_caster<std::set<Key, Compare, Alloc>>\n+    : set_caster<std::set<Key, Compare, Alloc>, Key> {};\n+\n+template <typename Key, typename Hash, typename Equal, typename Alloc>\n+struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>\n+    : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> {};\n+\n+template <typename Key, typename Value, typename Compare, typename Alloc>\n+struct type_caster<std::map<Key, Value, Compare, Alloc>>\n+    : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> {};\n+\n+template <typename Key, typename Value, typename Hash, typename Equal, typename Alloc>\n+struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>\n+    : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key, Value> {};\n+\n+// This type caster is intended to be used for std::optional and std::experimental::optional\n+template <typename Type, typename Value = typename Type::value_type>\n+struct optional_caster {\n+    using value_conv = make_caster<Value>;\n+\n+    template <typename T>\n+    static handle cast(T &&src, return_value_policy policy, handle parent) {\n+        if (!src) {\n+            return none().inc_ref();\n+        }\n+        if (!std::is_lvalue_reference<T>::value) {\n+            policy = return_value_policy_override<Value>::policy(policy);\n+        }\n+        return value_conv::cast(*std::forward<T>(src), policy, parent);\n+    }\n+\n+    bool load(handle src, bool convert) {\n+        if (!src) {\n+            return false;\n+        }\n+        if (src.is_none()) {\n+            return true; // default-constructed value is already empty\n+        }\n+        value_conv inner_caster;\n+        if (!inner_caster.load(src, convert)) {\n+            return false;\n+        }\n+\n+        value.emplace(cast_op<Value &&>(std::move(inner_caster)));\n+        return true;\n+    }\n+\n+    PYBIND11_TYPE_CASTER(Type, const_name(\"Optional[\") + value_conv::name + const_name(\"]\"));\n+};\n+\n+#if defined(PYBIND11_HAS_OPTIONAL)\n+template <typename T>\n+struct type_caster<std::optional<T>> : public optional_caster<std::optional<T>> {};\n+\n+template <>\n+struct type_caster<std::nullopt_t> : public void_caster<std::nullopt_t> {};\n+#endif\n+\n+#if defined(PYBIND11_HAS_EXP_OPTIONAL)\n+template <typename T>\n+struct type_caster<std::experimental::optional<T>>\n+    : public optional_caster<std::experimental::optional<T>> {};\n+\n+template <>\n+struct type_caster<std::experimental::nullopt_t>\n+    : public void_caster<std::experimental::nullopt_t> {};\n+#endif\n+\n+/// Visit a variant and cast any found type to Python\n+struct variant_caster_visitor {\n+    return_value_policy policy;\n+    handle parent;\n+\n+    using result_type = handle; // required by boost::variant in C++11\n+\n+    template <typename T>\n+    result_type operator()(T &&src) const {\n+        return make_caster<T>::cast(std::forward<T>(src), policy, parent);\n+    }\n+};\n+\n+/// Helper class which abstracts away variant's `visit` function. `std::variant` and similar\n+/// `namespace::variant` types which provide a `namespace::visit()` function are handled here\n+/// automatically using argument-dependent lookup. Users can provide specializations for other\n+/// variant-like classes, e.g. `boost::variant` and `boost::apply_visitor`.\n+template <template <typename...> class Variant>\n+struct visit_helper {\n+    template <typename... Args>\n+    static auto call(Args &&...args) -> decltype(visit(std::forward<Args>(args)...)) {\n+        return visit(std::forward<Args>(args)...);\n+    }\n+};\n+\n+/// Generic variant caster\n+template <typename Variant>\n+struct variant_caster;\n+\n+template <template <typename...> class V, typename... Ts>\n+struct variant_caster<V<Ts...>> {\n+    static_assert(sizeof...(Ts) > 0, \"Variant must consist of at least one alternative.\");\n+\n+    template <typename U, typename... Us>\n+    bool load_alternative(handle src, bool convert, type_list<U, Us...>) {\n+        auto caster = make_caster<U>();\n+        if (caster.load(src, convert)) {\n+            value = cast_op<U>(std::move(caster));\n+            return true;\n+        }\n+        return load_alternative(src, convert, type_list<Us...>{});\n+    }\n+\n+    bool load_alternative(handle, bool, type_list<>) { return false; }\n+\n+    bool load(handle src, bool convert) {\n+        // Do a first pass without conversions to improve constructor resolution.\n+        // E.g. `py::int_(1).cast<variant<double, int>>()` needs to fill the `int`\n+        // slot of the variant. Without two-pass loading `double` would be filled\n+        // because it appears first and a conversion is possible.\n+        if (convert && load_alternative(src, false, type_list<Ts...>{})) {\n+            return true;\n+        }\n+        return load_alternative(src, convert, type_list<Ts...>{});\n+    }\n+\n+    template <typename Variant>\n+    static handle cast(Variant &&src, return_value_policy policy, handle parent) {\n+        return visit_helper<V>::call(variant_caster_visitor{policy, parent},\n+                                     std::forward<Variant>(src));\n+    }\n+\n+    using Type = V<Ts...>;\n+    PYBIND11_TYPE_CASTER(Type,\n+                         const_name(\"Union[\") + detail::concat(make_caster<Ts>::name...)\n+                             + const_name(\"]\"));\n+};\n+\n+#if defined(PYBIND11_HAS_VARIANT)\n+template <typename... Ts>\n+struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> {};\n+\n+template <>\n+struct type_caster<std::monostate> : public void_caster<std::monostate> {};\n+#endif\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+inline std::ostream &operator<<(std::ostream &os, const handle &obj) {\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+    os << str(obj).cast<std::string_view>();\n+#else\n+    os << (std::string) str(obj);\n+#endif\n+    return os;\n+}\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/stl/filesystem.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "file_content_changes": "@@ -0,0 +1,116 @@\n+// Copyright (c) 2021 The Pybind Development Team.\n+// All rights reserved. Use of this source code is governed by a\n+// BSD-style license that can be found in the LICENSE file.\n+\n+#pragma once\n+\n+#include \"../pybind11.h\"\n+#include \"../detail/common.h\"\n+#include \"../detail/descr.h\"\n+#include \"../cast.h\"\n+#include \"../pytypes.h\"\n+\n+#include <string>\n+\n+#ifdef __has_include\n+#    if defined(PYBIND11_CPP17)\n+#        if __has_include(<filesystem>) && \\\n+          PY_VERSION_HEX >= 0x03060000\n+#            include <filesystem>\n+#            define PYBIND11_HAS_FILESYSTEM 1\n+#        elif __has_include(<experimental/filesystem>)\n+#            include <experimental/filesystem>\n+#            define PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM 1\n+#        endif\n+#    endif\n+#endif\n+\n+#if !defined(PYBIND11_HAS_FILESYSTEM) && !defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)           \\\n+    && !defined(PYBIND11_HAS_FILESYSTEM_IS_OPTIONAL)\n+#    error                                                                                        \\\n+        \"Neither #include <filesystem> nor #include <experimental/filesystem is available. (Use -DPYBIND11_HAS_FILESYSTEM_IS_OPTIONAL to ignore.)\"\n+#endif\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+#if defined(PYBIND11_HAS_FILESYSTEM) || defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)\n+template <typename T>\n+struct path_caster {\n+\n+private:\n+    static PyObject *unicode_from_fs_native(const std::string &w) {\n+#    if !defined(PYPY_VERSION)\n+        return PyUnicode_DecodeFSDefaultAndSize(w.c_str(), ssize_t(w.size()));\n+#    else\n+        // PyPy mistakenly declares the first parameter as non-const.\n+        return PyUnicode_DecodeFSDefaultAndSize(const_cast<char *>(w.c_str()), ssize_t(w.size()));\n+#    endif\n+    }\n+\n+    static PyObject *unicode_from_fs_native(const std::wstring &w) {\n+        return PyUnicode_FromWideChar(w.c_str(), ssize_t(w.size()));\n+    }\n+\n+public:\n+    static handle cast(const T &path, return_value_policy, handle) {\n+        if (auto py_str = unicode_from_fs_native(path.native())) {\n+            return module_::import(\"pathlib\")\n+                .attr(\"Path\")(reinterpret_steal<object>(py_str))\n+                .release();\n+        }\n+        return nullptr;\n+    }\n+\n+    bool load(handle handle, bool) {\n+        // PyUnicode_FSConverter and PyUnicode_FSDecoder normally take care of\n+        // calling PyOS_FSPath themselves, but that's broken on PyPy (PyPy\n+        // issue #3168) so we do it ourselves instead.\n+        PyObject *buf = PyOS_FSPath(handle.ptr());\n+        if (!buf) {\n+            PyErr_Clear();\n+            return false;\n+        }\n+        PyObject *native = nullptr;\n+        if constexpr (std::is_same_v<typename T::value_type, char>) {\n+            if (PyUnicode_FSConverter(buf, &native) != 0) {\n+                if (auto *c_str = PyBytes_AsString(native)) {\n+                    // AsString returns a pointer to the internal buffer, which\n+                    // must not be free'd.\n+                    value = c_str;\n+                }\n+            }\n+        } else if constexpr (std::is_same_v<typename T::value_type, wchar_t>) {\n+            if (PyUnicode_FSDecoder(buf, &native) != 0) {\n+                if (auto *c_str = PyUnicode_AsWideCharString(native, nullptr)) {\n+                    // AsWideCharString returns a new string that must be free'd.\n+                    value = c_str; // Copies the string.\n+                    PyMem_Free(c_str);\n+                }\n+            }\n+        }\n+        Py_XDECREF(native);\n+        Py_DECREF(buf);\n+        if (PyErr_Occurred()) {\n+            PyErr_Clear();\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    PYBIND11_TYPE_CASTER(T, const_name(\"os.PathLike\"));\n+};\n+\n+#endif // PYBIND11_HAS_FILESYSTEM || defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)\n+\n+#if defined(PYBIND11_HAS_FILESYSTEM)\n+template <>\n+struct type_caster<std::filesystem::path> : public path_caster<std::filesystem::path> {};\n+#elif defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)\n+template <>\n+struct type_caster<std::experimental::filesystem::path>\n+    : public path_caster<std::experimental::filesystem::path> {};\n+#endif\n+\n+PYBIND11_NAMESPACE_END(detail)\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/stl_bind.h", "status": "added", "additions": 785, "deletions": 0, "changes": 785, "file_content_changes": "@@ -0,0 +1,785 @@\n+/*\n+    pybind11/std_bind.h: Binding generators for STL data types\n+\n+    Copyright (c) 2016 Sergey Lyskov and Wenzel Jakob\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+#include \"operators.h\"\n+\n+#include <algorithm>\n+#include <sstream>\n+\n+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/* SFINAE helper class used by 'is_comparable */\n+template <typename T>\n+struct container_traits {\n+    template <typename T2>\n+    static std::true_type\n+    test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>()) *);\n+    template <typename T2>\n+    static std::false_type test_comparable(...);\n+    template <typename T2>\n+    static std::true_type test_value(typename T2::value_type *);\n+    template <typename T2>\n+    static std::false_type test_value(...);\n+    template <typename T2>\n+    static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);\n+    template <typename T2>\n+    static std::false_type test_pair(...);\n+\n+    static constexpr const bool is_comparable\n+        = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;\n+    static constexpr const bool is_pair\n+        = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;\n+    static constexpr const bool is_vector\n+        = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;\n+    static constexpr const bool is_element = !is_pair && !is_vector;\n+};\n+\n+/* Default: is_comparable -> std::false_type */\n+template <typename T, typename SFINAE = void>\n+struct is_comparable : std::false_type {};\n+\n+/* For non-map data structures, check whether operator== can be instantiated */\n+template <typename T>\n+struct is_comparable<\n+    T,\n+    enable_if_t<container_traits<T>::is_element && container_traits<T>::is_comparable>>\n+    : std::true_type {};\n+\n+/* For a vector/map data structure, recursively check the value type\n+   (which is std::pair for maps) */\n+template <typename T>\n+struct is_comparable<T, enable_if_t<container_traits<T>::is_vector>> {\n+    static constexpr const bool value = is_comparable<typename T::value_type>::value;\n+};\n+\n+/* For pairs, recursively check the two data types */\n+template <typename T>\n+struct is_comparable<T, enable_if_t<container_traits<T>::is_pair>> {\n+    static constexpr const bool value = is_comparable<typename T::first_type>::value\n+                                        && is_comparable<typename T::second_type>::value;\n+};\n+\n+/* Fallback functions */\n+template <typename, typename, typename... Args>\n+void vector_if_copy_constructible(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_if_equal_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_if_insertion_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_modifiers(const Args &...) {}\n+\n+template <typename Vector, typename Class_>\n+void vector_if_copy_constructible(enable_if_t<is_copy_constructible<Vector>::value, Class_> &cl) {\n+    cl.def(init<const Vector &>(), \"Copy constructor\");\n+}\n+\n+template <typename Vector, typename Class_>\n+void vector_if_equal_operator(enable_if_t<is_comparable<Vector>::value, Class_> &cl) {\n+    using T = typename Vector::value_type;\n+\n+    cl.def(self == self);\n+    cl.def(self != self);\n+\n+    cl.def(\n+        \"count\",\n+        [](const Vector &v, const T &x) { return std::count(v.begin(), v.end(), x); },\n+        arg(\"x\"),\n+        \"Return the number of times ``x`` appears in the list\");\n+\n+    cl.def(\n+        \"remove\",\n+        [](Vector &v, const T &x) {\n+            auto p = std::find(v.begin(), v.end(), x);\n+            if (p != v.end()) {\n+                v.erase(p);\n+            } else {\n+                throw value_error();\n+            }\n+        },\n+        arg(\"x\"),\n+        \"Remove the first item from the list whose value is x. \"\n+        \"It is an error if there is no such item.\");\n+\n+    cl.def(\n+        \"__contains__\",\n+        [](const Vector &v, const T &x) { return std::find(v.begin(), v.end(), x) != v.end(); },\n+        arg(\"x\"),\n+        \"Return true the container contains ``x``\");\n+}\n+\n+// Vector modifiers -- requires a copyable vector_type:\n+// (Technically, some of these (pop and __delitem__) don't actually require copyability, but it\n+// seems silly to allow deletion but not insertion, so include them here too.)\n+template <typename Vector, typename Class_>\n+void vector_modifiers(\n+    enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {\n+    using T = typename Vector::value_type;\n+    using SizeType = typename Vector::size_type;\n+    using DiffType = typename Vector::difference_type;\n+\n+    auto wrap_i = [](DiffType i, SizeType n) {\n+        if (i < 0) {\n+            i += n;\n+        }\n+        if (i < 0 || (SizeType) i >= n) {\n+            throw index_error();\n+        }\n+        return i;\n+    };\n+\n+    cl.def(\n+        \"append\",\n+        [](Vector &v, const T &value) { v.push_back(value); },\n+        arg(\"x\"),\n+        \"Add an item to the end of the list\");\n+\n+    cl.def(init([](const iterable &it) {\n+        auto v = std::unique_ptr<Vector>(new Vector());\n+        v->reserve(len_hint(it));\n+        for (handle h : it) {\n+            v->push_back(h.cast<T>());\n+        }\n+        return v.release();\n+    }));\n+\n+    cl.def(\n+        \"clear\", [](Vector &v) { v.clear(); }, \"Clear the contents\");\n+\n+    cl.def(\n+        \"extend\",\n+        [](Vector &v, const Vector &src) { v.insert(v.end(), src.begin(), src.end()); },\n+        arg(\"L\"),\n+        \"Extend the list by appending all the items in the given list\");\n+\n+    cl.def(\n+        \"extend\",\n+        [](Vector &v, const iterable &it) {\n+            const size_t old_size = v.size();\n+            v.reserve(old_size + len_hint(it));\n+            try {\n+                for (handle h : it) {\n+                    v.push_back(h.cast<T>());\n+                }\n+            } catch (const cast_error &) {\n+                v.erase(v.begin() + static_cast<typename Vector::difference_type>(old_size),\n+                        v.end());\n+                try {\n+                    v.shrink_to_fit();\n+                } catch (const std::exception &) {\n+                    // Do nothing\n+                }\n+                throw;\n+            }\n+        },\n+        arg(\"L\"),\n+        \"Extend the list by appending all the items in the given list\");\n+\n+    cl.def(\n+        \"insert\",\n+        [](Vector &v, DiffType i, const T &x) {\n+            // Can't use wrap_i; i == v.size() is OK\n+            if (i < 0) {\n+                i += v.size();\n+            }\n+            if (i < 0 || (SizeType) i > v.size()) {\n+                throw index_error();\n+            }\n+            v.insert(v.begin() + i, x);\n+        },\n+        arg(\"i\"),\n+        arg(\"x\"),\n+        \"Insert an item at a given position.\");\n+\n+    cl.def(\n+        \"pop\",\n+        [](Vector &v) {\n+            if (v.empty()) {\n+                throw index_error();\n+            }\n+            T t = std::move(v.back());\n+            v.pop_back();\n+            return t;\n+        },\n+        \"Remove and return the last item\");\n+\n+    cl.def(\n+        \"pop\",\n+        [wrap_i](Vector &v, DiffType i) {\n+            i = wrap_i(i, v.size());\n+            T t = std::move(v[(SizeType) i]);\n+            v.erase(std::next(v.begin(), i));\n+            return t;\n+        },\n+        arg(\"i\"),\n+        \"Remove and return the item at index ``i``\");\n+\n+    cl.def(\"__setitem__\", [wrap_i](Vector &v, DiffType i, const T &t) {\n+        i = wrap_i(i, v.size());\n+        v[(SizeType) i] = t;\n+    });\n+\n+    /// Slicing protocol\n+    cl.def(\n+        \"__getitem__\",\n+        [](const Vector &v, const slice &slice) -> Vector * {\n+            size_t start = 0, stop = 0, step = 0, slicelength = 0;\n+\n+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {\n+                throw error_already_set();\n+            }\n+\n+            auto *seq = new Vector();\n+            seq->reserve((size_t) slicelength);\n+\n+            for (size_t i = 0; i < slicelength; ++i) {\n+                seq->push_back(v[start]);\n+                start += step;\n+            }\n+            return seq;\n+        },\n+        arg(\"s\"),\n+        \"Retrieve list elements using a slice object\");\n+\n+    cl.def(\n+        \"__setitem__\",\n+        [](Vector &v, const slice &slice, const Vector &value) {\n+            size_t start = 0, stop = 0, step = 0, slicelength = 0;\n+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {\n+                throw error_already_set();\n+            }\n+\n+            if (slicelength != value.size()) {\n+                throw std::runtime_error(\n+                    \"Left and right hand size of slice assignment have different sizes!\");\n+            }\n+\n+            for (size_t i = 0; i < slicelength; ++i) {\n+                v[start] = value[i];\n+                start += step;\n+            }\n+        },\n+        \"Assign list elements using a slice object\");\n+\n+    cl.def(\n+        \"__delitem__\",\n+        [wrap_i](Vector &v, DiffType i) {\n+            i = wrap_i(i, v.size());\n+            v.erase(v.begin() + i);\n+        },\n+        \"Delete the list elements at index ``i``\");\n+\n+    cl.def(\n+        \"__delitem__\",\n+        [](Vector &v, const slice &slice) {\n+            size_t start = 0, stop = 0, step = 0, slicelength = 0;\n+\n+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {\n+                throw error_already_set();\n+            }\n+\n+            if (step == 1 && false) {\n+                v.erase(v.begin() + (DiffType) start, v.begin() + DiffType(start + slicelength));\n+            } else {\n+                for (size_t i = 0; i < slicelength; ++i) {\n+                    v.erase(v.begin() + DiffType(start));\n+                    start += step - 1;\n+                }\n+            }\n+        },\n+        \"Delete list elements using a slice object\");\n+}\n+\n+// If the type has an operator[] that doesn't return a reference (most notably std::vector<bool>),\n+// we have to access by copying; otherwise we return by reference.\n+template <typename Vector>\n+using vector_needs_copy\n+    = negation<std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]),\n+                            typename Vector::value_type &>>;\n+\n+// The usual case: access and iterate by reference\n+template <typename Vector, typename Class_>\n+void vector_accessor(enable_if_t<!vector_needs_copy<Vector>::value, Class_> &cl) {\n+    using T = typename Vector::value_type;\n+    using SizeType = typename Vector::size_type;\n+    using DiffType = typename Vector::difference_type;\n+    using ItType = typename Vector::iterator;\n+\n+    auto wrap_i = [](DiffType i, SizeType n) {\n+        if (i < 0) {\n+            i += n;\n+        }\n+        if (i < 0 || (SizeType) i >= n) {\n+            throw index_error();\n+        }\n+        return i;\n+    };\n+\n+    cl.def(\n+        \"__getitem__\",\n+        [wrap_i](Vector &v, DiffType i) -> T & {\n+            i = wrap_i(i, v.size());\n+            return v[(SizeType) i];\n+        },\n+        return_value_policy::reference_internal // ref + keepalive\n+    );\n+\n+    cl.def(\n+        \"__iter__\",\n+        [](Vector &v) {\n+            return make_iterator<return_value_policy::reference_internal, ItType, ItType, T &>(\n+                v.begin(), v.end());\n+        },\n+        keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+    );\n+}\n+\n+// The case for special objects, like std::vector<bool>, that have to be returned-by-copy:\n+template <typename Vector, typename Class_>\n+void vector_accessor(enable_if_t<vector_needs_copy<Vector>::value, Class_> &cl) {\n+    using T = typename Vector::value_type;\n+    using SizeType = typename Vector::size_type;\n+    using DiffType = typename Vector::difference_type;\n+    using ItType = typename Vector::iterator;\n+    cl.def(\"__getitem__\", [](const Vector &v, DiffType i) -> T {\n+        if (i < 0 && (i += v.size()) < 0) {\n+            throw index_error();\n+        }\n+        if ((SizeType) i >= v.size()) {\n+            throw index_error();\n+        }\n+        return v[(SizeType) i];\n+    });\n+\n+    cl.def(\n+        \"__iter__\",\n+        [](Vector &v) {\n+            return make_iterator<return_value_policy::copy, ItType, ItType, T>(v.begin(), v.end());\n+        },\n+        keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+    );\n+}\n+\n+template <typename Vector, typename Class_>\n+auto vector_if_insertion_operator(Class_ &cl, std::string const &name)\n+    -> decltype(std::declval<std::ostream &>() << std::declval<typename Vector::value_type>(),\n+                void()) {\n+    using size_type = typename Vector::size_type;\n+\n+    cl.def(\n+        \"__repr__\",\n+        [name](Vector &v) {\n+            std::ostringstream s;\n+            s << name << '[';\n+            for (size_type i = 0; i < v.size(); ++i) {\n+                s << v[i];\n+                if (i != v.size() - 1) {\n+                    s << \", \";\n+                }\n+            }\n+            s << ']';\n+            return s.str();\n+        },\n+        \"Return the canonical string representation of this list.\");\n+}\n+\n+// Provide the buffer interface for vectors if we have data() and we have a format for it\n+// GCC seems to have \"void std::vector<bool>::data()\" - doing SFINAE on the existence of data()\n+// is insufficient, we need to check it returns an appropriate pointer\n+template <typename Vector, typename = void>\n+struct vector_has_data_and_format : std::false_type {};\n+template <typename Vector>\n+struct vector_has_data_and_format<\n+    Vector,\n+    enable_if_t<std::is_same<decltype(format_descriptor<typename Vector::value_type>::format(),\n+                                      std::declval<Vector>().data()),\n+                             typename Vector::value_type *>::value>> : std::true_type {};\n+\n+// [workaround(intel)] Separate function required here\n+// Workaround as the Intel compiler does not compile the enable_if_t part below\n+// (tested with icc (ICC) 2021.1 Beta 20200827)\n+template <typename... Args>\n+constexpr bool args_any_are_buffer() {\n+    return detail::any_of<std::is_same<Args, buffer_protocol>...>::value;\n+}\n+\n+// [workaround(intel)] Separate function required here\n+// [workaround(msvc)] Can't use constexpr bool in return type\n+\n+// Add the buffer interface to a vector\n+template <typename Vector, typename Class_, typename... Args>\n+void vector_buffer_impl(Class_ &cl, std::true_type) {\n+    using T = typename Vector::value_type;\n+\n+    static_assert(vector_has_data_and_format<Vector>::value,\n+                  \"There is not an appropriate format descriptor for this vector\");\n+\n+    // numpy.h declares this for arbitrary types, but it may raise an exception and crash hard\n+    // at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so check here\n+    format_descriptor<T>::format();\n+\n+    cl.def_buffer([](Vector &v) -> buffer_info {\n+        return buffer_info(v.data(),\n+                           static_cast<ssize_t>(sizeof(T)),\n+                           format_descriptor<T>::format(),\n+                           1,\n+                           {v.size()},\n+                           {sizeof(T)});\n+    });\n+\n+    cl.def(init([](const buffer &buf) {\n+        auto info = buf.request();\n+        if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T))) {\n+            throw type_error(\"Only valid 1D buffers can be copied to a vector\");\n+        }\n+        if (!detail::compare_buffer_info<T>::compare(info)\n+            || (ssize_t) sizeof(T) != info.itemsize) {\n+            throw type_error(\"Format mismatch (Python: \" + info.format\n+                             + \" C++: \" + format_descriptor<T>::format() + \")\");\n+        }\n+\n+        T *p = static_cast<T *>(info.ptr);\n+        ssize_t step = info.strides[0] / static_cast<ssize_t>(sizeof(T));\n+        T *end = p + info.shape[0] * step;\n+        if (step == 1) {\n+            return Vector(p, end);\n+        }\n+        Vector vec;\n+        vec.reserve((size_t) info.shape[0]);\n+        for (; p != end; p += step) {\n+            vec.push_back(*p);\n+        }\n+        return vec;\n+    }));\n+\n+    return;\n+}\n+\n+template <typename Vector, typename Class_, typename... Args>\n+void vector_buffer_impl(Class_ &, std::false_type) {}\n+\n+template <typename Vector, typename Class_, typename... Args>\n+void vector_buffer(Class_ &cl) {\n+    vector_buffer_impl<Vector, Class_, Args...>(\n+        cl, detail::any_of<std::is_same<Args, buffer_protocol>...>{});\n+}\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+//\n+// std::vector\n+//\n+template <typename Vector, typename holder_type = std::unique_ptr<Vector>, typename... Args>\n+class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args &&...args) {\n+    using Class_ = class_<Vector, holder_type>;\n+\n+    // If the value_type is unregistered (e.g. a converting type) or is itself registered\n+    // module-local then make the vector binding module-local as well:\n+    using vtype = typename Vector::value_type;\n+    auto *vtype_info = detail::get_type_info(typeid(vtype));\n+    bool local = !vtype_info || vtype_info->module_local;\n+\n+    Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);\n+\n+    // Declare the buffer interface if a buffer_protocol() is passed in\n+    detail::vector_buffer<Vector, Class_, Args...>(cl);\n+\n+    cl.def(init<>());\n+\n+    // Register copy constructor (if possible)\n+    detail::vector_if_copy_constructible<Vector, Class_>(cl);\n+\n+    // Register comparison-related operators and functions (if possible)\n+    detail::vector_if_equal_operator<Vector, Class_>(cl);\n+\n+    // Register stream insertion operator (if possible)\n+    detail::vector_if_insertion_operator<Vector, Class_>(cl, name);\n+\n+    // Modifiers require copyable vector value type\n+    detail::vector_modifiers<Vector, Class_>(cl);\n+\n+    // Accessor and iterator; return by value if copyable, otherwise we return by ref + keep-alive\n+    detail::vector_accessor<Vector, Class_>(cl);\n+\n+    cl.def(\n+        \"__bool__\",\n+        [](const Vector &v) -> bool { return !v.empty(); },\n+        \"Check whether the list is nonempty\");\n+\n+    cl.def(\"__len__\", &Vector::size);\n+\n+#if 0\n+    // C++ style functions deprecated, leaving it here as an example\n+    cl.def(init<size_type>());\n+\n+    cl.def(\"resize\",\n+         (void (Vector::*) (size_type count)) & Vector::resize,\n+         \"changes the number of elements stored\");\n+\n+    cl.def(\"erase\",\n+        [](Vector &v, SizeType i) {\n+        if (i >= v.size())\n+            throw index_error();\n+        v.erase(v.begin() + i);\n+    }, \"erases element at index ``i``\");\n+\n+    cl.def(\"empty\",         &Vector::empty,         \"checks whether the container is empty\");\n+    cl.def(\"size\",          &Vector::size,          \"returns the number of elements\");\n+    cl.def(\"push_back\", (void (Vector::*)(const T&)) &Vector::push_back, \"adds an element to the end\");\n+    cl.def(\"pop_back\",                               &Vector::pop_back, \"removes the last element\");\n+\n+    cl.def(\"max_size\",      &Vector::max_size,      \"returns the maximum possible number of elements\");\n+    cl.def(\"reserve\",       &Vector::reserve,       \"reserves storage\");\n+    cl.def(\"capacity\",      &Vector::capacity,      \"returns the number of elements that can be held in currently allocated storage\");\n+    cl.def(\"shrink_to_fit\", &Vector::shrink_to_fit, \"reduces memory usage by freeing unused memory\");\n+\n+    cl.def(\"clear\", &Vector::clear, \"clears the contents\");\n+    cl.def(\"swap\",   &Vector::swap, \"swaps the contents\");\n+\n+    cl.def(\"front\", [](Vector &v) {\n+        if (v.size()) return v.front();\n+        else throw index_error();\n+    }, \"access the first element\");\n+\n+    cl.def(\"back\", [](Vector &v) {\n+        if (v.size()) return v.back();\n+        else throw index_error();\n+    }, \"access the last element \");\n+\n+#endif\n+\n+    return cl;\n+}\n+\n+//\n+// std::map, std::unordered_map\n+//\n+\n+PYBIND11_NAMESPACE_BEGIN(detail)\n+\n+/* Fallback functions */\n+template <typename, typename, typename... Args>\n+void map_if_insertion_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void map_assignment(const Args &...) {}\n+\n+// Map assignment when copy-assignable: just copy the value\n+template <typename Map, typename Class_>\n+void map_assignment(\n+    enable_if_t<is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {\n+    using KeyType = typename Map::key_type;\n+    using MappedType = typename Map::mapped_type;\n+\n+    cl.def(\"__setitem__\", [](Map &m, const KeyType &k, const MappedType &v) {\n+        auto it = m.find(k);\n+        if (it != m.end()) {\n+            it->second = v;\n+        } else {\n+            m.emplace(k, v);\n+        }\n+    });\n+}\n+\n+// Not copy-assignable, but still copy-constructible: we can update the value by erasing and\n+// reinserting\n+template <typename Map, typename Class_>\n+void map_assignment(enable_if_t<!is_copy_assignable<typename Map::mapped_type>::value\n+                                    && is_copy_constructible<typename Map::mapped_type>::value,\n+                                Class_> &cl) {\n+    using KeyType = typename Map::key_type;\n+    using MappedType = typename Map::mapped_type;\n+\n+    cl.def(\"__setitem__\", [](Map &m, const KeyType &k, const MappedType &v) {\n+        // We can't use m[k] = v; because value type might not be default constructable\n+        auto r = m.emplace(k, v);\n+        if (!r.second) {\n+            // value type is not copy assignable so the only way to insert it is to erase it\n+            // first...\n+            m.erase(r.first);\n+            m.emplace(k, v);\n+        }\n+    });\n+}\n+\n+template <typename Map, typename Class_>\n+auto map_if_insertion_operator(Class_ &cl, std::string const &name)\n+    -> decltype(std::declval<std::ostream &>() << std::declval<typename Map::key_type>()\n+                                               << std::declval<typename Map::mapped_type>(),\n+                void()) {\n+\n+    cl.def(\n+        \"__repr__\",\n+        [name](Map &m) {\n+            std::ostringstream s;\n+            s << name << '{';\n+            bool f = false;\n+            for (auto const &kv : m) {\n+                if (f) {\n+                    s << \", \";\n+                }\n+                s << kv.first << \": \" << kv.second;\n+                f = true;\n+            }\n+            s << '}';\n+            return s.str();\n+        },\n+        \"Return the canonical string representation of this map.\");\n+}\n+\n+template <typename Map>\n+struct keys_view {\n+    Map &map;\n+};\n+\n+template <typename Map>\n+struct values_view {\n+    Map &map;\n+};\n+\n+template <typename Map>\n+struct items_view {\n+    Map &map;\n+};\n+\n+PYBIND11_NAMESPACE_END(detail)\n+\n+template <typename Map, typename holder_type = std::unique_ptr<Map>, typename... Args>\n+class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args &&...args) {\n+    using KeyType = typename Map::key_type;\n+    using MappedType = typename Map::mapped_type;\n+    using KeysView = detail::keys_view<Map>;\n+    using ValuesView = detail::values_view<Map>;\n+    using ItemsView = detail::items_view<Map>;\n+    using Class_ = class_<Map, holder_type>;\n+\n+    // If either type is a non-module-local bound type then make the map binding non-local as well;\n+    // otherwise (e.g. both types are either module-local or converting) the map will be\n+    // module-local.\n+    auto *tinfo = detail::get_type_info(typeid(MappedType));\n+    bool local = !tinfo || tinfo->module_local;\n+    if (local) {\n+        tinfo = detail::get_type_info(typeid(KeyType));\n+        local = !tinfo || tinfo->module_local;\n+    }\n+\n+    Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);\n+    class_<KeysView> keys_view(\n+        scope, (\"KeysView[\" + name + \"]\").c_str(), pybind11::module_local(local));\n+    class_<ValuesView> values_view(\n+        scope, (\"ValuesView[\" + name + \"]\").c_str(), pybind11::module_local(local));\n+    class_<ItemsView> items_view(\n+        scope, (\"ItemsView[\" + name + \"]\").c_str(), pybind11::module_local(local));\n+\n+    cl.def(init<>());\n+\n+    // Register stream insertion operator (if possible)\n+    detail::map_if_insertion_operator<Map, Class_>(cl, name);\n+\n+    cl.def(\n+        \"__bool__\",\n+        [](const Map &m) -> bool { return !m.empty(); },\n+        \"Check whether the map is nonempty\");\n+\n+    cl.def(\n+        \"__iter__\",\n+        [](Map &m) { return make_key_iterator(m.begin(), m.end()); },\n+        keep_alive<0, 1>() /* Essential: keep map alive while iterator exists */\n+    );\n+\n+    cl.def(\n+        \"keys\",\n+        [](Map &m) { return KeysView{m}; },\n+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */\n+    );\n+\n+    cl.def(\n+        \"values\",\n+        [](Map &m) { return ValuesView{m}; },\n+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */\n+    );\n+\n+    cl.def(\n+        \"items\",\n+        [](Map &m) { return ItemsView{m}; },\n+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */\n+    );\n+\n+    cl.def(\n+        \"__getitem__\",\n+        [](Map &m, const KeyType &k) -> MappedType & {\n+            auto it = m.find(k);\n+            if (it == m.end()) {\n+                throw key_error();\n+            }\n+            return it->second;\n+        },\n+        return_value_policy::reference_internal // ref + keepalive\n+    );\n+\n+    cl.def(\"__contains__\", [](Map &m, const KeyType &k) -> bool {\n+        auto it = m.find(k);\n+        if (it == m.end()) {\n+            return false;\n+        }\n+        return true;\n+    });\n+    // Fallback for when the object is not of the key type\n+    cl.def(\"__contains__\", [](Map &, const object &) -> bool { return false; });\n+\n+    // Assignment provided only if the type is copyable\n+    detail::map_assignment<Map, Class_>(cl);\n+\n+    cl.def(\"__delitem__\", [](Map &m, const KeyType &k) {\n+        auto it = m.find(k);\n+        if (it == m.end()) {\n+            throw key_error();\n+        }\n+        m.erase(it);\n+    });\n+\n+    cl.def(\"__len__\", &Map::size);\n+\n+    keys_view.def(\"__len__\", [](KeysView &view) { return view.map.size(); });\n+    keys_view.def(\n+        \"__iter__\",\n+        [](KeysView &view) { return make_key_iterator(view.map.begin(), view.map.end()); },\n+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */\n+    );\n+    keys_view.def(\"__contains__\", [](KeysView &view, const KeyType &k) -> bool {\n+        auto it = view.map.find(k);\n+        if (it == view.map.end()) {\n+            return false;\n+        }\n+        return true;\n+    });\n+    // Fallback for when the object is not of the key type\n+    keys_view.def(\"__contains__\", [](KeysView &, const object &) -> bool { return false; });\n+\n+    values_view.def(\"__len__\", [](ValuesView &view) { return view.map.size(); });\n+    values_view.def(\n+        \"__iter__\",\n+        [](ValuesView &view) { return make_value_iterator(view.map.begin(), view.map.end()); },\n+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */\n+    );\n+\n+    items_view.def(\"__len__\", [](ItemsView &view) { return view.map.size(); });\n+    items_view.def(\n+        \"__iter__\",\n+        [](ItemsView &view) { return make_iterator(view.map.begin(), view.map.end()); },\n+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */\n+    );\n+\n+    return cl;\n+}\n+\n+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "third-party/pybind11", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1 +0,0 @@\n-Subproject commit aa304c9c7d725ffb9d10af08a3b34cb372307020"}]