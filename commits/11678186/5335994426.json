[{"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.cpp", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "file_content_changes": "@@ -1180,6 +1180,35 @@ struct AbsFOpConversion\n   }\n };\n \n+/// The lowering of index_cast becomes an integer conversion since index\n+/// becomes an integer.  If the bit width of the source and target integer\n+/// types is the same, just erase the cast.  If the target type is wider,\n+/// sign-extend the value, otherwise truncate it.\n+struct IndexCastOpLowering\n+    : public ElementwiseOpConversionBase<arith::IndexCastOp,\n+                                         IndexCastOpLowering> {\n+  using Base =\n+      ElementwiseOpConversionBase<arith::IndexCastOp, IndexCastOpLowering>;\n+  using Base::Base;\n+  using Adaptor = typename Base::OpAdaptor;\n+\n+  Value createDestOp(arith::IndexCastOp op, OpAdaptor adaptor,\n+                     ConversionPatternRewriter &rewriter, Type elemTy,\n+                     ValueRange operands, Location loc) const {\n+    auto outElemTy = getElementType(op.getOut());\n+    auto inElemTy = getElementType(op.getIn());\n+    unsigned targetBits = outElemTy.getIntOrFloatBitWidth();\n+    unsigned sourceBits = inElemTy.getIntOrFloatBitWidth();\n+\n+    if (targetBits == sourceBits)\n+      return operands[0];\n+    if (targetBits < sourceBits)\n+      return rewriter.replaceOpWithNewOp<LLVM::TruncOp>(op, elemTy,\n+                                                        operands[0]);\n+    return rewriter.replaceOpWithNewOp<LLVM::SExtOp>(op, elemTy, operands[0]);\n+  }\n+};\n+\n void populateElementwiseOpToLLVMPatterns(\n     TritonGPUToLLVMTypeConverter &typeConverter, RewritePatternSet &patterns,\n     PatternBenefit benefit) {\n@@ -1240,6 +1269,7 @@ void populateElementwiseOpToLLVMPatterns(\n   patterns.add<TruncFOpConversion>(typeConverter, benefit);\n   patterns.add<FPToSIOpConversion>(typeConverter, benefit);\n   patterns.add<SIToFPOpConversion>(typeConverter, benefit);\n+  patterns.add<IndexCastOpLowering>(typeConverter, benefit);\n \n   patterns.add<FpToFpOpConversion>(typeConverter, benefit);\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -388,7 +388,7 @@ struct GetProgramIdOpConversion\n \n     Value blockId =\n         rewriter.create<::mlir::gpu::BlockIdOp>(loc, dims[op.getAxisAsInt()]);\n-    rewriter.replaceOpWithNewOp<arith::TruncIOp>(op, i32_ty, blockId);\n+    rewriter.replaceOpWithNewOp<arith::IndexCastOp>(op, i32_ty, blockId);\n     return success();\n   }\n \n@@ -410,7 +410,7 @@ struct GetNumProgramsOpConversion\n \n     Value blockId =\n         rewriter.create<::mlir::gpu::GridDimOp>(loc, dims[op.getAxis()]);\n-    rewriter.replaceOpWithNewOp<arith::TruncIOp>(op, i32_ty, blockId);\n+    rewriter.replaceOpWithNewOp<arith::IndexCastOp>(op, i32_ty, blockId);\n \n     return success();\n   }"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "file_content_changes": "@@ -217,10 +217,9 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n   }\n \n   Value getThreadId(ConversionPatternRewriter &rewriter, Location loc) const {\n-    auto llvmIndexTy = this->getTypeConverter()->getIndexType();\n     auto tid = rewriter.create<::mlir::gpu::ThreadIdOp>(\n-        loc, rewriter.getIndexType(), ::mlir::gpu::Dimension::x);\n-    return rewriter.create<arith::TruncIOp>(loc, i32_ty, tid);\n+        loc, ::mlir::gpu::Dimension::x);\n+    return rewriter.create<arith::IndexCastOp>(loc, i32_ty, tid);\n   }\n \n   // -----------------------------------------------------------------------"}]