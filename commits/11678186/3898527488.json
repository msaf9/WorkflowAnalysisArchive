[{"filename": "include/triton/Dialect/TritonGPU/IR/TritonGPUAttrDefs.td", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "file_content_changes": "@@ -424,6 +424,11 @@ For example, the matrix L corresponding to blockTileSize=[32,16] is:\n     // Number of bits in versionMinor to hold the ID of the MMA encoding instance.\n     // Here 5 bits can hold 32 IDs in a single module.\n     static constexpr int numBitsToHoldMmaV1ID{5};\n+\n+    // Here is a temporary flag that indicates whether we need to update the warpsPerCTA for MMAv1.\n+    // The mmav1's wpt-related logic is separated into multiple files, so a global flag is added here for universal coordination.\n+    // TODO[Superjomn]: Remove this flag once the MMAv1 backend is ready.\n+    static constexpr bool _mmaV1UpdateWpt{false};\n   }];\n \n }"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "file_content_changes": "@@ -887,9 +887,31 @@ SmallVector<int64_t, 2> mmaVersionToShapePerWarp(int version) {\n \n SmallVector<unsigned, 2> warpsPerTileV1(const ArrayRef<int64_t> shape,\n                                         int numWarps) {\n-  // The wpt for mmaV1 is determined in GPUCombine Pass, here we just set a\n-  // default value and ensure product of wpt equals numWarps\n-  return {static_cast<unsigned>(numWarps), 1};\n+  if (!MmaEncodingAttr::_mmaV1UpdateWpt) {\n+    SmallVector<unsigned, 2> ret = {1, 1};\n+    SmallVector<int64_t, 2> shapePerWarp =\n+        mmaVersionToShapePerWarp(1 /*version*/);\n+    bool changed = false;\n+    do {\n+      changed = false;\n+      int pre = ret[0];\n+      if (ret[0] * ret[1] < numWarps) {\n+        ret[0] =\n+            std::clamp<unsigned>(ret[0] * 2, 1, shape[0] / shapePerWarp[0]);\n+        changed = pre != ret[0];\n+      }\n+      if (ret[0] * ret[1] < numWarps) {\n+        pre = ret[1];\n+        ret[1] =\n+            std::clamp<unsigned>(ret[1] * 2, 1, shape[1] / shapePerWarp[1]);\n+        changed = pre != ret[1];\n+      }\n+    } while (changed);\n+    return ret;\n+  } else {\n+    // Set a default value and ensure product of wpt equals numWarps\n+    return {static_cast<unsigned>(numWarps), 1};\n+  }\n }\n \n SmallVector<unsigned, 2> warpsPerTileV2(triton::DotOp dotOp,\n@@ -1085,12 +1107,13 @@ class BlockedToMMA : public mlir::RewritePattern {\n         getWarpsPerTile(dotOp, retShape, versionMajor, numWarps);\n     triton::gpu::MmaEncodingAttr mmaEnc;\n     if (versionMajor == 1) {\n-      auto shapeA = AType.getShape();\n-      auto shapeB = BType.getShape();\n-      bool isARow = AOrder[0] != 0;\n-      bool isBRow = BOrder[0] != 0;\n-      mmaEnc = triton::gpu::MmaEncodingAttr::get(\n-          oldRetType.getContext(), versionMajor, numWarps, mmaV1Counter++);\n+      if (MmaEncodingAttr::_mmaV1UpdateWpt)\n+        mmaEnc = triton::gpu::MmaEncodingAttr::get(\n+            oldRetType.getContext(), versionMajor, numWarps, mmaV1Counter++);\n+      else\n+        mmaEnc = triton::gpu::MmaEncodingAttr::get(\n+            dotOp->getContext(), versionMajor, 0 /*versionMinor*/,\n+            warpsPerTileV1(retShape, numWarps));\n     } else if (versionMajor == 2) {\n       mmaEnc = triton::gpu::MmaEncodingAttr::get(\n           oldRetType.getContext(), versionMajor, 0 /*versionMinor*/,"}, {"filename": "lib/Dialect/TritonGPU/Transforms/UpdateMmaForVolta.cpp", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "file_content_changes": "@@ -63,7 +63,8 @@ class CollectMmaToUpdateForVolta : public mlir::RewritePattern {\n           getWarpsPerCTA(DT.getShape(), isARow, isBRow, isAVec4, isBVec4,\n                          product(mmaLayout.getWarpsPerCTA()));\n       // Check if the wpt should be updated.\n-      if (tgtWpt == mmaLayout.getWarpsPerCTA())\n+      if (tgtWpt == mmaLayout.getWarpsPerCTA() ||\n+          !MmaEncodingAttr::_mmaV1UpdateWpt)\n         return failure();\n     }\n \n@@ -79,8 +80,10 @@ class CollectMmaToUpdateForVolta : public mlir::RewritePattern {\n       // Recalculate the wpt, for here we could get the latest information, the\n       // wpt should be updated.\n       auto newWpt =\n-          getWarpsPerCTA(DT.getShape(), isARow_, isBRow_, isAVec4_, isBVec4_,\n-                         product(mmaLayout.getWarpsPerCTA()));\n+          MmaEncodingAttr::_mmaV1UpdateWpt\n+              ? getWarpsPerCTA(DT.getShape(), isARow_, isBRow_, isAVec4_,\n+                               isBVec4_, product(mmaLayout.getWarpsPerCTA()))\n+              : mmaLayout.getWarpsPerCTA();\n       newMmaLayout = MmaEncodingAttr::get(ctx, mmaLayout.getVersionMajor(),\n                                           newWpt, AT.getShape(), BT.getShape(),\n                                           isARow, isBRow, mmaId);"}]