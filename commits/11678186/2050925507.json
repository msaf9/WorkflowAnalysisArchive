[{"filename": "python/setup.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -79,7 +79,7 @@ def run(self):\n \n     def build_extension(self, ext):\n         llvm_include_dir, llvm_library_dir = get_llvm()\n-        self.debug = True\n+        # self.debug = True\n         extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.path)))\n         # create build directories\n         build_suffix = 'debug' if self.debug else 'release'"}, {"filename": "python/triton/code_gen.py", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "file_content_changes": "@@ -46,7 +46,8 @@ def mangle_ty(type):\n def mangle_fn(name, arg_tys, constants):\n     # doesn't mangle ret type, which must be a function of arg tys\n     mangled_arg_names = '_'.join([mangle_ty(ty) for ty in arg_tys])\n-    mangled_constants = '_'.join([f'{i}c{constants[i]}' for i in sorted(constants)])\n+    key = lambda x: x.__name__ if isinstance(x, JITFunction) else repr(x)\n+    mangled_constants = '_'.join([f'{i}c{key(constants[i])}' for i in sorted(constants)])\n     mangled_constants = mangled_constants.replace('.','x')\n     return f'{name}__{mangled_arg_names}__{mangled_constants}'\n \n@@ -130,6 +131,7 @@ def visit_Return(self, node):\n             ret = ret.handle\n         if isinstance(ret, triton.language.constexpr):\n             ret = triton.language.core._to_ir(ret, self.builder)\n+        # TODO: should return tl.block\n         return self.builder.ret(ret)\n \n     def visit_FunctionDef(self, node):\n@@ -505,26 +507,14 @@ def visit_Call(self, node):\n         for keyword in node.keywords:\n             kws.update(self.visit(keyword))\n         args = [self.visit(arg) for arg in node.args]\n+    \n+\n         if isinstance(fn, JITFunction):\n-            # handle defaults\n-            off = len(fn.arg_names) - len(args)\n-            if off > 0:\n-                for arg in fn.arg_defaults[-off:]:\n-                    args.append(arg)\n-                    new_arg = triton.language.core._to_ir(arg, self.builder)\n-                    args.append(triton.language.block(new_arg))\n-            # handle type annotation\n-            # NOTE: for now, only `constexpr` annotation is supported\n-            for i, arg in enumerate(args):\n-                if isinstance(arg, triton.language.constexpr):\n-                    continue\n-                if i in fn.annotations:\n-                    assert fn.annotations[i] is triton.language.constexpr\n-                    if not isinstance(args[i], fn.annotations[i]):\n-                        args[i] = fn.annotations[i](arg)\n-                elif not self.is_triton_object(arg):\n-                    new_arg = triton.language.core._to_ir(arg, self.builder)\n-                    args[i] = triton.language.block(new_arg)\n+            from inspect import getcallargs\n+            args = getcallargs(fn.fn, *args, **kws)\n+            args = [args[name] for name in fn.arg_names]\n+            args = [arg if isinstance(arg, triton.language.block)\n+                          else triton.language.constexpr(arg) for arg in args]\n             # generate function def\n             attributes = dict()\n             constexprs = [i for i, arg in enumerate(args) if isinstance(arg, triton.language.constexpr)]\n@@ -543,6 +533,8 @@ def visit_Call(self, node):\n                 generator.visit(fn.parse())\n             symbol = self.module.get_function(fn_name)\n             ret = self.builder.call(symbol, arg_vals)\n+            if not ret.type.is_void() and not ret.type.is_struct():\n+                ret = triton.language.block(ret)\n             return ret\n         # built-in function\n         if hasattr(fn, '__self__') and self.is_triton_object(fn.__self__) or \\"}]