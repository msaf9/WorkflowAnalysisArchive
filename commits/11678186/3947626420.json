[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "file_content_changes": "@@ -174,7 +174,6 @@ struct ConvertLayoutOpConversion\n     auto sizePerThread = getSizePerThread(layout);\n     auto accumSizePerThread = product<unsigned>(sizePerThread);\n     SmallVector<unsigned> numCTAs(rank);\n-    llvm::outs() << \"processReplica layout: \" << layout << \"\\n\";\n     auto shapePerCTA = getShapePerCTA(layout, type.getShape());\n     auto order = getOrder(layout);\n     for (unsigned d = 0; d < rank; ++d) {\n@@ -265,7 +264,6 @@ struct ConvertLayoutOpConversion\n     auto order = getOrder(layout);\n     auto rank = type.getRank();\n     int accumSizePerThread = vals.size();\n-    printf(\"accumSizePerThread(acc.size): %d\\n\", accumSizePerThread);\n \n     SmallVector<unsigned> numCTAs(rank, 1);\n     SmallVector<unsigned> numCTAsEachRep(rank, 1);\n@@ -301,21 +299,8 @@ struct ConvertLayoutOpConversion\n             getMultiDimOffset(layout, loc, rewriter, elemId, type.getShape(),\n                               multiDimCTAInRepId, shapePerCTA);\n         coord2val[elemId] = std::make_pair(multiDimOffset, vals[elemId]);\n-        // if (sliceLayout) {\n-        //   LLVM::vprintf(\"acci %d\", {multiDimOffset[0]}, rewriter);\n-        //   printf(\"** vals.size: %ld\\n\", vals.size());\n-        // }\n       }\n \n-#define SHOW_ACCI 0\n-#if SHOW_ACCI\n-      for (unsigned elemId = 0; elemId < accumSizePerThread; elemId++) {\n-        auto [coord, currVal] = coord2val[elemId];\n-        LLVM::vprintf(\"acci t-%d (%d %d) %f\",\n-                      {LLVM::gThreadId, coord[0], coord[1], currVal}, rewriter);\n-      }\n-#endif\n-\n       if (needTrans) {\n         auto [isARow, isBRow, isAVec4, isBVec4, mmaId] =\n             mma.decodeVoltaLayoutStates();\n@@ -335,9 +320,6 @@ struct ConvertLayoutOpConversion\n       }\n     }\n \n-    // if (stNotRd) {\n-    // LLVM::vprintf(\"before storeptr t-%d\", {LLVM::gThreadId}, rewriter);\n-    //}\n     // Now the coord2valT has the transposed and contiguous elements(with\n     // vec=2), the original vals is not needed.\n     for (unsigned elemId = 0; elemId < accumSizePerThread; elemId += vec) {\n@@ -348,14 +330,12 @@ struct ConvertLayoutOpConversion\n       auto vecTy = vec_ty(elemTy, vec);\n       ptr = bitcast(ptr, ptr_ty(vecTy, 3));\n       if (stNotRd) {\n-        // LLVM::vprintf(\"ptr t-%d %d\", {LLVM::gThreadId, ptr}, rewriter);\n         Value valVec = undef(vecTy);\n         for (unsigned v = 0; v < vec; ++v) {\n           auto currVal = coord2valT[elemId + v].second;\n           valVec = insert_element(vecTy, valVec, currVal, idx_val(v));\n         }\n         store(valVec, ptr);\n-        // LLVM::vprintf(\"ptr t-%d done %d\", {LLVM::gThreadId, ptr}, rewriter);\n       } else {\n         Value valVec = load(ptr);\n         for (unsigned v = 0; v < vec; ++v) {\n@@ -412,9 +392,6 @@ struct ConvertLayoutOpConversion\n           sliceLayout.getParent().dyn_cast<MmaEncodingAttr>().isVolta();\n     }\n \n-    llvm::outs() << \"srcTy: \" << srcTy << \" \" << isSrcMmaV1 << \"\\n\";\n-    llvm::outs() << \"dstTy: \" << dstTy << \" \" << isDstMmaV1 << \"\\n\";\n-\n     for (unsigned d = 0; d < rank; ++d) {\n       unsigned inPerCTA = std::min<unsigned>(shape[d], srcShapePerCTA[d]);\n       unsigned outPerCTA = std::min<unsigned>(shape[d], dstShapePerCTA[d]);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "file_content_changes": "@@ -130,14 +130,10 @@ struct DotOpMmaV1ConversionHelper {\n     return numN;\n   }\n \n-  // NOTE isARow should be from a shared layout, it doesnt necessarily equal\n-  // DotOperand.isMMAv1Row\n   int numElemsPerThreadA(ArrayRef<int64_t> shape, bool isARow, bool isAVec4,\n                          int vec) const {\n     int numM = getNumM(shape[0], isARow, isAVec4);\n     int NK = shape[1];\n-    printf(\"* numElemsPerThreadA: numM:%d NK:%d vec:%d isARow:%d\\n\", numM, NK,\n-           vec, isARow);\n     // Here we mimic the logic in loadA, the result cannot be calculated\n     // directly.\n     llvm::DenseSet<std::pair<int, int>> visited;\n@@ -156,13 +152,9 @@ struct DotOpMmaV1ConversionHelper {\n         if (!visited.count({m, k}))\n           ld(m, k);\n \n-    printf(\"numElemsPerThreadA: %d\\n\", visited.size() * 2);\n-\n     return visited.size() * 2;\n   }\n \n-  // NOTE isBRow should be from a shared layout, it doesnt necessarily equal\n-  // DotOperand.isMMAv1Row\n   int numElemsPerThreadB(ArrayRef<int64_t> shape, bool isBRow, bool isBVec4,\n                          int vec) const {\n     unsigned numN = getNumN(shape[1], isBRow, isBVec4);\n@@ -187,8 +179,6 @@ struct DotOpMmaV1ConversionHelper {\n           ld(n, k);\n       }\n \n-    printf(\"numElemsPerThreadB: %d\\n\", visited.size() * 2);\n-\n     return visited.size() * 2;\n   }\n \n@@ -293,17 +283,13 @@ struct DotOpMmaV1ConversionHelper {\n         if (!has.count({m, k}))\n           loadA(m, k);\n \n-    printf(\"loadA-params t-0 numM:%d NK:%d vec:%d isARow:%d isAVec4:%d\\n\", numM,\n-           NK, vecA, isARow, isAVec4);\n-\n     SmallVector<Value> elems;\n     elems.reserve(has.size() * 2);\n     for (auto item : has) { // has is a map, the key should be ordered.\n       elems.push_back(item.second.first);\n       elems.push_back(item.second.second);\n     }\n \n-    printf(\"loadA.elems: %lu\\n\", elems.size());\n     Type resTy = struct_ty(SmallVector<Type>(elems.size(), elemX2Ty));\n     Value res = getStructFromElements(loc, elems, rewriter, resTy);\n     return res;\n@@ -418,7 +404,6 @@ struct DotOpMmaV1ConversionHelper {\n       elems.push_back(item.second.second);\n     }\n \n-    printf(\"loadB.elems: %lu\\n\", elems.size());\n     Type resTy = struct_ty(SmallVector<Type>(elems.size(), elemX2Ty));\n     Value res = getStructFromElements(loc, elems, rewriter, resTy);\n     return res;\n@@ -526,8 +511,6 @@ struct DotOpMmaV1ConversionHelper {\n   getMNCoords(Value thread, ConversionPatternRewriter &rewriter,\n               ArrayRef<unsigned> wpt, ArrayRef<int64_t> shape, bool isARow,\n               bool isBRow, bool isAVec4, bool isBVec4) {\n-    printf(\"getMNCoords t-0 wpt:[%d %d] shape:[%ld %ld] %d %d %d %d\\n\", wpt[0],\n-           wpt[1], shape[0], shape[1], isARow, isBRow, isAVec4, isBVec4);\n \n     auto *ctx = thread.getContext();\n     auto loc = UnknownLoc::get(ctx);\n@@ -545,10 +528,6 @@ struct DotOpMmaV1ConversionHelper {\n     SmallVector<int, 2> rep({aParam.rep[0], bParam.rep[1]});\n     SmallVector<int, 2> spw({aParam.spw[0], bParam.spw[1]});\n     SmallVector<unsigned, 2> shapePerCTA({spw[0] * wpt[0], spw[1] * wpt[1]});\n-    // printf(\"MN t-0 M shape:%lu spc:%d rep:%d\\n\", shape[0], shapePerCTA[0],\n-    //        rep[0]);\n-    // printf(\"MN t-0 N shape:%lu spc:%d rep:%d\\n\", shape[1], shapePerCTA[1],\n-    //        rep[1]);\n \n     Value lane = urem(thread, _32);\n     Value warp = udiv(thread, _32);\n@@ -620,23 +599,6 @@ struct DotOpMmaV1ConversionHelper {\n       }\n     }\n \n-#define SHOW_COORD 0\n-#if SHOW_COORD\n-    static bool visited{};\n-    if (!visited) {\n-      std::string fmt = \"coord t-%d \";\n-      SmallVector<Value> args;\n-      args.push_back(gThreadId);\n-      for (auto &coord : coords) {\n-        fmt += \"(%d %d) \";\n-        args.push_back(coord[0]);\n-        args.push_back(coord[1]);\n-      }\n-      LLVM::vprintf(fmt, args, rewriter);\n-      visited = true;\n-    }\n-#endif\n-\n     return coords; // {M,N} in row-major\n   }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "file_content_changes": "@@ -91,7 +91,6 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n   /// Convert to mma.m8n8k4\n   LogicalResult convertMMA884(triton::DotOp op, OpAdaptor adaptor,\n                               ConversionPatternRewriter &rewriter) const {\n-    printf(\">> begin dotop\\n\");\n     auto *ctx = op.getContext();\n     auto loc = op.getLoc();\n \n@@ -125,19 +124,11 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n         mmaLayout.decodeVoltaLayoutStates();\n     assert(isARow == isARow_);\n     assert(isBRow == isBRow_);\n-    printf(\"mma.decode t-0 %d %d %d %d %d\\n\", isARow_, isBRow_, isAVec4_,\n-           isBVec4_, mmaId);\n \n     DotOpMmaV1ConversionHelper helper(mmaLayout);\n \n     unsigned numM = helper.getNumM(AShape[0], isARow, isAVec4_);\n     unsigned numN = helper.getNumN(BShape[1], isBRow, isBVec4_);\n-    printf(\"MN0 t-0 isArow:%d isBRow:%d, isAVec4:%d, isBVec4:%d, M:%ld, N:%ld \"\n-           \"numM:%d numN:%d wpt:%d-%d\\n\",\n-           isARow, isBRow, isAVec4_, isBVec4_, AShape[0], BShape[1], numM, numN,\n-           wpt[0], wpt[1]);\n-    printf(\"mma884 numM: %d\\n\", numM);\n-    printf(\"mma884 numN: %d\\n\", numN);\n     unsigned NK = AShape[1];\n \n     auto has = helper.extractLoadedOperand(adaptor.a(), NK, rewriter);\n@@ -206,61 +197,23 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n         Value elem = extract_val(f32_ty, res, i32_arr_attr(i));\n         acc[idx[i]] = elem;\n       }\n-\n-#define SHOW_MMA_V1 0\n-#if SHOW_MMA_V1\n-      {\n-        std::vector<Value> args = {ha.first, ha.second, hb.first, hb.second};\n-\n-        auto get_f16 = [&](Value value, int idx) {\n-          return extract_element(f16_ty, value, idx_val(idx));\n-        };\n-\n-        std::vector<Value> pargs({getThreadId(rewriter, loc)});\n-        pargs.push_back(i32_val(m));\n-        pargs.push_back(i32_val(n));\n-        pargs.push_back(i32_val(k));\n-        for (int i = 0; i < 4; i++) {\n-          pargs.push_back(get_f16(args[i], 0));\n-          pargs.push_back(get_f16(args[i], 1));\n-        }\n-        for (int i = 0; i < 8; i++) {\n-          pargs.push_back(C[i]);\n-        }\n-        for (int i = 0; i < 8; i++) {\n-          pargs.push_back(acc[idx[i]]);\n-        }\n-\n-        LLVM::vprintf(\"mma t-%d [%d %d %d] A:(%f,%f) (%f,%f) B:(%f,%f) (%f,%f) \"\n-                      \"C:(%f,%f,%f,%f,%f,%f,%f,%f)\"\n-                      \" D:(%f,%f,%f,%f,%f,%f,%f,%f)\",\n-                      pargs, rewriter);\n-        // LLVM::vprintf(\"mma t-%d [%d %d %d] A:(%f,%f) (%f,%f) B:(%f,%f)\n-        // (%f,%f) \" \"C:(%f,%f,%f,%f,%f,%f,%f,%f)\", pargs, rewriter);\n-      }\n-#endif\n     };\n \n-    printf(\"mnk t-0 numM,numN,numK %d,%d,%d\\n\", numM, numN, NK);\n-\n     for (unsigned k = 0; k < NK; k += 4)\n       for (unsigned m = 0; m < numM / 2; ++m)\n         for (unsigned n = 0; n < numN / 2; ++n) {\n-          // printf(\"** m,n,k: %d %d %d\\n\", m, n, k);\n           callMMA(m, n, k);\n         }\n \n     // res holds the same layout of acc\n     for (size_t i = 0; i < acc.size(); ++i) {\n       resVals[i] = acc[i];\n     }\n-    // LLVM::vprintf_array(LLVM::gThreadId, acc, \"acc\", \"%f\", rewriter);\n \n     Type structTy = LLVM::LLVMStructType::getLiteral(\n         ctx, SmallVector<Type>(resSize, type::f32Ty(ctx)));\n     Value res = getStructFromElements(loc, resVals, rewriter, structTy);\n     rewriter.replaceOp(op, res);\n-    printf(\"<< end dotop\\n\");\n     return success();\n   }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "file_content_changes": "@@ -40,8 +40,6 @@ struct BroadcastOpConversion\n   LogicalResult\n   matchAndRewrite(triton::BroadcastOp op, OpAdaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n-    LLVM::gThreadId =\n-        getThreadId(rewriter, UnknownLoc::get(rewriter.getContext()));\n     // Following the order of indices in the legacy code, a broadcast of:\n     //   [s(0), s(1) ... s(k-1),    1, s(k+1), s(k+2) ... s(n-1)]\n     // =>\n@@ -83,17 +81,14 @@ struct BroadcastOpConversion\n         int dup = numElemsPerThread / srcUniqElems;\n         SmallVector<Value> retVals;\n         if (srcShape[0] == 1) { // add-cols\n-          for (int i = 0; i < srcUniqElems; ++i) {\n-            for (int k = 0; k < dup; ++k) {\n+          for (int i = 0; i < srcUniqElems; ++i)\n+            for (int k = 0; k < dup; ++k)\n               retVals.push_back(srcVals[i * 2]);\n-            }\n-          }\n+\n         } else { // add-rows\n-          for (int k = 0; k < dup; ++k) {\n-            for (int i = 0; i < srcUniqElems; ++i) {\n+          for (int k = 0; k < dup; ++k)\n+            for (int i = 0; i < srcUniqElems; ++i)\n               retVals.push_back(srcVals[i]);\n-            }\n-          }\n         }\n \n         auto llvmStructTy = getTypeConverter()->convertType(resultTy);\n@@ -118,28 +113,6 @@ struct BroadcastOpConversion\n       resultVals.push_back(srcValues.lookup(offset));\n     }\n \n-    if (srcTy.getEncoding().isa<MmaEncodingAttr>() &&\n-        resultTy.getEncoding().isa<MmaEncodingAttr>()) {\n-      // LLVM::vprintf_array(LLVM::gThreadId, srcVals, \"bst-in\", \"%f\",\n-      // rewriter); LLVM::vprintf_array(LLVM::gThreadId, resultVals, \"bst-out\",\n-      // \"%f\", rewriter);\n-    }\n-\n-    if (srcTy.getEncoding().isa<MmaEncodingAttr>() &&\n-        resultTy.getEncoding().isa<MmaEncodingAttr>()) {\n-      printf(\"-- broadcast src [%ld]: \", srcOffsets.size());\n-      for (int i = 0; i < srcOffsets.size(); i++) {\n-        printf(\"(%d,%d) \", srcOffsets[i][0], srcOffsets[i][1]);\n-      }\n-      printf(\"\\n\");\n-\n-      printf(\"-- broadcast dst[%ld]: \", resultOffsets.size());\n-      for (int i = 0; i < resultOffsets.size(); i++) {\n-        printf(\"(%d,%d) \", resultOffsets[i][0], resultOffsets[i][1]);\n-      }\n-      printf(\"\\n\");\n-    }\n-\n     auto llvmStructTy = getTypeConverter()->convertType(resultTy);\n     Value resultStruct =\n         getStructFromElements(loc, resultVals, rewriter, llvmStructTy);\n@@ -602,8 +575,6 @@ void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n   vprintf(fmt, new_arr, builder);\n }\n \n-Value gThreadId; // DEBUG\n-\n } // namespace LLVM\n } // namespace mlir\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -21,7 +21,6 @@ using ::mlir::triton::gpu::SliceEncodingAttr;\n \n namespace mlir {\n namespace LLVM {\n-extern Value gThreadId;\n \n // Helper function for using printf in LLVM conversion.\n void vprintf(StringRef msg, ValueRange args,\n@@ -214,7 +213,6 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n         ValueRange{rewriter.create<::mlir::gpu::ThreadIdOp>(\n             loc, rewriter.getIndexType(), ::mlir::gpu::Dimension::x)});\n     Value threadId = cast.getResult(0);\n-    LLVM::gThreadId = threadId; // DEBUG\n \n     return threadId;\n   }"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TypeConverter.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -120,15 +120,13 @@ class TritonGPUToLLVMTypeConverter : public LLVMTypeConverter {\n             DotOpMmaV1ConversionHelper::AParam param(isARow, isAVec4);\n             int elems =\n                 helper.numElemsPerThreadA(shape, isARow, isAVec4, param.vec);\n-            printf(\"A.typeconverter.elems: %d\\n\", elems);\n             Type x2Ty = vec_ty(elemTy, 2);\n             return struct_ty(SmallVector<Type>(elems, x2Ty));\n           }\n           if (dotOpLayout.getOpIdx() == 1) { // $b\n             DotOpMmaV1ConversionHelper::BParam param(isBRow, isBVec4);\n             int elems =\n                 helper.numElemsPerThreadB(shape, isBRow, isBVec4, param.vec);\n-            printf(\"B.typeconverter.elems: %d\\n\", elems);\n             Type x2Ty = vec_ty(elemTy, 2);\n             return struct_ty(SmallVector<Type>(elems, x2Ty));\n           }"}, {"filename": "lib/Dialect/TritonGPU/Transforms/UpdateMmaForVolta.cpp", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "file_content_changes": "@@ -114,7 +114,6 @@ class CollectMmaToUpdateForVolta : public mlir::RewritePattern {\n     int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n     rep[1] = 2 * packSize1;\n     spw[1] = fpw[1] * 4 * rep[1];\n-    printf(\"wpt-spw t-0 %d %d\\n\", spw[0], spw[1]);\n \n     do {\n       wpt_nm1 = wpt;\n@@ -318,8 +317,6 @@ class UpdateMmaForVoltaPass\n     MLIRContext *context = &getContext();\n     ModuleOp m = getOperation();\n \n-    // llvm::outs() << \"input ir:\\n\" << *m << \"\\n\";\n-\n     llvm::DenseMap<MmaEncodingAttr, MmaEncodingAttr> mmaToUpdate;\n     {\n       mlir::RewritePatternSet patterns(context);\n@@ -332,13 +329,6 @@ class UpdateMmaForVoltaPass\n         signalPassFailure();\n     }\n \n-    /*\n-    for (auto& item : mmaToUpdate) {\n-      llvm::outs() << \"updatemma t-0 \" << item.first << \" -> \" << item.second <<\n-    \"\\n\";\n-    }\n-     */\n-\n     if (!mmaToUpdate.empty()) {\n       mlir::RewritePatternSet patterns(context);\n       patterns.add<UpdateMMAForMMAv1>(context, mmaToUpdate);\n@@ -353,8 +343,6 @@ class UpdateMmaForVoltaPass\n \n       if (fixupLoops(m).failed())\n         signalPassFailure();\n-\n-      // llvm::outs() << \"output ir:\\n\" << *m << \"\\n\";\n     }\n   }\n };"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -902,9 +902,9 @@ def ttir_to_ttgir(mod, num_warps, num_stages, compute_capability):\n     pm.add_tritongpu_combine_pass(compute_capability)\n     pm.add_cse_pass()\n     pm.add_tritongpu_decompose_conversions_pass()\n-    if compute_capability // 10 == 7 or True:  # DEBUG\n+    if compute_capability // 10 == 7:\n         # The update_mma_for_volta pass helps to compute some information for MMA encoding specifically for MMAv1\n-        # NOTE this PR should be placed after all the passes those modifies mma layout\n+        # NOTE this pass should be placed after all the passes those modifies mma layout\n         pm.add_tritongpu_update_mma_for_volta_pass()\n     pm.add_cse_pass()\n     pm.add_symbol_dce_pass()"}]