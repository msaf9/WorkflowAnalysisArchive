[{"filename": ".github/workflows/integration-tests.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -151,7 +151,7 @@ jobs:\n           sudo apt update\n           sudo apt install gh\n \n-      - name: Get last merged PR workflow run ID\n+      - name: Download latest main artifacts\n         env:\n           ARTIFACT_NAME: artifacts\n           ARTIFACT_JOB_NAME: Integration-Tests"}, {"filename": "python/test/tools/compare_files.py", "status": "modified", "additions": 68, "deletions": 27, "changes": 95, "file_content_changes": "@@ -1,46 +1,47 @@\n import argparse\n import glob\n import os\n+from typing import Dict, List, Optional, Tuple\n \n import yaml\n \n \n-def list_files_with_extension(path, extension):\n+def list_files_with_extension(path: str, extension: str) -> List[str]:\n     files = glob.glob(os.path.join(path, f'*.{extension}'))\n     return files\n \n \n-def load_yaml_file(file_path):\n+def get_file_with_extension(path: str, ext: str) -> Optional[str]:\n+    # get all files in directory with extension\n+    files = list_files_with_extension(path, ext)\n+    if len(files) == 0:\n+        return None\n+    # filter out files with grp in their name\n+    files = [f for f in files if \"grp\" not in f]\n+    assert len(files) == 1, f\"Found {len(files)} files in {path} with extension {ext}!\"\n+    return files[0]\n+\n+\n+def load_yaml_file(file_path: str) -> List[Dict[str, str]]:\n     with open(file_path, 'r') as file:\n         content = yaml.safe_load(file)\n     return content\n \n \n-def compare_files(file1, file2):\n+def compare_files(file1: str, file2: str) -> bool:\n     with open(file1, 'rb') as f1, open(file2, 'rb') as f2:\n         content1 = f1.read()\n         content2 = f2.read()\n \n     return content1 == content2\n \n \n-def get_json_file(path):\n-    # get json file in directory\n-    json_files = list_files_with_extension(path, \"json\")\n-    if len(json_files) == 0:\n-        return None\n-    # filter out json files with grp in their name\n-    json_files = [f for f in json_files if \"grp\" not in f]\n-    assert len(json_files) == 1, f\"Found {len(json_files)} files in {path} with extension json!\"\n-    return json_files[0]\n-\n-\n-def get_name_to_hashes_dict(path):\n+def get_name_to_hashes_dict(path: str) -> Dict[str, List[str]]:\n     name_to_hashes = {}\n     for hash in os.listdir(path):\n         full_path = os.path.join(path, hash)\n         assert os.path.isdir(full_path), f\"Path {full_path} is not a directory!\"\n-        json_file = get_json_file(full_path)\n+        json_file = get_file_with_extension(full_path, \"json\")\n         if json_file is None:\n             continue\n         # load json file\n@@ -52,26 +53,61 @@ def get_name_to_hashes_dict(path):\n     return name_to_hashes\n \n \n-def compare_matching_files(name, extension, name_to_hashes1, name_to_hashes2, args):\n+def get_file_vec(path: str) -> List[Tuple[str, str]]:\n+    vec = []\n+    for ext in [\"json\", \"ttir\", \"ttgir\"]:\n+        file = get_file_with_extension(path, ext)\n+        if file is not None:\n+            vec.append((ext, file))\n+    return vec\n+\n+\n+def do_files_match(path1: str, path2: str) -> bool:\n+    files_vec1 = get_file_vec(path1)\n+    files_vec2 = get_file_vec(path2)\n+    # both hashes must at least have 1 json file and 1 ttir or ttgir file\n+    # and the number of files must match\n+    if len(files_vec1) <= 1 or len(files_vec2) <= 1 or len(files_vec1) != len(files_vec2):\n+        return False\n+    # if either path does not have a json file, return false\n+    if files_vec1[0][0] != \"json\" or files_vec2[0][0] != \"json\":\n+        return False\n+\n+    for (ext1, file1), (ext2, file2) in zip(files_vec1, files_vec2):\n+        if ext1 != ext2:\n+            return False\n+        if not compare_files(file1, file2):\n+            return False\n+        else:\n+            # once we actually compared a ttir or ttgir file, we can break\n+            if ext1 in (\"ttir\", \"ttgir\"):\n+                break\n+    return True\n+\n+\n+def compare_matching_files(name: str, extension: str, name_to_hashes1: Dict[str, List[str]], name_to_hashes2: Dict[str, List[str]], args) -> Tuple[str]:\n     hashes1 = name_to_hashes1[name]\n     hashes2 = name_to_hashes2[name]\n     for hash1 in hashes1:\n-        json1 = get_json_file(os.path.join(args.path1, hash1))\n-        assert json1 is not None\n+        path1 = os.path.join(args.path1, hash1)\n         for hash2 in hashes2:\n-            json2 = get_json_file(os.path.join(args.path2, hash2))\n-            assert json2 is not None\n-            if not compare_files(json1, json2):\n+            path2 = os.path.join(args.path2, hash2)\n+            # check whether both paths have:\n+            # 1. json files that match\n+            # 2. ttir files that match (if they exist), otherwise ttgir files that match (if they exist)\n+            # if any of these contraints is not met, then we can skip this pair of hashes since they are not a match\n+            if not do_files_match(path1, path2):\n                 continue\n-            ext_file1 = list_files_with_extension(os.path.join(args.path1, hash1), extension)[0]\n-            ext_file2 = list_files_with_extension(os.path.join(args.path2, hash2), extension)[0]\n+            ext_file1 = list_files_with_extension(path1, extension)[0]\n+            ext_file2 = list_files_with_extension(path2, extension)[0]\n             if not compare_files(ext_file1, ext_file2):\n                 return (ext_file1, ext_file2)\n     return ()\n \n \n-def main(args):\n+def main(args) -> None:\n     assert args.path1 != args.path2, \"Cannot compare files in the same directory!\"\n+    # Get kernel name to hashes dict, these hashes would have the same kernel name\n     name_to_hashes1 = get_name_to_hashes_dict(args.path1)\n     name_to_hashes2 = get_name_to_hashes_dict(args.path2)\n \n@@ -80,12 +116,17 @@ def main(args):\n     name_and_extension = load_yaml_file(yaml_file_path)[\"name_and_extension\"]\n \n     mismatches = {}\n+    # iterate over the kernels that need to be checked\n     for d in name_and_extension:\n-        name = d[\"name\"]\n-        extension = d[\"extension\"]\n+        name = d[\"name\"]  # kernel name\n+        extension = d[\"extension\"]  # extension of the file to be compared (e.g. ptx)\n+        # Compare all hashes on path 1 with all hashes on path 2\n+        # result is either the mismatching (file1, file2) with \"extension\" or empty tuple if no mismatch\n         result = compare_matching_files(name, extension, name_to_hashes1, name_to_hashes2, args)\n+        # If mismatch exists, add it to mismatches dict\n         if len(result) > 0:\n             mismatches[name] = result\n+    # If mismatches dict is not empty, print the mismatches and assert false\n     if len(mismatches) > 0:\n         print(f\"Found {len(mismatches)} mismatches:\")\n         for name, mismatch in mismatches.items():"}]