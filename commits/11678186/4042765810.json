[{"filename": "python/setup.py", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "file_content_changes": "@@ -54,12 +54,8 @@ def get_llvm_package_info():\n     system = platform.system()\n     system_suffix = {\"Linux\": \"linux-gnu-ubuntu-18.04\", \"Darwin\": \"apple-darwin\"}[system]\n     use_assert_enabled_llvm = check_env_flag(\"TRITON_USE_ASSERT_ENABLED_LLVM\", \"False\")\n-    if use_assert_enabled_llvm:\n-        name = 'llvm+mlir-15.0.0-x86_64-{}-assert'.format(system_suffix)\n-        url = \"https://github.com/shintaro-iwasaki/llvm-releases/releases/download/llvm-15.0.0-4ba6a9c9f65b/{}.tar.xz\".format(name)\n-    else:\n-        name = 'clang+llvm-15.0.0-x86_64-{}'.format(system_suffix)\n-        url = \"https://github.com/llvm/llvm-project/releases/download/llvmorg-15.0.0/{}.tar.xz\".format(name)\n+    name = 'llvm+mlir-15.0.7-x86_64-{}-{}'.format(system_suffix, \"assert\" if use_assert_enabled_llvm else \"release\")\n+    url = \"https://github.com/ptillet/triton-llvm-releases/releases/download/llvm-15.0.7-8dfdcc7b7bf6/{}.tar.xz\".format(name)\n     return Package(\"llvm\", name, url, \"lib\", \"LLVM_INCLUDE_DIRS\", \"LLVM_LIBRARY_DIR\", \"LLVM_SYSPATH\")\n \n "}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "file_content_changes": "@@ -321,7 +321,7 @@ void init_triton_ir(py::module &&m) {\n              return str;\n            })\n       .def(\"push_back\",\n-           [](mlir::ModuleOp &self, mlir::FuncOp &funcOp) -> void {\n+           [](mlir::ModuleOp &self, mlir::func::FuncOp &funcOp) -> void {\n              self.push_back(funcOp);\n            })\n       .def(\"has_function\",\n@@ -331,16 +331,18 @@ void init_triton_ir(py::module &&m) {\n              return false;\n            })\n       .def(\"get_function\",\n-           [](mlir::ModuleOp &self, std::string &funcName) -> mlir::FuncOp {\n-             return self.lookupSymbol<mlir::FuncOp>(funcName);\n-           })\n-      .def(\"get_single_function\", [](mlir::ModuleOp &self) -> mlir::FuncOp {\n-        llvm::SmallVector<mlir::FuncOp> funcs;\n-        self.walk([&](mlir::FuncOp func) { funcs.push_back(func); });\n-        if (funcs.size() != 1)\n-          throw std::runtime_error(\"Expected a single function\");\n-        return funcs[0];\n-      });\n+           [](mlir::ModuleOp &self,\n+              std::string &funcName) -> mlir::func::FuncOp {\n+             return self.lookupSymbol<mlir::func::FuncOp>(funcName);\n+           })\n+      .def(\"get_single_function\",\n+           [](mlir::ModuleOp &self) -> mlir::func::FuncOp {\n+             llvm::SmallVector<mlir::func::FuncOp> funcs;\n+             self.walk([&](mlir::func::FuncOp func) { funcs.push_back(func); });\n+             if (funcs.size() != 1)\n+               throw std::runtime_error(\"Expected a single function\");\n+             return funcs[0];\n+           });\n \n   m.def(\"make_attr\",\n         [](const std::vector<int> &values, mlir::MLIRContext &context) {\n@@ -361,47 +363,48 @@ void init_triton_ir(py::module &&m) {\n         registry.insert<mlir::triton::TritonDialect,\n                         mlir::triton::gpu::TritonGPUDialect,\n                         mlir::math::MathDialect, mlir::arith::ArithmeticDialect,\n-                        mlir::StandardOpsDialect, mlir::scf::SCFDialect>();\n+                        mlir::func::FuncDialect, mlir::scf::SCFDialect>();\n         context.appendDialectRegistry(registry);\n         context.loadAllAvailableDialects();\n \n         // parse module\n-        mlir::OwningOpRef<mlir::ModuleOp> module(\n-            mlir::parseSourceFile(inputFilename, &context));\n+        mlir::OwningOpRef<mlir::ModuleOp> module =\n+            mlir::parseSourceFile<mlir::ModuleOp>(inputFilename, &context);\n+        if (!module)\n+          throw std::runtime_error(\"Parse MLIR file failed.\");\n         // locations are incompatible with ptx < 7.5 !\n         module->walk([](mlir::Operation *op) {\n           op->setLoc(mlir::UnknownLoc::get(op->getContext()));\n         });\n-        if (!module)\n-          throw std::runtime_error(\"Parse MLIR file failed.\");\n \n         return module->clone();\n       },\n       ret::take_ownership);\n \n-  py::class_<mlir::FuncOp, mlir::OpState>(m, \"function\")\n+  py::class_<mlir::func::FuncOp, mlir::OpState>(m, \"function\")\n       // .def_property_readonly(\"attrs\", &ir::function::attrs)\n       // .def(\"add_attr\", &ir::function::add_attr);\n       .def(\"args\",\n-           [](mlir::FuncOp &self, unsigned idx) -> mlir::BlockArgument {\n+           [](mlir::func::FuncOp &self, unsigned idx) -> mlir::BlockArgument {\n              return self.getArgument(idx);\n            })\n       .def(\n           \"add_entry_block\",\n-          [](mlir::FuncOp &self) -> mlir::Block * {\n+          [](mlir::func::FuncOp &self) -> mlir::Block * {\n             return self.addEntryBlock();\n           },\n           ret::reference)\n       .def(\n           \"set_arg_attr\",\n-          [](mlir::FuncOp &self, int arg_no, const std::string &name, int val) {\n+          [](mlir::func::FuncOp &self, int arg_no, const std::string &name,\n+             int val) {\n             // set arg attributes \"name\" to value \"val\"\n             auto attrTy = mlir::IntegerType::get(self.getContext(), 32);\n             self.setArgAttr(arg_no, name, mlir::IntegerAttr::get(attrTy, val));\n           },\n           ret::reference)\n-      .def_property_readonly(\"type\", &mlir::FuncOp::getType)\n-      .def(\"reset_type\", &mlir::FuncOp::setType);\n+      .def_property_readonly(\"type\", &mlir::func::FuncOp::getFunctionType)\n+      .def(\"reset_type\", &mlir::func::FuncOp::setType);\n \n   py::class_<mlir::OpBuilder::InsertPoint>(m, \"InsertPoint\");\n \n@@ -418,13 +421,13 @@ void init_triton_ir(py::module &&m) {\n       .def(\"ret\",\n            [](mlir::OpBuilder &self, std::vector<mlir::Value> &vals) -> void {\n              auto loc = self.getUnknownLoc();\n-             self.create<mlir::ReturnOp>(loc, vals);\n+             self.create<mlir::func::ReturnOp>(loc, vals);\n            })\n       .def(\"call\",\n-           [](mlir::OpBuilder &self, mlir::FuncOp &func,\n+           [](mlir::OpBuilder &self, mlir::func::FuncOp &func,\n               std::vector<mlir::Value> &args) -> mlir::OpState {\n              auto loc = self.getUnknownLoc();\n-             return self.create<mlir::CallOp>(loc, func, args);\n+             return self.create<mlir::func::CallOp>(loc, func, args);\n            })\n       // insertion block/point\n       .def(\"set_insertion_point_to_start\",\n@@ -587,15 +590,16 @@ void init_triton_ir(py::module &&m) {\n       .def(\"get_or_insert_function\",\n            [](mlir::OpBuilder &self, mlir::ModuleOp &module,\n               std::string &funcName, mlir::Type &funcType,\n-              std::string &visibility) -> mlir::FuncOp {\n+              std::string &visibility) -> mlir::func::FuncOp {\n              if (mlir::Operation *funcOperation = module.lookupSymbol(funcName))\n-               return llvm::dyn_cast<mlir::FuncOp>(funcOperation);\n+               return llvm::dyn_cast<mlir::func::FuncOp>(funcOperation);\n              auto loc = self.getUnknownLoc();\n              if (auto funcTy = funcType.dyn_cast<mlir::FunctionType>()) {\n                llvm::SmallVector<mlir::NamedAttribute> attrs = {\n                    mlir::NamedAttribute(self.getStringAttr(\"sym_visibility\"),\n                                         self.getStringAttr(visibility))};\n-               return self.create<mlir::FuncOp>(loc, funcName, funcTy, attrs);\n+               return self.create<mlir::func::FuncOp>(loc, funcName, funcTy,\n+                                                      attrs);\n              }\n              throw std::runtime_error(\"invalid function type\");\n            })\n@@ -745,14 +749,14 @@ void init_triton_ir(py::module &&m) {\n       .def(\"create_to_index\",\n            [](mlir::OpBuilder &self, mlir::Value &input) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-             return self.create<mlir::arith::IndexCastOp>(loc, input,\n-                                                          self.getIndexType());\n+             return self.create<mlir::arith::IndexCastOp>(\n+                 loc, self.getIndexType(), input);\n            })\n       .def(\"create_index_to_si\",\n            [](mlir::OpBuilder &self, mlir::Value &input) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-             return self.create<mlir::arith::IndexCastOp>(loc, input,\n-                                                          self.getI32Type());\n+             return self.create<mlir::arith::IndexCastOp>(\n+                 loc, self.getI32Type(), input);\n            })\n       .def(\"create_fmul\",\n            [](mlir::OpBuilder &self, mlir::Value &lhs,\n@@ -1265,8 +1269,8 @@ void init_triton_ir(py::module &&m) {\n            [](mlir::OpBuilder &self, mlir::Value &condition,\n               mlir::Value &trueValue, mlir::Value &falseValue) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-             return self.create<mlir::SelectOp>(loc, condition, trueValue,\n-                                                falseValue);\n+             return self.create<mlir::arith::SelectOp>(loc, condition,\n+                                                       trueValue, falseValue);\n            })\n       .def(\"create_printf\",\n            [](mlir::OpBuilder &self, const std::string &prefix,\n@@ -1378,7 +1382,7 @@ void init_triton_ir(py::module &&m) {\n              self.addPass(mlir::triton::createConvertTritonGPUToLLVMPass());\n            })\n       .def(\"add_scf_to_cfg\", [](mlir::PassManager &self) {\n-        self.addPass(mlir::createLowerToCFGPass());\n+        self.addPass(mlir::createConvertSCFToCFPass());\n       });\n }\n "}]