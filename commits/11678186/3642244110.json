[{"filename": "include/triton/Dialect/TritonGPU/IR/TritonGPUOps.td", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "file_content_changes": "@@ -32,6 +32,12 @@ def TTG_AsyncWaitOp : TTG_Op<\"async_wait\"> {\n   let arguments = (ins I32Attr:$num);\n \n   let assemblyFormat = \"attr-dict\";\n+\n+  let extraClassDeclaration = [{\n+    static bool isSupported(int computeCapability) {\n+      return computeCapability >= 80;\n+    }\n+  }];\n }\n \n // Port Arith_CmpIOp & Arith_CmpFOp & Std_SelectOp to TritonGPU.\n@@ -152,7 +158,13 @@ def TTG_InsertSliceAsyncOp : TTG_Op<\"insert_slice_async\",\n   //}];\n \n   let extraClassDeclaration = [{\n-      static DenseSet<unsigned> getEligibleLoadByteWidth(int computeCapability);\n+    static DenseSet<unsigned> getEligibleLoadByteWidth(int computeCapability) {\n+      DenseSet<unsigned> validLoadBytes;\n+      if (computeCapability >= 80) {\n+        validLoadBytes = {4, 8, 16};\n+      }\n+      return validLoadBytes;\n+    }\n   }];\n \n   // The custom parser could be replaced with oilist in LLVM-16"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "file_content_changes": "@@ -4620,8 +4620,7 @@ class ConvertTritonGPUToLLVM\n       // capability does not support async copy, then we do decompose\n       if (triton::gpu::InsertSliceAsyncOp::getEligibleLoadByteWidth(\n               computeCapability)\n-              .contains(byteWidth) &&\n-          computeCapability >= 80)\n+              .contains(byteWidth))\n         return;\n \n       // load\n@@ -4655,13 +4654,8 @@ class ConvertTritonGPUToLLVM\n \n     // async wait is supported in Ampere and later\n     mod.walk([&](triton::gpu::AsyncWaitOp asyncWaitOp) -> void {\n-      if (computeCapability < 80) {\n-        asyncWaitOp.erase();\n-      } else if (decomposed) {\n-        OpBuilder builder(asyncWaitOp);\n-        // Wait for all previous async ops\n-        auto newAsyncWaitOp = builder.create<triton::gpu::AsyncWaitOp>(\n-            asyncWaitOp.getLoc(), builder.getI64IntegerAttr(0));\n+      if (!triton::gpu::AsyncWaitOp::isSupported(computeCapability) ||\n+          decomposed) {\n         asyncWaitOp.erase();\n       }\n     });"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "file_content_changes": "@@ -659,15 +659,6 @@ void printInsertSliceAsyncOp(OpAsmPrinter &printer,\n   printer.printStrippedAttrOrType(insertSliceAsyncOp.result().getType());\n }\n \n-DenseSet<unsigned>\n-InsertSliceAsyncOp::getEligibleLoadByteWidth(int computeCapability) {\n-  DenseSet<unsigned> validLoadBytes;\n-  if (computeCapability >= 80) {\n-    validLoadBytes = {4, 8, 16};\n-  }\n-  return validLoadBytes;\n-}\n-\n //===----------------------------------------------------------------------===//\n // ASM Interface (i.e.: alias)\n //===----------------------------------------------------------------------===//"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -134,7 +134,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n       /*printAfterOnlyOnChange=*/true,\n       /*printAfterOnlyOnFailure*/ false, llvm::dbgs(), printingFlags);\n \n-  pm.addPass(createConvertTritonGPUToLLVMPass());\n+  pm.addPass(createConvertTritonGPUToLLVMPass(computeCapability));\n   // Canonicalize to eliminate the remaining UnrealizedConversionCastOp\n   pm.addPass(mlir::createCanonicalizerPass());\n   pm.addPass(mlir::createCSEPass()); // Simplify the IR to improve readability."}]