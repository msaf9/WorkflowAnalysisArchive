[{"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "file_content_changes": "@@ -2638,8 +2638,6 @@ void generator::visit_layout_convert(ir::value *out, ir::value *in){\n   // Orders\n   analysis::distributed_layout* in_layout = dynamic_cast<analysis::distributed_layout*>(layouts_->get(in));\n   analysis::distributed_layout* out_layout = dynamic_cast<analysis::distributed_layout*>(layouts_->get(out));\n-  auto in_ord = in_layout->get_order();\n-  auto out_ord = out_layout->get_order();\n   Value *base;\n   base = gep(shmem_, i32(alloc_->offset(layouts_->get(layouts_->tmp(out)))));\n   base = bit_cast(base, ptr_ty(ty, 3));\n@@ -2656,9 +2654,16 @@ void generator::visit_layout_convert(ir::value *out, ir::value *in){\n     in_ax.push_back(axes_.at(a_axes_->get(in, d)).values);\n     out_ax.push_back(axes_.at(a_axes_->get(out, d)).values);\n   }\n-  in_ord = in_layout->to_mma() ? out_ord : in_ord;\n-  out_ord = out_layout->to_mma() ? in_ord : out_ord;\n-  int in_vec = out_ord[0] == 0 ? 1 : in_layout->contig_per_thread(in_ord[0]);\n+  auto in_ord =\n+      in_layout->to_mma() ? out_layout->get_order() : in_layout->get_order();\n+  auto out_ord =\n+      out_layout->to_mma() ? in_layout->get_order() : out_layout->get_order();\n+  // out_ord[0] == 0 and in_order[0] == 0 means the first dimension is\n+  // non-contiguous. in_vec can be greater than 0 only if both out_ord[0] and\n+  // and in_ord[0] are contiguous.\n+  int in_vec = out_ord[0] == 0  ? 1\n+               : in_ord[0] == 0 ? 1\n+                                : in_layout->contig_per_thread(in_ord[0]);\n   int out_vec = out_ord[0] == 0 ? 1 : out_layout->contig_per_thread(out_ord[0]);\n   int pad = std::max(in_vec, out_vec);\n   Value *in_ld = i32(shape[in_ord[0]] + pad);"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "file_content_changes": "@@ -793,8 +793,8 @@ def kernel(X, Z, BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, AXIS: tl.constexp\n \n @pytest.mark.parametrize(\"dtype_str, shape, perm\",\n                          [(dtype, shape, perm)\n-                          for dtype in ['float32']\n-                             for shape in [(128, 128)]\n+                          for dtype in ['float16', 'float32']\n+                             for shape in [(64, 64), (128, 128)]\n                              for perm in [(1, 0)]])\n def test_permute(dtype_str, shape, perm, device='cuda'):\n \n@@ -812,18 +812,26 @@ def kernel(X, stride_xm, stride_xn,\n     x = numpy_random(shape, dtype_str=dtype_str)\n     # triton result\n     z_tri = to_triton(np.empty_like(x), device=device)\n+    z_tri_contiguous = to_triton(np.empty_like(x), device=device)\n     x_tri = to_triton(x, device=device)\n     pgm = kernel[(1, 1)](x_tri, x_tri.stride(0), x_tri.stride(1),\n-                         z_tri, z_tri.stride(1), z_tri.stride(0),\n-                         BLOCK_M=shape[0], BLOCK_N=shape[1])\n+                             z_tri, z_tri.stride(1), z_tri.stride(0),\n+                             BLOCK_M=shape[0], BLOCK_N=shape[1])\n+    pgm_contiguous = kernel[(1, 1)](x_tri, x_tri.stride(1), x_tri.stride(0),\n+                                    z_tri_contiguous, z_tri_contiguous.stride(0), z_tri_contiguous.stride(1),\n+                                    BLOCK_M=shape[0], BLOCK_N=shape[1])\n     # torch result\n     z_ref = x.transpose(*perm)\n     # compare\n     triton.testing.assert_almost_equal(z_tri, z_ref)\n+    triton.testing.assert_almost_equal(z_tri_contiguous, z_ref)\n     # parse ptx to make sure ld/st are vectorized\n     ptx = pgm.asm['ptx']\n     assert 'ld.global.v4' in ptx\n     assert 'st.global.v4' in ptx\n+    ptx = pgm_contiguous.asm['ptx']\n+    assert 'ld.global.v4' in ptx\n+    assert 'st.global.v4' in ptx\n \n # ---------------\n # test dot"}]