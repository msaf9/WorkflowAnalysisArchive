[{"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "file_content_changes": "@@ -105,7 +105,17 @@ static std::map<std::string, std::string> getExternLibs(mlir::ModuleOp module) {\n     }\n   }\n \n-  if (!funcs.empty() && externLibs.empty()) {\n+  if (module.getOperation()->hasAttr(\"triton_gpu.externs\")) {\n+    auto dict = module.getOperation()\n+                    ->getAttr(\"triton_gpu.externs\")\n+                    .dyn_cast<DictionaryAttr>();\n+    for (auto &attr : dict) {\n+      externLibs[attr.getName().strref().trim().str()] =\n+          attr.getValue().dyn_cast<StringAttr>().strref().trim().str();\n+    }\n+  }\n+\n+  if (!funcs.empty()) {\n     // When using the Math Dialect, it is possible that some ops (e.g., log) are\n     // lowered to a function call. In this case, we need to link libdevice\n     // using its default path:\n@@ -123,15 +133,6 @@ static std::map<std::string, std::string> getExternLibs(mlir::ModuleOp module) {\n     externLibs.try_emplace(libdevice, path.string());\n   }\n \n-  if (module.getOperation()->hasAttr(\"triton_gpu.externs\")) {\n-    auto dict = module.getOperation()\n-                    ->getAttr(\"triton_gpu.externs\")\n-                    .dyn_cast<DictionaryAttr>();\n-    for (auto &attr : dict) {\n-      externLibs[attr.getName().strref().trim().str()] =\n-          attr.getValue().dyn_cast<StringAttr>().strref().trim().str();\n-    }\n-  }\n   return externLibs;\n }\n "}]