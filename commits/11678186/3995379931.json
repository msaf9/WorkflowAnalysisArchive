[{"filename": "CMakeLists.txt", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "file_content_changes": "@@ -1,4 +1,7 @@\n cmake_minimum_required(VERSION 3.6)\n+\n+cmake_policy(SET CMP0116 OLD)\n+\n include(ExternalProject)\n \n set(CMAKE_CXX_STANDARD 17)\n@@ -153,7 +156,6 @@ if(TRITON_BUILD_PYTHON_MODULE)\n     endif()\n endif()\n \n-\n # # Triton\n # file(GLOB_RECURSE LIBTRITON_SRC lib/*.cc)\n # if (WIN32 AND TRITON_BUILD_PYTHON_MODULE)\n@@ -210,7 +212,7 @@ if(TRITON_BUILD_PYTHON_MODULE)\n     # optimizations\n     MLIRPass\n     MLIRTransforms\n-    MLIRLLVMIR\n+    MLIRLLVMDialect\n     MLIRSupport\n     MLIRTargetLLVMIRExport\n     MLIRExecutionEngine"}, {"filename": "bin/CMakeLists.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -48,7 +48,7 @@ llvm_update_compile_flags(triton-translate)\n          # MLIR core\n          MLIROptLib\n          MLIRIR\n-         MLIRLLVMIR\n+         MLIRLLVMDialect\n          MLIRPass\n          MLIRSupport\n          MLIRTransforms"}, {"filename": "bin/FileCheck/FileCheck.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -19,6 +19,7 @@\n #include \"llvm/Support/CommandLine.h\"\n #include \"llvm/Support/InitLLVM.h\"\n #include \"llvm/Support/Process.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n #include \"llvm/Support/WithColor.h\"\n #include \"llvm/Support/raw_ostream.h\"\n #include <cmath>"}, {"filename": "bin/triton-opt.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -8,7 +8,7 @@\n \n #include \"mlir/IR/Dialect.h\"\n #include \"mlir/InitAllPasses.h\"\n-#include \"mlir/Support/MlirOptMain.h\"\n+#include \"mlir/Tools/mlir-opt/MlirOptMain.h\"\n \n namespace mlir {\n namespace test {\n@@ -33,8 +33,8 @@ int main(int argc, char **argv) {\n   // TODO: register Triton & TritonGPU passes\n   mlir::DialectRegistry registry;\n   registry.insert<mlir::triton::TritonDialect,\n-                  mlir::triton::gpu::TritonGPUDialect, mlir::math::MathDialect,\n-                  mlir::arith::ArithmeticDialect, mlir::StandardOpsDialect,\n+                  mlir::triton::gpu::TritonGPUDialect, mlir::func::FuncDialect,\n+                  mlir::math::MathDialect, mlir::arith::ArithmeticDialect,\n                   mlir::scf::SCFDialect, mlir::gpu::GPUDialect>();\n \n   return mlir::asMainReturnCode(mlir::MlirOptMain("}, {"filename": "bin/triton-translate.cpp", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "file_content_changes": "@@ -3,17 +3,20 @@\n #include \"mlir/IR/AsmState.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/Dialect.h\"\n-#include \"mlir/Parser.h\"\n+#include \"mlir/Parser/Parser.h\"\n #include \"mlir/Pass/Pass.h\"\n #include \"mlir/Pass/PassManager.h\"\n #include \"mlir/Support/FileUtilities.h\"\n #include \"mlir/Support/LogicalResult.h\"\n #include \"mlir/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.h\"\n #include \"mlir/Target/LLVMIR/Export.h\"\n+#include \"mlir/Transforms/Passes.h\"\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h\"\n #include \"triton/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n+#include \"triton/Dialect/Triton/Transforms/Passes.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n+#include \"triton/Dialect/TritonGPU/Transforms/Passes.h\"\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n #include \"triton/Target/PTX/PTXTranslation.h\"\n #include \"llvm/IR/LLVMContext.h\"\n@@ -38,7 +41,7 @@ OwningOpRef<ModuleOp> loadMLIRModule(llvm::StringRef inputFilename,\n   mlir::DialectRegistry registry;\n   registry.insert<TritonDialect, triton::gpu::TritonGPUDialect,\n                   mlir::math::MathDialect, arith::ArithmeticDialect,\n-                  StandardOpsDialect, scf::SCFDialect>();\n+                  scf::SCFDialect>();\n \n   context.appendDialectRegistry(registry);\n \n@@ -50,7 +53,7 @@ OwningOpRef<ModuleOp> loadMLIRModule(llvm::StringRef inputFilename,\n     context.loadAllAvailableDialects();\n     context.allowUnregisteredDialects();\n \n-    OwningOpRef<ModuleOp> module(parseSourceFile(sourceMgr, &context));\n+    OwningOpRef<ModuleOp> module = parseSourceFile<ModuleOp>(sourceMgr, &context);\n     if (!module) {\n       llvm::errs() << \"Parse MLIR file failed.\";\n       return nullptr;\n@@ -94,11 +97,42 @@ LogicalResult tritonTranslateMain(int argc, char **argv,\n   llvm::cl::ParseCommandLineOptions(argc, argv, toolName);\n \n   mlir::MLIRContext context;\n+  context.disableMultithreading();\n   auto module = loadMLIRModule(inputFilename, context);\n   if (!module) {\n     return failure();\n   }\n \n+  // TODO: make these parameters\n+  int numWarps = 8;\n+  int numStages = 1;\n+  mlir::PassManager pm(module->getContext());\n+  pm.enableIRPrinting();\n+  // This follows optimize_triton_ir() from python/triton/compiler.py\n+  // TODO: share code between these two places\n+  pm.addPass(createInlinerPass());\n+  pm.addPass(createCombineOpsPass());\n+  pm.addPass(createCanonicalizerPass());\n+  pm.addPass(createCSEPass());\n+  pm.addPass(createLoopInvariantCodeMotionPass());\n+  // This follows ttir_to_ttgir() from python/triton/compiler.py\n+  // TODO: share code between these two places\n+  pm.addPass(createConvertTritonToTritonGPUPass(numWarps));\n+  pm.addPass(createTritonGPUCoalescePass());\n+  pm.addPass(createTritonGPUCombineOpsPass(SMArch.getValue()));\n+  pm.addPass(createTritonGPUPipelinePass(numStages));\n+  pm.addPass(createTritonGPUPrefetchPass());\n+  pm.addPass(createCanonicalizerPass());\n+  pm.addPass(createCSEPass());\n+  pm.addPass(createTritonGPUCombineOpsPass(SMArch.getValue()));\n+  pm.addPass(createLoopInvariantCodeMotionPass());\n+  pm.addPass(createTritonGPUCombineOpsPass(SMArch.getValue()));\n+  pm.addPass(createCSEPass());\n+\n+  if(failed(pm.run(module.get()))) {\n+    return failure();\n+  }\n+\n   std::string errorMessage;\n   auto output = openOutputFile(outputFilename, &errorMessage);\n   if (!output) {"}, {"filename": "include/triton/Analysis/Alias.h", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "file_content_changes": "@@ -2,13 +2,13 @@\n #define TRITON_ANALYSIS_ALIAS_H\n \n #include \"mlir/Analysis/AliasAnalysis.h\"\n-#include \"mlir/Analysis/DataFlowAnalysis.h\"\n+#include \"mlir/Analysis/DataFlow/SparseAnalysis.h\"\n #include \"llvm/ADT/DenseSet.h\"\n \n namespace mlir {\n \n class AliasInfo {\n-public:\n+ public:\n   AliasInfo() = default;\n   AliasInfo(Value value) { insert(value); }\n \n@@ -21,15 +21,19 @@ class AliasInfo {\n   }\n \n   /// The pessimistic value state of a value without alias\n-  static AliasInfo getPessimisticValueState(MLIRContext *context) {\n+  static AliasInfo getPessimisticValueState(MLIRContext *context = nullptr) {\n     return AliasInfo();\n   }\n   static AliasInfo getPessimisticValueState(Value value) { return AliasInfo(); }\n \n   /// The union of both arguments\n   static AliasInfo join(const AliasInfo &lhs, const AliasInfo &rhs);\n \n-private:\n+  void print(raw_ostream& os) const {\n+    llvm::interleaveComma(allocs, os, [&](Value alloc) { alloc.print(os); });\n+  }\n+\n+ private:\n   /// The set of allocated values that are aliased by this lattice.\n   /// For now, we only consider aliased value produced by the following\n   /// situations:\n@@ -58,9 +62,10 @@ class AliasInfo {\n //===----------------------------------------------------------------------===//\n // Shared Memory Alias Analysis\n //===----------------------------------------------------------------------===//\n-class SharedMemoryAliasAnalysis : public ForwardDataFlowAnalysis<AliasInfo> {\n-public:\n-  using ForwardDataFlowAnalysis<AliasInfo>::ForwardDataFlowAnalysis;\n+class SharedMemoryAliasAnalysis : public dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AliasInfo>> {\n+ public:\n+  using dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AliasInfo>>::SparseDataFlowAnalysis;\n+  using dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AliasInfo>>::getLatticeElement;\n \n   /// XXX(Keren): Compatible interface with MLIR AliasAnalysis for future use.\n   /// Given two values, returns their aliasing behavior.\n@@ -70,11 +75,12 @@ class SharedMemoryAliasAnalysis : public ForwardDataFlowAnalysis<AliasInfo> {\n   ModRefResult getModRef(Operation *op, Value location);\n \n   /// Computes if the alloc set of the results are changed.\n-  ChangeResult\n+  void\n   visitOperation(Operation *op,\n-                 ArrayRef<LatticeElement<AliasInfo> *> operands) override;\n+                 ArrayRef<const dataflow::Lattice<AliasInfo> *> operands,\n+                 ArrayRef<dataflow::Lattice<AliasInfo> *> results) override;\n };\n \n-} // namespace mlir\n+}  // namespace mlir\n \n-#endif // TRITON_ANALYSIS_ALIAS_H\n+#endif  // TRITON_ANALYSIS_ALIAS_H"}, {"filename": "include/triton/Analysis/Allocation.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -187,6 +187,9 @@ class Allocation {\n   friend class triton::AllocationAnalysis;\n };\n \n+template <typename T>\n+Interval(T, T) -> Interval<T>;\n+\n } // namespace mlir\n \n #endif // TRITON_ANALYSIS_ALLOCATION_H"}, {"filename": "include/triton/Analysis/AxisInfo.h", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "file_content_changes": "@@ -1,10 +1,11 @@\n #ifndef TRITON_ANALYSIS_AXISINFO_H\n #define TRITON_ANALYSIS_AXISINFO_H\n \n-#include \"mlir/Analysis/DataFlowAnalysis.h\"\n+#include \"mlir/Analysis/DataFlow/SparseAnalysis.h\"\n #include \"llvm/Support/raw_ostream.h\"\n #include <iostream>\n \n+#include \"mlir/Support/LLVM.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n \n@@ -52,14 +53,25 @@ class AxisInfo {\n   }\n \n   /// The pessimistic value state of the contiguity is unknown.\n-  static AxisInfo getPessimisticValueState(MLIRContext *context) {\n+  static AxisInfo getPessimisticValueState(MLIRContext *context = nullptr) {\n     return AxisInfo();\n   }\n   static AxisInfo getPessimisticValueState(Value value);\n \n   // The gcd of both arguments for each dimension\n   static AxisInfo join(const AxisInfo &lhs, const AxisInfo &rhs);\n \n+  void print(raw_ostream& os) const {\n+    auto print = [&](StringRef name, DimVectorT vec) {\n+      os << name << \" = [\";\n+      llvm::interleaveComma(vec, os);\n+      os << \"]\";\n+    };\n+    print(\"contiguity\", contiguity);\n+    print(\", divisibility\", divisibility);\n+    print(\", constancy\", constancy);\n+  }\n+\n private:\n   /// The _contiguity_ information maps the `d`-th\n   /// dimension to the length of the shortest\n@@ -108,7 +120,7 @@ class AxisInfo {\n   int rank;\n };\n \n-class AxisInfoAnalysis : public ForwardDataFlowAnalysis<AxisInfo> {\n+class AxisInfoAnalysis : public dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>> {\n \n private:\n   static const int maxPow2Divisor = 65536;\n@@ -126,11 +138,13 @@ class AxisInfoAnalysis : public ForwardDataFlowAnalysis<AxisInfo> {\n       const std::function<int(AxisInfo, AxisInfo, int)> &getConstancy);\n \n public:\n-  using ForwardDataFlowAnalysis<AxisInfo>::ForwardDataFlowAnalysis;\n+  using dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>>::SparseDataFlowAnalysis;\n+  using dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>>::getLatticeElement;\n \n-  ChangeResult\n+  void\n   visitOperation(Operation *op,\n-                 ArrayRef<LatticeElement<AxisInfo> *> operands) override;\n+                 ArrayRef<const dataflow::Lattice<AxisInfo> *> operands,\n+                 ArrayRef<dataflow::Lattice<AxisInfo> *> results) override;\n \n   unsigned getPtrVectorSize(Value ptr);\n \n@@ -141,4 +155,4 @@ class AxisInfoAnalysis : public ForwardDataFlowAnalysis<AxisInfo> {\n \n } // namespace mlir\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"filename": "include/triton/Analysis/Utility.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "file_content_changes": "@@ -1,6 +1,7 @@\n #ifndef TRITON_ANALYSIS_UTILITY_H\n #define TRITON_ANALYSIS_UTILITY_H\n \n+#include \"mlir/Analysis/DataFlowFramework.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n #include <algorithm>\n #include <numeric>\n@@ -11,7 +12,7 @@ namespace mlir {\n class ReduceOpHelper {\n public:\n   explicit ReduceOpHelper(triton::ReduceOp op) : op(op) {\n-    srcTy = op.operand().getType().cast<RankedTensorType>();\n+    srcTy = op.getOperand().getType().cast<RankedTensorType>();\n   }\n \n   ArrayRef<int64_t> getSrcShape() { return srcTy.getShape(); }\n@@ -80,6 +81,9 @@ SmallVector<RES_T> reorder(ArrayRef<T> input, ArrayRef<unsigned> order) {\n bool isMmaToDotShortcut(triton::gpu::MmaEncodingAttr &mmaLayout,\n                         triton::gpu::DotOperandEncodingAttr &dotOperandLayout);\n \n+// Create a basic DataFlowSolver with constant and dead code analysis included.\n+std::unique_ptr<DataFlowSolver> createDataFlowSolver();\n+\n } // namespace mlir\n \n #endif // TRITON_ANALYSIS_UTILITY_H"}, {"filename": "include/triton/Conversion/Passes.td", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "file_content_changes": "@@ -12,7 +12,6 @@ def ConvertTritonToTritonGPU: Pass<\"convert-triton-to-tritongpu\", \"mlir::ModuleO\n \n     let dependentDialects = [\"mlir::arith::ArithmeticDialect\",\n                              \"mlir::math::MathDialect\",\n-                             \"mlir::StandardOpsDialect\",\n                              // TODO: Does this pass depend on SCF?\n                              \"mlir::scf::SCFDialect\",\n                              \"mlir::triton::TritonDialect\",\n@@ -41,8 +40,7 @@ def ConvertTritonGPUToLLVM : Pass<\"convert-triton-gpu-to-llvm\", \"mlir::ModuleOp\"\n                              \"mlir::tensor::TensorDialect\",\n                              \"mlir::triton::TritonDialect\",\n                              \"mlir::triton::gpu::TritonGPUDialect\",\n-                             \"mlir::NVVM::NVVMDialect\",\n-                             \"mlir::StandardOpsDialect\"];\n+                             \"mlir::NVVM::NVVMDialect\"];\n \n     let options = [\n         Option<\"computeCapability\", \"compute-capability\","}, {"filename": "include/triton/Dialect/Triton/IR/Dialect.h", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "file_content_changes": "@@ -1,14 +1,15 @@\n #ifndef TRITON_DIALECT_TRITON_IR_DIALECT_H_\n #define TRITON_DIALECT_TRITON_IR_DIALECT_H_\n \n+#include \"mlir/Dialect/Arithmetic/IR/Arithmetic.h\"\n+#include \"mlir/Dialect/ControlFlow/IR/ControlFlow.h\"\n+#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n #include \"mlir/Dialect/Math/IR/Math.h\"\n-#include \"mlir/Dialect/SCF/SCF.h\"\n-#include \"mlir/Dialect/StandardOps/IR/Ops.h\"\n+#include \"mlir/Dialect/SCF/IR/SCF.h\"\n #include \"mlir/Dialect/Tensor/IR/Tensor.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/Dialect.h\"\n #include \"mlir/Interfaces/ControlFlowInterfaces.h\"\n-\n #include \"triton/Dialect/Triton/IR/Dialect.h.inc\"\n #include \"triton/Dialect/Triton/IR/OpsEnums.h.inc\"\n #include \"triton/Dialect/Triton/IR/Traits.h\"\n@@ -22,31 +23,29 @@ namespace triton {\n \n class DialectInferLayoutInterface\n     : public DialectInterface::Base<DialectInferLayoutInterface> {\n-public:\n+ public:\n   DialectInferLayoutInterface(Dialect *dialect) : Base(dialect) {}\n \n   virtual LogicalResult\n   inferTransOpEncoding(Attribute operandEncoding,\n                        Attribute &resultEncoding) const = 0;\n \n-  virtual LogicalResult\n-  inferReduceOpEncoding(Attribute operandEncoding, unsigned axis,\n-                        Attribute &resultEncoding) const = 0;\n+  virtual LogicalResult inferReduceOpEncoding(\n+      Attribute operandEncoding, unsigned axis,\n+      Attribute &resultEncoding) const = 0;\n \n-  virtual LogicalResult\n-  inferExpandDimsOpEncoding(Attribute operandEncoding, unsigned axis,\n-                            Attribute &resultEncoding,\n-                            Optional<Location> location) const = 0;\n+  virtual LogicalResult inferExpandDimsOpEncoding(\n+      Attribute operandEncoding, unsigned axis, Attribute &resultEncoding,\n+      Optional<Location> location) const = 0;\n \n   // Note: this function only verify operand encoding but doesn't infer result\n   // encoding\n-  virtual LogicalResult\n-  inferDotOpEncoding(Attribute operandEncoding, unsigned opIdx,\n-                     Attribute retEncoding,\n-                     Optional<Location> location) const = 0;\n+  virtual LogicalResult inferDotOpEncoding(\n+      Attribute operandEncoding, unsigned opIdx, Attribute retEncoding,\n+      Optional<Location> location) const = 0;\n };\n \n-} // namespace triton\n-} // namespace mlir\n+}  // namespace triton\n+}  // namespace mlir\n \n-#endif // TRITON_IR_DIALECT_H_\n+#endif  // TRITON_IR_DIALECT_H_"}, {"filename": "include/triton/Dialect/Triton/IR/TritonDialect.td", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "file_content_changes": "@@ -14,7 +14,7 @@ def Triton_Dialect : Dialect {\n     Triton Dialect.\n \n     Dependent Dialects:\n-      * Arithmetic:\n+      * Arithmeticmetic:\n         * addf, addi, andi, cmpf, cmpi, divf, fptosi, ...\n       * Math:\n         * exp, sin, cos, log, ...\n@@ -25,19 +25,17 @@ def Triton_Dialect : Dialect {\n   let dependentDialects = [\n     \"arith::ArithmeticDialect\",\n     \"math::MathDialect\",\n-    \"StandardOpsDialect\",\n     \"scf::SCFDialect\",\n-\n-    // Since LLVM 15\n-    // \"cf::ControlFlowDialect\",\n-    // \"func::FuncDialect\"\n+    \"cf::ControlFlowDialect\",\n+    \"func::FuncDialect\"\n   ];\n \n   let extraClassDeclaration = [{\n     void registerTypes();\n   }];\n \n   let hasConstantMaterializer = 1;\n+  let useDefaultTypePrinterParser = 1;\n }\n \n include \"triton/Dialect/Triton/IR/TritonTypes.td\""}, {"filename": "include/triton/Dialect/Triton/IR/TritonOps.td", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "file_content_changes": "@@ -141,11 +141,7 @@ def TT_LoadOp : TT_Op<\"load\",\n                        \"triton::EvictionPolicy\":$evict, \"bool\":$isVolatile)>,\n     ];\n \n-    // let assemblyFormat = \"operands attr-dict `:` type($result)\";\n-    let parser = [{ return mlir::triton::parseLoadOp(parser, result); }];\n-\n-    let printer = [{ return mlir::triton::printLoadOp(p, *this); }];\n-\n+    let hasCustomAssemblyFormat = 1;\n     let hasCanonicalizer = 1;\n }\n \n@@ -167,11 +163,7 @@ def TT_StoreOp : TT_Op<\"store\",\n         OpBuilder<(ins \"Value\":$ptr, \"Value\":$value)>,\n     ];\n \n-    // let assemblyFormat = \"operands attr-dict `:` type($value)\";\n-    let parser = [{ return mlir::triton::parseStoreOp(parser, result); }];\n-\n-    let printer = [{ return mlir::triton::printStoreOp(p, *this); }];\n-\n+    let hasCustomAssemblyFormat = 1;\n     let hasCanonicalizer = 1;\n }\n "}, {"filename": "include/triton/Dialect/Triton/IR/TritonTypes.td", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -1,6 +1,7 @@\n #ifndef TRITON_TYPES\n #define TRITON_TYPES\n \n+include \"mlir/IR/AttrTypeBase.td\"\n include \"triton/Dialect/Triton/IR/TritonDialect.td\"\n \n //\n@@ -58,6 +59,7 @@ def TT_Ptr : TritonTypeDef<\"Pointer\", \"ptr\"> {\n         }]>\n     ];\n \n+    let hasCustomAssemblyFormat = 1;\n     let skipDefaultBuilders = 1;\n }\n def TT_PtrTensor : TensorOf<[TT_Ptr]>;"}, {"filename": "include/triton/Dialect/Triton/Transforms/Passes.td", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "file_content_changes": "@@ -16,8 +16,7 @@ def TritonCombineOps : Pass</*cli-arg*/\"triton-combine\", /*Op*/\"mlir::ModuleOp\">\n \n   let constructor = \"mlir::triton::createCombineOpsPass()\";\n \n-  let dependentDialects = [\"mlir::arith::ArithmeticDialect\",\n-                           /*SelectOp*/\"mlir::StandardOpsDialect\"];\n+  let dependentDialects = [\"mlir::arith::ArithmeticDialect\"];\n }\n \n #endif"}, {"filename": "include/triton/Dialect/TritonGPU/IR/Dialect.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "file_content_changes": "@@ -1,19 +1,18 @@\n #ifndef TRITON_DIALECT_TRITONGPU_IR_DIALECT_H_\n #define TRITON_DIALECT_TRITONGPU_IR_DIALECT_H_\n \n-#include \"mlir/Dialect/GPU/GPUDialect.h\"\n+#include \"mlir/Dialect/GPU/IR/GPUDialect.h\"\n #include \"mlir/Dialect/Tensor/IR/Tensor.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/Dialect.h\"\n \n // TritonGPU depends on Triton\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n-\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h.inc\"\n #include \"triton/Dialect/TritonGPU/IR/Traits.h\"\n \n+// #include \"triton/Dialect/Triton/IR/AttrInterfaces.h.inc\"\n #define GET_ATTRDEF_CLASSES\n-#include \"triton/Dialect/Triton/IR/AttrInterfaces.h.inc\"\n #include \"triton/Dialect/TritonGPU/IR/TritonGPUAttrDefs.h.inc\"\n \n #define GET_OP_CLASSES\n@@ -43,8 +42,8 @@ SmallVector<unsigned> getOrder(const Attribute &layout);\n \n bool isaDistributedLayout(const Attribute &layout);\n \n-} // namespace gpu\n-} // namespace triton\n-} // namespace mlir\n+}  // namespace gpu\n+}  // namespace triton\n+}  // namespace mlir\n \n-#endif // TRITON_DIALECT_TRITONGPU_IR_DIALECT_H_\n+#endif  // TRITON_DIALECT_TRITONGPU_IR_DIALECT_H_"}, {"filename": "include/triton/Dialect/TritonGPU/IR/TritonGPUAttrDefs.td", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "file_content_changes": "@@ -1,6 +1,7 @@\n #ifndef TRITONGPU_ATTRDEFS\n #define TRITONGPU_ATTRDEFS\n \n+include \"mlir/IR/AttrTypeBase.td\"\n include \"triton/Dialect/TritonGPU/IR/TritonGPUDialect.td\"\n include \"triton/Dialect/Triton/IR/TritonInterfaces.td\"\n \n@@ -136,6 +137,7 @@ A_{3, 2}  A_{3, 3}  A_{3, 0}  A_{3, 1} ...   [phase 1] /\n   ];\n \n   let extraClassDeclaration = extraBaseClassDeclaration;\n+  let hasCustomAssemblyFormat = 1;\n }\n \n //===----------------------------------------------------------------------===//\n@@ -273,6 +275,7 @@ for\n     // ArrayRefParameter<\"unsigned\">:$sizePerCTA\n   );\n \n+  let hasCustomAssemblyFormat = 1;\n }\n \n //===----------------------------------------------------------------------===//\n@@ -422,6 +425,7 @@ For example, the matrix L corresponding to blockTileSize=[32,16] is:\n     static constexpr int numBitsToHoldMmaV1ID{5};\n   }];\n \n+  let hasCustomAssemblyFormat = 1;\n }\n \n def SliceEncodingAttr : DistributedEncoding<\"SliceEncoding\"> {\n@@ -456,6 +460,8 @@ def SliceEncodingAttr : DistributedEncoding<\"SliceEncoding\"> {\n     template<class T>\n     SmallVector<T> paddedShape(ArrayRef<T> shape) const;\n   }];\n+\n+  let hasCustomAssemblyFormat = 1;\n }\n \n def DotOperandEncodingAttr : DistributedEncoding<\"DotOperandEncoding\"> {\n@@ -492,6 +498,7 @@ section 9.7.13.4.1 for more details.\n \n   ];\n \n+  let hasCustomAssemblyFormat = 1;\n   let extraClassDeclaration = extraBaseClassDeclaration;\n }\n "}, {"filename": "include/triton/Dialect/TritonGPU/IR/TritonGPUDialect.td", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -30,7 +30,7 @@ def TritonGPU_Dialect : Dialect {\n     }\n   }];\n   \n-\n+  let useDefaultAttributePrinterParser = 1;\n }\n \n #endif"}, {"filename": "include/triton/Dialect/TritonGPU/IR/TritonGPUOps.td", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "file_content_changes": "@@ -59,7 +59,7 @@ def TTG_AsyncCommitGroupOp : TTG_Op<\"async_commit_group\"> {\n // This is needed because these ops don't\n // handle encodings\n // e.g., https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/Arith/IR/ArithOps.td#L111\n-def TTG_CmpIOp : TTG_Op<\"cmpi\", [NoSideEffect, Elementwise, \n+def TTG_CmpIOp : TTG_Op<\"cmpi\", [NoSideEffect, Elementwise,\n                                  SameOperandsAndResultShape, \n                                  SameOperandsAndResultEncoding]> {\n   let summary = \"integer comparison operation\";\n@@ -73,7 +73,7 @@ def TTG_CmpIOp : TTG_Op<\"cmpi\", [NoSideEffect, Elementwise,\n   let results = (outs TT_BoolLike:$result);\n }\n \n-def TTG_CmpFOp : TTG_Op<\"cmpf\", [NoSideEffect, Elementwise, \n+def TTG_CmpFOp : TTG_Op<\"cmpf\", [NoSideEffect, Elementwise,\n                                  SameOperandsAndResultShape, \n                                  SameOperandsAndResultEncoding]> {\n   let summary = \"floating-point comparison operation\";\n@@ -88,8 +88,8 @@ def TTG_CmpFOp : TTG_Op<\"cmpf\", [NoSideEffect, Elementwise,\n }\n \n // TODO: migrate to arith::SelectOp on LLVM16\n-def TTG_SelectOp : TTG_Op<\"select\", [NoSideEffect, Elementwise, \n-                                     SameOperandsAndResultShape, \n+def TTG_SelectOp : TTG_Op<\"select\", [NoSideEffect, Elementwise,\n+                                     SameOperandsAndResultShape,\n                                      SameOperandsAndResultEncoding]> {\n   let summary = \"select operation\";\n \n@@ -188,10 +188,7 @@ def TTG_InsertSliceAsyncOp : TTG_Op<\"insert_slice_async\",\n     }\n   }];\n \n-  // The custom parser could be replaced with oilist in LLVM-16\n-  let parser = [{ return parseInsertSliceAsyncOp(parser, result); }];\n-\n-  let printer = [{ return printInsertSliceAsyncOp(p, *this); }];\n+  let hasCustomAssemblyFormat = 1;\n }\n \n def TTG_AllocTensorOp : TTG_Op<\"alloc_tensor\", [MemoryEffects<[MemAlloc]>,  // Allocate shared memory"}, {"filename": "lib/Analysis/Alias.cpp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "file_content_changes": "@@ -18,8 +18,11 @@ AliasInfo AliasInfo::join(const AliasInfo &lhs, const AliasInfo &rhs) {\n   return ret;\n }\n \n-ChangeResult SharedMemoryAliasAnalysis::visitOperation(\n-    Operation *op, ArrayRef<LatticeElement<AliasInfo> *> operands) {\n+\n+  void\n+  SharedMemoryAliasAnalysis::visitOperation(Operation *op,\n+                 ArrayRef<const dataflow::Lattice<AliasInfo> *> operands,\n+                 ArrayRef<dataflow::Lattice<AliasInfo> *> results) {\n   AliasInfo aliasInfo;\n   bool pessimistic = true;\n   if (maybeSharedAllocationOp(op)) {\n@@ -44,14 +47,11 @@ ChangeResult SharedMemoryAliasAnalysis::visitOperation(\n   }\n \n   if (pessimistic) {\n-    return markAllPessimisticFixpoint(op->getResults());\n+    return markAllPessimisticFixpoint(results);\n   }\n   // Join all lattice elements\n-  ChangeResult result = ChangeResult::NoChange;\n-  for (Value value : op->getResults()) {\n-    result |= getLatticeElement(value).join(aliasInfo);\n-  }\n-  return result;\n+  for (auto* result : results)\n+    propagateIfChanged(result, result->join(aliasInfo));\n }\n \n AliasResult SharedMemoryAliasAnalysis::alias(Value lhs, Value rhs) {"}, {"filename": "lib/Analysis/Allocation.cpp", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "file_content_changes": "@@ -2,6 +2,7 @@\n #include \"mlir/Analysis/Liveness.h\"\n #include \"mlir/Analysis/SliceAnalysis.h\"\n #include \"mlir/Dialect/Tensor/IR/Tensor.h\"\n+#include \"mlir/Analysis/DataFlowFramework.h\"\n #include \"triton/Analysis/Alias.h\"\n #include \"triton/Analysis/Utility.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n@@ -33,10 +34,8 @@ constexpr int kPtrBitWidth = 64;\n \n static std::pair<SmallVector<unsigned>, SmallVector<unsigned>>\n getCvtOrder(const Attribute &srcLayout, const Attribute &dstLayout) {\n-  auto srcBlockedLayout = srcLayout.dyn_cast<BlockedEncodingAttr>();\n   auto srcMmaLayout = srcLayout.dyn_cast<MmaEncodingAttr>();\n   auto srcDotLayout = srcLayout.dyn_cast<DotOperandEncodingAttr>();\n-  auto dstBlockedLayout = dstLayout.dyn_cast<BlockedEncodingAttr>();\n   auto dstMmaLayout = dstLayout.dyn_cast<MmaEncodingAttr>();\n   auto dstDotLayout = dstLayout.dyn_cast<DotOperandEncodingAttr>();\n   assert(!(srcMmaLayout && dstMmaLayout) &&\n@@ -224,14 +223,12 @@ class AllocationAnalysis {\n   }\n \n   void getValueAlias(Value value, SharedMemoryAliasAnalysis &analysis) {\n-    LatticeElement<AliasInfo> *latticeElement =\n-        analysis.lookupLatticeElement(value);\n-    if (latticeElement) {\n-      auto &info = latticeElement->getValue();\n-      if (!info.getAllocs().empty()) {\n-        for (auto alloc : info.getAllocs()) {\n-          allocation->addAlias(value, alloc);\n-        }\n+    dataflow::Lattice<AliasInfo> *latticeElement =\n+        analysis.getLatticeElement(value);\n+    if (latticeElement && !latticeElement->isUninitialized()) {\n+      AliasInfo &info = latticeElement->getValue();\n+      for (auto alloc : info.getAllocs()) {\n+        allocation->addAlias(value, alloc);\n       }\n     }\n   }\n@@ -244,14 +241,17 @@ class AllocationAnalysis {\n       getScratchValueSize(op);\n     });\n     // Get the alias values\n-    SharedMemoryAliasAnalysis aliasAnalysis(operation->getContext());\n-    aliasAnalysis.run(operation);\n+    std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n+    SharedMemoryAliasAnalysis* aliasAnalysis =\n+        solver->load<SharedMemoryAliasAnalysis>();\n+    if (failed(solver->initializeAndRun(operation)))\n+      return;  // TODO(csigg): error reporting?\n     operation->walk<WalkOrder::PreOrder>([&](Operation *op) {\n       for (auto operand : op->getOperands()) {\n-        getValueAlias(operand, aliasAnalysis);\n+        getValueAlias(operand, *aliasAnalysis);\n       }\n       for (auto value : op->getResults()) {\n-        getValueAlias(value, aliasAnalysis);\n+        getValueAlias(value, *aliasAnalysis);\n       }\n     });\n   }"}, {"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "file_content_changes": "@@ -1,4 +1,4 @@\n-#include \"mlir/Analysis/DataFlowAnalysis.h\"\n+#include \"mlir/Analysis/DataFlowFramework.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"llvm/Support/raw_ostream.h\"\n #include <iostream>\n@@ -43,7 +43,7 @@ AxisInfo AxisInfo::getPessimisticValueState(Value value) {\n   BlockArgument blockArg = value.dyn_cast<BlockArgument>();\n   if (blockArg && blockArg.getOwner()->isEntryBlock()) {\n     Operation *op = blockArg.getOwner()->getParentOp();\n-    if (FuncOp fun = dyn_cast<FuncOp>(op)) {\n+    if (func::FuncOp fun = dyn_cast<func::FuncOp>(op)) {\n       Attribute attr =\n           fun.getArgAttr(blockArg.getArgNumber(), \"tt.divisibility\");\n       if (attr)\n@@ -96,8 +96,9 @@ AxisInfo AxisInfoAnalysis::visitBinaryOp(\n   return AxisInfo(newContiguity, newDivisibility, newConstancy);\n }\n \n-ChangeResult AxisInfoAnalysis::visitOperation(\n-    Operation *op, ArrayRef<LatticeElement<AxisInfo> *> operands) {\n+void AxisInfoAnalysis::visitOperation(\n+    Operation *op, ArrayRef<const dataflow::Lattice<AxisInfo> *> operands,\n+    ArrayRef<dataflow::Lattice<AxisInfo> *> results) {\n   AxisInfo curr;\n   // This preserves the input axes (e.g., cast):\n   if (llvm::isa<arith::ExtSIOp, arith::ExtUIOp, arith::TruncIOp,\n@@ -265,15 +266,12 @@ ChangeResult AxisInfoAnalysis::visitOperation(\n     curr = operands[0]->getValue();\n   }\n   if (curr.getRank() == 0) {\n-    return markAllPessimisticFixpoint(op->getResults());\n+    return markAllPessimisticFixpoint(results);\n   }\n \n   // join all lattice elements\n-  ChangeResult result = ChangeResult::NoChange;\n-  for (Value value : op->getResults()) {\n-    result |= getLatticeElement(value).join(curr);\n-  }\n-  return result;\n+  for (auto* result : results)\n+    propagateIfChanged(result, result->join(curr));\n }\n \n unsigned AxisInfoAnalysis::getPtrVectorSize(Value ptr) {\n@@ -299,7 +297,10 @@ unsigned AxisInfoAnalysis::getPtrAlignment(Value ptr) {\n   auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>();\n   if (!tensorTy)\n     return 1;\n-  auto axisInfo = lookupLatticeElement(ptr)->getValue();\n+  dataflow::Lattice<AxisInfo>* latticeElement = getLatticeElement(ptr);\n+  if (!latticeElement || latticeElement->isUninitialized())\n+    return 1;\n+  auto axisInfo = latticeElement->getValue();\n   auto layout = tensorTy.getEncoding();\n   auto order = triton::gpu::getOrder(layout);\n   unsigned maxMultiple = axisInfo.getDivisibility(order[0]);\n@@ -312,8 +313,11 @@ unsigned AxisInfoAnalysis::getMaskAlignment(Value mask) {\n   auto tensorTy = mask.getType().dyn_cast<RankedTensorType>();\n   if (!tensorTy)\n     return 1;\n+  dataflow::Lattice<AxisInfo> *latticeElement = getLatticeElement(mask);\n+  if (!latticeElement || latticeElement->isUninitialized())\n+    return 1;\n+  auto maskAxis = latticeElement->getValue();\n   auto maskOrder = triton::gpu::getOrder(tensorTy.getEncoding());\n-  auto maskAxis = lookupLatticeElement(mask)->getValue();\n   auto alignment = std::max<unsigned>(maskAxis.getConstancy(maskOrder[0]), 1);\n   return alignment;\n }"}, {"filename": "lib/Analysis/Membar.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -2,7 +2,7 @@\n #include \"triton/Analysis/Alias.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n \n-#include \"mlir/Dialect/GPU/GPUDialect.h\"\n+#include \"mlir/Dialect/GPU/IR/GPUDialect.h\"\n #include \"mlir/Dialect/Tensor/IR/Tensor.h\"\n \n namespace mlir {"}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "file_content_changes": "@@ -1,5 +1,8 @@\n #include \"triton/Analysis/Utility.h\"\n+#include \"mlir/Analysis/DataFlow/ConstantPropagationAnalysis.h\"\n+#include \"mlir/Analysis/DataFlow/DeadCodeAnalysis.h\"\n #include \"mlir/IR/Dialect.h\"\n+#include \"mlir/IR/Matchers.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n \n@@ -164,4 +167,53 @@ bool isMmaToDotShortcut(triton::gpu::MmaEncodingAttr &mmaLayout,\n          dotOperandLayout.getParent() == mmaLayout;\n }\n \n+namespace {\n+// Copied from TestDeadCodeAnalysis.cpp, because some dead code analysis\n+// interacts with constant propagation, but SparseConstantPropagation\n+// doesn't seem to be sufficient.\n+struct ConstantAnalysis : public DataFlowAnalysis {\n+  using DataFlowAnalysis::DataFlowAnalysis;\n+\n+  LogicalResult initialize(Operation *top) override {\n+    WalkResult result = top->walk([&](Operation *op) {\n+      if (failed(visit(op)))\n+        return WalkResult::interrupt();\n+      return WalkResult::advance();\n+    });\n+    return success(!result.wasInterrupted());\n+  }\n+\n+  LogicalResult visit(ProgramPoint point) override {\n+    Operation *op = point.get<Operation *>();\n+    Attribute value;\n+    if (matchPattern(op, m_Constant(&value))) {\n+      auto *constant = getOrCreate<dataflow::Lattice<dataflow::ConstantValue>>(op->getResult(0));\n+      propagateIfChanged(\n+          constant, constant->join(dataflow::ConstantValue(value, op->getDialect())));\n+      return success();\n+    }\n+    setAllToUnknownConstants(op->getResults());\n+    for (Region &region : op->getRegions())\n+      setAllToUnknownConstants(region.getArguments());\n+    return success();\n+  }\n+\n+  /// Set all given values as not constants.\n+  void setAllToUnknownConstants(ValueRange values) {\n+    dataflow::ConstantValue unknownConstant(nullptr, nullptr);\n+    for (Value value : values) {\n+      auto *constant = getOrCreate<dataflow::Lattice<dataflow::ConstantValue>>(value);\n+      propagateIfChanged(constant, constant->join(unknownConstant));\n+    }\n+  }\n+};\n+} // namespace\n+\n+std::unique_ptr<DataFlowSolver> createDataFlowSolver() {\n+    auto solver = std::make_unique<DataFlowSolver>();\n+    solver->load<dataflow::DeadCodeAnalysis>();\n+    solver->load<ConstantAnalysis>();\n+    return solver;\n+}\n+\n } // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "file_content_changes": "@@ -159,9 +159,6 @@ struct ConvertLayoutOpConversion\n                       Value smemBase) const {\n     auto accumNumCTAsEachRep = product<unsigned>(numCTAsEachRep);\n     auto layout = type.getEncoding();\n-    auto blockedLayout = layout.dyn_cast<BlockedEncodingAttr>();\n-    auto sliceLayout = layout.dyn_cast<SliceEncodingAttr>();\n-    auto mmaLayout = layout.dyn_cast<MmaEncodingAttr>();\n     auto rank = type.getRank();\n     auto sizePerThread = getSizePerThread(layout);\n     auto accumSizePerThread = product<unsigned>(sizePerThread);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "file_content_changes": "@@ -7,10 +7,8 @@\n #include \"mlir/Conversion/LLVMCommon/LoweringOptions.h\"\n #include \"mlir/Conversion/LLVMCommon/Pattern.h\"\n #include \"mlir/Conversion/MathToLLVM/MathToLLVM.h\"\n-#include \"mlir/Conversion/SCFToStandard/SCFToStandard.h\"\n-#include \"mlir/Conversion/StandardToLLVM/ConvertStandardToLLVM.h\"\n #include \"mlir/Dialect/Arithmetic/IR/Arithmetic.h\"\n-#include \"mlir/Dialect/GPU/GPUDialect.h\"\n+#include \"mlir/Dialect/GPU/IR/GPUDialect.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/Dialect/Tensor/IR/Tensor.h\"\n #include \"mlir/IR/Matchers.h\"\n@@ -422,8 +420,6 @@ struct DotOpMmaV1ConversionHelper {\n   computeOffsets(Value threadId, bool isARow, bool isBRow, ArrayRef<int> fpw,\n                  ArrayRef<int> spw, ArrayRef<int> rep,\n                  ConversionPatternRewriter &rewriter, Location loc) const {\n-    auto *ctx = rewriter.getContext();\n-    Value _1 = i32_val(1);\n     Value _3 = i32_val(3);\n     Value _4 = i32_val(4);\n     Value _16 = i32_val(16);\n@@ -464,7 +460,6 @@ struct DotOpMmaV1ConversionHelper {\n     Value offsetBN = add(warpNOff, laneNOff);\n     Value offsetBK = and_(lane, _3);\n     // i indices\n-    Value offsetCM = add(and_(lane, _1), offsetAM);\n     if (isARow) {\n       offsetAM = add(offsetAM, urem(threadId, _4));\n       offsetAK = i32_val(0);\n@@ -1296,9 +1291,9 @@ struct MMA16816ConversionHelper {\n   MMA16816ConversionHelper(Type dotOperand, MmaEncodingAttr mmaLayout,\n                            Value thread, ConversionPatternRewriter &rewriter,\n                            TypeConverter *typeConverter, Location loc)\n-      : mmaLayout(mmaLayout), thread(thread), helper(mmaLayout),\n-        rewriter(rewriter), typeConverter(typeConverter), loc(loc),\n-        ctx(mmaLayout.getContext()), wpt(mmaLayout.getWarpsPerCTA()) {\n+      : mmaLayout(mmaLayout), wpt(mmaLayout.getWarpsPerCTA()), thread(thread),\n+        helper(mmaLayout), rewriter(rewriter),\n+        typeConverter(typeConverter), loc(loc), ctx(mmaLayout.getContext()) {\n     helper.deduceMmaType(dotOperand);\n \n     Value _32 = i32_val(32);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "file_content_changes": "@@ -115,8 +115,6 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n     auto DTensorTy = D.getType().cast<RankedTensorType>();\n     auto AShape = ATensorTy.getShape();\n     auto BShape = BTensorTy.getShape();\n-    auto DShape = DTensorTy.getShape();\n-    auto wpt = mmaLayout.getWarpsPerCTA();\n \n     bool isARow = ALayout.getIsMMAv1Row().cast<BoolAttr>().getValue();\n     bool isBRow = BLayout.getIsMMAv1Row().cast<BoolAttr>().getValue();\n@@ -221,7 +219,6 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n                               ConversionPatternRewriter &rewriter) const {\n     auto *ctx = rewriter.getContext();\n     auto loc = op.getLoc();\n-    auto threadId = getThreadId(rewriter, loc);\n \n     auto A = op.a();\n     auto B = op.b();\n@@ -230,12 +227,10 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n \n     auto aTensorTy = A.getType().cast<RankedTensorType>();\n     auto bTensorTy = B.getType().cast<RankedTensorType>();\n-    auto cTensorTy = C.getType().cast<RankedTensorType>();\n     auto dTensorTy = D.getType().cast<RankedTensorType>();\n \n     auto aShape = aTensorTy.getShape();\n     auto bShape = bTensorTy.getShape();\n-    auto cShape = cTensorTy.getShape();\n \n     BlockedEncodingAttr dLayout =\n         dTensorTy.getEncoding().cast<BlockedEncodingAttr>();"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -61,7 +61,6 @@ struct FpToFpOpConversion\n   convertFp16x4ToFp8x4(Location loc, ConversionPatternRewriter &rewriter,\n                        const Value &v0, const Value &v1, const Value &v2,\n                        const Value &v3) {\n-    auto ctx = rewriter.getContext();\n     auto fp16x2VecTy = vec_ty(f16_ty, 2);\n     Value fp16x2Vec0 = undef(fp16x2VecTy);\n     Value fp16x2Vec1 = undef(fp16x2VecTy);\n@@ -153,7 +152,6 @@ struct FpToFpOpConversion\n   convertBf16x4ToFp8x4(Location loc, ConversionPatternRewriter &rewriter,\n                        const Value &v0, const Value &v1, const Value &v2,\n                        const Value &v3) {\n-    auto ctx = rewriter.getContext();\n     auto bf16x2VecTy = vec_ty(i16_ty, 2);\n     Value bf16x2Vec0 = undef(bf16x2VecTy);\n     Value bf16x2Vec1 = undef(bf16x2VecTy);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/LoadStoreOpToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -320,7 +320,6 @@ struct StoreOpConversion\n             elem = rewriter.create<LLVM::SExtOp>(loc, type::i8Ty(ctx), elem);\n           elem = bitcast(elem, valueElemTy);\n \n-          Type u32Ty = typeConverter->convertType(type::u32Ty(ctx));\n           llWord = insert_element(wordTy, llWord, elem, i32_val(elemIdx));\n         }\n         llWord = bitcast(llWord, valArgTy);\n@@ -374,7 +373,6 @@ struct AtomicCASOpConversion\n                   ConversionPatternRewriter &rewriter) const override {\n     auto loc = op.getLoc();\n     MLIRContext *ctx = rewriter.getContext();\n-    Value ptr = op.ptr();\n \n     Value llPtr = adaptor.ptr();\n     Value llCmp = adaptor.cmp();"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ReduceOpToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -286,7 +286,6 @@ struct ReduceOpConversion\n     auto srcTy = op.operand().getType().cast<RankedTensorType>();\n     auto srcLayout = srcTy.getEncoding();\n     auto srcShape = srcTy.getShape();\n-    auto srcRank = srcTy.getRank();\n     auto order = getOrder(srcLayout);\n \n     auto threadsPerWarp = triton::gpu::getThreadsPerWarp(srcLayout);\n@@ -351,7 +350,6 @@ struct ReduceOpConversion\n \n     Value zero = i32_val(0);\n     Value laneZero = icmp_eq(laneIdAxis, zero);\n-    Value warpZero = icmp_eq(warpIdAxis, zero);\n \n     for (auto it : accs) {\n       const SmallVector<unsigned> &key = it.first;"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "file_content_changes": "@@ -11,11 +11,11 @@ using ::mlir::LLVM::getStructFromElements;\n using ::mlir::triton::gpu::getElemsPerThread;\n using ::mlir::triton::gpu::SharedEncodingAttr;\n \n-struct ReturnOpConversion : public ConvertOpToLLVMPattern<::mlir::ReturnOp> {\n-  using ConvertOpToLLVMPattern<ReturnOp>::ConvertOpToLLVMPattern;\n+struct ReturnOpConversion : public ConvertOpToLLVMPattern<func::ReturnOp> {\n+  using ConvertOpToLLVMPattern<func::ReturnOp>::ConvertOpToLLVMPattern;\n \n   LogicalResult\n-  matchAndRewrite(ReturnOp op, OpAdaptor adaptor,\n+  matchAndRewrite(func::ReturnOp op, OpAdaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n     unsigned numArguments = op.getNumOperands();\n \n@@ -505,7 +505,6 @@ struct ExtractSliceOpConversion\n \n     auto llvmElemTy = getTypeConverter()->convertType(srcTy.getElementType());\n     auto elemPtrTy = ptr_ty(llvmElemTy, 3);\n-    auto resTy = op.getType().dyn_cast<RankedTensorType>();\n     smemObj = SharedMemoryObject(gep(elemPtrTy, smemObj.base, offset),\n                                  strideVals, offsetVals);\n     auto retVal = getStructFromSharedMemoryObject(loc, smemObj, rewriter);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "file_content_changes": "@@ -4,12 +4,14 @@\n // TODO: refactor so that it doesn't fail if Allocation.h\n // is included after utility.h (due to conflict in `store` macro\n // and <atomic>\n+#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n #include \"triton/Analysis/Allocation.h\"\n \n //\n-#include \"Utility.h\"\n #include \"mlir/IR/TypeUtilities.h\"\n #include \"triton/Analysis/AxisInfo.h\"\n+// Needs to be last because of load macro.\n+#include \"Utility.h\"\n \n using namespace mlir;\n using namespace mlir::triton;\n@@ -38,15 +40,16 @@ void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n // TODO(Superjomn): remove the code when MLIR v15.0 is included.\n // All the rights are reserved by the LLVM community.\n \n-struct FuncOpConversionBase : public ConvertOpToLLVMPattern<FuncOp> {\n+struct FuncOpConversionBase : public ConvertOpToLLVMPattern<func::FuncOp> {\n private:\n   /// Only retain those attributes that are not constructed by\n   /// `LLVMFuncOp::build`. If `filterArgAttrs` is set, also filter out argument\n   /// attributes.\n-  static void filterFuncAttributes(ArrayRef<NamedAttribute> attrs,\n+  static void filterFuncAttributes(func::FuncOp op,\n                                    bool filterArgAttrs,\n                                    SmallVectorImpl<NamedAttribute> &result) {\n-    for (const auto &attr : attrs) {\n+\n+    for (const auto &attr : op->getAttrs()) {\n       if (attr.getName() == SymbolTable::getSymbolAttrName() ||\n           attr.getName() == FunctionOpInterface::getTypeAttrName() ||\n           attr.getName() == \"std.varargs\" ||\n@@ -64,26 +67,26 @@ struct FuncOpConversionBase : public ConvertOpToLLVMPattern<FuncOp> {\n   }\n \n protected:\n-  using ConvertOpToLLVMPattern<FuncOp>::ConvertOpToLLVMPattern;\n+  using ConvertOpToLLVMPattern<func::FuncOp>::ConvertOpToLLVMPattern;\n \n   // Convert input FuncOp to LLVMFuncOp by using the LLVMTypeConverter provided\n   // to this legalization pattern.\n   LLVM::LLVMFuncOp\n-  convertFuncOpToLLVMFuncOp(FuncOp funcOp,\n+  convertFuncOpToLLVMFuncOp(func::FuncOp funcOp,\n                             ConversionPatternRewriter &rewriter) const {\n     // Convert the original function arguments. They are converted using the\n     // LLVMTypeConverter provided to this legalization pattern.\n     auto varargsAttr = funcOp->getAttrOfType<BoolAttr>(\"func.varargs\");\n     TypeConverter::SignatureConversion result(funcOp.getNumArguments());\n     auto llvmType = getTypeConverter()->convertFunctionSignature(\n-        funcOp.getType(), varargsAttr && varargsAttr.getValue(), result);\n+        funcOp.getFunctionType(), varargsAttr && varargsAttr.getValue(), result);\n     if (!llvmType)\n       return nullptr;\n \n     // Propagate argument/result attributes to all converted arguments/result\n     // obtained after converting a given original argument/result.\n     SmallVector<NamedAttribute, 4> attributes;\n-    filterFuncAttributes(funcOp->getAttrs(), /*filterArgAttrs=*/true,\n+    filterFuncAttributes(funcOp, /*filterArgAttrs=*/true,\n                          attributes);\n     if (ArrayAttr resAttrDicts = funcOp.getAllResultAttrs()) {\n       assert(!resAttrDicts.empty() && \"expected array to be non-empty\");\n@@ -130,7 +133,7 @@ struct FuncOpConversionBase : public ConvertOpToLLVMPattern<FuncOp> {\n     }\n     auto newFuncOp = rewriter.create<LLVM::LLVMFuncOp>(\n         funcOp.getLoc(), funcOp.getName(), llvmType, linkage,\n-        /*dsoLocal*/ false, attributes);\n+        /*dsoLocal*/ false, LLVM::CConv::C, attributes);\n     rewriter.inlineRegionBefore(funcOp.getBody(), newFuncOp.getBody(),\n                                 newFuncOp.end());\n     if (failed(rewriter.convertRegionTypes(&newFuncOp.getBody(), *typeConverter,\n@@ -190,8 +193,8 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n                                                const Allocation *allocation,\n                                                Value smem,\n                                                IndexCacheInfo indexCacheInfo)\n-      : converter(&typeConverter), indexCacheInfo(indexCacheInfo),\n-        allocation(allocation), smem(smem) {}\n+      : converter(&typeConverter), allocation(allocation), smem(smem),\n+        indexCacheInfo(indexCacheInfo) {}\n \n   LLVMTypeConverter *getTypeConverter() const { return converter; }\n \n@@ -796,7 +799,6 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n                             ArrayRef<int64_t> shape) const {\n     auto parent = sliceLayout.getParent();\n     unsigned dim = sliceLayout.getDim();\n-    size_t rank = shape.size();\n     auto parentIndices =\n         emitIndices(loc, rewriter, parent, sliceLayout.paddedShape(shape));\n     unsigned numIndices = parentIndices.size();"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "file_content_changes": "@@ -3,11 +3,11 @@\n #include \"mlir/Conversion/ArithmeticToLLVM/ArithmeticToLLVM.h\"\n #include \"mlir/Conversion/GPUToNVVM/GPUToNVVMPass.h\"\n #include \"mlir/Conversion/MathToLLVM/MathToLLVM.h\"\n-#include \"mlir/Conversion/SCFToStandard/SCFToStandard.h\"\n-#include \"mlir/Conversion/StandardToLLVM/ConvertStandardToLLVM.h\"\n+#include \"mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/Dialect/LLVMIR/NVVMDialect.h\"\n #include \"mlir/Pass/Pass.h\"\n+#include \"mlir/Analysis/DataFlowFramework.h\"\n #include \"triton/Analysis/Allocation.h\"\n #include \"triton/Analysis/AxisInfo.h\"\n #include \"triton/Analysis/Membar.h\"\n@@ -40,7 +40,6 @@ class TritonLLVMConversionTarget : public ConversionTarget {\n     addIllegalDialect<triton::TritonDialect>();\n     addIllegalDialect<triton::gpu::TritonGPUDialect>();\n     addIllegalDialect<mlir::gpu::GPUDialect>();\n-    addIllegalDialect<mlir::StandardOpsDialect>();\n     addLegalOp<mlir::UnrealizedConversionCastOp>();\n   }\n };\n@@ -51,7 +50,7 @@ class TritonLLVMFunctionConversionTarget : public ConversionTarget {\n       : ConversionTarget(ctx) {\n     addLegalDialect<LLVM::LLVMDialect>();\n     addLegalDialect<NVVM::NVVMDialect>();\n-    addIllegalOp<mlir::FuncOp>();\n+    addIllegalOp<mlir::func::FuncOp>();\n     addLegalOp<mlir::UnrealizedConversionCastOp>();\n   }\n };\n@@ -69,7 +68,7 @@ struct FuncOpConversion : public FuncOpConversionBase {\n       : FuncOpConversionBase(converter, benefit), numWarps(numWarps) {}\n \n   LogicalResult\n-  matchAndRewrite(FuncOp funcOp, OpAdaptor adaptor,\n+  matchAndRewrite(func::FuncOp funcOp, OpAdaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n     auto newFuncOp = convertFuncOpToLLVMFuncOp(funcOp, rewriter);\n     if (!newFuncOp)\n@@ -133,7 +132,8 @@ class ConvertTritonGPUToLLVM\n     decomposeBlockedToDotOperand(mod);\n \n     // Step 2\n-    decomposeInsertSliceAsyncOp(mod);\n+    if (failed(decomposeInsertSliceAsyncOp(mod)))\n+        return signalPassFailure();\n \n     // Step 3\n     Allocation allocation(mod);\n@@ -142,7 +142,7 @@ class ConvertTritonGPUToLLVM\n \n     // Step 4\n     RewritePatternSet scf_patterns(context);\n-    mlir::populateLoopToStdConversionPatterns(scf_patterns);\n+    mlir::populateSCFToControlFlowConversionPatterns(scf_patterns);\n     mlir::ConversionTarget scf_target(*context);\n     scf_target.addIllegalOp<scf::ForOp, scf::IfOp, scf::ParallelOp,\n                             scf::WhileOp, scf::ExecuteRegionOp>();\n@@ -159,8 +159,10 @@ class ConvertTritonGPUToLLVM\n       return signalPassFailure();\n \n     // Step 6 - get axis and shared memory info\n-    AxisInfoAnalysis axisInfoAnalysis(mod.getContext());\n-    axisInfoAnalysis.run(mod);\n+    std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n+    AxisInfoAnalysis *axisInfoAnalysis = solver->load<AxisInfoAnalysis>();\n+    if (failed(solver->initializeAndRun(mod)))\n+      return signalPassFailure();\n     initSharedMemory(allocation.getSharedMemorySize(), typeConverter);\n     mod->setAttr(\"triton_gpu.shared\",\n                  mlir::IntegerAttr::get(mlir::IntegerType::get(context, 32),\n@@ -178,38 +180,38 @@ class ConvertTritonGPUToLLVM\n \n     // Normal conversions\n     populateTritonGPUToLLVMPatterns(typeConverter, patterns, numWarps,\n-                                    axisInfoAnalysis, &allocation, smem,\n+                                    *axisInfoAnalysis, &allocation, smem,\n                                     indexCacheInfo, /*benefit=*/10);\n     // ConvertLayoutOp\n     populateConvertLayoutOpToLLVMPatterns(typeConverter, patterns, numWarps,\n-                                          axisInfoAnalysis, &allocation, smem,\n+                                          *axisInfoAnalysis, &allocation, smem,\n                                           indexCacheInfo, /*benefit=*/10);\n     // DotOp\n     populateDotOpToLLVMPatterns(typeConverter, patterns, numWarps,\n-                                axisInfoAnalysis, &allocation, smem,\n+                                *axisInfoAnalysis, &allocation, smem,\n                                 /*benefit=*/10);\n     // ElementwiseOp\n     populateElementwiseOpToLLVMPatterns(typeConverter, patterns, numWarps,\n-                                        axisInfoAnalysis, &allocation, smem,\n+                                        *axisInfoAnalysis, &allocation, smem,\n                                         /*benefit=*/10);\n     // LoadStoreOp\n     populateLoadStoreOpToLLVMPatterns(typeConverter, patterns, numWarps,\n-                                      axisInfoAnalysis, &allocation, smem,\n+                                      *axisInfoAnalysis, &allocation, smem,\n                                       indexCacheInfo, /*benefit=*/10);\n     // ReduceOp\n     populateReduceOpToLLVMPatterns(typeConverter, patterns, numWarps,\n-                                   axisInfoAnalysis, &allocation, smem,\n+                                   *axisInfoAnalysis, &allocation, smem,\n                                    indexCacheInfo, /*benefit=*/10);\n     // ViewOp\n     populateViewOpToLLVMPatterns(typeConverter, patterns, numWarps,\n-                                 axisInfoAnalysis, &allocation, smem,\n+                                 *axisInfoAnalysis, &allocation, smem,\n                                  /*benefit=*/10);\n \n     // Add arith/math's patterns to help convert scalar expression to LLVM.\n     mlir::arith::populateArithmeticToLLVMConversionPatterns(typeConverter,\n                                                             patterns);\n     mlir::populateMathToLLVMConversionPatterns(typeConverter, patterns);\n-    mlir::populateStdToLLVMConversionPatterns(typeConverter, patterns);\n+    // mlir::populateStdToLLVMConversionPatterns(typeConverter, patterns);\n     mlir::populateGpuToNVVMConversionPatterns(typeConverter, patterns);\n \n     if (failed(applyPartialConversion(mod, target, std::move(patterns))))\n@@ -306,9 +308,11 @@ class ConvertTritonGPUToLLVM\n     });\n   }\n \n-  void decomposeInsertSliceAsyncOp(ModuleOp mod) const {\n-    AxisInfoAnalysis axisInfoAnalysis(mod.getContext());\n-    axisInfoAnalysis.run(mod);\n+  LogicalResult decomposeInsertSliceAsyncOp(ModuleOp mod) const {\n+    std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n+    AxisInfoAnalysis *axisInfoAnalysis = solver->load<AxisInfoAnalysis>();\n+    if (failed(solver->initializeAndRun(mod)))\n+      return failure();\n     // TODO(Keren): This is a hacky knob that may cause performance regression\n     // when decomposition has been performed. We should remove this knob once we\n     // have thorough analysis on async wait. Currently, we decompose\n@@ -342,7 +346,7 @@ class ConvertTritonGPUToLLVM\n       auto resSharedLayout =\n           dstTy.getEncoding().dyn_cast<triton::gpu::SharedEncodingAttr>();\n       auto resElemTy = dstTy.getElementType();\n-      unsigned inVec = axisInfoAnalysis.getPtrVectorSize(src);\n+      unsigned inVec = axisInfoAnalysis->getPtrVectorSize(src);\n       unsigned outVec = resSharedLayout.getVec();\n       unsigned minVec = std::min(outVec, inVec);\n       auto maxBitWidth =\n@@ -400,11 +404,11 @@ class ConvertTritonGPUToLLVM\n       } else if (decomposed) {\n         // Wait for all previous async ops\n         OpBuilder builder(asyncWaitOp);\n-        auto newAsyncWaitOp =\n-            builder.create<triton::gpu::AsyncWaitOp>(asyncWaitOp.getLoc(), 0);\n+        builder.create<triton::gpu::AsyncWaitOp>(asyncWaitOp.getLoc(), 0);\n         asyncWaitOp.erase();\n       }\n     });\n+    return success();\n   }\n };\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -281,6 +281,7 @@ struct SharedMemoryObject {\n     strides = getStridesFromShapeAndOrder(shape, order, loc, rewriter);\n \n     for (auto idx : order) {\n+      (void)idx;\n       offsets.emplace_back(i32_val(0));\n     }\n   }"}, {"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.cpp", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "file_content_changes": "@@ -1,10 +1,9 @@\n #include \"triton/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.h\"\n \n #include \"mlir/Dialect/Arithmetic/IR/Arithmetic.h\"\n-#include \"mlir/Dialect/GPU/GPUDialect.h\"\n+#include \"mlir/Dialect/GPU/IR/GPUDialect.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/Dialect/LLVMIR/NVVMDialect.h\"\n-#include \"mlir/Dialect/StandardOps/IR/Ops.h\"\n #include \"mlir/Pass/Pass.h\"\n #include \"mlir/Transforms/DialectConversion.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n@@ -59,10 +58,13 @@ class ArithConstantPattern : public OpConversionPattern<arith::ConstantOp> {\n     Type retType = getTypeConverter()->convertType(op.getType());\n     auto value = adaptor.getValue().dyn_cast<DenseElementsAttr>();\n     assert(value);\n-    rewriter.replaceOpWithNewOp<arith::ConstantOp>(\n-        op, retType,\n-        value.reshape(retType) // This is a hack. We just want to add encoding\n-    );\n+    if (value.getElementType().isInteger(1) && value.isSplat())\n+      // Workaround until https://reviews.llvm.org/D133743 is included.\n+      value = DenseElementsAttr::get(retType, value.getSplatValue<bool>());\n+    else\n+      // This is a hack. We just want to add encoding\n+      value = value.reshape(retType);\n+    rewriter.replaceOpWithNewOp<arith::ConstantOp>(op, retType, value);\n     return success();\n   }\n };\n@@ -127,12 +129,12 @@ void populateArithmeticPatternsAndLegality(\n }\n \n // this shouldn't exist if mlir's SelectOp checked encodings properly\n-class StdSelectPattern : public OpConversionPattern<SelectOp> {\n+class StdSelectPattern : public OpConversionPattern<arith::SelectOp> {\n public:\n-  using OpConversionPattern<SelectOp>::OpConversionPattern;\n+  using OpConversionPattern<arith::SelectOp>::OpConversionPattern;\n \n   LogicalResult\n-  matchAndRewrite(SelectOp op, typename SelectOp::Adaptor adaptor,\n+  matchAndRewrite(arith::SelectOp op, OpAdaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n     Type retType = this->getTypeConverter()->convertType(op.getType());\n     rewriter.replaceOpWithNewOp<triton::gpu::SelectOp>(\n@@ -148,8 +150,8 @@ void populateStdPatternsAndLegality(TritonGPUTypeConverter &typeConverter,\n   MLIRContext *context = patterns.getContext();\n   // Rewrite rule\n   patterns.add<StdSelectPattern>(typeConverter, context);\n-  target.addLegalOp<ReturnOp>(); // this is ok because all functions are inlined\n-                                 // by the frontend\n+  target.addLegalOp<func::ReturnOp>(); // this is ok because all functions are\n+                                       // inlined by the frontend\n }\n \n void populateMathPatternsAndLegality(TritonGPUTypeConverter &typeConverter,\n@@ -454,7 +456,7 @@ struct TritonPrintfPattern : public OpConversionPattern<triton::PrintfOp> {\n void populateTritonPatterns(TritonGPUTypeConverter &typeConverter,\n                             RewritePatternSet &patterns) {\n   MLIRContext *context = patterns.getContext();\n-  patterns.add< // TODO: view should have custom pattern that views the layout\n+  patterns.insert< // TODO: view should have custom pattern that views the layout\n       TritonGenericPattern<triton::ViewOp>,\n       TritonGenericPattern<triton::BitcastOp>,\n       TritonGenericPattern<triton::FpToFpOp>,"}, {"filename": "lib/Dialect/Triton/IR/CMakeLists.txt", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "file_content_changes": "@@ -10,11 +10,7 @@ add_mlir_dialect_library(TritonIR\n \n   LINK_LIBS PUBLIC\n   MLIRIR\n-  MLIRArithmetic\n-  MLIRSCF\n-\n-  # Since LLVM 15\n-  # MLIRFunc\n-  # else\n-  MLIRStandard\n+  MLIRArithmeticDialect\n+  MLIRSCFDialect\n+  MLIRFuncDialect\n )"}, {"filename": "lib/Dialect/Triton/IR/Ops.cpp", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "file_content_changes": "@@ -1,10 +1,9 @@\n-#include \"triton/Dialect/Triton/IR/Dialect.h\"\n-#include \"triton/Dialect/Triton/IR/Types.h\"\n-\n #include \"mlir/IR/Builders.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n #include \"mlir/IR/BuiltinTypes.h\"\n #include \"mlir/IR/OperationSupport.h\"\n+#include \"triton/Dialect/Triton/IR/Dialect.h\"\n+#include \"triton/Dialect/Triton/IR/Types.h\"\n \n namespace mlir {\n namespace triton {\n@@ -38,8 +37,8 @@ static Type getPointerTypeSameShape(Type type) {\n }\n \n // Parser & printer for assembly forms\n-ParseResult parseLoadOp(OpAsmParser &parser, OperationState &result) {\n-  SmallVector<OpAsmParser::OperandType, 4> allOperands;\n+ParseResult LoadOp::parse(OpAsmParser &parser, OperationState &result) {\n+  SmallVector<OpAsmParser::UnresolvedOperand, 4> allOperands;\n   Type resultTypes[1];\n   SMLoc allOperandLoc = parser.getCurrentLocation();\n   if (parser.parseOperandList(allOperands) ||\n@@ -73,18 +72,18 @@ ParseResult parseLoadOp(OpAsmParser &parser, OperationState &result) {\n   return success();\n }\n \n-void printLoadOp(OpAsmPrinter &printer, LoadOp loadOp) {\n+void LoadOp::print(OpAsmPrinter &printer) {\n   printer << \" \";\n-  printer << loadOp.getOperation()->getOperands();\n+  printer << getOperation()->getOperands();\n   // \"operand_segment_sizes\" can be deduced, so we don't print it.\n-  printer.printOptionalAttrDict(loadOp->getAttrs(),\n-                                {loadOp.operand_segment_sizesAttrName()});\n+  printer.printOptionalAttrDict(getOperation()->getAttrs(),\n+                                {operand_segment_sizesAttrName()});\n   printer << \" : \";\n-  printer.printStrippedAttrOrType(loadOp.result().getType());\n+  printer.printStrippedAttrOrType(getResult().getType());\n }\n \n-ParseResult parseStoreOp(OpAsmParser &parser, OperationState &result) {\n-  SmallVector<OpAsmParser::OperandType, 4> allOperands;\n+ParseResult StoreOp::parse(OpAsmParser &parser, OperationState &result) {\n+  SmallVector<OpAsmParser::UnresolvedOperand, 4> allOperands;\n   Type valueType;\n   SMLoc allOperandLoc = parser.getCurrentLocation();\n   if (parser.parseOperandList(allOperands) ||\n@@ -104,12 +103,12 @@ ParseResult parseStoreOp(OpAsmParser &parser, OperationState &result) {\n   return success();\n }\n \n-void printStoreOp(OpAsmPrinter &printer, StoreOp storeOp) {\n+void StoreOp::print(OpAsmPrinter &printer) {\n   printer << \" \";\n-  printer << storeOp.getOperation()->getOperands();\n-  printer.printOptionalAttrDict(storeOp->getAttrs(), /*elidedAttrs=*/{});\n+  printer << getOperation()->getOperands();\n+  printer.printOptionalAttrDict(getOperation()->getAttrs(), /*elidedAttrs=*/{});\n   printer << \" : \";\n-  printer.printStrippedAttrOrType(storeOp.value().getType());\n+  printer.printStrippedAttrOrType(value().getType());\n }\n \n } // namespace triton\n@@ -316,7 +315,8 @@ OpFoldResult SplatOp::fold(ArrayRef<Attribute> operands) {\n   if (!constOperand)\n     return {};\n   auto shapedType = getType().cast<ShapedType>();\n-  auto ret = SplatElementsAttr::get(shapedType, {constOperand.getValue()});\n+  auto ret = SplatElementsAttr::get(\n+      shapedType, ArrayRef<Attribute>(constOperand.getValue()));\n   return ret;\n }\n "}, {"filename": "lib/Dialect/Triton/Transforms/Combine.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -57,13 +57,13 @@ DenseElementsAttr getConstantValue(Builder &builder, Attribute value,\n class CombineSelectMaskedLoadPattern : public mlir::RewritePattern {\n public:\n   CombineSelectMaskedLoadPattern(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(mlir::SelectOp::getOperationName(), 3, context,\n+      : mlir::RewritePattern(mlir::arith::SelectOp::getOperationName(), 3, context,\n                              {triton::LoadOp::getOperationName()}) {}\n \n   mlir::LogicalResult\n   matchAndRewrite(mlir::Operation *op,\n                   mlir::PatternRewriter &rewriter) const override {\n-    auto selectOp = llvm::dyn_cast<mlir::SelectOp>(op);\n+    auto selectOp = llvm::dyn_cast<mlir::arith::SelectOp>(op);\n     if (!selectOp)\n       return mlir::failure();\n "}, {"filename": "lib/Dialect/Triton/Transforms/Combine.td", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,9 +1,9 @@\n #ifndef TRITON_PATTERNS\n #define TRITON_PATTERNS\n \n-include \"mlir/Dialect/StandardOps/IR/Ops.td\"\n include \"mlir/Dialect/Arithmetic/IR/ArithmeticOps.td\"\n include \"triton/Dialect/Triton/IR/TritonOps.td\"\n+include \"mlir/IR/PatternBase.td\"\n \n \n // AddIOp(DotOp(a, b, c), d) and c==0 => DotOp(a, b, d)"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "file_content_changes": "@@ -1,13 +1,13 @@\n+#include \"triton/Dialect/Triton/IR/Dialect.h\"\n+\n #include <numeric>\n \n+#include \"llvm/ADT/TypeSwitch.h\"\n #include \"mlir/IR/DialectImplementation.h\"\n #include \"mlir/IR/OpImplementation.h\"\n #include \"triton/Analysis/Utility.h\"\n-#include \"triton/Dialect/Triton/IR/Dialect.h\"\n-#include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n-#include \"llvm/ADT/TypeSwitch.h\"\n-\n #include \"triton/Dialect/TritonGPU/IR/Dialect.cpp.inc\"\n+#include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n \n using namespace mlir;\n using namespace mlir::triton::gpu;\n@@ -376,7 +376,6 @@ template SmallVector<int64_t>\n SliceEncodingAttr::paddedShape<int64_t>(ArrayRef<int64_t> shape) const;\n \n unsigned SliceEncodingAttr::getElemsPerThread(ArrayRef<int64_t> shape) const {\n-  size_t rank = shape.size();\n   auto parent = getParent();\n   return ::getElemsPerThread(parent, paddedShape(shape));\n }\n@@ -657,9 +656,9 @@ void DotOperandEncodingAttr::print(mlir::AsmPrinter &printer) const {\n // InsertSliceAsyncOp\n //===----------------------------------------------------------------------===//\n \n-ParseResult parseInsertSliceAsyncOp(OpAsmParser &parser,\n-                                    OperationState &result) {\n-  SmallVector<OpAsmParser::OperandType, 8> allOperands;\n+ParseResult InsertSliceAsyncOp::parse(OpAsmParser &parser,\n+                                      OperationState &result) {\n+  SmallVector<OpAsmParser::UnresolvedOperand, 8> allOperands;\n   Type srcType, dstType;\n   SMLoc allOperandLoc = parser.getCurrentLocation();\n   if (parser.parseOperandList(allOperands) ||\n@@ -698,18 +697,16 @@ ParseResult parseInsertSliceAsyncOp(OpAsmParser &parser,\n   return success();\n }\n \n-void printInsertSliceAsyncOp(OpAsmPrinter &printer,\n-                             InsertSliceAsyncOp insertSliceAsyncOp) {\n+void InsertSliceAsyncOp::print(OpAsmPrinter &printer) {\n   printer << \" \";\n-  printer << insertSliceAsyncOp.getOperation()->getOperands();\n+  printer << getOperation()->getOperands();\n   // \"operand_segment_sizes\" can be deduced, so we don't print it.\n-  printer.printOptionalAttrDict(\n-      insertSliceAsyncOp->getAttrs(),\n-      {insertSliceAsyncOp.operand_segment_sizesAttrName()});\n+  printer.printOptionalAttrDict(getOperation()->getAttrs(),\n+                                {operand_segment_sizesAttrName()});\n   printer << \" : \";\n-  printer.printStrippedAttrOrType(insertSliceAsyncOp.src().getType());\n+  printer.printStrippedAttrOrType(src().getType());\n   printer << \" -> \";\n-  printer.printStrippedAttrOrType(insertSliceAsyncOp.result().getType());\n+  printer.printStrippedAttrOrType(result().getType());\n }\n \n //===----------------------------------------------------------------------===//"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Coalesce.cpp", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "file_content_changes": "@@ -16,7 +16,10 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n     auto origType = ptr.getType().cast<RankedTensorType>();\n     // Get the shape of the tensor.\n     size_t rank = origType.getRank();\n-    AxisInfo info = axisInfo.lookupLatticeElement(ptr)->getValue();\n+    dataflow::Lattice<AxisInfo> *latticeElement =\n+        axisInfo.getLatticeElement(ptr);\n+    AxisInfo info = latticeElement && !latticeElement->isUninitialized() ?\n+        latticeElement->getValue() : AxisInfo();\n     // Layout order in decreasing order of contiguity\n     SmallVector<unsigned, 4> order(rank);\n     std::iota(order.begin(), order.end(), 0);\n@@ -69,7 +72,6 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n     auto mod = op->getParentOfType<ModuleOp>();\n     int numWarps = triton::gpu::TritonGPUDialect::getNumWarps(mod);\n \n-    AxisInfo info = axisInfo.lookupLatticeElement(ptr)->getValue();\n     auto convertType = getTypeConverter(axisInfo, ptr, numWarps);\n     // convert operands\n     SmallVector<Value, 4> newArgs;\n@@ -105,8 +107,11 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n   void runOnOperation() override {\n     Operation *op = getOperation();\n     // Run axis info analysis\n-    AxisInfoAnalysis axisInfo(&getContext());\n-    axisInfo.run(op);\n+    std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n+    AxisInfoAnalysis* axisInfo =\n+        solver->load<AxisInfoAnalysis>();\n+    if (failed(solver->initializeAndRun(op)))\n+      return signalPassFailure();\n     OpBuilder builder(op);\n \n     // For each memory op that has a layout L1:\n@@ -120,16 +125,16 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n       OpBuilder::InsertionGuard g(builder);\n       builder.setInsertionPoint(curr);\n       if (auto load = dyn_cast<triton::LoadOp>(curr))\n-        coalesceOp<triton::LoadOp>(axisInfo, curr, load.ptr(), builder);\n+        coalesceOp<triton::LoadOp>(*axisInfo, curr, load.ptr(), builder);\n       if (auto op = dyn_cast<triton::AtomicRMWOp>(curr))\n-        coalesceOp<triton::AtomicRMWOp>(axisInfo, curr, op.ptr(), builder);\n+        coalesceOp<triton::AtomicRMWOp>(*axisInfo, curr, op.ptr(), builder);\n       if (auto op = dyn_cast<triton::AtomicCASOp>(curr))\n-        coalesceOp<triton::AtomicCASOp>(axisInfo, curr, op.ptr(), builder);\n+        coalesceOp<triton::AtomicCASOp>(*axisInfo, curr, op.ptr(), builder);\n       if (auto load = dyn_cast<triton::gpu::InsertSliceAsyncOp>(curr))\n-        coalesceOp<triton::gpu::InsertSliceAsyncOp>(axisInfo, curr, load.src(),\n+        coalesceOp<triton::gpu::InsertSliceAsyncOp>(*axisInfo, curr, load.src(),\n                                                     builder);\n       if (auto store = dyn_cast<triton::StoreOp>(curr))\n-        coalesceOp<triton::StoreOp>(axisInfo, curr, store.ptr(), builder);\n+        coalesceOp<triton::StoreOp>(*axisInfo, curr, store.ptr(), builder);\n     });\n   }\n };"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,6 +1,6 @@\n #include \"Utility.h\"\n #include \"mlir/Analysis/SliceAnalysis.h\"\n-#include \"mlir/Dialect/SCF/SCF.h\"\n+#include \"mlir/Dialect/SCF/IR/SCF.h\"\n #include \"mlir/IR/BlockAndValueMapping.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n #include \"mlir/IR/Matchers.h\""}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.td", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -3,5 +3,6 @@\n \n include \"triton/Dialect/TritonGPU/IR/TritonGPUOps.td\"\n include \"triton/Dialect/Triton/IR/TritonOps.td\"\n+include \"mlir/IR/PatternBase.td\"\n \n #endif"}, {"filename": "lib/Dialect/TritonGPU/Transforms/DecomposeConversions.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,5 +1,5 @@\n #include \"mlir/Analysis/SliceAnalysis.h\"\n-#include \"mlir/Dialect/SCF/SCF.h\"\n+#include \"mlir/Dialect/SCF/IR/SCF.h\"\n #include \"mlir/IR/BlockAndValueMapping.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n #include \"mlir/IR/Matchers.h\""}, {"filename": "lib/Dialect/TritonGPU/Transforms/ReorderInstructions.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,5 +1,5 @@\n #include \"mlir/Analysis/SliceAnalysis.h\"\n-#include \"mlir/Dialect/SCF/SCF.h\"\n+#include \"mlir/Dialect/SCF/IR/SCF.h\"\n #include \"mlir/IR/BlockAndValueMapping.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n #include \"mlir/IR/Matchers.h\""}, {"filename": "lib/Dialect/TritonGPU/Transforms/TritonGPUConversion.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -82,7 +82,7 @@ TritonGPUConversionTarget::TritonGPUConversionTarget(\n                scf::ReduceReturnOp>();\n \n   addDynamicallyLegalDialect<arith::ArithmeticDialect, math::MathDialect,\n-                             triton::TritonDialect, StandardOpsDialect,\n+                             triton::TritonDialect,\n                              scf::SCFDialect>([&](Operation *op) {\n     if (typeConverter.isLegal(op))\n       return true;"}, {"filename": "lib/Dialect/TritonGPU/Transforms/UpdateMmaForVolta.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,5 +1,5 @@\n #include \"Utility.h\"\n-#include \"mlir/Dialect/SCF/SCF.h\"\n+#include \"mlir/Dialect/SCF/IR/SCF.h\"\n #include \"mlir/IR/Matchers.h\"\n #include \"mlir/IR/PatternMatch.h\"\n #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\""}, {"filename": "lib/Dialect/TritonGPU/Transforms/Utility.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,5 +1,5 @@\n #include \"Utility.h\"\n-#include \"mlir/Dialect/SCF/SCF.h\"\n+#include \"mlir/Dialect/SCF/IR/SCF.h\"\n #include \"mlir/IR/BlockAndValueMapping.h\"\n #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"\n "}, {"filename": "lib/Target/LLVMIR/CMakeLists.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "file_content_changes": "@@ -6,8 +6,7 @@ add_mlir_translation_library(TritonLLVMIR\n \n         LINK_LIBS PUBLIC\n         MLIRIR\n-        MLIRLLVMIR\n-        MLIRSCFToStandard\n+        MLIRLLVMDialect\n         MLIRSupport\n         MLIRTargetLLVMIRExport\n         )"}, {"filename": "lib/Target/PTX/PTXTranslation.cpp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -1,11 +1,14 @@\n #include \"triton/Target/PTX/PTXTranslation.h\"\n+#include <optional>\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n \n #include \"llvm/IR/IRBuilder.h\"\n #include \"llvm/IR/LegacyPassManager.h\"\n #include \"llvm/IR/Module.h\"\n #include \"llvm/IR/Verifier.h\"\n #include \"llvm/MC/TargetRegistry.h\"\n+#include \"llvm/Pass.h\"\n+#include \"llvm/Support/CommandLine.h\"\n #include \"llvm/Support/TargetSelect.h\"\n #include \"llvm/Target/TargetMachine.h\"\n "}, {"filename": "python/setup.py", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -55,11 +55,11 @@ def get_llvm_package_info():\n     system_suffix = {\"Linux\": \"linux-gnu-ubuntu-18.04\", \"Darwin\": \"apple-darwin\"}[system]\n     use_assert_enabled_llvm = check_env_flag(\"TRITON_USE_ASSERT_ENABLED_LLVM\", \"False\")\n     if use_assert_enabled_llvm:\n-        name = 'llvm+mlir-14.0.0-x86_64-{}-assert'.format(system_suffix)\n-        url = \"https://github.com/shintaro-iwasaki/llvm-releases/releases/download/llvm-14.0.0-329fda39c507/{}.tar.xz\".format(name)\n+        name = 'llvm+mlir-15.0.0-x86_64-{}-assert'.format(system_suffix)\n+        url = \"https://github.com/shintaro-iwasaki/llvm-releases/releases/download/llvm-15.0.0-4ba6a9c9f65b/{}.tar.xz\".format(name)\n     else:\n-        name = 'clang+llvm-14.0.0-x86_64-{}'.format(system_suffix)\n-        url = \"https://github.com/llvm/llvm-project/releases/download/llvmorg-14.0.0/{}.tar.xz\".format(name)\n+        name = 'clang+llvm-15.0.0-x86_64-{}'.format(system_suffix)\n+        url = \"https://github.com/llvm/llvm-project/releases/download/llvmorg-15.0.0/{}.tar.xz\".format(name)\n     return Package(\"llvm\", name, url, \"lib\", \"LLVM_INCLUDE_DIRS\", \"LLVM_LIBRARY_DIR\", \"LLVM_SYSPATH\")\n \n "}, {"filename": "test/Analysis/test-alias.mlir", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "file_content_changes": "@@ -11,7 +11,7 @@\n \n // CHECK-LABEL: matmul_loop\n // There shouldn't be any aliasing with the dot op encoding.\n-func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_ptr_init = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n   %b_ptr_init = tt.broadcast %B : (!tt.ptr<f16>) -> tensor<32x128x!tt.ptr<f16>, #BL>\n   %a_mask = arith.constant dense<true> : tensor<128x32xi1, #AL>\n@@ -36,7 +36,7 @@ func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B\n }\n \n // CHECK-LABEL: alloc\n-func @alloc(%A : !tt.ptr<f16>) {\n+func.func @alloc(%A : !tt.ptr<f16>) {\n   // CHECK: %cst -> %cst\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x32xf16, #AL>\n@@ -46,15 +46,15 @@ func @alloc(%A : !tt.ptr<f16>) {\n }\n \n // CHECK-LABEL: convert\n-func @convert(%A : !tt.ptr<f16>) {\n+func.func @convert(%A : !tt.ptr<f16>) {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #AL>\n   // CHECK: %0 -> %0\n   %cst1 = triton_gpu.convert_layout %cst0 : (tensor<16x16xf16, #AL>) -> tensor<16x16xf16, #A_SHARED>\n   return\n }\n \n // CHECK-LABEL: trans\n-func @trans(%A : !tt.ptr<f16>) {\n+func.func @trans(%A : !tt.ptr<f16>) {\n   // CHECK: %cst -> %cst\n   %tensor = arith.constant dense<0.000000e+00> : tensor<16x32xf16, #A_SHARED>\n   // CHECK: %0 -> %cst\n@@ -63,7 +63,7 @@ func @trans(%A : !tt.ptr<f16>) {\n }\n \n // CHECK-LABEL: insert_slice_async\n-func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n+func.func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n   %a_ptr = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<16x16x!tt.ptr<f16>, #AL>\n   %mask = tt.splat %i1 : (i1) -> tensor<16x16xi1, #AL>\n   %other = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #AL>\n@@ -76,7 +76,7 @@ func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n }\n \n // CHECK-LABEL: insert_slice\n-func @insert_slice(%A : !tt.ptr<f16>, %i1 : i1) {\n+func.func @insert_slice(%A : !tt.ptr<f16>, %i1 : i1) {\n   %a_ptr = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<16x16x!tt.ptr<f16>, #AL>\n   %mask = tt.splat %i1 : (i1) -> tensor<16x16xi1, #AL>\n   %other = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #AL>\n@@ -90,7 +90,7 @@ func @insert_slice(%A : !tt.ptr<f16>, %i1 : i1) {\n }\n \n // CHECK-LABEL: extract_slice\n-func @extract_slice(%A : !tt.ptr<f16>) {\n+func.func @extract_slice(%A : !tt.ptr<f16>) {\n   // CHECK: %cst -> %cst\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<1x16x16xf16, #A_SHARED>\n   %index = arith.constant 0 : index\n@@ -100,7 +100,7 @@ func @extract_slice(%A : !tt.ptr<f16>) {\n }\n \n // CHECK-LABEL: if_cat\n-func @if_cat(%i1 : i1) {\n+func.func @if_cat(%i1 : i1) {\n   // CHECK: %cst -> %cst\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK: %cst_0 -> %cst_0\n@@ -119,7 +119,7 @@ func @if_cat(%i1 : i1) {\n }\n \n // CHECK-LABEL: if_alias\n-func @if_alias(%i1 : i1) {\n+func.func @if_alias(%i1 : i1) {\n   // CHECK: %cst -> %cst\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK-NEXT: %cst_0 -> %cst_0\n@@ -134,7 +134,7 @@ func @if_alias(%i1 : i1) {\n }\n \n // CHECK-LABEL: for\n-func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   // CHECK: %cst -> %cst\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: %cst_0 -> %cst_0\n@@ -154,7 +154,7 @@ func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.p\n }\n \n // CHECK-LABEL: for_if\n-func @for_if(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n+func.func @for_if(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n   // CHECK: %cst -> %cst\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: %cst_0 -> %cst_0\n@@ -180,7 +180,7 @@ func @for_if(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !t\n }\n \n // CHECK-LABEL: for_if_for\n-func @for_if_for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n+func.func @for_if_for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n   // CHECK: %cst -> %cst\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: %cst_0 -> %cst_0"}, {"filename": "test/Analysis/test-alignment.mlir", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "file_content_changes": "@@ -1,51 +1,51 @@\n // RUN: triton-opt %s -test-print-alignment -split-input-file 2>&1 | FileCheck %s\n \n-func @permute_2d(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32 {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}) {\n-  // CHECK: Contiguity: [1, 1] ; Divisibility: [1, 1] ; Constancy: [1, 1]\n+func.func @permute_2d(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32 {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}) {\n+  // CHECK: contiguity = [1, 1], divisibility = [1, 1], constancy = [1, 1]\n   %cst = arith.constant dense<true> : tensor<128x128xi1>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [1, 1] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [1, 1], constancy = [1, 1]\n   %cst_0 = arith.constant dense<0.000000e+00> : tensor<128x128xf32>\n-  // CHECK-NEXT: Contiguity: [128] ; Divisibility: [65536] ; Constancy: [1]\n+  // CHECK-NEXT: contiguity = [128], divisibility = [65536], constancy = [1]\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [128] ; Divisibility: [65536] ; Constancy: [1]\n+  // CHECK-NEXT: contiguity = [128], divisibility = [65536], constancy = [1]\n   %1 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [128, 1] ; Divisibility: [65536, 1] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [128, 1], divisibility = [65536, 1], constancy = [1, 1]\n   %2 = tt.expand_dims %0 {axis = 1 : i32} : (tensor<128xi32>) -> tensor<128x1xi32>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [16, 16] ; Constancy: [128, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [16, 16], constancy = [128, 1]\n   %3 = tt.splat %arg1 : (i32) -> tensor<128x1xi32>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [1048576, 16] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [1048576, 16], constancy = [1, 1]\n   %4 = arith.muli %2, %3 : tensor<128x1xi32>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [16, 16] ; Constancy: [128, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [16, 16], constancy = [128, 1]\n   %5 = tt.splat %arg0 : (!tt.ptr<f32>) -> tensor<128x1x!tt.ptr<f32>>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [16, 16] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [16, 16], constancy = [1, 1]\n   %6 = tt.addptr %5, %4 : tensor<128x1x!tt.ptr<f32>>, tensor<128x1xi32>\n-  // CHECK-NEXT: Contiguity: [1, 128] ; Divisibility: [1, 65536] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [1, 128], divisibility = [1, 65536], constancy = [1, 1]\n   %7 = tt.expand_dims %1 {axis = 0 : i32}: (tensor<128xi32>) -> tensor<1x128xi32>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [16, 16] ; Constancy: [1, 128]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [16, 16], constancy = [1, 128]\n   %8 = tt.broadcast %6 : (tensor<128x1x!tt.ptr<f32>>) -> tensor<128x128x!tt.ptr<f32>>\n-  // CHECK-NEXT: Contiguity: [1, 128] ; Divisibility: [1, 65536] ; Constancy: [128, 1]\n+  // CHECK-NEXT: contiguity = [1, 128], divisibility = [1, 65536], constancy = [128, 1]\n   %9 = tt.broadcast %7 : (tensor<1x128xi32>) -> tensor<128x128xi32>\n-  // CHECK-NEXT: Contiguity: [1, 128] ; Divisibility: [1, 16] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [1, 128], divisibility = [1, 16], constancy = [1, 1]\n   %10 = tt.addptr %8, %9 : tensor<128x128x!tt.ptr<f32>>, tensor<128x128xi32>\n-  // CHECK-NEXT: Contiguity: [128, 1] ; Divisibility: [65536, 1] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [128, 1], divisibility = [65536, 1], constancy = [1, 1]\n   %11 = tt.expand_dims %0 {axis = 1 : i32}: (tensor<128xi32>) -> tensor<128x1xi32>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [16, 16] ; Constancy: [128, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [16, 16], constancy = [128, 1]\n   %12 = tt.splat %arg2 : (!tt.ptr<f32>) -> tensor<128x1x!tt.ptr<f32>>\n-  // CHECK-NEXT: Contiguity: [128, 1] ; Divisibility: [16, 1] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [128, 1], divisibility = [16, 1], constancy = [1, 1]\n   %13 = tt.addptr %12, %11 : tensor<128x1x!tt.ptr<f32>>, tensor<128x1xi32>\n-  // CHECK-NEXT: Contiguity: [1, 128] ; Divisibility: [1, 65536] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [1, 128], divisibility = [1, 65536], constancy = [1, 1]\n   %14 = tt.expand_dims %1 {axis = 0 : i32} : (tensor<128xi32>) -> tensor<1x128xi32>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [16, 16] ; Constancy: [1, 128]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [16, 16], constancy = [1, 128]\n   %15 = tt.splat %arg3 : (i32) -> tensor<1x128xi32>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [16, 1048576] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [16, 1048576], constancy = [1, 1]\n   %16 = arith.muli %14, %15 : tensor<1x128xi32>\n-  // CHECK-NEXT: Contiguity: [128, 1] ; Divisibility: [16, 1] ; Constancy: [1, 128]\n+  // CHECK-NEXT: contiguity = [128, 1], divisibility = [16, 1], constancy = [1, 128]\n   %17 = tt.broadcast %13 : (tensor<128x1x!tt.ptr<f32>>) -> tensor<128x128x!tt.ptr<f32>>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [16, 1048576] ; Constancy: [128, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [16, 1048576], constancy = [128, 1]\n   %18 = tt.broadcast %16 : (tensor<1x128xi32>) -> tensor<128x128xi32>\n-  // CHECK-NEXT: Contiguity: [128, 1] ; Divisibility: [16, 1] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [128, 1], divisibility = [16, 1], constancy = [1, 1]\n   %19 = tt.addptr %17, %18 : tensor<128x128x!tt.ptr<f32>>, tensor<128x128xi32>\n-  // CHECK-NEXT: Contiguity: [1, 1] ; Divisibility: [1, 1] ; Constancy: [1, 1]\n+  // CHECK-NEXT: contiguity = [1, 1], divisibility = [1, 1], constancy = [1, 1]\n   %20 = tt.load %10, %cst, %cst_0 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<128x128xf32>\n   tt.store %19, %20, %cst : tensor<128x128xf32>\n   return\n@@ -56,28 +56,28 @@ func @permute_2d(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32 {t\n module {\n \n // This is a tiny test for verifying StoreOp-related alignment, It simply store a constant to a buffer.\n-func @store_constant_align(%addr: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n: i32 {tt.divisibility = 16 : i32}) {\n-  // CHECK: Contiguity: [1] ; Divisibility: [1] ; Constancy: [1]\n+func.func @store_constant_align(%addr: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n: i32 {tt.divisibility = 16 : i32}) {\n+  // CHECK: contiguity = [1], divisibility = [1], constancy = [1]\n   %pid = tt.get_program_id {axis = 0 : i32} : i32\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [128] ; Constancy: [1]\n+  // CHECK-NEXT: contiguity = [1], divisibility = [128], constancy = [1]\n   %c128_i32 = arith.constant 128 : i32\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [128] ; Constancy: [1]\n+  // CHECK-NEXT: contiguity = [1], divisibility = [128], constancy = [1]\n   %1 = arith.muli %pid, %c128_i32 : i32\n-  // CHECK-NEXT: Contiguity: [128] ; Divisibility: [65536] ; Constancy: [1]\n+  // CHECK-NEXT: contiguity = [128], divisibility = [65536], constancy = [1]\n   %2 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n- // CHECK-NEXT: Contiguity: [1] ; Divisibility: [128] ; Constancy: [128]\n+ // CHECK-NEXT: contiguity = [1], divisibility = [128], constancy = [128]\n   %3 = tt.splat %1 : (i32) -> tensor<128xi32>\n- // CHECK-NEXT: Contiguity: [128] ; Divisibility: [128] ; Constancy: [1]\n+ // CHECK-NEXT: contiguity = [128], divisibility = [128], constancy = [1]\n   %4 = arith.addi %3, %2 : tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [16] ; Constancy: [128]\n+  // CHECK-NEXT: contiguity = [1], divisibility = [16], constancy = [128]\n   %5 = tt.splat %addr : (!tt.ptr<f32>) -> tensor<128x!tt.ptr<f32>>\n-  // CHECK-NEXT: Contiguity: [128] ; Divisibility: [16] ; Constancy: [1]\n+  // CHECK-NEXT: contiguity = [128], divisibility = [16], constancy = [1]\n   %6 = tt.addptr %5, %4 : tensor<128x!tt.ptr<f32>>, tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [16] ; Constancy: [128]\n+  // CHECK-NEXT: contiguity = [1], divisibility = [16], constancy = [128]\n   %9 = tt.splat %n : (i32) -> tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [128] ; Constancy: [16]\n+  // CHECK-NEXT: contiguity = [1], divisibility = [128], constancy = [16]\n   %mask = arith.cmpi slt, %4, %9 : tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [1] ; Constancy: [1]\n+  // CHECK-NEXT: contiguity = [1], divisibility = [1], constancy = [1]\n   %cst = arith.constant dense<0.0> : tensor<128xf32>\n   tt.store %5, %cst, %mask : tensor<128xf32>\n   return\n@@ -89,7 +89,7 @@ func @store_constant_align(%addr: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n:\n \n // This IR is dumped from vecadd test.\n // Note, the hint {tt.divisibility = 16 : i32} for %n_elements affects the alignment of mask.\n-func @vecadd_mask_align_16(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n_elements: i32 {tt.divisibility = 16 : i32}) {\n+func.func @vecadd_mask_align_16(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n_elements: i32 {tt.divisibility = 16 : i32}) {\n   %c64_i32 = arith.constant 64 : i32\n   %0 = tt.get_program_id {axis = 0 : i32} : i32\n   %1 = arith.muli %0, %c64_i32 : i32\n@@ -101,13 +101,13 @@ func @vecadd_mask_align_16(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %ar\n   %7 = tt.splat %arg1 : (!tt.ptr<f32>) -> tensor<64x!tt.ptr<f32>>\n   %8 = tt.addptr %7, %4 : tensor<64x!tt.ptr<f32>>, tensor<64xi32>\n   %9 = tt.splat %n_elements : (i32) -> tensor<64xi32>\n-  // CHECK: Contiguity: [1] ; Divisibility: [64] ; Constancy: [16] ( %{{.*}} = arith.cmpi slt, %{{.*}}, %{{.*}} : tensor<64xi32> )\n+  // CHECK: arith.cmpi slt, %{{.*}} => contiguity = [1], divisibility = [64], constancy = [16]\n   %mask = arith.cmpi slt, %4, %9 : tensor<64xi32>\n   %11 = tt.load %6, %mask {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n   %12 = tt.load %8, %mask {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n   %13 = arith.addf %11, %12 : tensor<64xf32>\n   %14 = tt.splat %arg2 : (!tt.ptr<f32>) -> tensor<64x!tt.ptr<f32>>\n-  // CHECK: Contiguity: [64] ; Divisibility: [16] ; Constancy: [1] ( %{{.*}} = tt.addptr %{{.*}}, %{{.*}} : tensor<64x!tt.ptr<f32>>, tensor<64xi32> )\n+  // CHECK: tt.addptr %{{.*}} => contiguity = [64], divisibility = [16], constancy = [1]\n   %15 = tt.addptr %14, %4 : tensor<64x!tt.ptr<f32>>, tensor<64xi32>\n   tt.store %15, %13, %mask : tensor<64xf32>\n   return\n@@ -117,7 +117,7 @@ func @vecadd_mask_align_16(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %ar\n \n // This IR is dumped from vecadd test.\n // Note, there is no divisibility hint for %n_elements, Triton should assume its divisibility to be 1 by default.\n-func @vecadd_mask_align_1(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n_elements: i32) {\n+func.func @vecadd_mask_align_1(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n_elements: i32) {\n   %c64_i32 = arith.constant 64 : i32\n   %0 = tt.get_program_id {axis = 0 : i32} : i32\n   %1 = arith.muli %0, %c64_i32 : i32\n@@ -129,7 +129,7 @@ func @vecadd_mask_align_1(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg\n   %7 = tt.splat %arg1 : (!tt.ptr<f32>) -> tensor<64x!tt.ptr<f32>>\n   %8 = tt.addptr %7, %4 : tensor<64x!tt.ptr<f32>>, tensor<64xi32>\n   %9 = tt.splat %n_elements : (i32) -> tensor<64xi32>\n-  // CHECK: Contiguity: [1] ; Divisibility: [64] ; Constancy: [1] ( %{{.*}} = arith.cmpi slt, %{{.*}}, %{{.*}} : tensor<64xi32> )\n+  // CHECK: arith.cmpi slt, %{{.*}} => contiguity = [1], divisibility = [64], constancy = [1]\n   %10 = arith.cmpi slt, %4, %9 : tensor<64xi32>\n   %11 = tt.load %6, %10 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n   %12 = tt.load %8, %10 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>"}, {"filename": "test/Analysis/test-allocation.mlir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "file_content_changes": "@@ -13,7 +13,7 @@\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n \n // CHECK-LABEL: matmul_loop\n-func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_ptr_init = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n   %b_ptr_init = tt.broadcast %B : (!tt.ptr<f16>) -> tensor<32x128x!tt.ptr<f16>, #BL>\n \n@@ -46,7 +46,7 @@ func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B\n \n // Shared memory is available after a tensor's liveness range ends\n // CHECK-LABEL: reusable\n-func @reusable(%A : !tt.ptr<f16>) {\n+func.func @reusable(%A : !tt.ptr<f16>) {\n   %cst1 = arith.constant dense<true> : tensor<128x32xi1, #AL>\n   %cst2 = arith.constant dense<0.000000e+00> : tensor<128x32xf16, #AL>\n   %cst3 = arith.constant dense<true> : tensor<32x128xi1, #AL>\n@@ -78,7 +78,7 @@ func @reusable(%A : !tt.ptr<f16>) {\n // %cst1->%cst4\n // %cst3->%g->%h->%i\n // CHECK-LABEL: preallocate\n-func @preallocate(%A : !tt.ptr<f16>) {\n+func.func @preallocate(%A : !tt.ptr<f16>) {\n   // CHECK: offset = 0, size = 512\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 1024, size = 512\n@@ -113,7 +113,7 @@ func @preallocate(%A : !tt.ptr<f16>) {\n \n // Unused tensors are immediately released\n // CHECK-LABEL: unused\n-func @unused(%A : !tt.ptr<f16>) {\n+func.func @unused(%A : !tt.ptr<f16>) {\n   // CHECK: offset = 0, size = 1024\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<32x16xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 0, size = 512\n@@ -128,7 +128,7 @@ func @unused(%A : !tt.ptr<f16>) {\n \n // cst0 is alive through the entire function, it cannot be released before the end of the function\n // CHECK-LABEL: longlive\n-func @longlive(%A : !tt.ptr<f16>) {\n+func.func @longlive(%A : !tt.ptr<f16>) {\n   // CHECK: offset = 0, size = 512\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 512, size = 512\n@@ -156,7 +156,7 @@ func @longlive(%A : !tt.ptr<f16>) {\n }\n \n // CHECK-LABEL: alloc\n-func @alloc(%A : !tt.ptr<f16>) {\n+func.func @alloc(%A : !tt.ptr<f16>) {\n   // CHECK: offset = 0, size = 512\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x32xf16, #AL>\n@@ -167,7 +167,7 @@ func @alloc(%A : !tt.ptr<f16>) {\n }\n \n // CHECK-LABEL: scratch\n-func @scratch() {\n+func.func @scratch() {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #AL>\n   // CHECK: scratch offset = 0, size = 512\n   %b = tt.reduce %cst0 {redOp = 1 : i32, axis = 0 : i32} : tensor<16x16xf16, #AL> -> tensor<16xf16, #sliceAd0>\n@@ -176,15 +176,15 @@ func @scratch() {\n }\n \n // CHECK-LABEL: trans\n-func @trans(%A : !tt.ptr<f16>) {\n+func.func @trans(%A : !tt.ptr<f16>) {\n   // CHECK: offset = 0, size = 1024\n   %tensor = arith.constant dense<0.000000e+00> : tensor<16x32xf16, #A_SHARED>\n   %b = tt.trans %tensor : (tensor<16x32xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED_T>\n   return\n }\n \n // CHECK-LABEL: insert_slice_async\n-func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n+func.func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n   %a_ptr = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<16x16x!tt.ptr<f16>, #AL>\n   %mask = tt.splat %i1 : (i1) -> tensor<16x16xi1, #AL>\n   %other = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #AL>\n@@ -197,7 +197,7 @@ func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n }\n \n // CHECK-LABEL: extract_slice\n-func @extract_slice(%A : !tt.ptr<f16>) {\n+func.func @extract_slice(%A : !tt.ptr<f16>) {\n   // CHECK: offset = 0, size = 512\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<1x16x16xf16, #A_SHARED>\n   %index = arith.constant 0 : index\n@@ -209,7 +209,7 @@ func @extract_slice(%A : !tt.ptr<f16>) {\n // B0 -> (B1) -> B0\n // Memory used by B1 can be reused by B0.\n // CHECK-LABEL: if\n-func @if(%i1 : i1) {\n+func.func @if(%i1 : i1) {\n   // CHECK: offset = 0, size = 512\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 512, size = 512\n@@ -233,7 +233,7 @@ func @if(%i1 : i1) {\n // B0 -> (B1) -> (B2) -> B0\n // Memory used by B0 cannot be reused by B1 or B2.\n // CHECK-LABEL: if_else\n-func @if_else(%i1 : i1) {\n+func.func @if_else(%i1 : i1) {\n   // CHECK: offset = 0, size = 512\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 512, size = 512\n@@ -260,7 +260,7 @@ func @if_else(%i1 : i1) {\n // Block arguments and yields are memory aliases that do not trigger a new\n // allocation.\n // CHECK-LABEL: for\n-func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   // CHECK: offset = 0, size = 8192\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 8192, size = 8192\n@@ -275,7 +275,7 @@ func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.p\n }\n \n // CHECK-LABEL: for_if_slice\n-func @for_if_slice(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n+func.func @for_if_slice(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n   // CHECK: offset = 0, size = 8192\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 8192, size = 8192\n@@ -296,7 +296,7 @@ func @for_if_slice(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %\n \n // c0 cannot be released in the loop\n // CHECK-LABEL: for_use_ancestor\n-func @for_use_ancestor(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n+func.func @for_use_ancestor(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n   // CHECK: offset = 0, size = 8192\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 8192, size = 8192\n@@ -316,7 +316,7 @@ func @for_use_ancestor(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16\n // a_shared_init, b_shared_init, and c_shared_init's liveness ranges are span over the entire function before cst2.\n // So they cannot be reused by cst0 and cst1, but can be reused by cst2.\n // CHECK-LABEL: for_if_for\n-func @for_if_for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n+func.func @for_if_for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>, %i1 : i1) {\n   // CHECK: offset = 0, size = 8192\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: offset = 8192, size = 8192"}, {"filename": "test/Analysis/test-membar.mlir", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "file_content_changes": "@@ -14,7 +14,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n \n // CHECK-LABEL: matmul_loop\n // There shouldn't be any membar with the dot op encoding.\n-func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_ptr_init = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n   %b_ptr_init = tt.broadcast %B : (!tt.ptr<f16>) -> tensor<32x128x!tt.ptr<f16>, #BL>\n \n@@ -42,7 +42,7 @@ func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B\n }\n \n // CHECK-LABEL: raw_single_block\n-func @raw_single_block(%A : !tt.ptr<f16>) {\n+func.func @raw_single_block(%A : !tt.ptr<f16>) {\n   %cst1 = arith.constant dense<true> : tensor<128x32xi1, #AL>\n   %cst2 = arith.constant dense<0.000000e+00> : tensor<128x32xf16, #AL>\n   %a_ptr = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n@@ -54,7 +54,7 @@ func @raw_single_block(%A : !tt.ptr<f16>) {\n }\n \n // CHECK-LABEL: war_single_block\n-func @war_single_block(%A : !tt.ptr<f16>) {\n+func.func @war_single_block(%A : !tt.ptr<f16>) {\n   %cst1 = arith.constant dense<true> : tensor<128x32xi1, #AL>\n   %cst2 = arith.constant dense<0.000000e+00> : tensor<128x32xf16, #AL>\n   %a_ptr = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n@@ -70,7 +70,7 @@ func @war_single_block(%A : !tt.ptr<f16>) {\n }\n \n // CHECK-LABEL: scratch\n-func @scratch() {\n+func.func @scratch() {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK: Membar 1\n   %a = tt.cat %cst0, %cst0 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n@@ -81,7 +81,7 @@ func @scratch() {\n }\n \n // CHECK-LABEL: async_wait\n-func @async_wait() {\n+func.func @async_wait() {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   // CHECK: Membar 1\n   %a = tt.cat %cst0, %cst0 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n@@ -92,7 +92,7 @@ func @async_wait() {\n }\n \n // CHECK-LABEL: alloc\n-func @alloc() {\n+func.func @alloc() {\n   %cst0 = triton_gpu.alloc_tensor : tensor<16x16xf16, #A_SHARED>\n   %a = tt.cat %cst0, %cst0 {axis = 0} : (tensor<16x16xf16, #A_SHARED>, tensor<16x16xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED>\n   // CHECK: Membar 2\n@@ -101,7 +101,7 @@ func @alloc() {\n }\n \n // CHECK-LABEL: extract_slice\n-func @extract_slice() {\n+func.func @extract_slice() {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<1x16x16xf16, #A_SHARED>\n   %index = arith.constant 0 : index\n   %cst1 = tensor.extract_slice %cst0[%index, 0, 0][1, 16, 16][1, 1, 1] : tensor<1x16x16xf16, #A_SHARED> to tensor<16x16xf16, #A_SHARED>\n@@ -113,14 +113,14 @@ func @extract_slice() {\n }\n \n // CHECK-LABEL: trans\n-func @trans() {\n+func.func @trans() {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x32xf16, #A_SHARED>\n   %b = tt.trans %cst0 : (tensor<16x32xf16, #A_SHARED>) -> tensor<32x16xf16, #A_SHARED_T>\n   return\n }\n \n // CHECK-LABEL: insert_slice_async\n-func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n+func.func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n   %a_ptr = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<16x16x!tt.ptr<f16>, #AL>\n   %mask = tt.splat %i1 : (i1) -> tensor<16x16xi1, #AL>\n   %other = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #AL>\n@@ -135,7 +135,7 @@ func @insert_slice_async(%A : !tt.ptr<f16>, %i1 : i1) {\n }\n \n // CHECK-LABEL: insert_slice\n-func @insert_slice(%A : !tt.ptr<f16>, %i1 : i1) {\n+func.func @insert_slice(%A : !tt.ptr<f16>, %i1 : i1) {\n   %a_ptr = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<16x16x!tt.ptr<f16>, #AL>\n   %mask = tt.splat %i1 : (i1) -> tensor<16x16xi1, #AL>\n   %other = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #AL>\n@@ -153,7 +153,7 @@ func @insert_slice(%A : !tt.ptr<f16>, %i1 : i1) {\n \n // If branch inserted a barrier for %cst0 and %cst1, but else didn't, then the barrier should be inserted in the parent region\n // CHECK-LABEL: multi_blocks\n-func @multi_blocks(%i1 : i1) {\n+func.func @multi_blocks(%i1 : i1) {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   scf.if %i1 {\n@@ -174,7 +174,7 @@ func @multi_blocks(%i1 : i1) {\n \n // Both branches inserted a barrier for %cst0 and %cst1, then the barrier doesn't need to be inserted in the parent region\n // CHECK-LABEL: multi_blocks_join_barrier\n-func @multi_blocks_join_barrier(%i1 : i1) {\n+func.func @multi_blocks_join_barrier(%i1 : i1) {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   scf.if %i1 {\n@@ -192,7 +192,7 @@ func @multi_blocks_join_barrier(%i1 : i1) {\n \n // Read yielded tensor requires a barrier\n // CHECK-LABEL: multi_blocks_yield\n-func @multi_blocks_yield(%i1 : i1) {\n+func.func @multi_blocks_yield(%i1 : i1) {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %a = scf.if %i1 -> (tensor<32x16xf16, #A_SHARED>) {\n@@ -212,7 +212,7 @@ func @multi_blocks_yield(%i1 : i1) {\n \n // Conservatively add a barrier as if the branch (%i1) is never taken\n // CHECK-LABEL: multi_blocks_noelse\n-func @multi_blocks_noelse(%i1 : i1) {\n+func.func @multi_blocks_noelse(%i1 : i1) {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   scf.if %i1 {\n@@ -226,7 +226,7 @@ func @multi_blocks_noelse(%i1 : i1) {\n \n // Conservatively add a barrier as if the branch (%i2) is never taken\n // CHECK-LABEL: multi_blocks_nested_scf\n-func @multi_blocks_nested_scf(%i1 : i1, %i2 : i1) {\n+func.func @multi_blocks_nested_scf(%i1 : i1, %i2 : i1) {\n   %cst0 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   %cst1 = arith.constant dense<0.000000e+00> : tensor<16x16xf16, #A_SHARED>\n   scf.if %i1 {\n@@ -247,7 +247,7 @@ func @multi_blocks_nested_scf(%i1 : i1, %i2 : i1) {\n }\n \n // CHECK-LABEL: for\n-func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %b_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %c_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n@@ -262,7 +262,7 @@ func @for(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.p\n // Although a_shared and b_shared are synced before entering the loop,\n // they are reassociated with aliases (c_shared) and thus require a barrier.\n // CHECK-LABEL: for_alias\n-func @for_alias(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @for_alias(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %b_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: Membar 2\n@@ -282,7 +282,7 @@ func @for_alias(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B :\n // Although cst2 is not an argument of scf.yield, its memory is reused by cst1.\n // So we need a barrier both before and after cst1\n // CHECK-LABEL: for_reuse\n-func @for_reuse(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @for_reuse(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %b_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: Membar 2\n@@ -302,7 +302,7 @@ func @for_reuse(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B :\n \n \n // CHECK-LABEL: for_reuse_nested\n-func @for_reuse_nested(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @for_reuse_nested(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   %b_shared_init = arith.constant dense<0.00e+00> : tensor<128x32xf16, #A_SHARED>\n   // CHECK-NEXT: Membar 2"}, {"filename": "test/Conversion/triton_ops.mlir", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "file_content_changes": "@@ -1,6 +1,6 @@\n // RUN: triton-opt %s | FileCheck %s\n \n-func @cast_ops(%scalar_ptr: !tt.ptr<f32>, %scalar_f32: f32, %scalar_i64: i64) {\n+func.func @cast_ops(%scalar_ptr: !tt.ptr<f32>, %scalar_f32: f32, %scalar_i64: i64) {\n   // scalar -> scalar\n   // CHECK:  i64 -> !tt.ptr<f32>\n   %0 = tt.int_to_ptr %scalar_i64 : i64 -> !tt.ptr<f32>\n@@ -35,7 +35,7 @@ func @cast_ops(%scalar_ptr: !tt.ptr<f32>, %scalar_f32: f32, %scalar_i64: i64) {\n   return\n }\n \n-func @addptr_ops(%scalar_ptr: !tt.ptr<f32>, %scalar_i32: i32) {\n+func.func @addptr_ops(%scalar_ptr: !tt.ptr<f32>, %scalar_i32: i32) {\n   // scalar -> scalar\n   // CHECK: !tt.ptr<f32>\n   %0 = tt.addptr %scalar_ptr, %scalar_i32 : !tt.ptr<f32>, i32\n@@ -54,7 +54,7 @@ func @addptr_ops(%scalar_ptr: !tt.ptr<f32>, %scalar_i32: i32) {\n   return\n }\n \n-func @load_store_ops_scalar(%ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %mask : i1) {\n+func.func @load_store_ops_scalar(%ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %mask : i1) {\n   // Test if Load/Store ops can handle scalar values\n   %other = arith.constant 0.0e+0 : f32\n \n@@ -76,7 +76,7 @@ func @load_store_ops_scalar(%ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %ma\n   return\n }\n \n-func @reduce_ops_infer(%ptr: !tt.ptr<f32>, %v : tensor<1x2x4xf32>) {\n+func.func @reduce_ops_infer(%ptr: !tt.ptr<f32>, %v : tensor<1x2x4xf32>) {\n   // Test if reduce ops infer types correctly\n \n   // CHECK: %{{.*}} = tt.reduce %{{.*}} -> tensor<2x4xf32>\n@@ -101,7 +101,7 @@ func @reduce_ops_infer(%ptr: !tt.ptr<f32>, %v : tensor<1x2x4xf32>) {\n   return\n }\n \n-func @dot_ops_infer(%ptr: !tt.ptr<f32>, %v : f32) {\n+func.func @dot_ops_infer(%ptr: !tt.ptr<f32>, %v : f32) {\n   // Test if reduce ops infer types correctly\n   %v128x32 = tt.splat %v : (f32) -> tensor<128x32xf32>\n   %v32x128 = tt.splat %v : (f32) -> tensor<32x128xf32>"}, {"filename": "test/Conversion/triton_to_tritongpu.mlir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -1,6 +1,6 @@\n // RUN: triton-opt %s -split-input-file -convert-triton-to-tritongpu=num-warps=2 | FileCheck %s\n \n-func @ops() {\n+func.func @ops() {\n   // CHECK: module attributes {\"triton_gpu.num-warps\" = 2 : i32} {{.*}}\n   %a = arith.constant dense<1.00e+00> : tensor<128x32xf16>\n   %b = arith.constant dense<2.00e+00> : tensor<32x128xf16>\n@@ -11,7 +11,7 @@ func @ops() {\n \n // -----\n \n-func @load_ops(%ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32}) {\n+func.func @load_ops(%ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32}) {\n   // Test if LoadOp is lowered properly (see #771)\n   %ptrs = tt.splat %ptr : (!tt.ptr<f32>) -> tensor<128x!tt.ptr<f32>>\n   %mask = arith.constant dense<true> : tensor<128xi1>\n@@ -30,7 +30,7 @@ func @load_ops(%ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32}) {\n \n // -----\n \n-func @reduce_ops(%ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32}) {\n+func.func @reduce_ops(%ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32}) {\n   // Test if the total number of threadsPerWarp is 32\n   // Test if the total number of warps is 2\n   // CHECK: #blocked0 = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [4, 8], warpsPerCTA = [1, 2], order = [0, 1]}>"}, {"filename": "test/Conversion/tritongpu_to_llvm.mlir", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "file_content_changes": "@@ -4,7 +4,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK: llvm.func @test_empty_kernel(%arg0: i32, %arg1: !llvm.ptr<f16, 1>)\n   // Here the 128 comes from the 4 in module attribute multiples 32\n   // CHECK:  attributes {nvvm.kernel = 1 : ui1, nvvm.maxntid = 128 : i32} {{.*}}\n-  func @test_empty_kernel(%lb : index, %A : !tt.ptr<f16>) {\n+  func.func @test_empty_kernel(%lb : index, %A : !tt.ptr<f16>) {\n     // CHECK:  llvm.return\n     return\n   }\n@@ -15,7 +15,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_load\n-  func @basic_load(%a_ptr_init : tensor<256x!tt.ptr<f32>, #blocked0>, %cst : tensor<256xi1, #blocked0>, %cst_0 : tensor<256xf32, #blocked0>) {\n+  func.func @basic_load(%a_ptr_init : tensor<256x!tt.ptr<f32>, #blocked0>, %cst : tensor<256xi1, #blocked0>, %cst_0 : tensor<256xf32, #blocked0>) {\n     // CHECK: llvm.inline_asm\n     // CHECK: llvm.inline_asm\n     %1 = tt.load %a_ptr_init, %cst, %cst_0 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<256xf32, #blocked0>\n@@ -28,7 +28,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [2], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: vectorized_load\n-  func @vectorized_load(%a_ptr_init : tensor<256x!tt.ptr<f32>, #blocked0>, %cst : tensor<256xi1, #blocked0>, %cst_0 : tensor<256xf32, #blocked0>) {\n+  func.func @vectorized_load(%a_ptr_init : tensor<256x!tt.ptr<f32>, #blocked0>, %cst : tensor<256xi1, #blocked0>, %cst_0 : tensor<256xf32, #blocked0>) {\n     // CHECK: llvm.inline_asm\n     // CHECK-SAME: ld.global.b32\n     // CHECK: llvm.inline_asm\n@@ -43,7 +43,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [8], threadsPerWarp = [32], warpsPerCTA = [1], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK-LABEL: vectorized_load_f16\n-  func @vectorized_load_f16(%a_ptr_init: tensor<256x!tt.ptr<f16>, #blocked0>, %cst : tensor<256xi1, #blocked0>, %cst_0 : tensor<256xf16, #blocked0>) {\n+  func.func @vectorized_load_f16(%a_ptr_init: tensor<256x!tt.ptr<f16>, #blocked0>, %cst : tensor<256xi1, #blocked0>, %cst_0 : tensor<256xf16, #blocked0>) {\n     // CHECK: llvm.inline_asm\n     // CHECK-SAME: ld.global.b16\n     // CHECK: llvm.inline_asm\n@@ -59,7 +59,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [8], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: masked_load_const_other\n-  func @masked_load_const_other(%a_ptr_init : tensor<256x!tt.ptr<f32>, #blocked0>, %cst : tensor<256xi1, #blocked0>) {\n+  func.func @masked_load_const_other(%a_ptr_init : tensor<256x!tt.ptr<f32>, #blocked0>, %cst : tensor<256xi1, #blocked0>) {\n     %cst_0 = arith.constant dense<0.000000e+00> : tensor<256xf32, #blocked0>\n     %1 = tt.load %a_ptr_init, %cst, %cst_0 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<256xf32, #blocked0>\n     return\n@@ -72,7 +72,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [8], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: masked_load_const_other_vec\n-  func @masked_load_const_other_vec(%a_ptr_init : tensor<256x!tt.ptr<f32>, #blocked0>, %cst : tensor<256xi1, #blocked0>) {\n+  func.func @masked_load_const_other_vec(%a_ptr_init : tensor<256x!tt.ptr<f32>, #blocked0>, %cst : tensor<256xi1, #blocked0>) {\n     %cst_0 = arith.constant dense<0.000000e+00> : tensor<256xf32, #blocked0>\n     %1 = tt.load %a_ptr_init, %cst, %cst_0 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<256xf32, #blocked0>\n     return\n@@ -84,7 +84,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [2], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 2 : i32} {\n   // CHECK-LABEL: global_load_store_no_vec\n-  func @global_load_store_no_vec(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg3: i32) {\n+  func.func @global_load_store_no_vec(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg3: i32) {\n     %c256_i32 = arith.constant 256 : i32\n     %0 = tt.get_program_id {axis = 0 : i32} : i32\n     %1 = arith.muli %0, %c256_i32 : i32\n@@ -128,7 +128,7 @@ module attributes {\"triton_gpu.num-warps\" = 2 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [2], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 2 : i32} {\n   // CHECK-LABEL: global_load_store_vec4\n-  func @global_load_store_vec4(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg3: i32) {\n+  func.func @global_load_store_vec4(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg3: i32) {\n     %c256_i32 = arith.constant 256 : i32\n     %0 = tt.get_program_id {axis = 0 : i32} : i32\n     %1 = arith.muli %0, %c256_i32 : i32\n@@ -165,7 +165,7 @@ module attributes {\"triton_gpu.num-warps\" = 2 : i32} {\n #blocked = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [2], order = [0]}>\n // Note, the %n_elements doesn't have a \"tt.divisibility\" hint, so Triton assumes it's divisibility is 1, this should effect the mask's alignment and further restrict the load/store ops' vector width to be 1.\n module attributes {\"triton_gpu.num-warps\" = 2 : i32} {\n-  func @vecadd_masked_vec1(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n_elements: i32) {\n+  func.func @vecadd_masked_vec1(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n_elements: i32) {\n     %c64_i32 = arith.constant 64 : i32\n     %0 = tt.get_program_id {axis = 0 : i32} : i32\n     %1 = arith.muli %0, %c64_i32 : i32\n@@ -195,7 +195,7 @@ module attributes {\"triton_gpu.num-warps\" = 2 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [8], threadsPerWarp = [32], warpsPerCTA = [1], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK-LABEL: global_load_store_vec8\n-    func @global_load_store_vec8(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg3: i32) {\n+    func.func @global_load_store_vec8(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 4 : i32}, %arg3: i32) {\n     %c256_i32 = arith.constant 256 : i32\n     %0 = tt.get_program_id {axis = 0 : i32} : i32\n     %1 = arith.muli %0, %c256_i32 : i32\n@@ -238,7 +238,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n #blocked2 = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_view_broadcast\n-  func @basic_view_broadcast(%arg : tensor<256xf32,#blocked0>) {\n+  func.func @basic_view_broadcast(%arg : tensor<256xf32,#blocked0>) {\n     // CHECK: llvm.mlir.undef\n     // CHECK: %[[T0:.*]] = llvm.extractvalue\n     // CHECK: %[[T1:.*]] = llvm.extractvalue\n@@ -262,7 +262,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [2], threadsPerWarp = [32], warpsPerCTA = [1], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_make_range\n-  func @basic_make_range() {\n+  func.func @basic_make_range() {\n     // CHECK: nvvm.read.ptx.sreg.tid.x\n     // CHECK: llvm.mlir.undef\n     // CHECK: llvm.insertvalue\n@@ -277,7 +277,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_addf\n-  func @basic_addf(%arg0 : tensor<256xf32,#blocked0>, %arg1 : tensor<256xf32,#blocked0>) {\n+  func.func @basic_addf(%arg0 : tensor<256xf32,#blocked0>, %arg1 : tensor<256xf32,#blocked0>) {\n     // CHECK: llvm.fadd\n     // CHECK: llvm.fadd\n     %1 = arith.addf %arg0, %arg1 : tensor<256xf32,#blocked0>\n@@ -290,7 +290,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_addi\n-  func @basic_addi(%arg0 : tensor<256xi32,#blocked0>, %arg1 : tensor<256xi32,#blocked0>) {\n+  func.func @basic_addi(%arg0 : tensor<256xi32,#blocked0>, %arg1 : tensor<256xi32,#blocked0>) {\n     // CHECK: llvm.add\n     // CHECK: llvm.add\n     %1 = arith.addi %arg0, %arg1 : tensor<256xi32,#blocked0>\n@@ -302,7 +302,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n \n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_program_id\n-  func @basic_program_id() {\n+  func.func @basic_program_id() {\n     // CHECK: nvvm.read.ptx.sreg.ctaid.x : i32\n     %0 = tt.get_program_id {axis = 0 : i32} : i32\n     return\n@@ -314,7 +314,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_addptr\n-  func @basic_addptr(%arg0 : tensor<256x!tt.ptr<f32>,#blocked0>, %arg1 : tensor<256xi32,#blocked0>) {\n+  func.func @basic_addptr(%arg0 : tensor<256x!tt.ptr<f32>,#blocked0>, %arg1 : tensor<256xi32,#blocked0>) {\n     // CHECK: llvm.getelementptr\n     // CHECK: llvm.getelementptr\n     %0 = tt.addptr %arg0, %arg1 : tensor<256x!tt.ptr<f32>, #blocked0>, tensor<256xi32, #blocked0>\n@@ -328,7 +328,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK: llvm.mlir.global external @global_smem\n   // CHECK-LABEL: basic_alloc_tensor\n-  func @basic_alloc_tensor() {\n+  func.func @basic_alloc_tensor() {\n     // CHECK: llvm.mlir.addressof @global_smem\n     // CHECK-NEXT: llvm.bitcast\n     // CHECK-NEXT: llvm.mlir.constant\n@@ -345,7 +345,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK: llvm.mlir.global external @global_smem\n   // CHECK-LABEL: basic_extract_slice\n-  func @basic_extract_slice() {\n+  func.func @basic_extract_slice() {\n     // CHECK: llvm.mlir.addressof @global_smem\n     // CHECK: llvm.extractvalue\n     // CHECK-NEXT: llvm.extractvalue\n@@ -378,7 +378,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n \n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_async_wait\n-  func @basic_async_wait() {\n+  func.func @basic_async_wait() {\n     // CHECK: cp.async.wait_group 0x4\n     triton_gpu.async_wait {num = 4: i32}\n     return\n@@ -397,7 +397,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #A = #triton_gpu.shared<{vec = 8, perPhase = 1, maxPhase = 4, order = [1, 0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_insert_slice_async_fallback\n-  func @basic_insert_slice_async_fallback(%arg0: !tt.ptr<f16> {tt.divisibility = 1 : i32}) {\n+  func.func @basic_insert_slice_async_fallback(%arg0: !tt.ptr<f16> {tt.divisibility = 1 : i32}) {\n     %off0_ = tt.make_range {end = 16 : i32, start = 0 : i32} : tensor<16xi32, #slice2d1>\n     %off1_ = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<64xi32, #slice3d0>\n     %off0 = tt.expand_dims %off0_ {axis = 1 : i32} : (tensor<16xi32, #slice2d1>) -> tensor<16x1xi32, #block2>\n@@ -436,7 +436,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #A = #triton_gpu.shared<{vec = 8, perPhase = 1, maxPhase = 4, order = [1, 0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_insert_slice_async_v4\n-  func @basic_insert_slice_async_v4(%arg0: !tt.ptr<f32> {tt.divisibility = 8 : i32}) {\n+  func.func @basic_insert_slice_async_v4(%arg0: !tt.ptr<f32> {tt.divisibility = 8 : i32}) {\n     %off0_ = tt.make_range {end = 16 : i32, start = 0 : i32} : tensor<16xi32, #slice2d1>\n     %off1_ = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<64xi32, #slice3d0>\n     %off0 = tt.expand_dims %off0_ {axis = 1 : i32} : (tensor<16xi32, #slice2d1>) -> tensor<16x1xi32, #block2>\n@@ -478,7 +478,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #A = #triton_gpu.shared<{vec = 1, perPhase = 1, maxPhase = 4, order = [1, 0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_insert_slice_async_v1\n-  func @basic_insert_slice_async_v1(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}) {\n+  func.func @basic_insert_slice_async_v1(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}) {\n     %off0_ = tt.make_range {end = 16 : i32, start = 0 : i32} : tensor<16xi32, #slice2d1>\n     %off1_ = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #slice3d0>\n     %off0 = tt.expand_dims %off0_ {axis = 1 : i32} : (tensor<16xi32, #slice2d1>) -> tensor<16x1xi32, #block2>\n@@ -523,7 +523,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #A = #triton_gpu.shared<{vec = 1, perPhase = 1, maxPhase = 4, order = [1, 0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_insert_slice_async_v1_multictas\n-  func @basic_insert_slice_async_v1_multictas(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}) {\n+  func.func @basic_insert_slice_async_v1_multictas(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}) {\n     %off0_ = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #slice2d1>\n     %off1_ = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #slice3d0>\n     %off0 = tt.expand_dims %off0_ {axis = 1 : i32} : (tensor<32xi32, #slice2d1>) -> tensor<32x1xi32, #block2>\n@@ -574,7 +574,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK: basic_splat\n-  func @basic_splat(%ptr: !tt.ptr<f32>) {\n+  func.func @basic_splat(%ptr: !tt.ptr<f32>) {\n     // CHECK: llvm.mlir.undef\n     // CHECK: llvm.insertvalue\n     // CHECK: llvm.insertvalue\n@@ -588,7 +588,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: basic_store\n-  func @basic_store(%ptrs: tensor<256x!tt.ptr<f32>, #blocked0>, %vals: tensor<256xf32, #blocked0>, %mask: tensor<256xi1, #blocked0>) {\n+  func.func @basic_store(%ptrs: tensor<256x!tt.ptr<f32>, #blocked0>, %vals: tensor<256xf32, #blocked0>, %mask: tensor<256xi1, #blocked0>) {\n     // CHECK: llvm.inline_asm\n     // CHECK-SAME: st.global.b32 [ ${{.*}} + 0 ], { ${{.*}} };\n     // CHECK: llvm.inline_asm\n@@ -605,7 +605,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK: llvm.mlir.global external @global_smem() {addr_space = 3 : i32} : !llvm.array<0 x i8>\n   // CHECK-LABEL: convert_layout_blocked_blocked\n-  func @convert_layout_blocked_blocked(%arg0: tensor<16x16xf32, #blocked0>) {\n+  func.func @convert_layout_blocked_blocked(%arg0: tensor<16x16xf32, #blocked0>) {\n     // CHECK: llvm.mlir.addressof @global_smem\n     // CHECK: llvm.store\n     // CHECK-SAME: !llvm.ptr<vector<1xf32>, 3>\n@@ -652,7 +652,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK: llvm.mlir.global external @global_smem() {addr_space = 3 : i32} : !llvm.array<0 x i8>\n   // CHECK-LABEL: convert_layout_blocked_blocked_vec\n-  func @convert_layout_blocked_blocked_vec(%arg0: tensor<16x16xf32, #blocked0>) {\n+  func.func @convert_layout_blocked_blocked_vec(%arg0: tensor<16x16xf32, #blocked0>) {\n     // CHECK: llvm.mlir.addressof @global_smem\n     // CHECK: llvm.store\n     // CHECK-SAME: !llvm.ptr<vector<4xf32>, 3>\n@@ -675,7 +675,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK: llvm.mlir.global external @global_smem() {addr_space = 3 : i32} : !llvm.array<0 x i8>\n   // CHECK-LABEL: convert_layout_blocked_blocked_multi_rep\n-  func @convert_layout_blocked_blocked_multi_rep(%arg0: tensor<16x16xf32, #blocked0>) {\n+  func.func @convert_layout_blocked_blocked_multi_rep(%arg0: tensor<16x16xf32, #blocked0>) {\n     // CHECK: llvm.mlir.addressof @global_smem\n     // CHECK: llvm.store\n     // CHECK-SAME: !llvm.ptr<vector<4xf32>, 3>\n@@ -706,7 +706,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n #dot_operand_b = #triton_gpu.dot_op<{opIdx=1, parent=#mma0}>\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK-LABEL: convert_dot\n-  func @convert_dot(%A: tensor<16x16xf16, #blocked0>, %B: tensor<16x16xf16, #blocked0>) {\n+  func.func @convert_dot(%A: tensor<16x16xf16, #blocked0>, %B: tensor<16x16xf16, #blocked0>) {\n     %AA = triton_gpu.convert_layout %A : (tensor<16x16xf16, #blocked0>) -> tensor<16x16xf16, #shared0>\n     %BB = triton_gpu.convert_layout %B : (tensor<16x16xf16, #blocked0>) -> tensor<16x16xf16, #shared0>\n     // CHECK: llvm.inline_asm\n@@ -730,7 +730,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n // TODO: problems in MLIR's parser on slice layout\n // #blocked0 = #triton_gpu.blocked<{sizePerThread = [1, 4], threadsPerWarp = [8, 4], warpsPerCTA = [1, 1], order = [1, 0]}>\n // module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n-//   func @make_range_sliced_layout() {\n+//   func.func @make_range_sliced_layout() {\n //     %0 = tt.make_range {end = 16 : i32, start = 0 : i32} : tensor<16xi32, #triton_gpu.slice<{dim = 0, parent = #blocked0}>>\n //     return\n //   }\n@@ -743,7 +743,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK: llvm.mlir.global external @global_smem() {addr_space = 3 : i32} : !llvm.array<0 x i8>\n   // CHECK-LABEL: convert_layout_mmav2_block\n-  func @convert_layout_mmav2_blocked(%arg0: tensor<32x16xf32, #mma>) {\n+  func.func @convert_layout_mmav2_blocked(%arg0: tensor<32x16xf32, #mma>) {\n     // CHECK: llvm.store\n     // CHECK-SAME: !llvm.ptr<vector<2xf32>, 3>\n     // CHECK: llvm.store\n@@ -763,7 +763,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK: llvm.mlir.global external @global_smem() {addr_space = 3 : i32} : !llvm.array<0 x i8>\n   // CHECK-LABEL: convert_layout_mmav1_block\n-  func @convert_layout_mmav1_blocked(%arg0: tensor<32x64xf32, #mma>) {\n+  func.func @convert_layout_mmav1_blocked(%arg0: tensor<32x64xf32, #mma>) {\n     // CHECK: llvm.store\n     // CHECK-SAME: !llvm.ptr<vector<2xf32>, 3>\n     // CHECK: llvm.store\n@@ -786,7 +786,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK: llvm.mlir.global external @global_smem() {addr_space = 3 : i32} : !llvm.array<0 x i8>\n   // CHECK-LABEL: convert_layout_blocked_shared\n-  func @convert_layout_blocked_shared(%arg0: tensor<128x32xf32, #blocked0>) {\n+  func.func @convert_layout_blocked_shared(%arg0: tensor<128x32xf32, #blocked0>) {\n     // CHECK: llvm.store\n     // CHECK-SAME: !llvm.ptr<vector<8xf32>, 3>\n     // CHECK: llvm.store\n@@ -802,7 +802,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n #blocked1 = #triton_gpu.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [1, 1], order = [1, 0]}>\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK-LABEL: convert_blocked1d_to_slice0\n-  func @convert_blocked1d_to_slice0(%src:tensor<32xi32, #blocked0>) {\n+  func.func @convert_blocked1d_to_slice0(%src:tensor<32xi32, #blocked0>) {\n     // CHECK-COUNT-4: llvm.load {{.*}} : !llvm.ptr<vector<1xi32>, 3>\n     %cvt = triton_gpu.convert_layout %src : (tensor<32xi32, #blocked0>) -> tensor<32xi32, #triton_gpu.slice<{dim = 0, parent = #blocked1}>>\n     return\n@@ -815,7 +815,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n #blocked1 = #triton_gpu.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [1, 1], order = [1, 0]}>\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK-LABEL: convert_blocked1d_to_slice1\n-  func @convert_blocked1d_to_slice1(%src:tensor<32xi32, #blocked0>) {\n+  func.func @convert_blocked1d_to_slice1(%src:tensor<32xi32, #blocked0>) {\n     // CHECK-COUNT-32: llvm.load {{.*}} : !llvm.ptr<vector<1xi32>, 3>\n     %cvt = triton_gpu.convert_layout %src : (tensor<32xi32, #blocked0>) -> tensor<32xi32, #triton_gpu.slice<{dim = 1, parent = #blocked1}>>\n     return\n@@ -828,7 +828,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n #blocked1 = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [1], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK-LABEL: convert_blocked_to_blocked_ptr\n-  func @convert_blocked_to_blocked_ptr(%src:tensor<32x!tt.ptr<f32>, #blocked0>) {\n+  func.func @convert_blocked_to_blocked_ptr(%src:tensor<32x!tt.ptr<f32>, #blocked0>) {\n     // CHECK: llvm.ptrtoint\n     // CHECK: llvm.store\n     // CHECK: nvvm.barrier0\n@@ -847,7 +847,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n #dot_operand_a = #triton_gpu.dot_op<{opIdx=0, parent=#mma}>\n #dot_operand_b = #triton_gpu.dot_op<{opIdx=1, parent=#mma}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n-  func @matmul_kernel_dot_operand_layout(%ptr:!tt.ptr<f32> {tt.divisibility = 16 : i32},\n+  func.func @matmul_kernel_dot_operand_layout(%ptr:!tt.ptr<f32> {tt.divisibility = 16 : i32},\n   %a:tensor<128x32xf16, #shared>, %b:tensor<32x256xf16, #shared>) {\n     %cst = arith.constant dense<0.000000e+00> : tensor<128x256xf32, #mma>\n     // CHECK: ldmatrix.sync.aligned.m8n8.x4.shared.b16\n@@ -873,7 +873,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #dot_operand_a = #triton_gpu.dot_op<{opIdx=0, parent=#mma, isMMAv1Row=true}>\n #dot_operand_b = #triton_gpu.dot_op<{opIdx=1, parent=#mma, isMMAv1Row=true}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n-  func @matmul884_kernel_dot_operand_layout(%ptr:!tt.ptr<f32> {tt.divisibility = 16 : i32},\n+  func.func @matmul884_kernel_dot_operand_layout(%ptr:!tt.ptr<f32> {tt.divisibility = 16 : i32},\n   %a:tensor<32x64xf16, #shared0>, %b:tensor<64x64xf16, #shared1>) {\n     %cst = arith.constant dense<0.000000e+00> : tensor<32x64xf32, #mma>\n     // CHECK: ldmatrix.sync.aligned.m8n8.x4.shared.b16\n@@ -896,7 +896,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #dot_operand_a = #triton_gpu.dot_op<{opIdx=0, parent=#blocked}>\n #dot_operand_b = #triton_gpu.dot_op<{opIdx=1, parent=#blocked}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n-  func @matmul_fmadot(%ptr:!tt.ptr<f32> {tt.divisibility = 16 : i32},\n+  func.func @matmul_fmadot(%ptr:!tt.ptr<f32> {tt.divisibility = 16 : i32},\n   %a:tensor<32x16xf32, #shared>, %b:tensor<16x32xf32, #shared>) {\n     %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked>\n     // CHECK: llvm.intr.fmuladd\n@@ -920,7 +920,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #dot_operand_b = #triton_gpu.dot_op<{opIdx=1, parent=#mma}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: matmul_tf32dot\n-  func @matmul_tf32dot(%ptr:!tt.ptr<f32> {tt.divisibility = 16 : i32},\n+  func.func @matmul_tf32dot(%ptr:!tt.ptr<f32> {tt.divisibility = 16 : i32},\n   %a:tensor<32x16xf32, #shared>, %b:tensor<16x32xf32, #shared>) {\n     %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #mma>\n     // CHECK: llvm.inline_asm\n@@ -955,7 +955,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: atomic_add_f32\n-  func @atomic_add_f32(%arg0 : tensor<256x!tt.ptr<f32>, #blocked0>, %arg1 : tensor<256xi1, #blocked0>, %arg2 : tensor<256xf32, #blocked0>) {\n+  func.func @atomic_add_f32(%arg0 : tensor<256x!tt.ptr<f32>, #blocked0>, %arg1 : tensor<256xi1, #blocked0>, %arg2 : tensor<256xf32, #blocked0>) {\n     // CHECK: llvm.inline_asm\n     // CHECK-SAME: atom.global.gpu.add.f32\n     %0 = \"tt.atomic_rmw\" (%arg0, %arg2, %arg1) {atomic_rmw_op = 5 : i32} : (tensor<256x!tt.ptr<f32>, #blocked0>, tensor<256xf32, #blocked0>, tensor<256xi1, #blocked0>) -> tensor<256xf32, #blocked0>\n@@ -967,7 +967,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n \n-func @test_get_program_id(%a: tensor<32x!tt.ptr<i32>, #blocked0>) {\n+func.func @test_get_program_id(%a: tensor<32x!tt.ptr<i32>, #blocked0>) {\n   %blockidx = tt.get_program_id {axis=0:i32} : i32\n   %blockidy = tt.get_program_id {axis=1:i32} : i32\n   %blockidz = tt.get_program_id {axis=2:i32} : i32\n@@ -987,7 +987,7 @@ func @test_get_program_id(%a: tensor<32x!tt.ptr<i32>, #blocked0>) {\n // -----\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n-  func @test_get_num_program(%a: tensor<32x!tt.ptr<i32>, #blocked0>) {\n+  func.func @test_get_num_program(%a: tensor<32x!tt.ptr<i32>, #blocked0>) {\n     // CHECK: nvvm.read.ptx.sreg.nctaid.x\n     // CHECK: nvvm.read.ptx.sreg.nctaid.y\n     // CHECK: nvvm.read.ptx.sreg.nctaid.z\n@@ -1007,7 +1007,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [2], threadsPerWarp = [32], warpsPerCTA = [1], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK-LABEL: test_index_cache\n-  func @test_index_cache() {\n+  func.func @test_index_cache() {\n     // CHECK: nvvm.read.ptx.sreg.tid.x\n     %0 = tt.make_range {end = 256 : i32, start = 0 : i32} : tensor<256xi32, #blocked0>\n     // CHECK-NOT: nvvm.read.ptx.sreg.tid.x\n@@ -1021,7 +1021,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n #shared0 = #triton_gpu.shared<{vec = 8, perPhase = 2, maxPhase = 4, order = [1, 0]}>\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK-LABEL: test_base_index_cache\n-  func @test_base_index_cache(%arg0: tensor<128x32xf32, #blocked0>) {\n+  func.func @test_base_index_cache(%arg0: tensor<128x32xf32, #blocked0>) {\n     // CHECK: nvvm.read.ptx.sreg.tid.x\n     %0 = triton_gpu.convert_layout %arg0 : (tensor<128x32xf32, #blocked0>) -> tensor<128x32xf32, #shared0>\n     // CHECK-NOT: nvvm.read.ptx.sreg.tid.x\n@@ -1035,7 +1035,7 @@ module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n #shared0 = #triton_gpu.shared<{vec = 8, perPhase = 2, maxPhase = 4, order = [1, 0]}>\n module attributes {\"triton_gpu.num-warps\" = 1 : i32} {\n   // CHECK-LABEL: test_index_cache_different_block\n-  func @test_index_cache_different_block(%arg0: tensor<128x32xf32, #blocked0>, %arg1: i1) {\n+  func.func @test_index_cache_different_block(%arg0: tensor<128x32xf32, #blocked0>, %arg1: i1) {\n     // CHECK: nvvm.read.ptx.sreg.tid.x\n     %0 = triton_gpu.convert_layout %arg0 : (tensor<128x32xf32, #blocked0>) -> tensor<128x32xf32, #shared0>\n     scf.if %arg1 {"}, {"filename": "test/Target/tritongpu_to_llvmir.mlir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -8,7 +8,7 @@\n \n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n \n-func @test_empty_kernel(%lb : index, %A : !tt.ptr<f16>) {\n+func.func @test_empty_kernel(%lb : index, %A : !tt.ptr<f16>) {\n \n   return\n }"}, {"filename": "test/Target/tritongpu_to_ptx.mlir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -6,7 +6,7 @@\n \n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n \n-func @test_empty_kernel(%lb : index, %A : !tt.ptr<f16>) {\n+func.func @test_empty_kernel(%lb : index, %A : !tt.ptr<f16>) {\n \n   return\n }"}, {"filename": "test/Triton/combine.mlir", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "file_content_changes": "@@ -2,10 +2,10 @@\n // RUN: triton-opt %s -split-input-file -canonicalize -triton-combine | FileCheck %s\n \n // CHECK-LABEL: @test_combine_dot_add_pattern\n-func @test_combine_dot_add_pattern() -> (tensor<128x128xf32>, tensor<128x128xf32>) {\n-    // CHECK: %[[d:.*]] = arith.constant dense<3.000000e+00> : tensor<128x128xf32>\n-    // CHECK: %[[b:.*]] = arith.constant dense<2.000000e+00> : tensor<128x128xf32>\n-    // CHECK: %[[a:.*]] = arith.constant dense<1.000000e+00> : tensor<128x128xf32>\n+func.func @test_combine_dot_add_pattern() -> (tensor<128x128xf32>, tensor<128x128xf32>) {\n+    // CHECK-DAG: %[[d:.*]] = arith.constant dense<3.000000e+00> : tensor<128x128xf32>\n+    // CHECK-DAG: %[[b:.*]] = arith.constant dense<2.000000e+00> : tensor<128x128xf32>\n+    // CHECK-DAG: %[[a:.*]] = arith.constant dense<1.000000e+00> : tensor<128x128xf32>\n     %a = arith.constant dense<1.0> : tensor<128x128xf32>\n     %b = arith.constant dense<2.0> : tensor<128x128xf32>\n     %zero = arith.constant dense<0.0> : tensor<128x128xf32>\n@@ -24,7 +24,7 @@ func @test_combine_dot_add_pattern() -> (tensor<128x128xf32>, tensor<128x128xf32\n \n \n // COM: CHECK-LABEL: @test_combine_addptr_pattern\n-func @test_combine_addptr_pattern(%base: !tt.ptr<f32>) -> tensor<8x!tt.ptr<f32>> {\n+func.func @test_combine_addptr_pattern(%base: !tt.ptr<f32>) -> tensor<8x!tt.ptr<f32>> {\n     %off0 = arith.constant 10 : i32\n     %off1 = arith.constant 15 : i32\n \n@@ -47,40 +47,40 @@ func @test_combine_addptr_pattern(%base: !tt.ptr<f32>) -> tensor<8x!tt.ptr<f32>>\n \n \n // CHECK-LABEL: @test_combine_select_masked_load_pattern\n-func @test_combine_select_masked_load_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %cond: i1) -> (tensor<8xf32>, tensor<8xf32>) {\n+func.func @test_combine_select_masked_load_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %cond: i1) -> (tensor<8xf32>, tensor<8xf32>) {\n     %mask = tt.broadcast %cond : (i1) -> tensor<8xi1>\n     %false_val = arith.constant dense<0.0> : tensor<8xf32>\n \n     // CHECK: %[[res1:.*]] = tt.load %{{.*}}, %{{.*}}, %{{.*}} {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<8xf32>\n     %x = tt.load %ptr, %mask, %false_val {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<8xf32>\n-    %0 = select %cond, %x, %false_val : tensor<8xf32>\n+    %0 = arith.select %cond, %x, %false_val : tensor<8xf32>\n \n     // CHECK: %[[res2:.*]] = tt.load %{{.*}}, %{{.*}}, %{{.*}} {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<8xf32>\n     %y = tt.load %ptr, %mask, %false_val {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<8xf32>\n-    %1 = select %cond, %y, %false_val : tensor<8xf32>\n+    %1 = arith.select %cond, %y, %false_val : tensor<8xf32>\n \n     // CHECK: return %[[res1]], %[[res2]] : tensor<8xf32>, tensor<8xf32>\n     return %0, %1 : tensor<8xf32>, tensor<8xf32>\n }\n \n // CHECK-LABEL: @test_combine_select_masked_load_fail_pattern\n-func @test_combine_select_masked_load_fail_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %dummy_load: tensor<8xf32>, %dummy_broadcast: tensor<8xi1>, %cond: i1) -> (tensor<8xf32>, tensor<8xf32>) {\n+func.func @test_combine_select_masked_load_fail_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %dummy_load: tensor<8xf32>, %dummy_broadcast: tensor<8xi1>, %cond: i1) -> (tensor<8xf32>, tensor<8xf32>) {\n     %false_val = arith.constant dense<0.0> : tensor<8xf32>\n \n     // Case 1: value at the \"load\" position is not an \"op\".  Select should not be canonicalized.\n-    // CHECK: %{{.*}} = select %{{.*}}, %{{.*}}, %{{.*}} : tensor<8xf32>\n-    %0 = select %cond, %dummy_load, %false_val : tensor<8xf32>\n+    // CHECK: %{{.*}} = arith.select %{{.*}}, %{{.*}}, %{{.*}} : tensor<8xf32>\n+    %0 = arith.select %cond, %dummy_load, %false_val : tensor<8xf32>\n \n     // Case 2: value at the \"broadcast\" position is not an \"op\".  Select should not be canonicalized.\n     %real_load = tt.load %ptr, %dummy_broadcast, %false_val {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<8xf32>\n-    // CHECK: %{{.*}} = select %{{.*}}, %{{.*}}, %{{.*}} : tensor<8xf32>\n-    %1 = select %cond, %real_load, %false_val : tensor<8xf32>\n+    // CHECK: %{{.*}} = arith.select %{{.*}}, %{{.*}}, %{{.*}} : tensor<8xf32>\n+    %1 = arith.select %cond, %real_load, %false_val : tensor<8xf32>\n \n     return %0, %1 : tensor<8xf32>, tensor<8xf32>\n }\n \n // CHECK-LABEL: @test_combine_broadcast_constant_pattern\n-func @test_combine_broadcast_constant_pattern(%cst : f32) -> tensor<8x2xf32> {\n+func.func @test_combine_broadcast_constant_pattern(%cst : f32) -> tensor<8x2xf32> {\n     // CHECK: %[[cst:.*]] = arith.constant dense<1.000000e+00> : tensor<8x2xf32>\n     %const = arith.constant dense<1.0> : tensor<8xf32>\n     %bst_out = tt.broadcast %const : (tensor<8xf32>) -> tensor<8x2xf32>\n@@ -90,7 +90,7 @@ func @test_combine_broadcast_constant_pattern(%cst : f32) -> tensor<8x2xf32> {\n }\n \n // CHECK-LABEL: @test_canonicalize_masked_load_pattern\n-func @test_canonicalize_masked_load_pattern(%ptr: tensor<8x!tt.ptr<f32>>) -> (tensor<8xf32>, tensor<8xf32>, tensor<8xf32>) {\n+func.func @test_canonicalize_masked_load_pattern(%ptr: tensor<8x!tt.ptr<f32>>) -> (tensor<8xf32>, tensor<8xf32>, tensor<8xf32>) {\n     %true_mask = arith.constant dense<true> : tensor<8xi1>\n     %false_mask = arith.constant dense<false> : tensor<8xi1>\n     %other_val = arith.constant dense<0.0> : tensor<8xf32>\n@@ -111,7 +111,7 @@ func @test_canonicalize_masked_load_pattern(%ptr: tensor<8x!tt.ptr<f32>>) -> (te\n }\n \n // CHECK-LABEL: @test_canonicalize_masked_load_fail_pattern\n-func @test_canonicalize_masked_load_fail_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %mask: tensor<8xi1>) -> (tensor<8xf32>, tensor<8xf32>) {\n+func.func @test_canonicalize_masked_load_fail_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %mask: tensor<8xi1>) -> (tensor<8xf32>, tensor<8xf32>) {\n     %other_val = arith.constant dense<0.0> : tensor<8xf32>\n \n     // Case: value at the \"mask\" position is not an \"op\".  Load should not be canonicalized.\n@@ -124,7 +124,7 @@ func @test_canonicalize_masked_load_fail_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %\n }\n \n // CHECK-LABEL: @test_canonicalize_masked_store_pattern\n-func @test_canonicalize_masked_store_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %val: tensor<8xf32>) {\n+func.func @test_canonicalize_masked_store_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %val: tensor<8xf32>) {\n     %true_mask = arith.constant dense<true> : tensor<8xi1>\n     %false_mask = arith.constant dense<false> : tensor<8xi1>\n \n@@ -138,7 +138,7 @@ func @test_canonicalize_masked_store_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %val:\n }\n \n // CHECK-LABEL: @test_canonicalize_masked_store_fail_pattern\n-func @test_canonicalize_masked_store_fail_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %val: tensor<8xf32>, %mask: tensor<8xi1>) {\n+func.func @test_canonicalize_masked_store_fail_pattern(%ptr: tensor<8x!tt.ptr<f32>>, %val: tensor<8xf32>, %mask: tensor<8xi1>) {\n     // Case: value at the \"mask\" position is not an \"op\".  Store should not be canonicalized.\n     // CHECK: tt.store %{{.*}}, %{{.*}}, %{{.*}} : tensor<8xf32>\n     tt.store %ptr, %val, %mask : tensor<8xf32>"}, {"filename": "test/Triton/vecadd.mlir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1,7 +1,7 @@\n // RUN: triton-opt %s -verify-diagnostics\n \n module {\n-  func @add_kernel__Pfp32_Pfp32_Pfp32_i32_i32_i32__(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: !tt.ptr<f32>, %arg3: i32, %arg4: i32, %arg5: i32) {\n+  func.func @add_kernel__Pfp32_Pfp32_Pfp32_i32_i32_i32__(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: !tt.ptr<f32>, %arg3: i32, %arg4: i32, %arg5: i32) {\n     %0 = tt.get_program_id {axis = 0 : i32} : i32\n     %c256_i32 = arith.constant 256 : i32\n     %1 = arith.muli %0, %c256_i32 : i32\n@@ -43,7 +43,7 @@ module {\n   }\n }\n // module {\n-//   func @add_kernel__Pfp32_Pfp32_Pfp32_i32_i32_i32__(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: !tt.ptr<f32>, %arg3: i32, %arg4: i32, %arg5: i32) {\n+//   func.func @add_kernel__Pfp32_Pfp32_Pfp32_i32_i32_i32__(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: !tt.ptr<f32>, %arg3: i32, %arg4: i32, %arg5: i32) {\n //     %c64 = arith.constant 64 : index\n //     %c32 = arith.constant 32 : index\n //     %c0 = arith.constant 0 : index"}, {"filename": "test/TritonGPU/coalesce.mlir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -19,7 +19,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n // CHECK: [[store_val:%.*]] = triton_gpu.convert_layout {{.*}} -> tensor<64x64xf32, [[col_layout]]>\n // CHECK: [[store_mask:%.*]] = triton_gpu.convert_layout {{.*}} -> tensor<64x64xi1, [[col_layout]]>\n // CHECK: tt.store [[store_ptr]], [[store_val]], [[store_mask]]\n-func @transpose(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32},\n+func.func @transpose(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32},\n                 %arg1: i32 {tt.divisibility = 16 : i32},\n                 %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32},\n                 %arg3: i32 {tt.divisibility = 16 : i32}) {"}, {"filename": "test/TritonGPU/combine.mlir", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "file_content_changes": "@@ -7,31 +7,31 @@\n // CHECK: [[row_layout:#.*]] = #triton_gpu.blocked<{sizePerThread = [1, 4], threadsPerWarp = [2, 16], warpsPerCTA = [1, 4], order = [1, 0]}>\n // CHECK: [[col_layout:#.*]] = #triton_gpu.blocked<{sizePerThread = [4, 1], threadsPerWarp = [16, 2], warpsPerCTA = [4, 1], order = [0, 1]}>\n // CHECK: [[col_layout_novec:#.*]] = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}>\n-func @cst() -> tensor<1024xi32, #layout1> {\n+func.func @cst() -> tensor<1024xi32, #layout1> {\n   %cst = arith.constant dense<0> : tensor<1024xi32, #layout0>\n   %1 = triton_gpu.convert_layout %cst : (tensor<1024xi32, #layout0>) -> tensor<1024xi32, #layout1>\n   // CHECK-NOT: triton_gpu.convert_layout\n   // CHECK: return %cst : tensor<1024xi32, [[target_layout]]>\n   return %1: tensor<1024xi32, #layout1>\n }\n \n-func @range() -> tensor<1024xi32, #layout1> {\n+func.func @range() -> tensor<1024xi32, #layout1> {\n   %0 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #layout0>\n   %1 = triton_gpu.convert_layout %0 : (tensor<1024xi32, #layout0>) -> tensor<1024xi32, #layout1>\n   // CHECK-NOT: triton_gpu.convert_layout\n   // CHECK: return %0 : tensor<1024xi32, [[target_layout]]>\n   return %1: tensor<1024xi32, #layout1>\n }\n \n-func @splat(%arg0: i32) -> tensor<1024xi32, #layout1> {\n+func.func @splat(%arg0: i32) -> tensor<1024xi32, #layout1> {\n   %0 = tt.splat %arg0 : (i32) -> tensor<1024xi32, #layout0>\n   %1 = triton_gpu.convert_layout %0 : (tensor<1024xi32, #layout0>) -> tensor<1024xi32, #layout1>\n   // CHECK-NOT: triton_gpu.convert_layout\n   // CHECK: return %0 : tensor<1024xi32, [[target_layout]]>\n   return %1: tensor<1024xi32, #layout1>\n }\n \n-func @remat(%arg0: i32) -> tensor<1024xi32, #layout1> {\n+func.func @remat(%arg0: i32) -> tensor<1024xi32, #layout1> {\n   %0 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #layout0>\n   %1 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #layout0>\n   %2 = arith.muli %0, %1 : tensor<1024xi32, #layout0>\n@@ -60,7 +60,7 @@ func @remat(%arg0: i32) -> tensor<1024xi32, #layout1> {\n #blocked4 = #triton_gpu.blocked<{sizePerThread = [4, 1], threadsPerWarp = [16, 2], warpsPerCTA = [4, 1], order = [0, 1]}>\n \n // CHECK-LABEL: transpose\n-func @transpose(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32 {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}) {\n+func.func @transpose(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32 {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}) {\n   // CHECK-NOT: triton_gpu.convert_layout\n   // CHECK: [[loaded_val:%.*]] = tt.load {{.*}}, {{%cst.*}}, {{%cst.*}} {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64x64xf32, [[row_layout]]>\n   // CHECK: [[cvt_val:%.*]] = triton_gpu.convert_layout [[loaded_val]] : (tensor<64x64xf32, [[row_layout]]>) -> tensor<64x64xf32, [[col_layout]]>\n@@ -101,7 +101,7 @@ func @transpose(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32 {tt\n }\n \n // CHECK-LABEL: loop\n-func @loop(%arg0: !tt.ptr<f32>, %arg1: i32, %arg2: !tt.ptr<f32>, %arg3: i32, %arg4: i32) {\n+func.func @loop(%arg0: !tt.ptr<f32>, %arg1: i32, %arg2: !tt.ptr<f32>, %arg3: i32, %arg4: i32) {\n     // CHECK-NOT: triton_gpu.convert_layout\n     // CHECK: [[loop_ret:%.*]]:2 = scf.for {{.*}} -> (tensor<64x64xf32, [[row_layout]]>, tensor<64x64x!tt.ptr<f32>, [[row_layout]]>)\n     // CHECK-NEXT: {{.*}} = tt.load {{.*}} : tensor<64x64xf32, [[row_layout]]>\n@@ -155,7 +155,7 @@ func @loop(%arg0: !tt.ptr<f32>, %arg1: i32, %arg2: !tt.ptr<f32>, %arg3: i32, %ar\n }\n \n // CHECK-LABEL: vecadd\n-func @vecadd(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32) {\n+func.func @vecadd(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32) {\n   // CHECK-NOT: triton_gpu.convert_layout\n   %c256_i32 = arith.constant 256 : i32\n   %0 = tt.get_program_id {axis = 0 : i32} : i32\n@@ -187,7 +187,7 @@ func @vecadd(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f3\n \n // Select has args with different element types\n // CHECK-LABEL: select\n-func @select(%arg0: !tt.ptr<f64> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f64> {tt.divisibility = 16 : i32}, %arg2: i32 {tt.divisibility = 16 : i32}) {\n+func.func @select(%arg0: !tt.ptr<f64> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f64> {tt.divisibility = 16 : i32}, %arg2: i32 {tt.divisibility = 16 : i32}) {\n   // CHECK-NOT: triton_gpu.convert_layout\n   %cst = arith.constant dense<30000> : tensor<1x1xi32, #blocked2>\n   %cst_0 = arith.constant dense<30000> : tensor<1x512xi32, #blocked2>"}, {"filename": "test/TritonGPU/loop-pipeline.mlir", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -8,7 +8,7 @@\n #A = #triton_gpu.dot_op<{opIdx = 0, parent = #C}>\n #B = #triton_gpu.dot_op<{opIdx = 1, parent = #C}>\n \n-// CHECK: func @matmul_loop\n+// CHECK: func.func @matmul_loop\n // CHECK-DAG: %[[CONSTANT_0:.*]] = arith.constant 0 : i32\n // CHECK-DAG: %[[CONSTANT_1:.*]] = arith.constant 1 : i32\n // CHECK-DAG: %[[CONSTANT_2:.*]] = arith.constant 2 : i32\n@@ -44,7 +44,7 @@\n // CHECK-DAG: %[[NEXT_PIPELINE_IDX:.*]] = arith.addi %[[PIPELINE_IDX]], %[[CONSTANT_1]]\n // CHECK-DAG: %[[NEXT_LOOP_IDX:.*]] = arith.addi %[[LOOP_IDX]], %[[CONSTANT_1]]\n // CHECK:   scf.yield {{.*}}, {{.*}}, {{.*}}, %[[NEXT_A_BUFFER]], %[[NEXT_B_BUFFER]], %[[NEXT_A]], %[[NEXT_B]], {{.*}}, {{.*}}, {{.*}}, %[[NEXT_PIPELINE_IDX]], %[[NEXT_LOOP_IDX]]\n-func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_ptr_init = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n   %b_ptr_init = tt.broadcast %B : (!tt.ptr<f16>) -> tensor<32x128x!tt.ptr<f16>, #BL>\n \n@@ -73,7 +73,7 @@ func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B\n }\n \n \n-// CHECK: func @matmul_loop_nested\n+// CHECK: func.func @matmul_loop_nested\n // CHECK-DAG: %[[CONSTANT_0:.*]] = arith.constant 0 : i32\n // CHECK-DAG: %[[CONSTANT_1:.*]] = arith.constant 1 : i32\n // CHECK-DAG: %[[CONSTANT_2:.*]] = arith.constant 2 : i32\n@@ -103,7 +103,7 @@ func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B\n // CHECK-DAG: %[[NEXT_PIPELINE_IDX:.*]] = arith.addi %[[PIPELINE_IDX]], %[[CONSTANT_1]]\n // CHECK-DAG: %[[NEXT_LOOP_IDX:.*]] = arith.addi %[[LOOP_IDX]], %[[CONSTANT_1]]\n // CHECK:     scf.yield {{.*}}, {{.*}}, {{.*}}, %[[NEXT_A_BUFFER]], %[[NEXT_B_BUFFER]], %[[NEXT_A]], %[[NEXT_B]], {{.*}}, {{.*}}, {{.*}}, %[[NEXT_PIPELINE_IDX]], %[[NEXT_LOOP_IDX]]\n-func @matmul_loop_nested(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @matmul_loop_nested(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   scf.for %iv0 = %lb to %ub step %step {\n     %a_ptr_init = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n     %b_ptr_init = tt.broadcast %B : (!tt.ptr<f16>) -> tensor<32x128x!tt.ptr<f16>, #BL>\n@@ -134,7 +134,7 @@ func @matmul_loop_nested(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f\n }\n \n \n-// CHECK: func @matmul_loop_single_pipeline\n+// CHECK: func.func @matmul_loop_single_pipeline\n // CHECK-DAG: %[[CONSTANT_0:.*]] = arith.constant 0 : i32\n // CHECK-DAG: %[[CONSTANT_1:.*]] = arith.constant 1 : i32\n // CHECK-DAG: %[[CONSTANT_2:.*]] = arith.constant 2 : i32\n@@ -156,7 +156,7 @@ func @matmul_loop_nested(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f\n // CHECK-DAG: %[[NEXT_PIPELINE_IDX:.*]] = arith.addi %[[PIPELINE_IDX]], %[[CONSTANT_1]]\n // CHECK-DAG: %[[NEXT_LOOP_IDX:.*]] = arith.addi %[[LOOP_IDX]], %[[CONSTANT_1]]\n // CHECK:   scf.yield {{.*}}, {{.*}}, %[[NEXT_B_BUFFER]], %[[NEXT_B]], {{.*}}, {{.*}}, %[[NEXT_PIPELINE_IDX]], %[[NEXT_LOOP_IDX]]\n-func @matmul_loop_single_pipeline(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @matmul_loop_single_pipeline(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_ptr_init = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n   %b_ptr_init = tt.broadcast %B : (!tt.ptr<f16>) -> tensor<32x128x!tt.ptr<f16>, #BL>\n "}, {"filename": "test/TritonGPU/matmul.mlir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -4,7 +4,7 @@\n // CHECK: offset = 49152, size = 49152\n // CHECK: size = 98304\n module {\n-func @matmul_kernel__Pfp32_Pfp32_Pfp32_i32_i32_i32_i32_i32_i32_i32_i32_i32__12c64_13c64_14c64_15c8(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32 {tt.divisibility = 16 : i32}, %arg7: i32, %arg8: i32 {tt.divisibility = 16 : i32}, %arg9: i32, %arg10: i32 {tt.divisibility = 16 : i32}, %arg11: i32) {\n+func.func @matmul_kernel__Pfp32_Pfp32_Pfp32_i32_i32_i32_i32_i32_i32_i32_i32_i32__12c64_13c64_14c64_15c8(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32 {tt.divisibility = 16 : i32}, %arg7: i32, %arg8: i32 {tt.divisibility = 16 : i32}, %arg9: i32, %arg10: i32 {tt.divisibility = 16 : i32}, %arg11: i32) {\n     %cst = arith.constant dense<true> : tensor<64x64xi1>\n     %c64 = arith.constant 64 : index\n     %c0 = arith.constant 0 : index\n@@ -22,7 +22,7 @@ func @matmul_kernel__Pfp32_Pfp32_Pfp32_i32_i32_i32_i32_i32_i32_i32_i32_i32__12c6\n     %7 = arith.muli %6, %c8_i32 : i32\n     %8 = arith.subi %2, %7 : i32\n     %9 = arith.cmpi slt, %8, %c8_i32 : i32\n-    %10 = select %9, %8, %c8_i32 : i32\n+    %10 = arith.select %9, %8, %c8_i32 : i32\n     %11 = arith.remsi %0, %10 : i32\n     %12 = arith.addi %7, %11 : i32\n     %13 = arith.remsi %0, %5 : i32"}, {"filename": "test/TritonGPU/prefetch.mlir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -11,7 +11,7 @@\n #B_OP = #triton_gpu.dot_op<{opIdx = 1, parent = #C}>\n \n \n-// CHECK: func @matmul_loop\n+// CHECK: func.func @matmul_loop\n // CHECK-DAG: %[[A0_PREFETCH_SMEM:.*]] = tensor.extract_slice %[[A0:.*]][0, 0] [128, 16]\n // CHECK-DAG: %[[A0_PREFETCH:.*]] = triton_gpu.convert_layout %[[A0_PREFETCH_SMEM]]\n // CHECK-DAG: %[[B0_PREFETCH_SMEM:.*]] = tensor.extract_slice %[[B0:.*]][0, 0] [16, 128]\n@@ -28,7 +28,7 @@\n // CHECK-DAG:   %[[NEXT_B_PREFETCH_SMEM:.*]] = tensor.extract_slice {{.*}}[0, 0] [16, 128]\n // CHECK-DAG:   %[[NEXT_B_PREFETCH:.*]] = triton_gpu.convert_layout %[[NEXT_B_PREFETCH_SMEM]]\n // CHECK:     scf.yield {{.*}}, {{.*}}, {{.*}}, {{.*}}, {{.*}}, %[[NEXT_A_PREFETCH]], %[[NEXT_B_PREFETCH]]\n-func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n+func.func @matmul_loop(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>, %B : !tt.ptr<f16>) {\n   %a_ptr_init = tt.broadcast %A : (!tt.ptr<f16>) -> tensor<128x32x!tt.ptr<f16>, #AL>\n   %b_ptr_init = tt.broadcast %B : (!tt.ptr<f16>) -> tensor<32x128x!tt.ptr<f16>, #BL>\n "}, {"filename": "test/TritonGPU/update-mma-for-volta.mlir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -15,7 +15,7 @@\n // CHECK: [[new_mma:#mma.*]] = #triton_gpu.mma<{versionMajor = 1, versionMinor = 3, warpsPerCTA = [4, 2]}>\n module attributes {\"triton_gpu.num-warps\" = 16 : i32} {\n   // CHECK-LABEL: dot_mmav1\n-  func @dot_mmav1(%A: tensor<64x64xf16, #blocked0>, %B: tensor<64x64xf16, #blocked0>) -> tensor<64x64xf32, #blocked0> {\n+  func.func @dot_mmav1(%A: tensor<64x64xf16, #blocked0>, %B: tensor<64x64xf16, #blocked0>) -> tensor<64x64xf32, #blocked0> {\n     %C = arith.constant dense<0.000000e+00> : tensor<64x64xf32, #blocked0>\n     %AA = triton_gpu.convert_layout %A : (tensor<64x64xf16, #blocked0>) -> tensor<64x64xf16, #dot_operand_a>\n     %BB = triton_gpu.convert_layout %B : (tensor<64x64xf16, #blocked0>) -> tensor<64x64xf16, #dot_operand_b>\n@@ -50,7 +50,7 @@ module attributes {\"triton_gpu.num-warps\" = 16 : i32} {\n \n module attributes {\"triton_gpu.num-warps\" = 16 : i32} {\n   // CHECK-LABEL: dot_mmav1\n-  func @dot_mmav1(%A: tensor<64x64xf16, #blocked0>, %B: tensor<64x64xf16, #blocked0>) -> tensor<64x64xf32, #blocked0> {\n+  func.func @dot_mmav1(%A: tensor<64x64xf16, #blocked0>, %B: tensor<64x64xf16, #blocked0>) -> tensor<64x64xf32, #blocked0> {\n     %C = arith.constant dense<0.000000e+00> : tensor<64x64xf32, #blocked0>\n     %AA = triton_gpu.convert_layout %A : (tensor<64x64xf16, #blocked0>) -> tensor<64x64xf16, #dot_operand_a>\n     %BB = triton_gpu.convert_layout %B : (tensor<64x64xf16, #blocked0>) -> tensor<64x64xf16, #dot_operand_b>"}, {"filename": "test/lib/Analysis/TestAlias.cpp", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "file_content_changes": "@@ -9,10 +9,10 @@ using namespace mlir;\n namespace {\n \n struct TestAliasPass\n-    : public PassWrapper<TestAliasPass, OperationPass<FuncOp>> {\n+    : public PassWrapper<TestAliasPass, OperationPass<func::FuncOp>> {\n+\n+  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestAliasPass);\n \n-  // LLVM15+\n-  // MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestAliasPass);\n   static void print(StringRef name, SmallVector<std::string, 4> &vals,\n                     raw_ostream &os) {\n     if (vals.empty())\n@@ -39,23 +39,24 @@ struct TestAliasPass\n     auto op_name = SymbolTable::getSymbolName(operation).getValue().str();\n     os << op_name << \"\\n\";\n \n-    SharedMemoryAliasAnalysis analysis(&getContext());\n-    analysis.run(operation);\n+    std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n+    SharedMemoryAliasAnalysis* analysis =\n+        solver->load<SharedMemoryAliasAnalysis>();\n+    if (failed(solver->initializeAndRun(operation)))\n+      return signalPassFailure();\n \n     AsmState state(operation->getParentOfType<ModuleOp>());\n     // Get operation ids of value's aliases\n     auto getAllocOpNames = [&](Value value) {\n-      LatticeElement<AliasInfo> *latticeElement =\n-          analysis.lookupLatticeElement(value);\n+      dataflow::Lattice<AliasInfo> *latticeElement =\n+          analysis->getLatticeElement(value);\n       SmallVector<std::string, 4> opNames;\n-      if (latticeElement) {\n+      if (latticeElement && !latticeElement->isUninitialized()) {\n         auto &info = latticeElement->getValue();\n-        if (!info.getAllocs().empty()) {\n-          for (auto &alias : info.getAllocs()) {\n-            auto opName =\n-                getValueOperandName(alias.getDefiningOp()->getResult(0), state);\n-            opNames.push_back(std::move(opName));\n-          }\n+        for (auto &alias : info.getAllocs()) {\n+          auto opName =\n+              getValueOperandName(alias.getDefiningOp()->getResult(0), state);\n+          opNames.push_back(std::move(opName));\n         }\n       }\n       // Ensure deterministic output"}, {"filename": "test/lib/Analysis/TestAllocation.cpp", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "file_content_changes": "@@ -6,10 +6,9 @@ using namespace mlir;\n namespace {\n \n struct TestAllocationPass\n-    : public PassWrapper<TestAllocationPass, OperationPass<FuncOp>> {\n+    : public PassWrapper<TestAllocationPass, OperationPass<func::FuncOp>> {\n \n-  // LLVM15+\n-  // MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestAllocationPass);\n+  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestAllocationPass);\n \n   StringRef getArgument() const final { return \"test-print-allocation\"; }\n   StringRef getDescription() const final {"}, {"filename": "test/lib/Analysis/TestAxisInfo.cpp", "status": "modified", "additions": 10, "deletions": 32, "changes": 42, "file_content_changes": "@@ -1,25 +1,15 @@\n #include \"mlir/Pass/Pass.h\"\n #include \"triton/Analysis/AxisInfo.h\"\n+#include \"triton/Analysis/Utility.h\"\n \n using namespace mlir;\n \n namespace {\n \n struct TestAxisInfoPass\n-    : public PassWrapper<TestAxisInfoPass, OperationPass<FuncOp>> {\n+    : public PassWrapper<TestAxisInfoPass, OperationPass<func::FuncOp>> {\n \n-  // LLVM15+\n-  // MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestAlignmentPass);\n-\n-  void print(const std::string &name, raw_ostream &os, ArrayRef<int> vals) {\n-    os << name << \": [\";\n-    for (size_t d = 0; d < vals.size(); d++) {\n-      if (d != 0)\n-        os << \", \";\n-      os << vals[d];\n-    }\n-    os << \"]\";\n-  }\n+  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestAxisInfoPass);\n \n   StringRef getArgument() const final { return \"test-print-alignment\"; }\n   StringRef getDescription() const final {\n@@ -30,30 +20,18 @@ struct TestAxisInfoPass\n     Operation *operation = getOperation();\n     auto &os = llvm::errs();\n     os << \"Testing: \" << operation->getName() << \"\\n\";\n-    AxisInfoAnalysis analysis(&getContext());\n-    analysis.run(operation);\n+\n+    std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n+    AxisInfoAnalysis* analysis = solver->load<AxisInfoAnalysis>();\n+    if (failed(solver->initializeAndRun(operation)))\n+      return signalPassFailure();\n     operation->walk([&](Operation *op) {\n       if (op->getNumResults() < 1)\n         return;\n       for (Value result : op->getResults()) {\n-        // std::ostringstream oss;\n-        // result.print(oss);\n-        // os << \" => \";\n-        LatticeElement<AxisInfo> *latticeElement =\n-            analysis.lookupLatticeElement(result);\n-        if (!latticeElement) {\n-          os << \"None\\n\";\n-          return;\n-        }\n-        AxisInfo &info = latticeElement->getValue();\n-        print(\"Contiguity\", os, info.getContiguity());\n-        os << \" ; \";\n-        print(\"Divisibility\", os, info.getDivisibility());\n-        os << \" ; \";\n-        print(\"Constancy\", os, info.getConstancy());\n-        os << \" ( \";\n         result.print(os);\n-        os << \" ) \";\n+        os << \" => \";\n+        analysis->getLatticeElement(result)->getValue().print(os);\n         os << \"\\n\";\n       }\n     });"}, {"filename": "test/lib/Analysis/TestMembar.cpp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "file_content_changes": "@@ -1,4 +1,4 @@\n-#include \"mlir/Dialect/GPU/GPUDialect.h\"\n+#include \"mlir/Dialect/GPU/IR/GPUDialect.h\"\n #include \"mlir/IR/Dialect.h\"\n #include \"mlir/Pass/Pass.h\"\n #include \"triton/Analysis/Allocation.h\"\n@@ -9,10 +9,9 @@ using namespace mlir;\n namespace {\n \n struct TestMembarPass\n-    : public PassWrapper<TestMembarPass, OperationPass<FuncOp>> {\n+    : public PassWrapper<TestMembarPass, OperationPass<func::FuncOp>> {\n \n-  // LLVM15+\n-  // MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestMembarPass);\n+  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestMembarPass);\n \n   StringRef getArgument() const final { return \"test-print-membar\"; }\n   StringRef getDescription() const final {"}]