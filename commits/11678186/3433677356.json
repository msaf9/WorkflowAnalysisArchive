[{"filename": "include/triton/Conversion/TritonGPUToLLVM/PtxAsmFormat.h", "status": "modified", "additions": 23, "deletions": 60, "changes": 83, "file_content_changes": "@@ -241,70 +241,18 @@ template <class ConcreteT> struct PTXInstrBase : public PTXInstrCommon {\n \n struct PTXInstr : public PTXInstrBase<PTXInstr> {\n   using PTXInstrBase<PTXInstr>::PTXInstrBase;\n-};\n-\n-// A helper for PTX ld/st instruction.\n-// Usage:\n-// PtxIOInstr store(\"st\");\n-// store.predicate(pValue).global().v(32).b(1); // @%0 st.global.v32.b1\n-// store.addAddr(addrValue, \"l\", off);\n-struct PTXIOInstr : public PTXInstrBase<PTXIOInstr> {\n-  using PTXInstrBase<PTXIOInstr>::PTXInstrBase;\n-\n-  // Add \".global\" suffix to instruction\n-  PTXIOInstr &global(bool predicate = true) {\n-    o(\"global\", predicate);\n-    return *this;\n-  }\n-\n-  // Add \".shared\" suffix to instruction\n-  PTXIOInstr &shared(bool predicate = true) {\n-    o(\"shared\", predicate);\n-    return *this;\n-  }\n-\n-  // Add \".v\" suffix to instruction\n-  PTXIOInstr &v(int vecWidth, bool predicate = true) {\n-    if (vecWidth > 1) {\n-      o(\"v\" + std::to_string(vecWidth), predicate);\n-    }\n-    return *this;\n-  }\n \n-  // Add \".b\" suffix to instruction\n-  PTXIOInstr &b(int width) {\n-    o(\"b\" + std::to_string(width));\n-    return *this;\n-  }\n-};\n-\n-struct PTXCpAsyncInstrBase : public PTXInstrBase<PTXCpAsyncInstrBase> {\n-  explicit PTXCpAsyncInstrBase(PTXBuilder *builder)\n-      : PTXInstrBase(builder, \"cp.async\") {}\n-};\n+  // Append a \".global\" to the instruction.\n+  PTXInstr &global();\n \n-struct PTXCpAsyncCommitGroupInstr : public PTXCpAsyncInstrBase {\n-  explicit PTXCpAsyncCommitGroupInstr(PTXBuilder *builder)\n-      : PTXCpAsyncInstrBase(builder) {\n-    o(\"commit_group\");\n-  }\n-};\n+  // Append a \".shared\" to the instruction.\n+  PTXInstr &shared();\n \n-struct PTXCpAsyncWaitGroupInstr : public PTXCpAsyncInstrBase {\n-  explicit PTXCpAsyncWaitGroupInstr(PTXBuilder *builder)\n-      : PTXCpAsyncInstrBase(builder) {\n-    o(\"wait_group\");\n-  }\n-};\n+  // Append a \".v[0-9]+\" to the instruction\n+  PTXInstr &v(int vecWidth, bool predicate = true);\n \n-struct PTXCpAsyncLoadInstr : public PTXCpAsyncInstrBase {\n-  explicit PTXCpAsyncLoadInstr(PTXBuilder *builder,\n-                               triton::CacheModifier modifier)\n-      : PTXCpAsyncInstrBase(builder) {\n-    o(triton::stringifyCacheModifier(modifier).str());\n-    o(\"shared\");\n-    o(\"global\");\n-  }\n+  // Append a\".b[0-9]+\" to the instruction\n+  PTXInstr &b(int width);\n };\n \n // Record the operands and context for \"launching\" a PtxInstr.\n@@ -342,6 +290,21 @@ struct PTXInstrExecution {\n   bool onlyAttachMLIRArgs{};\n };\n \n+//// =============================== Some instruction wrappers\n+///===============================\n+// We add the wrappers to make the usage more intuitive by avoiding mixing the\n+// PTX code with some trivial C++ code.\n+\n+struct PTXCpAsyncLoadInstr : PTXInstrBase<PTXCpAsyncLoadInstr> {\n+  explicit PTXCpAsyncLoadInstr(PTXBuilder *builder,\n+                               triton::CacheModifier modifier)\n+      : PTXInstrBase(builder, \"cp.async\") {\n+    o(triton::stringifyCacheModifier(modifier).str());\n+    o(\"shared\");\n+    o(\"global\");\n+  }\n+};\n+\n } // namespace triton\n } // namespace mlir\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/PtxAsmFormat.cpp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "file_content_changes": "@@ -179,5 +179,27 @@ PTXInstrExecution::getArgList() const {\n   return args;\n }\n \n+PTXInstr &PTXInstr::global() {\n+  o(\"global\");\n+  return *this;\n+}\n+\n+PTXInstr &PTXInstr::shared() {\n+  o(\"shared\");\n+  return *this;\n+}\n+\n+PTXInstr &PTXInstr::v(int vecWidth, bool predicate) {\n+  if (vecWidth > 1) {\n+    o(\"v\" + std::to_string(vecWidth), predicate);\n+  }\n+  return *this;\n+}\n+\n+PTXInstr &PTXInstr::b(int width) {\n+  o(\"b\" + std::to_string(width));\n+  return *this;\n+}\n+\n } // namespace triton\n } // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "file_content_changes": "@@ -388,9 +388,9 @@ static Value storeShared(ConversionPatternRewriter &rewriter, Location loc,\n   const char *c = bits == 64 ? \"l\" : (bits == 16 ? \"h\" : \"r\");\n \n   PTXBuilder builder;\n-  auto &st = builder.create<PTXIOInstr>(\"st\")->shared().b(bits);\n   auto *ptrOpr = builder.newAddrOperand(ptr, \"r\");\n   auto *valOpr = builder.newOperand(val, c);\n+  auto &st = builder.create<>(\"st\")->shared().b(bits);\n   st(ptrOpr, valOpr).predicate(pred, \"b\");\n   return builder.launch(rewriter, loc, void_ty(ctx));\n }\n@@ -1005,7 +1005,6 @@ struct LoadOpConversion\n       const bool hasL2EvictPolicy = false;\n \n       PTXBuilder ptxBuilder;\n-      auto &ld = *ptxBuilder.create<PTXIOInstr>(\"ld\");\n \n       Value pred = mask ? maskElems[vecStart] : int_val(1, 1);\n \n@@ -1025,16 +1024,18 @@ struct LoadOpConversion\n           ptxBuilder.newAddrOperand(ptrElems[vecStart], \"l\", in_off);\n \n       // Define the instruction opcode\n-      ld.o(\"volatile\", op.isVolatile())\n-          .global()\n-          .o(\"ca\", op.cache() == triton::CacheModifier::CA)\n-          .o(\"cg\", op.cache() == triton::CacheModifier::CG)\n-          .o(\"L1::evict_first\",\n-             op.evict() == triton::EvictionPolicy::EVICT_FIRST)\n-          .o(\"L1::evict_last\", op.evict() == triton::EvictionPolicy::EVICT_LAST)\n-          .o(\"L1::cache_hint\", hasL2EvictPolicy)\n-          .v(nWords)\n-          .b(width);\n+      auto &ld = *ptxBuilder.create<>(\"ld\")\n+                      ->o(\"volatile\", op.isVolatile())\n+                      .global()\n+                      .o(\"ca\", op.cache() == triton::CacheModifier::CA)\n+                      .o(\"cg\", op.cache() == triton::CacheModifier::CG)\n+                      .o(\"L1::evict_first\",\n+                         op.evict() == triton::EvictionPolicy::EVICT_FIRST)\n+                      .o(\"L1::evict_last\",\n+                         op.evict() == triton::EvictionPolicy::EVICT_LAST)\n+                      .o(\"L1::cache_hint\", hasL2EvictPolicy)\n+                      .v(nWords)\n+                      .b(width);\n \n       PTXBuilder::Operand *evictOpr{};\n \n@@ -1049,8 +1050,8 @@ struct LoadOpConversion\n \n       if (other) {\n         for (size_t ii = 0; ii < nWords; ++ii) {\n-          PTXInstr &mov = *ptxBuilder.create<>(\"mov\");\n-          mov.o(\"u\" + std::to_string(width));\n+          PTXInstr &mov =\n+              *ptxBuilder.create<>(\"mov\")->o(\"u\" + std::to_string(width));\n \n           size_t size = width / valueElemNbits;\n \n@@ -1222,7 +1223,7 @@ struct StoreOpConversion\n           ptxBuilder.newAddrOperand(ptrElems[vecStart], \"l\", in_off);\n \n       auto &ptxStoreInstr =\n-          ptxBuilder.create<PTXIOInstr>(\"st\")->global().v(nWords).b(width);\n+          ptxBuilder.create<>(\"st\")->global().v(nWords).b(width);\n       ptxStoreInstr(asmAddr, asmArgList).predicate(maskVal, \"b\");\n \n       Type boolTy = getTypeConverter()->convertType(rewriter.getIntegerType(1));\n@@ -4802,7 +4803,7 @@ struct AsyncWaitOpConversion\n   matchAndRewrite(triton::gpu::AsyncWaitOp op, OpAdaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n     PTXBuilder ptxBuilder;\n-    auto &asyncWaitOp = *ptxBuilder.create<PTXCpAsyncWaitGroupInstr>();\n+    auto &asyncWaitOp = *ptxBuilder.create<>(\"cp.async.wait_group\");\n     auto num = op->getAttrOfType<IntegerAttr>(\"num\").getInt();\n     asyncWaitOp(ptxBuilder.newConstantOperand(num));\n \n@@ -5025,7 +5026,7 @@ struct InsertSliceAsyncOpConversion\n     }\n \n     PTXBuilder ptxBuilder;\n-    ptxBuilder.create<PTXCpAsyncCommitGroupInstr>()->operator()();\n+    ptxBuilder.create<>(\"cp.async.commit_group\")->operator()();\n     ptxBuilder.launch(rewriter, loc, void_ty(getContext()));\n     rewriter.replaceOp(op, llDst);\n     return success();\n@@ -5178,9 +5179,7 @@ struct AtomicRMWOpConversion\n       auto *ptrOpr = ptxBuilder.newAddrOperand(rmwPtr, \"r\");\n       auto *valOpr = ptxBuilder.newOperand(rmvVal, \"r\");\n \n-      auto &atom = *ptxBuilder.create<>(\"atom\");\n-\n-      atom.o(\"global\").o(\"gpu\");\n+      auto &atom = ptxBuilder.create<>(\"atom\")->global().o(\"gpu\");\n       auto rmwOp = stringifyRMWOp(atomicRmwAttr).str();\n       auto sBits = std::to_string(valueElemNbits);\n       switch (atomicRmwAttr) {"}, {"filename": "unittest/Conversion/TritonGPUToLLVM/PtxAsmFormatTest.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -76,7 +76,7 @@ TEST_F(PtxAsmFormatTest, complexInstruction) {\n \n   auto &ld =\n       builder\n-          .create<PTXIOInstr>(\"ld\") //\n+          .create<>(\"ld\") //\n           ->o(\"volatile\", isVolatile)\n           .global()\n           .o(\"ca\", cache == CacheModifier::CA)"}]