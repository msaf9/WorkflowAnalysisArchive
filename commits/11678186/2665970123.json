[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "file_content_changes": "@@ -1308,7 +1308,8 @@ def _kernel(dst):\n \n @pytest.mark.parametrize(\"dtype_str, expr, lib_path\",\n                          [('int32', 'libdevice.ffs', ''),\n-                          ('float32', 'libdevice.pow', '/usr/local/cuda/nvvm/libdevice/libdevice.10.bc')])\n+                          ('float32', 'libdevice.pow', '/usr/local/cuda/nvvm/libdevice/libdevice.10.bc'),\n+                          ('float64', 'libdevice.norm4d', '')])\n def test_libdevice(dtype_str, expr, lib_path):\n \n     @triton.jit\n@@ -1332,6 +1333,9 @@ def kernel(X, Y, BLOCK: tl.constexpr):\n         x = np.abs(x)\n         kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.libdevice.pow(x, x)'})\n         y_ref = np.power(x, x)\n+    elif expr == 'libdevice.norm4d':\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.libdevice.norm4d(x, x, x, x)'})\n+        y_ref = np.sqrt(4 * np.power(x, 2))\n \n     x_tri = to_triton(x)\n     # triton result"}, {"filename": "python/triton/language/extern.py", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "file_content_changes": "@@ -69,7 +69,18 @@ def elementwise(lib_name: str, lib_path: str, args: list, arg_type_symbol_dict:\n             dispatch_args[0], dispatch_args[1], _builder)\n         ret_shape = dispatch_args[0].shape\n     else:\n-        return ValueError(\"elementwise function takes 1 or 2 arguments\")\n+        for i in range(len(dispatch_args)):\n+            dispatch_args[i] = core._to_tensor(dispatch_args[i], _builder)\n+        broadcast_arg = dispatch_args[0]\n+        # Get the broadcast shape over all the arguments\n+        for i in range(len(dispatch_args)):\n+            _, broadcast_arg = semantic.binary_op_type_checking_impl(\n+                dispatch_args[i], broadcast_arg, _builder)\n+        # Change the shape of each argument based on the broadcast shape\n+        for i in range(len(dispatch_args)):\n+            dispatch_args[i], _ = semantic.binary_op_type_checking_impl(\n+                dispatch_args[i], broadcast_arg, _builder)\n+        ret_shape = broadcast_arg.shape\n     func = getattr(_builder, \"create_extern_elementwise\")\n     return dispatch(func, lib_name, lib_path, dispatch_args, arg_type_symbol_dict, ret_shape, _builder)\n "}, {"filename": "python/triton/language/libdevice.10.bc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "file_content_changes": "N/A"}, {"filename": "python/triton/language/libdevice.py", "status": "modified", "additions": 795, "deletions": 487, "changes": 1282, "file_content_changes": "N/A"}, {"filename": "python/triton/tools/build_extern.py", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "file_content_changes": "@@ -59,8 +59,16 @@ def convert_type(type_str):\n         return None\n \n \n+def to_unsigned(type_str):\n+    if type_str == \"int32\":\n+        return \"uint32\"\n+    elif type_str == \"int64\":\n+        return \"uint64\"\n+    else:\n+        return type_str\n+\n class ExternLibrary(ABC):\n-    def __init__(self, name: str, path: str, format: bool = True) -> None:\n+    def __init__(self, name: str, path: str, format: bool = True, grouping: bool = True) -> None:\n         '''\n         Abstract class for extern library.\n \n@@ -72,6 +80,7 @@ def __init__(self, name: str, path: str, format: bool = True) -> None:\n         self._path = path\n         self._symbols = {}\n         self._format = True\n+        self._grouping = grouping\n \n     @property\n     def name(self):\n@@ -85,6 +94,10 @@ def path(self):\n     def symbols(self):\n         return self._symbols\n \n+    @property\n+    def grouping(self):\n+        return self._grouping\n+\n     @abstractmethod\n     def parse_symbols(self, input_file):\n         pass\n@@ -146,11 +159,24 @@ def _extract_symbol(self, line):\n             arg_name = 'arg' + str(i)\n             arg_types.append(arg_type)\n             arg_names.append(arg_name)\n+        if op_name == \"sad\":\n+            # Special case for sad, where the last argument is an unsigned int\n+            arg_types[-1] = to_unsigned(arg_types[-1])\n+        elif op_name.startswith(\"u\"):\n+            # LLVM does not differentiate between signed and unsigned integer type.\n+            # We have to convert the types to unsigned\n+            ret_type = to_unsigned(ret_type)\n+            for i, arg_type in enumerate(arg_types):\n+                arg_types[i] = to_unsigned(arg_type)\n         return Symbol(func_name, op_name, ret_type, arg_names, arg_types)\n \n     def _group_symbols(self):\n+        symbol_set = {}\n+        for symbol in self._symbols.values():\n+            op_name = symbol.op_name\n+            symbol_set[op_name] = symbol\n         # The following cases are grouped together:\n-        # op_name, <u/ull/ll>op_name<ll/f/i/if>\n+        # op_name, <u/ull/ll>op_name<ll/f/i>\n         for symbol in self._symbols.values():\n             op_name = symbol.op_name\n             if \"max\" in op_name:\n@@ -159,6 +185,18 @@ def _group_symbols(self):\n                 op_name = \"min\"\n             elif \"abs\" in op_name:\n                 op_name = \"abs\"\n+            elif \"pow\" in op_name and \"fast\" in op_name:\n+                op_name = \"pow\"\n+            elif \"round\" in op_name:\n+                if \"llround\" in op_name:\n+                    op_name = \"llround\"\n+                else:\n+                    op_name = \"round\"\n+            elif \"rint\" in op_name:\n+                if \"llrint\" in op_name:\n+                    op_name = \"llrint\"\n+                else:\n+                    op_name = \"rint\"\n             elif op_name.startswith(\"ull\"):\n                 if \"2\" not in op_name:\n                     # e.g., ullmax->max\n@@ -177,16 +215,15 @@ def _group_symbols(self):\n                 if \"2\" not in op_name:\n                     # e.g., llmax->max\n                     op_name = op_name[2:]\n-            elif op_name.endswith(\"i\"):\n-                op_name = op_name[:-1]\n-            elif op_name.endswith(\"if\"):\n-                op_name = op_name[:-2]\n             elif op_name.endswith(\"ll\"):\n                 op_name = op_name[:-2]\n             elif op_name.endswith(\"f\"):\n                 op_name = op_name[:-1]\n-            # Update op_name\n-            symbol._op_name = op_name\n+            if op_name in symbol_set:\n+                # Update op_name only if there's an existing symbol\n+                symbol._op_name = op_name\n+            else:\n+                op_name = symbol._op_name\n             if op_name in self._symbol_groups:\n                 self._symbol_groups[op_name].append(symbol)\n             else:\n@@ -211,7 +248,8 @@ def _output_stubs(self):\n         #   arg_type_symbol_dict = {[arg_type]: {(symbol, ret_type)}}\n         #   return extern.dispatch(\"libdevice\", <path>, <args>, <arg_type_symbol_dict>, _builder)\n         import_str = \"from . import core, extern\\n\"\n-        header_str = \"LIBDEVICE_PATH = \\\"{}\\\"\\n\".format(self._path)\n+        import_str += \"import os\\n\"\n+        header_str = f\"LIBDEVICE_PATH = os.path.dirname(os.path.abspath(__file__)) + \\\"/libdevice.10.bc\\\"\\n\"\n         func_str = \"\"\n         for symbols in self._symbol_groups.values():\n             func_str += \"@extern.extern\\n\"\n@@ -223,15 +261,15 @@ def _output_stubs(self):\n             return_str = f\"\\treturn extern.elementwise(\\\"{self._name}\\\", LIBDEVICE_PATH, [\"\n             for arg_name in symbols[0].arg_names:\n                 return_str += f\"{arg_name}, \"\n-            return_str += \"], \"\n+            return_str += \"], \\n\"\n \n             arg_type_symbol_dict_str = \"{\"\n             for symbol in symbols:\n                 arg_type_symbol_dict_str += \"(\"\n                 for arg_type in symbol.arg_types:\n                     arg_type_symbol_dict_str += f\"core.dtype(\\\"{arg_type}\\\"),\"\n                 ret_type = f\"core.dtype(\\\"{symbol.ret_type}\\\")\"\n-                arg_type_symbol_dict_str += \"): (\\\"\" + symbol.name + \"\\\", \" + ret_type + \"),\"\n+                arg_type_symbol_dict_str += \"): (\\\"\" + symbol.name + \"\\\", \" + ret_type + \"),\\n\"\n             arg_type_symbol_dict_str += \"}\"\n \n             return_str += arg_type_symbol_dict_str"}]