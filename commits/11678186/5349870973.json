[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "file_content_changes": "@@ -1,8 +1,10 @@\n #include \"ConvertLayoutOpToLLVM.h\"\n #include \"Utility.h\"\n \n+using ::mlir::LLVM::delinearize;\n using ::mlir::LLVM::getSharedMemoryObjectFromStruct;\n using ::mlir::LLVM::getStridesFromShapeAndOrder;\n+using ::mlir::LLVM::linearize;\n using ::mlir::triton::gpu::DotOperandEncodingAttr;\n using ::mlir::triton::gpu::getContigPerThread;\n using ::mlir::triton::gpu::getOrder;\n@@ -143,9 +145,10 @@ struct ConvertLayoutOpConversion\n       Value laneId = urem(threadId, warpSize);\n       Value warpId = udiv(threadId, warpSize);\n       // TODO: fix the bug in MMAEncodingAttr document\n-      SmallVector<Value> multiDimWarpId(2);\n-      multiDimWarpId[0] = udiv(warpId, i32_val(mmaLayout.getWarpsPerCTA()[1]));\n-      multiDimWarpId[1] = urem(warpId, i32_val(mmaLayout.getWarpsPerCTA()[1]));\n+      auto warpsPerCTA = mmaLayout.getWarpsPerCTA();\n+      auto order = triton::gpu::getOrder(mmaLayout);\n+      SmallVector<Value> multiDimWarpId =\n+          delinearize(rewriter, loc, warpId, warpsPerCTA, order);\n       Value _1 = i32_val(1);\n       Value _2 = i32_val(2);\n       Value _4 = i32_val(4);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM/SharedToDotOperandMMAv2.cpp", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "file_content_changes": "@@ -4,6 +4,7 @@\n using namespace mlir;\n \n using ValueTable = std::map<std::pair<unsigned, unsigned>, Value>;\n+using ::mlir::LLVM::delinearize;\n using ::mlir::LLVM::getSharedMemoryObjectFromStruct;\n using ::mlir::LLVM::getStridesFromShapeAndOrder;\n using ::mlir::triton::gpu::DotOperandEncodingAttr;\n@@ -552,13 +553,19 @@ Value loadArg(ConversionPatternRewriter &rewriter, Location loc, Value tensor,\n   int kWidth = encoding.getMMAv2kWidth();\n \n   auto warpsPerCTA = mmaLayout.getWarpsPerCTA();\n+  auto order = triton::gpu::getOrder(mmaLayout);\n   Value warp = udiv(thread, i32_val(32));\n   Value lane = urem(thread, i32_val(32));\n-  Value warpRowIndex =\n-      urem(udiv(warp, i32_val(warpsPerCTA[1])), i32_val(warpsPerCTA[0]));\n-  Value warpColIndex = urem(warp, i32_val(warpsPerCTA[1]));\n-  Value warpM = urem(warpRowIndex, i32_val(shape[0] / 16));\n-  Value warpN = urem(warpColIndex, i32_val(shape[1] / 8));\n+\n+  SmallVector<Value> multiDimWarpId =\n+      delinearize(rewriter, loc, warp, warpsPerCTA, order);\n+  if (order[0] == 1) {\n+    multiDimWarpId[0] = urem(multiDimWarpId[0], i32_val(warpsPerCTA[0]));\n+  } else {\n+    multiDimWarpId[1] = urem(multiDimWarpId[1], i32_val(warpsPerCTA[1]));\n+  }\n+  Value warpM = urem(multiDimWarpId[0], i32_val(shape[0] / 16));\n+  Value warpN = urem(multiDimWarpId[1], i32_val(shape[1] / 8));\n \n   int warpsPerTile;\n   if (isA)"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ReduceOpToLLVM.cpp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -1,8 +1,11 @@\n #include \"ReduceOpToLLVM.h\"\n+#include \"Utility.h\"\n \n using namespace mlir;\n using namespace mlir::triton;\n \n+using ::mlir::LLVM::delinearize;\n+using ::mlir::LLVM::linearize;\n using ::mlir::LLVM::shflSync;\n using ::mlir::LLVM::storeShared;\n using ::mlir::triton::gpu::getOrder;"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 16, "deletions": 68, "changes": 84, "file_content_changes": "@@ -15,6 +15,7 @@\n using namespace mlir;\n using namespace mlir::triton;\n \n+using ::mlir::LLVM::delinearize;\n using ::mlir::LLVM::SharedMemoryObject;\n using ::mlir::triton::gpu::BlockedEncodingAttr;\n using ::mlir::triton::gpu::DotOperandEncodingAttr;\n@@ -504,65 +505,6 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     return mask;\n   }\n \n-  // Convert an \\param index to a multi-dim coordinate given \\param shape and\n-  // \\param order.\n-  SmallVector<Value> delinearize(ConversionPatternRewriter &rewriter,\n-                                 Location loc, Value linear,\n-                                 ArrayRef<unsigned> shape,\n-                                 ArrayRef<unsigned> order) const {\n-    unsigned rank = shape.size();\n-    assert(rank == order.size());\n-    auto reordered = reorder(shape, order);\n-    auto reorderedMultiDim = delinearize(rewriter, loc, linear, reordered);\n-    SmallVector<Value> multiDim(rank);\n-    for (unsigned i = 0; i < rank; ++i) {\n-      multiDim[order[i]] = reorderedMultiDim[i];\n-    }\n-    return multiDim;\n-  }\n-\n-  SmallVector<Value> delinearize(ConversionPatternRewriter &rewriter,\n-                                 Location loc, Value linear,\n-                                 ArrayRef<unsigned> shape) const {\n-    unsigned rank = shape.size();\n-    assert(rank > 0);\n-    SmallVector<Value> multiDim(rank);\n-    if (rank == 1) {\n-      multiDim[0] = linear;\n-    } else {\n-      Value remained = linear;\n-      for (auto &&en : llvm::enumerate(shape.drop_back())) {\n-        Value dimSize = i32_val(en.value());\n-        multiDim[en.index()] = urem(remained, dimSize);\n-        remained = udiv(remained, dimSize);\n-      }\n-      multiDim[rank - 1] = remained;\n-    }\n-    return multiDim;\n-  }\n-\n-  Value linearize(ConversionPatternRewriter &rewriter, Location loc,\n-                  ArrayRef<Value> multiDim, ArrayRef<unsigned> shape,\n-                  ArrayRef<unsigned> order) const {\n-    return linearize(rewriter, loc, reorder<Value>(multiDim, order),\n-                     reorder<unsigned>(shape, order));\n-  }\n-\n-  Value linearize(ConversionPatternRewriter &rewriter, Location loc,\n-                  ArrayRef<Value> multiDim, ArrayRef<unsigned> shape) const {\n-    auto rank = multiDim.size();\n-    Value linear = i32_val(0);\n-    if (rank > 0) {\n-      linear = multiDim.back();\n-      for (auto [dim, dimShape] :\n-           llvm::reverse(llvm::zip(multiDim.drop_back(), shape.drop_back()))) {\n-        Value dimSize = i32_val(dimShape);\n-        linear = add(mul(linear, dimSize), dim);\n-      }\n-    }\n-    return linear;\n-  }\n-\n   Value dot(ConversionPatternRewriter &rewriter, Location loc,\n             ArrayRef<Value> offsets, ArrayRef<Value> strides) const {\n     assert(offsets.size() == strides.size());\n@@ -927,19 +869,25 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n                               const MmaEncodingAttr &mmaLayout,\n                               RankedTensorType type) const {\n     auto shape = type.getShape();\n-    auto _warpsPerCTA = mmaLayout.getWarpsPerCTA();\n-    assert(_warpsPerCTA.size() == 2);\n-    SmallVector<Value> warpsPerCTA = {i32_val(_warpsPerCTA[0]),\n-                                      i32_val(_warpsPerCTA[1])};\n+    auto warpsPerCTA = mmaLayout.getWarpsPerCTA();\n+    assert(warpsPerCTA.size() == 2);\n+    auto order = triton::gpu::getOrder(mmaLayout);\n     Value threadId = getThreadId(rewriter, loc);\n     Value warpSize = i32_val(32);\n     Value laneId = urem(threadId, warpSize);\n     Value warpId = udiv(threadId, warpSize);\n-    Value warpId0 = urem(urem(udiv(warpId, warpsPerCTA[1]), warpsPerCTA[0]),\n-                         i32_val(shape[0] / 16));\n-    Value warpId1 = urem(urem(warpId, warpsPerCTA[1]), i32_val(shape[1] / 8));\n-    Value offWarp0 = mul(warpId0, i32_val(16));\n-    Value offWarp1 = mul(warpId1, i32_val(8));\n+\n+    SmallVector<Value> multiDimWarpId =\n+        delinearize(rewriter, loc, warpId, warpsPerCTA, order);\n+    if (order[0] == 1) {\n+      multiDimWarpId[0] = urem(multiDimWarpId[0], i32_val(warpsPerCTA[0]));\n+    } else {\n+      multiDimWarpId[1] = urem(multiDimWarpId[1], i32_val(warpsPerCTA[1]));\n+    }\n+    multiDimWarpId[0] = urem(multiDimWarpId[0], i32_val(shape[0] / 16));\n+    multiDimWarpId[1] = urem(multiDimWarpId[1], i32_val(shape[1] / 8));\n+    Value offWarp0 = mul(multiDimWarpId[0], i32_val(16));\n+    Value offWarp1 = mul(multiDimWarpId[1], i32_val(8));\n \n     SmallVector<Value> multiDimBase(2);\n     multiDimBase[0] = add(udiv(laneId, i32_val(4)), offWarp0);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.cpp", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "file_content_changes": "@@ -70,6 +70,65 @@ getStridesFromShapeAndOrder(ArrayRef<int64_t> shape, ArrayRef<unsigned> order,\n   return strides;\n }\n \n+// Convert an \\param index to a multi-dim coordinate given \\param shape and\n+// \\param order.\n+SmallVector<Value> delinearize(ConversionPatternRewriter &rewriter,\n+                               Location loc, Value linear,\n+                               ArrayRef<unsigned> shape,\n+                               ArrayRef<unsigned> order) {\n+  unsigned rank = shape.size();\n+  assert(rank == order.size());\n+  auto reordered = reorder(shape, order);\n+  auto reorderedMultiDim = delinearize(rewriter, loc, linear, reordered);\n+  SmallVector<Value> multiDim(rank);\n+  for (unsigned i = 0; i < rank; ++i) {\n+    multiDim[order[i]] = reorderedMultiDim[i];\n+  }\n+  return multiDim;\n+}\n+\n+SmallVector<Value> delinearize(ConversionPatternRewriter &rewriter,\n+                               Location loc, Value linear,\n+                               ArrayRef<unsigned> shape) {\n+  unsigned rank = shape.size();\n+  assert(rank > 0);\n+  SmallVector<Value> multiDim(rank);\n+  if (rank == 1) {\n+    multiDim[0] = linear;\n+  } else {\n+    Value remained = linear;\n+    for (auto &&en : llvm::enumerate(shape.drop_back())) {\n+      Value dimSize = i32_val(en.value());\n+      multiDim[en.index()] = urem(remained, dimSize);\n+      remained = udiv(remained, dimSize);\n+    }\n+    multiDim[rank - 1] = remained;\n+  }\n+  return multiDim;\n+}\n+\n+Value linearize(ConversionPatternRewriter &rewriter, Location loc,\n+                ArrayRef<Value> multiDim, ArrayRef<unsigned> shape,\n+                ArrayRef<unsigned> order) {\n+  return linearize(rewriter, loc, reorder<Value>(multiDim, order),\n+                   reorder<unsigned>(shape, order));\n+}\n+\n+Value linearize(ConversionPatternRewriter &rewriter, Location loc,\n+                ArrayRef<Value> multiDim, ArrayRef<unsigned> shape) {\n+  auto rank = multiDim.size();\n+  Value linear = i32_val(0);\n+  if (rank > 0) {\n+    linear = multiDim.back();\n+    for (auto [dim, dimShape] :\n+         llvm::reverse(llvm::zip(multiDim.drop_back(), shape.drop_back()))) {\n+      Value dimSize = i32_val(dimShape);\n+      linear = add(mul(linear, dimSize), dim);\n+    }\n+  }\n+  return linear;\n+}\n+\n Value storeShared(ConversionPatternRewriter &rewriter, Location loc, Value ptr,\n                   Value val, Value pred) {\n   MLIRContext *ctx = rewriter.getContext();"}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "file_content_changes": "@@ -258,6 +258,24 @@ SharedMemoryObject\n getSharedMemoryObjectFromStruct(Location loc, Value llvmStruct,\n                                 ConversionPatternRewriter &rewriter);\n \n+// Convert an \\param index to a multi-dim coordinate given \\param shape and\n+// \\param order.\n+SmallVector<Value> delinearize(ConversionPatternRewriter &rewriter,\n+                               Location loc, Value linear,\n+                               ArrayRef<unsigned> shape,\n+                               ArrayRef<unsigned> order);\n+\n+SmallVector<Value> delinearize(ConversionPatternRewriter &rewriter,\n+                               Location loc, Value linear,\n+                               ArrayRef<unsigned> shape);\n+\n+Value linearize(ConversionPatternRewriter &rewriter, Location loc,\n+                ArrayRef<Value> multiDim, ArrayRef<unsigned> shape,\n+                ArrayRef<unsigned> order);\n+\n+Value linearize(ConversionPatternRewriter &rewriter, Location loc,\n+                ArrayRef<Value> multiDim, ArrayRef<unsigned> shape);\n+\n Value storeShared(ConversionPatternRewriter &rewriter, Location loc, Value ptr,\n                   Value val, Value pred);\n "}]