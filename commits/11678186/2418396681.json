[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -1106,6 +1106,7 @@ def kernel(X):\n # test if\n # -------------\n \n+\n def test_if():\n \n     @triton.jit\n@@ -1121,4 +1122,4 @@ def kernel(Cond, XTrue, XFalse, Ret):\n     x_true = torch.tensor([3.14], dtype=torch.float32, device='cuda')\n     x_false = torch.tensor([1.51], dtype=torch.float32, device='cuda')\n     ret = torch.empty(1, dtype=torch.float32, device='cuda')\n-    kernel[(1,)](cond, x_true, x_false, ret)\n\\ No newline at end of file\n+    kernel[(1,)](cond, x_true, x_false, ret)"}, {"filename": "python/tutorials/01-vector-add.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -34,7 +34,7 @@ def add_kernel(\n     # for instance, if you had a vector of length 256 and block_size of 64, the programs\n     # would each access the elements [0:64, 64:128, 128:192, 192:256].\n     # Note that offsets is a list of pointers\n-    for block_start in range(pid*BLOCK_SIZE, n_elements, tl.num_programs(0)*BLOCK_SIZE):\n+    for block_start in range(pid * BLOCK_SIZE, n_elements, tl.num_programs(0) * BLOCK_SIZE):\n         offsets = block_start + tl.arange(0, BLOCK_SIZE)\n         # Create a mask to guard memory operations against out-of-bounds accesses\n         mask = offsets < n_elements"}]