[{"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "file_content_changes": "@@ -19,7 +19,6 @@\n #include \"llvm/Linker/Linker.h\"\n #include \"llvm/Support/SourceMgr.h\"\n #include <filesystem>\n-#include <iostream>\n #include <dlfcn.h>\n \n namespace mlir {\n@@ -118,43 +117,47 @@ static std::map<std::string, std::string> getExternLibs(mlir::ModuleOp module) {\n   }\n \n   if (!funcs.empty()) {\n-    // When using the Math Dialect, it is possible that some ops (e.g., log) are\n-    // lowered to a function call. In this case, we need to link libdevice\n-    // using its default path:\n-    // [triton root dir]/python/triton/language/libdevice.10.bc\n-    // TODO(Keren): handle external linkage other than libdevice?\n     static const std::string libdevice = \"libdevice\";\n     namespace fs = std::filesystem;\n-    static const auto this_file_path = std::filesystem::path(__FILE__);\n-    static const auto compile_time_path = this_file_path\n-                                              .parent_path()\n-                                              .parent_path()\n-                                              .parent_path()\n-                                              .parent_path() /\n-                                          \"python\" / \"triton\" /\n-                                          \"third_party\" / \"cuda\" / \"lib\" /\n-                                          \"libdevice.10.bc\";\n-    if (fs::exists(compile_time_path)) {\n-        externLibs.try_emplace(libdevice, compile_time_path.string());\n+    // Search for libdevice relative to its library path if used from Python\n+    // Then native code is in `triton/_C/libtriton.so` and libdevice in\n+    // `triton/third_party/cuda/lib/libdevice.10.bc`\n+    static const auto this_library_path = [] {\n+        Dl_info fileinfo;\n+        if (dladdr(reinterpret_cast<void*>(&getExternLibs), &fileinfo) == 0) {\n+          return std::filesystem::path();\n+        }\n+        return std::filesystem::path(fileinfo.dli_fname);\n+    }();\n+    static const auto runtime_path = this_library_path\n+                                         .parent_path()\n+                                         .parent_path() /\n+                                     \"third_party\" / \"cuda\" / \"lib\" /\n+                                     \"libdevice.10.bc\";\n+    if (fs::exists(runtime_path)) {\n+        externLibs.try_emplace(libdevice, runtime_path.string());\n     } else {\n-      static const auto this_library_path = [] {\n-          Dl_info fileinfo;\n-          if (dladdr(reinterpret_cast<void*>(&getExternLibs), &fileinfo) == 0) {\n-            std::cerr << \"Can't get info about current symbol\" << dlerror() << std::endl;\n-            return std::filesystem::path();\n-          }\n-          return std::filesystem::path(fileinfo.dli_fname);\n-      }();\n-      static const auto runtime_path = this_library_path\n-                                           .parent_path()\n-                                           .parent_path() /\n-                                       \"third_party\" / \"cuda\" / \"lib\" /\n-                                       \"libdevice.10.bc\";\n-      if (fs::exists(runtime_path)) {\n-          externLibs.try_emplace(libdevice, runtime_path.string());\n-      } else {\n-          std::cerr << runtime_path.string() << \" does not exists\" << std::endl;\n+      // When using the Math Dialect, it is possible that some ops (e.g., log) are\n+      // lowered to a function call. In this case, we need to link libdevice\n+      // using its default path:\n+      // [triton root dir]/python/triton/language/libdevice.10.bc\n+      // TODO(Keren): handle external linkage other than libdevice?\n+      static const auto this_file_path = std::filesystem::path(__FILE__);\n+      static const auto compiletime_path = this_file_path\n+                                               .parent_path()\n+                                               .parent_path()\n+                                               .parent_path()\n+                                               .parent_path() /\n+                                           \"python\" / \"triton\" /\n+                                           \"third_party\" / \"cuda\" / \"lib\" /\n+                                           \"libdevice.10.bc\";\n+      if (!fs::exists(compiletime_path)) {\n+        std::string error_msg = \"Can't find libdevice at neither \" +\n+                                 runtime_path.string() + \" nor \" +\n+                                 compiletime_path.string();\n+        llvm::report_fatal_error(error_msg.c_str());\n       }\n+      externLibs.try_emplace(libdevice, compiletime_path.string());\n     }\n   }\n "}]