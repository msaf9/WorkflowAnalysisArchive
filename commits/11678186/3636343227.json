[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "file_content_changes": "@@ -3518,14 +3518,18 @@ DotOpConversion::convertMMA884(triton::DotOp op, DotOpAdaptor adaptor,\n   auto has = helper.extractLoadedOperand(loadedA, NK, rewriter);\n   auto hbs = helper.extractLoadedOperand(loadedB, NK, rewriter);\n \n-  // initialize accumulators\n+  // Initialize accumulators with external values, the acc holds the accumulator\n+  // value that is shared between the MMA instructions inside a DotOp, we can\n+  // call its layout the accumulator-internal layout.\n   SmallVector<Value> acc = getElementsFromStruct(loc, loadedC, rewriter);\n   size_t resSize = acc.size();\n-  SmallVector<Value> resVals(resSize);\n \n-  auto callMMA = [&](unsigned m, unsigned n, unsigned k) {\n-    auto ha = has.at({m, k});\n-    auto hb = hbs.at({n, k});\n+  // The resVals holds the final result of the DotOp.\n+  // NOTE The current layout of resVals is different from acc, we call it the\n+  // accumulator-external layout. and\n+  SmallVector<Value> resVals(acc.size());\n+\n+  auto getIdx = [&](int m, int n) {\n     std::vector<size_t> idx{{\n         (m * 2 + 0) + (n * 4 + 0) * numM, // row0\n         (m * 2 + 0) + (n * 4 + 1) * numM,\n@@ -3536,8 +3540,24 @@ DotOpConversion::convertMMA884(triton::DotOp op, DotOpAdaptor adaptor,\n         (m * 2 + 1) + (n * 4 + 2) * numM, // row3\n         (m * 2 + 1) + (n * 4 + 3) * numM,\n     }};\n+    return idx;\n+  };\n+\n+  { // convert the acc's value from accumuator-external layout to\n+    // accumulator-internal layout.\n+    SmallVector<Value> acc2(acc.size());\n+    auto idx = getIdx(0 /*m*/, 0 /*n*/);\n+    for (unsigned i = 0; i < 8; ++i)\n+      acc2[idx[i]] = acc[(0 * numN / 2 + 0) * 8 + i];\n+    acc = acc2;\n+  }\n+\n+  auto callMMA = [&](unsigned m, unsigned n, unsigned k) {\n+    auto ha = has.at({m, k});\n+    auto hb = hbs.at({n, k});\n \n     PTXBuilder builder;\n+    auto idx = getIdx(m, n);\n \n     auto *resOprs = builder.newListOperand(8, \"=f\");\n     auto *AOprs = builder.newListOperand({"}, {"filename": "python/tests/test_gemm.py", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "file_content_changes": "@@ -310,3 +310,17 @@ def matmul_kernel(\n ])\n def test_gemm_no_scf_for_mmav1(SHAPE, NUM_WARPS, TRANS_A, TRANS_B):\n     test_gemm_no_scf(SHAPE, NUM_WARPS, TRANS_A, TRANS_B)\n+\n+\n+@pytest.mark.parametrize('SIZE_M,SIZE_N,SIZE_K,NUM_WARPS,BLOCK_SIZE_M,BLOCK_SIZE_N,BLOCK_SIZE_K,TRANS_A,TRANS_B', [\n+    # Non-forloop\n+    [16, 16, 16, 1, 16, 16, 16, False, False],\n+    [16, 16, 32, 1, 16, 16, 32, False, False],\n+    [32, 16, 32, 1, 32, 16, 32, False, False],\n+    [32, 32, 32, 1, 32, 32, 32, False, False],\n+    [128, 32, 32, 1, 128, 32, 32, False, False],\n+\n+    [16, 16, 32, 1, 16, 16, 16, False, False],\n+])\n+def test_gemm_for_mmav1(SIZE_M, SIZE_N, SIZE_K, NUM_WARPS, BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K, TRANS_A, TRANS_B):\n+    test_gemm(SIZE_M, SIZE_N, SIZE_K, NUM_WARPS, BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K, TRANS_A, TRANS_B)"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -583,7 +583,7 @@ def visit_For(self, node):\n            isinstance(step, triton.language.constexpr):\n             sta_range = iterator(lb.value, ub.value, step.value)\n             static_unrolling = os.environ.get('TRITON_STATIC_LOOP_UNROLLING', False)\n-            if static_unrolling and len(range) <= 10:\n+            if static_unrolling and len(sta_range) <= 10:\n                 for i in sta_range:\n                     self.lscope[node.target.id] = triton.language.constexpr(i)\n                     self.visit_compound_statement(node.body)"}]