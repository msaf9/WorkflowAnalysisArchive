[{"filename": "lib/Conversion/TritonGPUToLLVM/DotHelpers.h", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "file_content_changes": "@@ -43,12 +43,52 @@ using ::mlir::triton::gpu::SharedEncodingAttr;\n struct DotOpMmaV1ConversionHelper {\n   MmaEncodingAttr mmaLayout;\n   ArrayRef<unsigned> wpt;\n+  static constexpr std::array<int, 3> fpw{{2, 2, 1}};\n \n   using ValueTable = std::map<std::pair<int, int>, std::pair<Value, Value>>;\n \n   explicit DotOpMmaV1ConversionHelper(MmaEncodingAttr mmaLayout)\n       : mmaLayout(mmaLayout), wpt(mmaLayout.getWarpsPerCTA()) {}\n \n+  // Help to share some variables across multiple functions for A.\n+  struct AParam {\n+    SmallVector<int> rep;\n+    SmallVector<int> spw;\n+\n+    // TODO[Superjomn]: Support the case when isAVec4=false later\n+    // Currently, we only support ld.v2, for the mma layout varies with\n+    // different ld vector width.\n+    // bool isAVec4 = !isARow && shapeTransed[orderTransed[0]] <= 16;\n+    const bool isAVec4{true};\n+\n+    explicit AParam(bool isARow) {\n+      int packSize0 = (isARow || isAVec4) ? 1 : 2;\n+\n+      int repM = 2 * packSize0;\n+      int repK = 1;\n+      int spwM = fpw[0] * 4 * repM;\n+      rep.assign({repM, 0, repK});\n+      spw.assign({spwM, 0, 1});\n+    }\n+  };\n+\n+  // Help to share some variables across multiple functions for A.\n+  struct BParam {\n+    SmallVector<int> rep;\n+    SmallVector<int> spw;\n+    // TODO[Superjomn]: Support the case when isBVec4=false later\n+    // Currently, we only support ld.v2, for the mma layout varies with\n+    // different ld vector width.\n+    // bool isBVec4 = isBRow && shapeTransed[orderTransed[0]] <= 16;\n+    const bool isBVec4{true};\n+\n+    explicit BParam(bool isBRow) {\n+      int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n+      rep.assign({0, 2 * packSize1, 1});\n+      spw.assign({0, fpw[1] * 4 * rep[1], 1});\n+    }\n+  };\n+\n   int getRepM(int M) const {\n     return std::max<int>(M / (wpt[0] * instrShape[0]), 1);\n   }\n@@ -71,23 +111,9 @@ struct DotOpMmaV1ConversionHelper {\n   unsigned getNumM(ArrayRef<int64_t> shapeTransed,\n                    ArrayRef<unsigned> orderTransed) const {\n     bool isARow = orderTransed[0] != 0;\n-    bool isAVec4 =\n-        !isARow && shapeTransed[orderTransed[0]] <= 16; // fp16*4 = 16bytes\n-    // TODO[Superjomn]: Support the case when isAVec4=false later\n-    // Currently, we only support ld.v2, for the mma layout varies with\n-    // different ld vector width.\n-    isAVec4 = true;\n+    AParam param(isARow);\n \n-    int packSize0 = (isARow || isAVec4) ? 1 : 2;\n-\n-    SmallVector<int> fpw({2, 2, 1});\n-    int repM = 2 * packSize0;\n-    int repK = 1;\n-    int spwM = fpw[0] * 4 * repM;\n-    SmallVector<int> rep({repM, 0, repK}); // pad N with 0\n-    SmallVector<int> spw({spwM, 0, 1});    // pad N with 0\n-\n-    unsigned numM = rep[0] * shapeTransed[0] / (spw[0] * wpt[0]);\n+    unsigned numM = param.rep[0] * shapeTransed[0] / (param.spw[0] * wpt[0]);\n     return numM;\n   }\n \n@@ -97,18 +123,9 @@ struct DotOpMmaV1ConversionHelper {\n   unsigned getNumN(ArrayRef<int64_t> shapeTransed,\n                    ArrayRef<unsigned> orderTransed) const {\n     bool isBRow = orderTransed[0] != 0;\n-    bool isBVec4 = isBRow && shapeTransed[orderTransed[0]] <= 16;\n-    // TODO[Superjomn]: Support the case when isBVec4=false later\n-    // Currently, we only support ld.v2, for the mma layout varies with\n-    // different ld vector width.\n-    isBVec4 = true;\n+    BParam param(isBRow);\n \n-    int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n-    SmallVector<int> fpw({2, 2, 1});\n-    SmallVector<int> rep({0, 2 * packSize1, 1});       // pad M with 0\n-    SmallVector<int> spw({0, fpw[1] * 4 * rep[1], 1}); // pad M with 0\n-\n-    unsigned numN = rep[1] * shapeTransed[1] / (spw[1] * wpt[1]);\n+    unsigned numN = param.rep[1] * shapeTransed[1] / (param.spw[1] * wpt[1]);\n     return numN;\n   }\n \n@@ -1350,22 +1367,11 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   Value smemBase = smemObj.getBaseBeforeSwizzle(order[0], loc, rewriter);\n \n   bool isARow = order[0] != 0;\n-  bool isAVec4 = !isARow && shape[order[0]] <= 16; // fp16*4 = 16bytes\n-  // TODO[Superjomn]: Support the case when isAVec4=false later\n-  // Currently, we only support ld.v2, for the mma layout varies with different\n-  // ld vector width.\n-  isAVec4 = true;\n-  int packSize0 = (isARow || isAVec4) ? 1 : 2;\n-\n-  SmallVector<int> fpw({2, 2, 1});\n-  int repM = 2 * packSize0;\n-  int repK = 1;\n-  int spwM = fpw[0] * 4 * repM;\n-  SmallVector<int> rep({repM, 0, repK}); // pad N with 0\n-  SmallVector<int> spw({spwM, 0, 1});    // pad N with 0\n-\n-  auto [offsetAM, offsetAK, _0, _1] =\n-      computeOffsets(thread, isARow, false, fpw, spw, rep, rewriter, loc);\n+  AParam param(isARow);\n+\n+  auto [offsetAM, offsetAK, _0, _1] = computeOffsets(\n+      thread, isARow, false, fpw, param.spw, param.rep, rewriter, loc);\n+\n   // TODO [Superjomn]: transA cannot be accessed in ConvertLayoutOp.\n   bool transA = false;\n   if (transA) {\n@@ -1480,17 +1486,9 @@ Value DotOpMmaV1ConversionHelper::loadB(\n \n   Value smem = smemObj.getBaseBeforeSwizzle(order[0], loc, rewriter);\n   bool isBRow = order[0] != 0;\n-  bool isBVec4 = isBRow && shape[order[0]] <= 16;\n-  // TODO[Superjomn]: Support the case when isBVec4=false later\n-  // Currently, we only support ld.v2, for the mma layout varies with different\n-  // ld vector width.\n-  isBVec4 = true;\n-  int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n-  SmallVector<int> fpw({2, 2, 1});\n-  SmallVector<int> rep({0, 2 * packSize1, 1});       // pad M with 0\n-  SmallVector<int> spw({0, fpw[1] * 4 * rep[1], 1}); // pad M with 0\n-  int vecB = sharedLayout.getVec();\n+  BParam param(isBRow);\n \n+  int vecB = sharedLayout.getVec();\n   Value strideBN = isBRow ? i32_val(1) : strides[1];\n   Value strideBK = isBRow ? strides[0] : i32_val(1);\n   Value strideB0 = isBRow ? strideBN : strideBK;\n@@ -1501,8 +1499,8 @@ Value DotOpMmaV1ConversionHelper::loadB(\n   // TODO [Superjomn]: transB cannot be accessed in ConvertLayoutOp.\n   bool transB = false;\n \n-  auto [_0, _1, offsetBN, offsetBK] =\n-      computeOffsets(thread, false, isBRow, fpw, spw, rep, rewriter, loc);\n+  auto [_0, _1, offsetBN, offsetBK] = computeOffsets(\n+      thread, false, isBRow, fpw, param.spw, param.rep, rewriter, loc);\n   if (transB) {\n     std::swap(order[0], order[1]);\n     std::swap(shape[0], shape[1]);"}]