[{"filename": "bin/triton-opt.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -32,7 +32,7 @@ int main(int argc, char **argv) {\n \n   // TODO: register Triton & TritonGPU passes\n   mlir::DialectRegistry registry;\n-  registry.insert<mlir::triton::TritonDialect,\n+  registry.insert<mlir::triton::TritonDialect, mlir::cf::ControlFlowDialect,\n                   mlir::triton::gpu::TritonGPUDialect, mlir::func::FuncDialect,\n                   mlir::math::MathDialect, mlir::arith::ArithDialect,\n                   mlir::scf::SCFDialect, mlir::gpu::GPUDialect>();"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "file_content_changes": "@@ -115,15 +115,14 @@ class ConvertTritonGPUToLLVM\n     // Step 1: Decompose unoptimized layout conversions to use shared memory\n     // Step 2: Decompose insert_slice_async to use load + insert_slice for\n     //   pre-Ampere architectures or unsupported vectorized load sizes\n-    // Step 3: Convert SCF to CFG\n-    // Step 4: Allocate shared memories and insert barriers\n-    // Step 5: Convert FuncOp to LLVMFuncOp via partial conversion\n-    // Step 6: Get axis and shared memory info\n-    // Step 7: Convert the rest of ops via partial conversion\n+    // Step 3: Allocate shared memories and insert barriers\n+    // Step 4: Convert FuncOp to LLVMFuncOp via partial conversion\n+    // Step 5: Get axis and shared memory info\n+    // Step 6: Convert the rest of ops via partial conversion\n     //\n-    // The reason for a separation between 5/7 is that, step 6 is out of the\n+    // The reason for a separation between 4/6 is that, step 5 is out of the\n     // scope of Dialect Conversion, thus we need to make sure the smem is not\n-    // revised during the conversion of step 7.\n+    // revised during the conversion of step 6.\n \n     // Step 1\n     decomposeMmaToDotOperand(mod, numWarps);\n@@ -134,28 +133,18 @@ class ConvertTritonGPUToLLVM\n       return signalPassFailure();\n \n     // Step 3\n-    RewritePatternSet scfPatterns(context);\n-    mlir::populateSCFToControlFlowConversionPatterns(scfPatterns);\n-    mlir::ConversionTarget scfTarget(*context);\n-    scfTarget.addIllegalOp<scf::ForOp, scf::IfOp, scf::ParallelOp, scf::WhileOp,\n-                           scf::ExecuteRegionOp>();\n-    scfTarget.markUnknownOpDynamicallyLegal([](Operation *) { return true; });\n-    if (failed(applyPartialConversion(mod, scfTarget, std::move(scfPatterns))))\n-      return signalPassFailure();\n-\n-    // Step 4\n     Allocation allocation(mod);\n     MembarAnalysis membarPass(&allocation);\n     membarPass.run();\n \n-    // Step 5\n+    // Step 4\n     RewritePatternSet funcPatterns(context);\n     funcPatterns.add<FuncOpConversion>(typeConverter, numWarps, /*benefit=*/1);\n     if (failed(\n             applyPartialConversion(mod, funcTarget, std::move(funcPatterns))))\n       return signalPassFailure();\n \n-    // Step 6 - get axis and shared memory info\n+    // Step 5 - get axis and shared memory info\n     std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n     AxisInfoAnalysis *axisInfoAnalysis = solver->load<AxisInfoAnalysis>();\n     if (failed(solver->initializeAndRun(mod)))\n@@ -165,7 +154,7 @@ class ConvertTritonGPUToLLVM\n                  mlir::IntegerAttr::get(mlir::IntegerType::get(context, 32),\n                                         allocation.getSharedMemorySize()));\n \n-    // Step 7 - rewrite rest of ops\n+    // Step 6 - rewrite rest of ops\n     // We set a higher benefit here to ensure triton's patterns runs before\n     // arith patterns for some encoding not supported by the community\n     // patterns."}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -294,6 +294,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n       /*printAfterOnlyOnChange=*/true,\n       /*printAfterOnlyOnFailure*/ false, llvm::dbgs(), printingFlags);\n \n+  pm.addPass(mlir::createConvertSCFToCFPass());\n   pm.addPass(createConvertTritonGPUToLLVMPass(computeCapability));\n   // Canonicalize to eliminate the remaining UnrealizedConversionCastOp\n   pm.addPass(mlir::createCanonicalizerPass());"}, {"filename": "test/Analysis/test-membar.mlir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,4 +1,4 @@\n-// RUN: triton-opt %s -split-input-file --mlir-disable-threading -test-print-membar 2>&1 | FileCheck %s\n+// RUN: triton-opt %s -split-input-file --mlir-disable-threading --convert-scf-to-cf -test-print-membar 2>&1 | FileCheck %s\n \n #AL = #triton_gpu.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>\n #sliceAd0 = #triton_gpu.slice<{dim = 0, parent = #AL}>"}, {"filename": "test/lib/Analysis/TestMembar.cpp", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "file_content_changes": "@@ -27,18 +27,6 @@ struct TestMembarPass\n     auto opName = SymbolTable::getSymbolName(operation).getValue().str();\n     os << opName << \"\\n\";\n \n-    // Lower the module to the cf dialect\n-    auto *context = operation->getContext();\n-    RewritePatternSet scfPatterns(context);\n-    mlir::populateSCFToControlFlowConversionPatterns(scfPatterns);\n-    mlir::ConversionTarget scfTarget(*context);\n-    scfTarget.addIllegalOp<scf::ForOp, scf::IfOp, scf::ParallelOp, scf::WhileOp,\n-                           scf::ExecuteRegionOp>();\n-    scfTarget.markUnknownOpDynamicallyLegal([](Operation *) { return true; });\n-    if (failed(applyPartialConversion(operation, scfTarget,\n-                                      std::move(scfPatterns))))\n-      return signalPassFailure();\n-\n     // Print all ops after membar pass\n     Allocation allocation(operation);\n     MembarAnalysis membarPass(&allocation);"}]