[{"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "file_content_changes": "@@ -51,9 +51,8 @@ class DecomposeDotOperand : public mlir::RewritePattern {\n         dstType.getEncoding().isa<triton::gpu::DotOperandEncodingAttr>()) {\n       auto tmpType =\n           RankedTensorType::get(dstType.getShape(), dstType.getElementType(),\n-                                dstType.getEncoding()\n-                                    .cast<triton::gpu::DotOperandEncodingAttr>()\n-                                    .getParent());\n+                                triton::gpu::SharedEncodingAttr::get(\n+                                    op->getContext(), 1, 1, 1, {1, 0}));\n       auto tmp = rewriter.create<triton::gpu::ConvertLayoutOp>(\n           convert.getLoc(), tmpType, convert.getOperand());\n       auto newConvert = rewriter.create<triton::gpu::ConvertLayoutOp>(\n@@ -129,6 +128,9 @@ class SimplifyConversion : public mlir::RewritePattern {\n     }\n     // cvt(type2, x)\n     if (llvm::isa<triton::gpu::ConvertLayoutOp>(arg)) {\n+      if (srcType.getEncoding().isa<triton::gpu::SharedEncodingAttr>() &&\n+          !dstType.getEncoding().isa<triton::gpu::SharedEncodingAttr>())\n+        return mlir::failure();\n       rewriter.replaceOpWithNewOp<triton::gpu::ConvertLayoutOp>(\n           op, op->getResultTypes().front(), arg->getOperand(0));\n       return mlir::success();\n@@ -574,7 +576,7 @@ class TritonGPUCombineOpsPass\n     mlir::RewritePatternSet patterns(context);\n \n     patterns.add<SimplifyConversion>(context);\n-    // patterns.add<DecomposeDotOperand>(context);\n+    patterns.add<DecomposeDotOperand>(context);\n     patterns.add<RematerializeBackward>(context);\n     patterns.add<RematerializeForward>(context);\n     patterns.add<MoveConvertOutOfLoop>(context);"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Swizzle.cpp", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "file_content_changes": "@@ -68,35 +68,34 @@ struct SwizzlePass : public TritonGPUSwizzleBase<SwizzlePass> {\n   void runOnOperation() override {\n     Operation *op = getOperation();\n     MLIRContext *context = &getContext();\n-    op->walk([&](triton::DotOp dotOp) -> void {\n-      OpBuilder builder(dotOp);\n-      auto _retEncoding =\n-          dotOp.getResult().getType().cast<RankedTensorType>().getEncoding();\n-      auto retEncoding = _retEncoding.dyn_cast<triton::gpu::MmaEncodingAttr>();\n-      if (!retEncoding)\n+    op->walk([&](triton::gpu::ConvertLayoutOp cvtOp) -> void {\n+      OpBuilder builder(cvtOp);\n+      auto arg = cvtOp.getOperand();\n+      auto argType = arg.getType().cast<RankedTensorType>();\n+      auto retType = cvtOp.getResult().getType().cast<RankedTensorType>();\n+      auto argEncoding =\n+          argType.getEncoding().dyn_cast<triton::gpu::SharedEncodingAttr>();\n+      auto retEncoding =\n+          retType.getEncoding().dyn_cast<triton::gpu::DotOperandEncodingAttr>();\n+      if (!argEncoding || !retEncoding)\n         return;\n-      for (int opIdx : {0, 1}) {\n-        Value op = dotOp.getOperand(opIdx);\n-        // if the dot operand is of dot_op layout which is converted from\n-        // shared layout\n-        if (auto cvt = op.getDefiningOp<triton::gpu::ConvertLayoutOp>()) {\n-          auto ty = cvt.src().getType().template cast<RankedTensorType>();\n-          // compute new swizzled encoding\n-          SwizzleInfo swizzle = getSwizzleMMA(opIdx, retEncoding, ty);\n-          auto newEncoding = triton::gpu::SharedEncodingAttr::get(\n-              &getContext(), swizzle.vec, swizzle.perPhase, swizzle.maxPhase,\n-              ty.getEncoding()\n-                  .cast<triton::gpu::SharedEncodingAttr>()\n-                  .getOrder());\n-          // create conversion\n-          auto newType = RankedTensorType::get(\n-              ty.getShape(), ty.getElementType(), newEncoding);\n-          Operation *newOp = builder.create<triton::gpu::ConvertLayoutOp>(\n-              op.getLoc(), newType, op);\n-          // bind new op to cvt operand\n-          cvt->replaceUsesOfWith(op, newOp->getResult(0));\n-        }\n-      }\n+      auto opIdx = retEncoding.getOpIdx();\n+      // compute new swizzled encoding\n+      auto parentEncoding =\n+          retEncoding.getParent().dyn_cast<triton::gpu::MmaEncodingAttr>();\n+      if (!parentEncoding)\n+        return;\n+      SwizzleInfo swizzle = getSwizzleMMA(opIdx, parentEncoding, argType);\n+      auto newEncoding = triton::gpu::SharedEncodingAttr::get(\n+          &getContext(), swizzle.vec, swizzle.perPhase, swizzle.maxPhase,\n+          argEncoding.getOrder());\n+      // create conversion\n+      auto newType = RankedTensorType::get(\n+          argType.getShape(), argType.getElementType(), newEncoding);\n+      Operation *newArg = builder.create<triton::gpu::ConvertLayoutOp>(\n+          cvtOp.getLoc(), newType, arg);\n+      // bind new op to cvt operand\n+      cvtOp->replaceUsesOfWith(arg, newArg->getResult(0));\n     });\n   }\n };"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -145,6 +145,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n     llvm::errs() << \"Pass execution failed\";\n     return nullptr;\n   }\n+  // llvm::outs() << module << \"\\n\";\n \n   auto llvmir = translateLLVMToLLVMIR(llvmContext, module);\n   if (!llvmir) {"}]