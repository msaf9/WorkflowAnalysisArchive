[{"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "file_content_changes": "@@ -538,17 +538,17 @@ struct DotOpMmaV2ConversionHelper {\n \n   // The type of matrix that loaded by either a ldmatrix or composed lds.\n   Type getMatType() const {\n-    Type fp32Ty = type::f32Ty(ctx);\n+    // floating point types\n+    Type fp32x1Ty = vec_ty(type::f32Ty(ctx), 1);\n     Type fp16x2Ty = vec_ty(type::f16Ty(ctx), 2);\n     Type i16x2Ty = vec_ty(type::i16Ty(ctx), 2);\n-    // floating point types\n     Type fp16x2Pack4Ty =\n         LLVM::LLVMStructType::getLiteral(ctx, SmallVector<Type>(4, fp16x2Ty));\n     // LLVM 14.0 does not support bf16 type, so we use i16 instead.\n     Type bf16x2Pack4Ty =\n         LLVM::LLVMStructType::getLiteral(ctx, SmallVector<Type>(4, i16x2Ty));\n     Type fp32Pack4Ty =\n-        LLVM::LLVMStructType::getLiteral(ctx, SmallVector<Type>(4, fp32Ty));\n+        LLVM::LLVMStructType::getLiteral(ctx, SmallVector<Type>(4, fp32x1Ty));\n     // integer types\n     Type i8x4Ty = vec_ty(type::i8Ty(ctx), 4);\n     Type i8x4Pack4Ty =\n@@ -960,7 +960,7 @@ class MMA16816SmemLoader {\n   // Load 4 matrices and returns 4 vec<2> elements.\n   std::tuple<Value, Value, Value, Value>\n   loadX4(int mat0, int mat1, ArrayRef<Value> offs, ArrayRef<Value> ptrs,\n-         Type ldmatrixRetTy, Type shemPtrTy) const {\n+         Type matTy, Type shemPtrTy) const {\n     assert(mat0 % 2 == 0 && mat1 % 2 == 0 &&\n            \"smem matrix load must be aligned\");\n     int matIdx[2] = {mat0, mat1};\n@@ -983,6 +983,9 @@ class MMA16816SmemLoader {\n \n     Value ptr = getPtr(ptrIdx);\n \n+    // The struct should have exactly the same element types.\n+    Type elemTy = matTy.cast<LLVM::LLVMStructType>().getBody()[0];\n+\n     if (canUseLdmatrix) {\n       Value sOffset =\n           mul(i32_val(matIdx[order[1]] * sMatStride * sMatShape), sStride);\n@@ -1000,20 +1003,12 @@ class MMA16816SmemLoader {\n       ldmatrix(resArgs, addrArg);\n \n       // The result type is 4xi32, each i32 is composed of 2xf16\n-      // elements(adjacent two columns in a row)\n-      Value resV4 = builder.launch(rewriter, loc, ldmatrixRetTy);\n-\n-      auto getIntAttr = [&](int v) {\n-        return ArrayAttr::get(ctx, {IntegerAttr::get(i32_ty, v)});\n-      };\n-\n-      // The struct should have exactly the same element types.\n-      Type elemType = resV4.getType().cast<LLVM::LLVMStructType>().getBody()[0];\n-\n-      return {extract_val(elemType, resV4, getIntAttr(0)),\n-              extract_val(elemType, resV4, getIntAttr(1)),\n-              extract_val(elemType, resV4, getIntAttr(2)),\n-              extract_val(elemType, resV4, getIntAttr(3))};\n+      // elements (adjacent two columns in a row) or a single f32 element.\n+      Value resV4 = builder.launch(rewriter, loc, matTy);\n+      return {extract_val(elemTy, resV4, i32_arr_attr(0)),\n+              extract_val(elemTy, resV4, i32_arr_attr(1)),\n+              extract_val(elemTy, resV4, i32_arr_attr(2)),\n+              extract_val(elemTy, resV4, i32_arr_attr(3))};\n     } else if (elemBytes == 4 &&\n                needTrans) { // Use lds.32 to load tf32 matrices\n       Value ptr2 = getPtr(ptrIdx + 1);\n@@ -1025,21 +1020,23 @@ class MMA16816SmemLoader {\n           add(sOffsetElemVal, mul(i32_val(sOffsetArrElem), sStride));\n \n       Value elems[4];\n-      Type elemTy = type::f32Ty(ctx);\n-      Type elemPtrTy = ptr_ty(elemTy);\n       if (kOrder == 1) {\n-        elems[0] = load(gep(elemPtrTy, ptr, sOffsetElemVal));\n-        elems[1] = load(gep(elemPtrTy, ptr2, sOffsetElemVal));\n-        elems[2] = load(gep(elemPtrTy, ptr, sOffsetArrElemVal));\n-        elems[3] = load(gep(elemPtrTy, ptr2, sOffsetArrElemVal));\n+        elems[0] = load(gep(shemPtrTy, ptr, sOffsetElemVal));\n+        elems[1] = load(gep(shemPtrTy, ptr2, sOffsetElemVal));\n+        elems[2] = load(gep(shemPtrTy, ptr, sOffsetArrElemVal));\n+        elems[3] = load(gep(shemPtrTy, ptr2, sOffsetArrElemVal));\n       } else {\n-        elems[0] = load(gep(elemPtrTy, ptr, sOffsetElemVal));\n-        elems[2] = load(gep(elemPtrTy, ptr2, sOffsetElemVal));\n-        elems[1] = load(gep(elemPtrTy, ptr, sOffsetArrElemVal));\n-        elems[3] = load(gep(elemPtrTy, ptr2, sOffsetArrElemVal));\n+        elems[0] = load(gep(shemPtrTy, ptr, sOffsetElemVal));\n+        elems[2] = load(gep(shemPtrTy, ptr2, sOffsetElemVal));\n+        elems[1] = load(gep(shemPtrTy, ptr, sOffsetArrElemVal));\n+        elems[3] = load(gep(shemPtrTy, ptr2, sOffsetArrElemVal));\n       }\n-      return {elems[0], elems[1], elems[2], elems[3]};\n-\n+      std::array<Value, 4> retElems;\n+      retElems.fill(undef(elemTy));\n+      for (auto i = 0; i < 4; ++i) {\n+        retElems[i] = insert_element(elemTy, retElems[i], elems[i], i32_val(0));\n+      }\n+      return {retElems[0], retElems[1], retElems[2], retElems[3]};\n     } else if (elemBytes == 1 && needTrans) { // work with int8\n       std::array<std::array<Value, 4>, 2> ptrs;\n       ptrs[0] = {\n@@ -1064,49 +1061,42 @@ class MMA16816SmemLoader {\n           add(sOffsetElemVal, mul(i32_val(sOffsetArrElem), sStride));\n \n       std::array<Value, 4> i8v4Elems;\n-      std::array<Value, 4> i32Elems;\n-      i8v4Elems.fill(\n-          rewriter.create<LLVM::UndefOp>(loc, vec_ty(type::i8Ty(ctx), 4)));\n+      i8v4Elems.fill(undef(elemTy));\n \n       Value i8Elems[4][4];\n-      Type elemTy = type::i8Ty(ctx);\n-      Type elemPtrTy = ptr_ty(elemTy);\n-      Type i8x4Ty = vec_ty(type::i8Ty(ctx), 4);\n       if (kOrder == 1) {\n         for (int i = 0; i < 2; ++i)\n           for (int j = 0; j < 4; ++j)\n-            i8Elems[i][j] = load(gep(elemPtrTy, ptrs[i][j], sOffsetElemVal));\n+            i8Elems[i][j] = load(gep(shemPtrTy, ptrs[i][j], sOffsetElemVal));\n \n         for (int i = 2; i < 4; ++i)\n           for (int j = 0; j < 4; ++j)\n             i8Elems[i][j] =\n-                load(gep(elemPtrTy, ptrs[i - 2][j], sOffsetArrElemVal));\n+                load(gep(shemPtrTy, ptrs[i - 2][j], sOffsetArrElemVal));\n \n         for (int m = 0; m < 4; ++m) {\n           for (int e = 0; e < 4; ++e)\n             i8v4Elems[m] = insert_element(i8v4Elems[m].getType(), i8v4Elems[m],\n                                           i8Elems[m][e], i32_val(e));\n-          i32Elems[m] = bitcast(i8v4Elems[m], i8x4Ty);\n         }\n       } else { // k first\n         for (int j = 0; j < 4; ++j)\n-          i8Elems[0][j] = load(gep(elemPtrTy, ptrs[0][j], sOffsetElemVal));\n+          i8Elems[0][j] = load(gep(shemPtrTy, ptrs[0][j], sOffsetElemVal));\n         for (int j = 0; j < 4; ++j)\n-          i8Elems[2][j] = load(gep(elemPtrTy, ptrs[1][j], sOffsetElemVal));\n+          i8Elems[2][j] = load(gep(shemPtrTy, ptrs[1][j], sOffsetElemVal));\n         for (int j = 0; j < 4; ++j)\n-          i8Elems[1][j] = load(gep(elemPtrTy, ptrs[0][j], sOffsetArrElemVal));\n+          i8Elems[1][j] = load(gep(shemPtrTy, ptrs[0][j], sOffsetArrElemVal));\n         for (int j = 0; j < 4; ++j)\n-          i8Elems[3][j] = load(gep(elemPtrTy, ptrs[1][j], sOffsetArrElemVal));\n+          i8Elems[3][j] = load(gep(shemPtrTy, ptrs[1][j], sOffsetArrElemVal));\n \n         for (int m = 0; m < 4; ++m) {\n           for (int e = 0; e < 4; ++e)\n             i8v4Elems[m] = insert_element(i8v4Elems[m].getType(), i8v4Elems[m],\n                                           i8Elems[m][e], i32_val(e));\n-          i32Elems[m] = bitcast(i8v4Elems[m], i8x4Ty);\n         }\n       }\n \n-      return {i32Elems[0], i32Elems[1], i32Elems[2], i32Elems[3]};\n+      return {i8v4Elems[0], i8v4Elems[1], i8v4Elems[2], i8v4Elems[3]};\n     }\n \n     assert(false && \"Invalid smem load\");\n@@ -1413,14 +1403,10 @@ struct MMA16816ConversionHelper {\n       mma(retArgs, aArgs, bArgs, cArgs);\n       Value mmaOut = builder.launch(rewriter, loc, helper.getMmaRetType());\n \n-      auto getIntAttr = [&](int v) {\n-        return ArrayAttr::get(ctx, {IntegerAttr::get(i32_ty, v)});\n-      };\n-\n       Type elemTy = mmaOut.getType().cast<LLVM::LLVMStructType>().getBody()[0];\n       for (int i = 0; i < 4; ++i)\n         fc[m * colsPerThread + 4 * n + i] =\n-            extract_val(elemTy, mmaOut, getIntAttr(i));\n+            extract_val(elemTy, mmaOut, i32_arr_attr(i));\n     };\n \n     for (int k = 0; k < numRepK; ++k)"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpToLLVM.cpp", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "file_content_changes": "@@ -201,12 +201,8 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n       Value res =\n           builder.launch(rewriter, loc, helper.getMmaRetType(ATensorTy));\n \n-      auto getIntAttr = [&](int v) {\n-        return ArrayAttr::get(ctx, {IntegerAttr::get(i32_ty, v)});\n-      };\n-\n-      for (unsigned i = 0; i < 8; i++) {\n-        Value elem = extract_val(f32_ty, res, getIntAttr(i));\n+      for (auto i = 0; i < 8; i++) {\n+        Value elem = extract_val(f32_ty, res, i32_arr_attr(i));\n         acc[idx[i]] = elem;\n         resVals[(m * numN / 2 + n) * 8 + i] = elem;\n       }"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.cpp", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "file_content_changes": "@@ -49,10 +49,8 @@ struct FpToFpOpConversion\n         struct_ty(SmallVector<Type>{fp16x2VecTy, fp16x2VecTy});\n     auto fp16x2x2Struct =\n         builder.launch(rewriter, loc, fp16x2x2StructTy, false);\n-    auto fp16x2Vec0 =\n-        extract_val(fp16x2VecTy, fp16x2x2Struct, rewriter.getI32ArrayAttr({0}));\n-    auto fp16x2Vec1 =\n-        extract_val(fp16x2VecTy, fp16x2x2Struct, rewriter.getI32ArrayAttr({1}));\n+    auto fp16x2Vec0 = extract_val(fp16x2VecTy, fp16x2x2Struct, i32_arr_attr(0));\n+    auto fp16x2Vec1 = extract_val(fp16x2VecTy, fp16x2x2Struct, i32_arr_attr(1));\n     return {extract_element(f16_ty, fp16x2Vec0, i32_val(0)),\n             extract_element(f16_ty, fp16x2Vec0, i32_val(1)),\n             extract_element(f16_ty, fp16x2Vec1, i32_val(0)),\n@@ -143,10 +141,8 @@ struct FpToFpOpConversion\n         struct_ty(SmallVector<Type>{bf16x2VecTy, bf16x2VecTy});\n     auto bf16x2x2Struct =\n         builder.launch(rewriter, loc, bf16x2x2StructTy, false);\n-    auto bf16x2Vec0 =\n-        extract_val(bf16x2VecTy, bf16x2x2Struct, rewriter.getI32ArrayAttr({0}));\n-    auto bf16x2Vec1 =\n-        extract_val(bf16x2VecTy, bf16x2x2Struct, rewriter.getI32ArrayAttr({1}));\n+    auto bf16x2Vec0 = extract_val(bf16x2VecTy, bf16x2x2Struct, i32_arr_attr(0));\n+    auto bf16x2Vec1 = extract_val(bf16x2VecTy, bf16x2x2Struct, i32_arr_attr(1));\n     return {extract_element(i16_ty, bf16x2Vec0, i32_val(0)),\n             extract_element(i16_ty, bf16x2Vec0, i32_val(1)),\n             extract_element(i16_ty, bf16x2Vec1, i32_val(0)),"}, {"filename": "lib/Conversion/TritonGPUToLLVM/LoadStoreOpToLLVM.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -214,7 +214,7 @@ struct LoadOpConversion\n         Value curr;\n         if (retTy.isa<LLVM::LLVMStructType>()) {\n           curr = extract_val(IntegerType::get(getContext(), width), ret,\n-                             rewriter.getI64ArrayAttr(ii));\n+                             i64_arr_attr(ii));\n         } else {\n           curr = ret;\n         }"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TypeConverter.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "file_content_changes": "@@ -90,7 +90,7 @@ class TritonGPUToLLVMTypeConverter : public LLVMTypeConverter {\n         Type elemTy = convertType(type.getElementType());\n         if (mmaLayout.isAmpere()) {\n           const llvm::DenseMap<int, Type> targetTyMap = {\n-              {32, elemTy},\n+              {32, vec_ty(elemTy, 1)},\n               {16, vec_ty(elemTy, 2)},\n               {8, vec_ty(elemTy, 4)},\n           };\n@@ -103,8 +103,7 @@ class TritonGPUToLLVMTypeConverter : public LLVMTypeConverter {\n           if (dotOpLayout.getOpIdx() == 0) { // $a\n             auto elems =\n                 MMA16816ConversionHelper::getANumElemsPerThread(type, wpt[0]);\n-            return LLVM::LLVMStructType::getLiteral(\n-                ctx, SmallVector<Type>(elems, targetTy));\n+            return struct_ty(SmallVector<Type>(elems, targetTy));\n           }\n           if (dotOpLayout.getOpIdx() == 1) { // $b\n             auto elems ="}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "file_content_changes": "@@ -95,6 +95,10 @@\n                             __VA_ARGS__)\n #define tid_val() getThreadId(rewriter, loc)\n \n+// Attributes\n+#define i32_arr_attr(...) rewriter.getI32ArrayAttr({__VA_ARGS__})\n+#define i64_arr_attr(...) rewriter.getI64ArrayAttr({__VA_ARGS__})\n+\n namespace mlir {\n namespace triton {\n \n@@ -191,7 +195,7 @@ getElementsFromStruct(Location loc, Value llvmStruct,\n   SmallVector<Value> results(types.size());\n   for (unsigned i = 0; i < types.size(); ++i) {\n     Type type = types[i];\n-    results[i] = extract_val(type, llvmStruct, rewriter.getI64ArrayAttr(i));\n+    results[i] = extract_val(type, llvmStruct, i64_arr_attr(i));\n   }\n   return results;\n }"}]