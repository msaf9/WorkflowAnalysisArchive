[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -629,8 +629,8 @@ def visit_For(self, node):\n         iter_args = [self.visit(arg) for arg in node.iter.args]\n         if IteratorClass == triton.language.static_range:\n             iterator = IteratorClass(*iter_args)\n-            static_range = range(iterator.start.value, \n-                                 iterator.end.value, \n+            static_range = range(iterator.start.value,\n+                                 iterator.end.value,\n                                  iterator.step.value)\n             for i in static_range:\n                 self.lscope[node.target.id] = triton.language.constexpr(i)"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "file_content_changes": "@@ -1312,27 +1312,28 @@ def printf(prefix, *args, _builder=None):\n # Iterators\n # -----------------------\n \n+\n class static_range:\n \n-  \"\"\"Iterator that counts upward forever.\"\"\"\n-\n-  def __init__(self, arg1, arg2=None, step=None):\n-      assert isinstance(arg1, constexpr)\n-      if step is None:\n-          self.step = constexpr(1)\n-      else:\n-          assert isinstance(step, constexpr)\n-          self.step = step\n-      if arg2 is None:\n-          self.start = constexpr(0)\n-          self.end = arg1\n-      else:\n-          assert isinstance(arg2, constexpr)\n-          self.start = arg1\n-          self.end = arg2\n-\n-  def __iter__(self):\n-      raise RuntimeError(\"static_range can only be used in @triton.jit'd functions\")\n-\n-  def __next__(self):\n-      raise RuntimeError(\"static_range can only be used in @triton.jit'd functions\")\n\\ No newline at end of file\n+    \"\"\"Iterator that counts upward forever.\"\"\"\n+\n+    def __init__(self, arg1, arg2=None, step=None):\n+        assert isinstance(arg1, constexpr)\n+        if step is None:\n+            self.step = constexpr(1)\n+        else:\n+            assert isinstance(step, constexpr)\n+            self.step = step\n+        if arg2 is None:\n+            self.start = constexpr(0)\n+            self.end = arg1\n+        else:\n+            assert isinstance(arg2, constexpr)\n+            self.start = arg1\n+            self.end = arg2\n+\n+    def __iter__(self):\n+        raise RuntimeError(\"static_range can only be used in @triton.jit'd functions\")\n+\n+    def __next__(self):\n+        raise RuntimeError(\"static_range can only be used in @triton.jit'd functions\")"}, {"filename": "python/triton/language/random.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -11,6 +11,7 @@\n # randint\n # -------------------\n \n+\n @triton.jit\n def philox_impl(c0, c1, c2, c3, k0, k1, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n     \"\"\""}]