[{"filename": "include/triton/Dialect/Triton/IR/TritonOps.td", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -257,7 +257,7 @@ def TT_AtomicCASOp : TT_Op<\"atomic_cas\", [MemoryEffects<[MemRead]>,\n     }];\n \n     let arguments = (ins TT_PtrLike:$ptr, TT_Type:$cmp, TT_Type:$val,\n-                     DefaultValuedAttr<TT_MemSemanticAttr, \"triton::MemSemantic::ACQUIRE_RELEASE\">:$sem);\n+                     TT_MemSemanticAttr:$sem);\n \n     let results = (outs TT_Type:$result);\n }"}, {"filename": "lib/Conversion/TritonGPUToLLVM/LoadStoreOpToLLVM.cpp", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "file_content_changes": "@@ -419,7 +419,11 @@ struct AtomicCASOpConversion\n     auto *cmpOpr = ptxBuilderAtomicCAS.newOperand(casCmp, \"r\");\n     auto *valOpr = ptxBuilderAtomicCAS.newOperand(casVal, \"r\");\n     auto &atom = *ptxBuilderAtomicCAS.create<PTXInstr>(\"atom\");\n-    atom.global().o(\"cas\").o(\"b32\");\n+    std::string semStr;\n+    llvm::raw_string_ostream os(semStr);\n+    os << op.getSem();\n+    llvm::outs() << op.getSem() << \"\\n\";\n+    atom.global().o(semStr).o(\"cas\").o(\"b32\");\n     atom(dstOpr, ptrOpr, cmpOpr, valOpr).predicate(mask);\n     auto old = ptxBuilderAtomicCAS.launch(rewriter, loc, valueElemTy);\n     barrier();"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "file_content_changes": "@@ -1051,7 +1051,8 @@ def kernel(X, SHAPE0: tl.constexpr, SHAPE1: tl.constexpr):\n     assert torch.min(x).item() == 0.0\n \n \n-def test_atomic_cas():\n+@pytest.mark.parametrize(\"sem\", [None, 'acquire', 'release', 'acq_rel', 'relaxed'])\n+def test_atomic_cas(sem):\n     # 1. make sure that atomic_cas changes the original value (Lock)\n     @triton.jit\n     def change_value(Lock):\n@@ -1064,9 +1065,9 @@ def change_value(Lock):\n \n     # 2. only one block enters the critical section\n     @triton.jit\n-    def serialized_add(data, Lock):\n+    def serialized_add(data, Lock, SEM: tl.constexpr):\n         ptrs = data + tl.arange(0, 128)\n-        while tl.atomic_cas(Lock, 0, 1) == 1:\n+        while tl.atomic_cas(Lock, 0, 1, SEM) == 1:\n             pass\n \n         tl.store(ptrs, tl.load(ptrs) + 1.0)\n@@ -1077,8 +1078,10 @@ def serialized_add(data, Lock):\n     Lock = torch.zeros((1,), device='cuda', dtype=torch.int32)\n     data = torch.zeros((128,), device='cuda', dtype=torch.float32)\n     ref = torch.full((128,), 64.0)\n-    serialized_add[(64,)](data, Lock)\n+    h = serialized_add[(64,)](data, Lock, SEM=sem)\n+    sem_str = \"acq_rel\" if sem is None else sem\n     np.testing.assert_allclose(to_numpy(data), to_numpy(ref))\n+    assert f\"atom.global.{sem_str}\" in h.asm[\"ptx\"]\n \n \n # ---------------"}, {"filename": "python/triton/language/semantic.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1043,7 +1043,7 @@ def atomic_cas(ptr: tl.tensor,\n     element_ty = ptr.type.scalar.element_ty\n     if element_ty.primitive_bitwidth not in [16, 32, 64]:\n         raise ValueError(\"atomic_cas only supports elements with width {16, 32, 64}\")\n-    return tl.tensor(builder.create_atomic_cas(ptr.handle, cmp.handle, val.handle), val.type, sem)\n+    return tl.tensor(builder.create_atomic_cas(ptr.handle, cmp.handle, val.handle, sem), val.type)\n \n \n def atom_red_typechecking_impl(ptr: tl.tensor,"}]