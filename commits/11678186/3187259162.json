[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "file_content_changes": "@@ -548,6 +548,9 @@ class ConvertTritonGPUOpToLLVMPattern\n     auto warpsPerCTA = blockedLayout.getWarpsPerCTA();\n     unsigned rank = shape.size();\n     SmallVector<unsigned> shapePerCTA = getShapePerCTA(blockedLayout);\n+    SmallVector<unsigned> tilesPerDim(rank);\n+    for (unsigned k = 0; k < rank; ++k)\n+      tilesPerDim[k] = ceil<unsigned>(shape[k], shapePerCTA[k]);\n \n     // step 1, delinearize threadId to get the base index\n     auto multiDimBase =\n@@ -558,8 +561,7 @@ class ConvertTritonGPUOpToLLVMPattern\n     SmallVector<SmallVector<unsigned>> offset(rank);\n     for (unsigned k = 0; k < rank; ++k) {\n       // 1 block in minimum if shape[k] is less than shapePerCTA[k]\n-      for (unsigned blockOffset = 0;\n-           blockOffset < ceil<unsigned>(shape[k], shapePerCTA[k]);\n+      for (unsigned blockOffset = 0; blockOffset < tilesPerDim[k];\n            ++blockOffset)\n         for (unsigned warpOffset = 0; warpOffset < warpsPerCTA[k]; ++warpOffset)\n           for (unsigned threadOffset = 0; threadOffset < threadsPerWarp[k];\n@@ -577,15 +579,12 @@ class ConvertTritonGPUOpToLLVMPattern\n     SmallVector<SmallVector<Value>> multiDimIdx(elemsPerThread,\n                                                 SmallVector<Value>(rank));\n     unsigned totalSizePerThread = product<unsigned>(sizePerThread);\n-    SmallVector<unsigned> threadsPerDim(rank);\n-    for (unsigned k = 0; k < rank; ++k)\n-      threadsPerDim[k] = ceil<unsigned>(shape[k], sizePerThread[k]);\n \n     for (unsigned n = 0; n < elemsPerThread; ++n) {\n       unsigned linearNanoTileId = n / totalSizePerThread;\n       unsigned linearNanoTileElemId = n % totalSizePerThread;\n       SmallVector<unsigned> multiDimNanoTileId =\n-          getMultiDimIndex<unsigned>(linearNanoTileId, threadsPerDim);\n+          getMultiDimIndex<unsigned>(linearNanoTileId, tilesPerDim);\n       SmallVector<unsigned> multiDimNanoTileElemId =\n           getMultiDimIndex<unsigned>(linearNanoTileElemId, sizePerThread);\n       for (unsigned k = 0; k < rank; ++k) {"}, {"filename": "test/Conversion/tritongpu_to_llvm.mlir", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "file_content_changes": "@@ -426,6 +426,56 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n \n // -----\n \n+#block0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [8], warpsPerCTA = [4], order = [0]}>\n+#block2 = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [8, 1], warpsPerCTA = [4, 1], order = [1, 0]}>\n+#block3 = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 8], warpsPerCTA = [1, 4], order = [1, 0]}>\n+#AL = #triton_gpu.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>\n+#A = #triton_gpu.shared<{vec = 1, perPhase = 1, maxPhase = 4, order = [1, 0]}>\n+module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n+  // CHECK-LABEL: basic_insert_slice_async_v1_multictas\n+  func @basic_insert_slice_async_v1_multictas(%arg0: !tt.ptr<f32> {tt.divisibility = 4 : i32}) {\n+    %off0_ = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #block0>\n+    %off1_ = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #block0>\n+    %off0 = tt.expand_dims %off0_ {axis = 1 : i32} : (tensor<32xi32, #block0>) -> tensor<32x1xi32, #block2>\n+    %off1 = tt.expand_dims %off1_ {axis = 0 : i32} : (tensor<32xi32, #block0>) -> tensor<1x32xi32, #block3>\n+    %broadcast_off0_scalar = tt.broadcast %off0 : (tensor<32x1xi32, #block2>) -> tensor<32x32xi32, #block2>\n+    %cst_scalar = arith.constant 32 : i32\n+    %cst = tt.splat %cst_scalar : (i32) -> tensor<32x32xi32, #block2>\n+    %broadcast_off0_ = arith.muli %broadcast_off0_scalar, %cst : tensor<32x32xi32, #block2>\n+    %broadcast_off1_ = tt.broadcast %off1 : (tensor<1x32xi32, #block3>) -> tensor<32x32xi32, #block3>\n+    %broadcast_off0 = triton_gpu.convert_layout %broadcast_off0_ : (tensor<32x32xi32, #block2>) -> tensor<32x32xi32, #AL>\n+    %broadcast_off1 = triton_gpu.convert_layout %broadcast_off1_ : (tensor<32x32xi32, #block3>) -> tensor<32x32xi32, #AL>\n+    %off = arith.addi %broadcast_off0, %broadcast_off1 : tensor<32x32xi32, #AL>\n+    %a_init = tt.splat %arg0 : (!tt.ptr<f32>) -> tensor<32x32x!tt.ptr<f32>, #AL>\n+    %a_ptr = tt.addptr %a_init, %off : tensor<32x32x!tt.ptr<f32>, #AL>\n+    %tensor = triton_gpu.alloc_tensor : tensor<2x32x32xf32, #A>\n+    %index = arith.constant 1 : i32\n+\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.ca.shared.global.L2::evict_normal [ ${{.*}} + 0 ], [ ${{.*}} + 0 ], 0x20, 0x20\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.ca.shared.global.L2::evict_normal [ ${{.*}} + 0 ], [ ${{.*}} + 0 ], 0x20, 0x20\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.ca.shared.global.L2::evict_normal [ ${{.*}} + 0 ], [ ${{.*}} + 0 ], 0x20, 0x20\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.ca.shared.global.L2::evict_normal [ ${{.*}} + 0 ], [ ${{.*}} + 0 ], 0x20, 0x20\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.ca.shared.global.L2::evict_normal [ ${{.*}} + 512 ], [ ${{.*}} + 0 ], 0x20, 0x20\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.ca.shared.global.L2::evict_normal [ ${{.*}} + 512 ], [ ${{.*}} + 0 ], 0x20, 0x20\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.ca.shared.global.L2::evict_normal [ ${{.*}} + 512 ], [ ${{.*}} + 0 ], 0x20, 0x20\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.ca.shared.global.L2::evict_normal [ ${{.*}} + 512 ], [ ${{.*}} + 0 ], 0x20, 0x20\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: cp.async.commit_group\n+    %a = triton_gpu.insert_slice_async %a_ptr, %tensor, %index {axis = 0 : i32, cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<32x32x!tt.ptr<f32>, #AL> -> tensor<2x32x32xf32, #A>\n+    return\n+  }\n+}\n+\n+// -----\n+\n #blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n   // CHECK: basic_splat"}]