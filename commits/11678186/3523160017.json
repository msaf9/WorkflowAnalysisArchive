[{"filename": "lib/Analysis/Allocation.cpp", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "file_content_changes": "@@ -112,6 +112,20 @@ SmallVector<unsigned> getScratchConfigForReduce(triton::ReduceOp op) {\n   return smemShape;\n }\n \n+// only valid for scalar\n+SmallVector<unsigned> getScratchConfigForAtomicRMW(triton::AtomicRMWOp op) {\n+  SmallVector<unsigned> smemShape;\n+  auto ptrTy = op.ptr().getType();\n+  if (auto tensorType = ptrTy.dyn_cast<RankedTensorType>()) {\n+    // do nothing or just assert because shared memory is not used in tensor\n+  } else {\n+    // need only bytes for scalar\n+    // always vec = 1 and elemsPerThread = 1 for scalar?\n+    smemShape.push_back(1);\n+  }\n+  return smemShape;\n+}\n+\n class AllocationAnalysis {\n public:\n   AllocationAnalysis(Operation *operation, Allocation *allocation)\n@@ -200,6 +214,23 @@ class AllocationAnalysis {\n                    elems * kPtrBitWidth / 8 :\n                    elems * srcTy.getElementTypeBitWidth() / 8;\n       allocation->addBuffer<BufferT::BufferKind::Scratch>(op, bytes);\n+    } else if (auto atomicRMWOp = dyn_cast<triton::AtomicRMWOp>(op)) {\n+      auto value = op->getOperand(0);\n+      // only scalar requires scratch memory\n+      // make it explicit for readability\n+      if (value.getType().dyn_cast<RankedTensorType>()) {\n+        // nothing to do\n+      } else {\n+        auto smemShape = getScratchConfigForAtomicRMW(atomicRMWOp);\n+        unsigned elems = std::accumulate(smemShape.begin(), smemShape.end(), 1,\n+                                         std::multiplies{});\n+        auto elemTy =\n+            value.getType().cast<triton::PointerType>().getPointeeType();\n+        auto bytes = elemTy.isa<triton::PointerType>()\n+                         ? elems * kPtrBitWidth / 8\n+                         : elems * elemTy.getIntOrFloatBitWidth() / 8;\n+        allocation->addBuffer<BufferT::BufferKind::Scratch>(op, bytes);\n+      }\n     }\n   }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "file_content_changes": "@@ -5923,10 +5923,11 @@ struct AtomicRMWOpConversion\n       triton::AtomicRMWOp>::ConvertTritonGPUOpToLLVMPattern;\n \n   AtomicRMWOpConversion(LLVMTypeConverter &converter,\n+                        const Allocation *allocation, Value smem,\n                         AxisInfoAnalysis &axisAnalysisPass,\n                         PatternBenefit benefit)\n-      : ConvertTritonGPUOpToLLVMPattern<triton::AtomicRMWOp>(converter,\n-                                                             benefit),\n+      : ConvertTritonGPUOpToLLVMPattern<triton::AtomicRMWOp>(\n+            converter, allocation, smem, benefit),\n         LoadStoreConversionBase(axisAnalysisPass) {}\n \n   LogicalResult\n@@ -5947,30 +5948,29 @@ struct AtomicRMWOpConversion\n     auto valElements = getElementsFromStruct(loc, llVal, rewriter);\n     auto ptrElements = getElementsFromStruct(loc, llPtr, rewriter);\n     auto maskElements = getElementsFromStruct(loc, llMask, rewriter);\n-\n-    // TODO[dongdongl]: Support scalar\n-\n+   \n     auto valueTy = op.getResult().getType().dyn_cast<RankedTensorType>();\n-    if (!valueTy)\n-      return failure();\n     Type valueElemTy =\n-        getTypeConverter()->convertType(valueTy.getElementType());\n-\n-    auto valTy = val.getType().cast<RankedTensorType>();\n+        valueTy ? getTypeConverter()->convertType(valueTy.getElementType())\n+                : op.getResult().getType();\n     const size_t valueElemNbits = valueElemTy.getIntOrFloatBitWidth();\n-    auto vec = getVectorSize(ptr);\n-    vec = std::min<unsigned>(vec, valTy.getElementType().isF16() ? 2 : 1);\n-\n-    auto vecTy = vec_ty(valueElemTy, vec);\n     auto elemsPerThread = getElemsPerThread(val.getType());\n-    // mask\n+    // vec = 1 for scalar\n+    auto vec = getVectorSize(ptr);\n     Value mask = int_val(1, 1);\n-    auto shape = valueTy.getShape();\n-    auto numElements = product(shape);\n     auto tid = tid_val();\n-    mask = and_(mask, icmp_slt(mul(tid, i32_val(elemsPerThread)),\n-                               i32_val(numElements)));\n+    // tensor\n+    if (valueTy) {\n+      auto valTy = val.getType().cast<RankedTensorType>();\n+      vec = std::min<unsigned>(vec, valTy.getElementType().isF16() ? 2 : 1);\n+      // mask\n+      auto shape = valueTy.getShape();\n+      auto numElements = product(shape);\n+      mask = and_(mask, icmp_slt(mul(tid, i32_val(elemsPerThread)),\n+                                 i32_val(numElements)));\n+    }\n \n+    auto vecTy = vec_ty(valueElemTy, vec);\n     SmallVector<Value> resultVals(elemsPerThread);\n     for (size_t i = 0; i < elemsPerThread; i += vec) {\n       Value rmwVal = undef(vecTy);\n@@ -5984,10 +5984,12 @@ struct AtomicRMWOpConversion\n       rmwMask = and_(rmwMask, mask);\n       std::string sTy;\n       PTXBuilder ptxBuilder;\n-\n-      auto *dstOpr = ptxBuilder.newOperand(\"=r\");\n+      std::string tyId = valueElemNbits * vec == 64\n+                             ? \"l\"\n+                             : (valueElemNbits * vec == 32 ? \"r\" : \"h\");\n+      auto *dstOpr = ptxBuilder.newOperand(\"=\" + tyId);\n       auto *ptrOpr = ptxBuilder.newAddrOperand(rmwPtr, \"l\");\n-      auto *valOpr = ptxBuilder.newOperand(rmwVal, \"r\");\n+      auto *valOpr = ptxBuilder.newOperand(rmwVal, tyId);\n \n       auto &atom = ptxBuilder.create<>(\"atom\")->global().o(\"gpu\");\n       auto rmwOp = stringifyRMWOp(atomicRmwAttr).str();\n@@ -6029,18 +6031,33 @@ struct AtomicRMWOpConversion\n         return failure();\n       }\n       atom.o(rmwOp).o(sTy);\n-      atom(dstOpr, ptrOpr, valOpr).predicate(rmwMask);\n-\n-      auto ret = ptxBuilder.launch(rewriter, loc, valueElemTy);\n-      for (int ii = 0; ii < vec; ++ii) {\n-        resultVals[i * vec + ii] =\n-            vec == 1 ? ret : extract_element(valueElemTy, ret, idx_val(ii));\n+      if (valueTy) {\n+        atom(dstOpr, ptrOpr, valOpr).predicate(rmwMask);\n+        auto ret = ptxBuilder.launch(rewriter, loc, valueElemTy);\n+        for (int ii = 0; ii < vec; ++ii) {\n+          resultVals[i * vec + ii] =\n+              vec == 1 ? ret : extract_element(valueElemTy, ret, idx_val(ii));\n+        }\n+      } else {\n+        barrier();\n+        rmwMask = and_(rmwMask, icmp_eq(tid, i32_val(0)));\n+        atom(dstOpr, ptrOpr, valOpr).predicate(rmwMask);\n+        auto old = ptxBuilder.launch(rewriter, loc, valueElemTy);\n+        Value atomPtr = getSharedMemoryBase(loc, rewriter, op.getOperation());\n+        atomPtr = bitcast(atomPtr, ptr_ty(valueElemTy, 3));\n+        store(old, atomPtr);\n+        barrier();\n+        Value ret = load(atomPtr);\n+        barrier();\n+        rewriter.replaceOp(op, {ret});\n       }\n     }\n-    Type structTy = getTypeConverter()->convertType(valueTy);\n-    Value resultStruct =\n-        getStructFromElements(loc, resultVals, rewriter, structTy);\n-    rewriter.replaceOp(op, {resultStruct});\n+    if (valueTy) {\n+      Type structTy = getTypeConverter()->convertType(valueTy);\n+      Value resultStruct =\n+          getStructFromElements(loc, resultVals, rewriter, structTy);\n+      rewriter.replaceOp(op, {resultStruct});\n+    }\n     return success();\n   }\n };\n@@ -6126,7 +6143,7 @@ void populateTritonToLLVMPatterns(mlir::LLVMTypeConverter &typeConverter,\n   patterns.add<ReduceOpConversion>(typeConverter, allocation, smem, benefit);\n   patterns.add<ConvertLayoutOpConversion>(typeConverter, allocation, smem,\n                                           benefit);\n-  patterns.add<AtomicRMWOpConversion>(typeConverter, axisInfoAnalysis, benefit);\n+  patterns.add<AtomicRMWOpConversion>(typeConverter, allocation, smem, axisInfoAnalysis, benefit);\n   patterns.add<ExtractSliceOpConversion>(typeConverter, allocation, smem,\n                                          benefit);\n   patterns.add<GetProgramIdOpConversion>(typeConverter, benefit);"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "file_content_changes": "@@ -1106,7 +1106,20 @@ void init_triton_ir(py::module &&m) {\n               mlir::Value &ptr, mlir::Value &val,\n               mlir::Value &mask) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-             mlir::Type dstType = val.getType();\n+             auto srcTensorType =\n+                 ptr.getType().dyn_cast<mlir::RankedTensorType>();\n+             mlir::Type dstType;\n+             if (srcTensorType) {\n+               mlir::Type dstElemType = srcTensorType.getElementType()\n+                                            .cast<mlir::triton::PointerType>()\n+                                            .getPointeeType();\n+               dstType = mlir::RankedTensorType::get(srcTensorType.getShape(),\n+                                                     dstElemType);\n+             } else {\n+               auto ptrType = mlir::getElementTypeOrSelf(ptr)\n+                                  .cast<mlir::triton::PointerType>();\n+               dstType = ptrType.getPointeeType();\n+             }\n              return self.create<mlir::triton::AtomicRMWOp>(loc, dstType, rmwOp,\n                                                            ptr, val, mask);\n            })"}, {"filename": "python/tests/test_core.py", "status": "modified", "additions": 60, "deletions": 80, "changes": 140, "file_content_changes": "@@ -595,100 +595,80 @@ def without_fn(X, Y, A, B, C):\n         assert c_tri == c_ref\n \n \n-# # ---------------\n-# # test atomics\n-# # ---------------\n-# @pytest.mark.parametrize(\"op, dtype_x_str, mode\", itertools.chain.from_iterable([\n-#     [\n-#         ('add', 'float16', mode),\n-#         ('add', 'uint32', mode), ('add', 'int32', mode), ('add', 'float32', mode),\n-#         ('max', 'uint32', mode), ('max', 'int32', mode), ('max', 'float32', mode),\n-#         ('min', 'uint32', mode), ('min', 'int32', mode), ('min', 'float32', mode),\n-#     ]\n-#     for mode in ['all_neg', 'all_pos', 'min_neg', 'max_pos']]))\n-# def test_atomic_rmw(op, dtype_x_str, mode, device='cuda'):\n-#     n_programs = 5\n-\n-#     # triton kernel\n-#     @triton.jit\n-#     def kernel(X, Z):\n-#         pid = tl.program_id(0)\n-#         x = tl.load(X + pid)\n-#         old = GENERATE_TEST_HERE\n+# ---------------\n+# test atomics\n+# ---------------\n+@pytest.mark.parametrize(\"op, dtype_x_str, mode\", itertools.chain.from_iterable([\n+    [\n+        ('add', 'float16', mode),\n+        ('add', 'uint32', mode), ('add', 'int32', mode), ('add', 'float32', mode),\n+        ('max', 'uint32', mode), ('max', 'int32', mode), #('max', 'float32', mode),\n+        ('min', 'uint32', mode), ('min', 'int32', mode), #('min', 'float32', mode),\n+    ]\n+    for mode in ['all_neg', 'all_pos', 'min_neg', 'max_pos']]))\n+def test_atomic_rmw(op, dtype_x_str, mode, device='cuda'):\n+    n_programs = 5\n \n-#     kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': f'tl.atomic_{op}(Z, x)'})\n-#     numpy_op = {'add': np.sum, 'max': np.max, 'min': np.min}[op]\n-#     max_neutral = float('-inf') if dtype_x_str in float_dtypes else np.iinfo(getattr(np, dtype_x_str)).min\n-#     min_neutral = float('inf') if dtype_x_str in float_dtypes else np.iinfo(getattr(np, dtype_x_str)).max\n-#     neutral = {'add': 0, 'max': max_neutral, 'min': min_neutral}[op]\n+    # triton kernel\n+    @triton.jit\n+    def kernel(X, Z):\n+        pid = tl.program_id(0)\n+        x = tl.load(X + pid)\n+        old = GENERATE_TEST_HERE\n \n-#     # triton result\n-#     rs = RandomState(17)\n-#     x = numpy_random((n_programs, ), dtype_str=dtype_x_str, rs=rs)\n-#     if mode == 'all_neg':\n-#         x = -np.abs(x)\n-#     if mode == 'all_pos':\n-#         x = np.abs(x)\n-#     if mode == 'min_neg':\n-#         idx = rs.randint(n_programs, size=(1, )).item()\n-#         x[idx] = -np.max(np.abs(x)) - 1\n-#     if mode == 'max_pos':\n-#         idx = rs.randint(n_programs, size=(1, )).item()\n-#         x[idx] = np.max(np.abs(x)) + 1\n-#     x_tri = to_triton(x, device=device)\n+    kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': f'tl.atomic_{op}(Z, x)'})\n+    numpy_op = {'add': np.sum, 'max': np.max, 'min': np.min}[op]\n+    max_neutral = float('-inf') if dtype_x_str in float_dtypes else np.iinfo(getattr(np, dtype_x_str)).min\n+    min_neutral = float('inf') if dtype_x_str in float_dtypes else np.iinfo(getattr(np, dtype_x_str)).max\n+    neutral = {'add': 0, 'max': max_neutral, 'min': min_neutral}[op]\n \n-#     z_tri = to_triton(np.array([neutral], dtype=getattr(np, dtype_x_str)), device=device)\n-#     kernel[(n_programs, )](x_tri, z_tri)\n-#     # torch result\n-#     z_ref = numpy_op(x).astype(getattr(np, dtype_x_str))\n-#     # compare\n-#     exact = op not in ['add']\n-#     if exact:\n-#         assert z_ref.item() == to_numpy(z_tri).item()\n-#     else:\n-#         np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01)\n+    # triton result\n+    rs = RandomState(17)\n+    x = numpy_random((n_programs, ), dtype_str=dtype_x_str, rs=rs)\n+    if mode == 'all_neg':\n+        x = -np.abs(x)\n+    if mode == 'all_pos':\n+        x = np.abs(x)\n+    if mode == 'min_neg':\n+        idx = rs.randint(n_programs, size=(1, )).item()\n+        x[idx] = -np.max(np.abs(x)) - 1\n+    if mode == 'max_pos':\n+        idx = rs.randint(n_programs, size=(1, )).item()\n+        x[idx] = np.max(np.abs(x)) + 1\n+    x_tri = to_triton(x, device=device)\n \n+    z_tri = to_triton(np.array([neutral], dtype=getattr(np, dtype_x_str)), device=device)\n+    kernel[(n_programs, )](x_tri, z_tri)\n+    # torch result\n+    z_ref = numpy_op(x).astype(getattr(np, dtype_x_str))\n+    # compare\n+    exact = op not in ['add']\n+    if exact:\n+        assert z_ref.item() == to_numpy(z_tri).item()\n+    else:\n+        np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01)\n \n-# @pytest.mark.parametrize(\"axis\", [0, 1])\n-# def test_tensor_atomic_rmw(axis, device=\"cuda\"):\n-#     shape0, shape1 = 8, 8\n-#     # triton kernel\n \n-#     @triton.jit\n-#     def kernel(Z, X, AXIS: tl.constexpr, SHAPE0: tl.constexpr, SHAPE1: tl.constexpr):\n-#         off0 = tl.arange(0, SHAPE0)\n-#         off1 = tl.arange(0, SHAPE1)\n-#         x = tl.load(X + off0[:, None] * SHAPE1 + off1[None, :])\n-#         z = tl.sum(x, axis=AXIS)\n-#         tl.atomic_add(Z + off0, z)\n-#     rs = RandomState(17)\n-#     x = numpy_random((shape0, shape1), dtype_str=\"float32\", rs=rs)\n-#     # reference result\n-#     z_ref = np.sum(x, axis=axis)\n-#     # triton result\n-#     x_tri = to_triton(x, device=device)\n-#     z_tri = to_triton(np.zeros((shape0,), dtype=\"float32\"), device=device)\n-#     kernel[(1,)](z_tri, x_tri, axis, shape0, shape1)\n-#     np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=1e-4)\n+@pytest.mark.parametrize(\"axis\", [0, 1])\n+def test_tensor_atomic_rmw(axis, device=\"cuda\"):\n+    shape0, shape1 = 8, 8\n+    # triton kernel\n \n-def test_tensor_atomic_rmw_add_elementwise(device=\"cuda\"):\n-    shape0, shape1 = 2, 8\n     @triton.jit\n-    def kernel(Z, X, SHAPE0: tl.constexpr, SHAPE1: tl.constexpr):\n+    def kernel(Z, X, AXIS: tl.constexpr, SHAPE0: tl.constexpr, SHAPE1: tl.constexpr):\n         off0 = tl.arange(0, SHAPE0)\n         off1 = tl.arange(0, SHAPE1)\n         x = tl.load(X + off0[:, None] * SHAPE1 + off1[None, :])\n-        tl.atomic_add(Z + off0[:, None] * SHAPE1 + off1[None, :], x)\n-\n+        z = tl.sum(x, axis=AXIS)\n+        tl.atomic_add(Z + off0, z)\n     rs = RandomState(17)\n     x = numpy_random((shape0, shape1), dtype_str=\"float32\", rs=rs)\n-    z = numpy_random((shape0, shape1), dtype_str=\"float32\", rs=rs)\n-    # reference\n-    z_ref = z + x\n+    # reference result\n+    z_ref = np.sum(x, axis=axis)\n     # triton result\n-    x_tri = torch.from_numpy(x).to(device=device)\n-    z_tri = torch.from_numpy(z).to(device=device)\n-    kernel[(1,)](z_tri, x_tri, shape0, shape1)\n+    x_tri = to_triton(x, device=device)\n+    z_tri = to_triton(np.zeros((shape0,), dtype=\"float32\"), device=device)\n+    kernel[(1,)](z_tri, x_tri, axis, shape0, shape1)\n     np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=1e-4)\n \n # def test_atomic_cas():"}]