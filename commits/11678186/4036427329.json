[{"filename": "bin/triton-translate.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -50,7 +50,8 @@ OwningOpRef<ModuleOp> loadMLIRModule(llvm::StringRef inputFilename,\n     context.loadAllAvailableDialects();\n     context.allowUnregisteredDialects();\n \n-    OwningOpRef<ModuleOp> module = parseSourceFile<ModuleOp>(sourceMgr, &context);\n+    OwningOpRef<ModuleOp> module =\n+        parseSourceFile<ModuleOp>(sourceMgr, &context);\n     if (!module) {\n       llvm::errs() << \"Parse MLIR file failed.\";\n       return nullptr;"}, {"filename": "include/triton/Analysis/Alias.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "file_content_changes": "@@ -8,7 +8,7 @@\n namespace mlir {\n \n class AliasInfo {\n- public:\n+public:\n   AliasInfo() = default;\n   AliasInfo(Value value) { insert(value); }\n \n@@ -29,11 +29,11 @@ class AliasInfo {\n   /// The union of both arguments\n   static AliasInfo join(const AliasInfo &lhs, const AliasInfo &rhs);\n \n-  void print(raw_ostream& os) const {\n+  void print(raw_ostream &os) const {\n     llvm::interleaveComma(allocs, os, [&](Value alloc) { alloc.print(os); });\n   }\n \n- private:\n+private:\n   /// The set of allocated values that are aliased by this lattice.\n   /// For now, we only consider aliased value produced by the following\n   /// situations:\n@@ -62,10 +62,13 @@ class AliasInfo {\n //===----------------------------------------------------------------------===//\n // Shared Memory Alias Analysis\n //===----------------------------------------------------------------------===//\n-class SharedMemoryAliasAnalysis : public dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AliasInfo>> {\n- public:\n-  using dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AliasInfo>>::SparseDataFlowAnalysis;\n-  using dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AliasInfo>>::getLatticeElement;\n+class SharedMemoryAliasAnalysis\n+    : public dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AliasInfo>> {\n+public:\n+  using dataflow::SparseDataFlowAnalysis<\n+      dataflow::Lattice<AliasInfo>>::SparseDataFlowAnalysis;\n+  using dataflow::SparseDataFlowAnalysis<\n+      dataflow::Lattice<AliasInfo>>::getLatticeElement;\n \n   /// XXX(Keren): Compatible interface with MLIR AliasAnalysis for future use.\n   /// Given two values, returns their aliasing behavior.\n@@ -81,6 +84,6 @@ class SharedMemoryAliasAnalysis : public dataflow::SparseDataFlowAnalysis<datafl\n                  ArrayRef<dataflow::Lattice<AliasInfo> *> results) override;\n };\n \n-}  // namespace mlir\n+} // namespace mlir\n \n-#endif  // TRITON_ANALYSIS_ALIAS_H\n+#endif // TRITON_ANALYSIS_ALIAS_H"}, {"filename": "include/triton/Analysis/Allocation.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "file_content_changes": "@@ -188,8 +188,7 @@ class Allocation {\n   friend class triton::AllocationAnalysis;\n };\n \n-template <typename T>\n-Interval(T, T) -> Interval<T>;\n+template <typename T> Interval(T, T) -> Interval<T>;\n \n } // namespace mlir\n "}, {"filename": "include/triton/Analysis/AxisInfo.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "file_content_changes": "@@ -61,7 +61,7 @@ class AxisInfo {\n   // The gcd of both arguments for each dimension\n   static AxisInfo join(const AxisInfo &lhs, const AxisInfo &rhs);\n \n-  void print(raw_ostream& os) const {\n+  void print(raw_ostream &os) const {\n     auto print = [&](StringRef name, DimVectorT vec) {\n       os << name << \" = [\";\n       llvm::interleaveComma(vec, os);\n@@ -120,7 +120,8 @@ class AxisInfo {\n   int rank;\n };\n \n-class AxisInfoAnalysis : public dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>> {\n+class AxisInfoAnalysis\n+    : public dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>> {\n \n private:\n   static const int maxPow2Divisor = 65536;\n@@ -138,13 +139,14 @@ class AxisInfoAnalysis : public dataflow::SparseDataFlowAnalysis<dataflow::Latti\n       const std::function<int(AxisInfo, AxisInfo, int)> &getConstancy);\n \n public:\n-  using dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>>::SparseDataFlowAnalysis;\n-  using dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>>::getLatticeElement;\n-\n-  void\n-  visitOperation(Operation *op,\n-                 ArrayRef<const dataflow::Lattice<AxisInfo> *> operands,\n-                 ArrayRef<dataflow::Lattice<AxisInfo> *> results) override;\n+  using dataflow::SparseDataFlowAnalysis<\n+      dataflow::Lattice<AxisInfo>>::SparseDataFlowAnalysis;\n+  using dataflow::SparseDataFlowAnalysis<\n+      dataflow::Lattice<AxisInfo>>::getLatticeElement;\n+\n+  void visitOperation(Operation *op,\n+                      ArrayRef<const dataflow::Lattice<AxisInfo> *> operands,\n+                      ArrayRef<dataflow::Lattice<AxisInfo> *> results) override;\n \n   unsigned getPtrVectorSize(Value ptr);\n "}, {"filename": "include/triton/Dialect/Triton/IR/Dialect.h", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "file_content_changes": "@@ -23,29 +23,31 @@ namespace triton {\n \n class DialectInferLayoutInterface\n     : public DialectInterface::Base<DialectInferLayoutInterface> {\n- public:\n+public:\n   DialectInferLayoutInterface(Dialect *dialect) : Base(dialect) {}\n \n   virtual LogicalResult\n   inferTransOpEncoding(Attribute operandEncoding,\n                        Attribute &resultEncoding) const = 0;\n \n-  virtual LogicalResult inferReduceOpEncoding(\n-      Attribute operandEncoding, unsigned axis,\n-      Attribute &resultEncoding) const = 0;\n+  virtual LogicalResult\n+  inferReduceOpEncoding(Attribute operandEncoding, unsigned axis,\n+                        Attribute &resultEncoding) const = 0;\n \n-  virtual LogicalResult inferExpandDimsOpEncoding(\n-      Attribute operandEncoding, unsigned axis, Attribute &resultEncoding,\n-      Optional<Location> location) const = 0;\n+  virtual LogicalResult\n+  inferExpandDimsOpEncoding(Attribute operandEncoding, unsigned axis,\n+                            Attribute &resultEncoding,\n+                            Optional<Location> location) const = 0;\n \n   // Note: this function only verify operand encoding but doesn't infer result\n   // encoding\n-  virtual LogicalResult inferDotOpEncoding(\n-      Attribute operandEncoding, unsigned opIdx, Attribute retEncoding,\n-      Optional<Location> location) const = 0;\n+  virtual LogicalResult\n+  inferDotOpEncoding(Attribute operandEncoding, unsigned opIdx,\n+                     Attribute retEncoding,\n+                     Optional<Location> location) const = 0;\n };\n \n-}  // namespace triton\n-}  // namespace mlir\n+} // namespace triton\n+} // namespace mlir\n \n-#endif  // TRITON_IR_DIALECT_H_\n+#endif // TRITON_IR_DIALECT_H_"}, {"filename": "include/triton/Dialect/TritonGPU/IR/Dialect.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -41,8 +41,8 @@ SmallVector<unsigned> getOrder(const Attribute &layout);\n \n bool isaDistributedLayout(const Attribute &layout);\n \n-}  // namespace gpu\n-}  // namespace triton\n-}  // namespace mlir\n+} // namespace gpu\n+} // namespace triton\n+} // namespace mlir\n \n-#endif  // TRITON_DIALECT_TRITONGPU_IR_DIALECT_H_\n+#endif // TRITON_DIALECT_TRITONGPU_IR_DIALECT_H_"}, {"filename": "lib/Analysis/Alias.cpp", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "file_content_changes": "@@ -18,11 +18,9 @@ AliasInfo AliasInfo::join(const AliasInfo &lhs, const AliasInfo &rhs) {\n   return ret;\n }\n \n-\n-  void\n-  SharedMemoryAliasAnalysis::visitOperation(Operation *op,\n-                 ArrayRef<const dataflow::Lattice<AliasInfo> *> operands,\n-                 ArrayRef<dataflow::Lattice<AliasInfo> *> results) {\n+void SharedMemoryAliasAnalysis::visitOperation(\n+    Operation *op, ArrayRef<const dataflow::Lattice<AliasInfo> *> operands,\n+    ArrayRef<dataflow::Lattice<AliasInfo> *> results) {\n   AliasInfo aliasInfo;\n   bool pessimistic = true;\n   if (maybeSharedAllocationOp(op)) {\n@@ -50,7 +48,7 @@ AliasInfo AliasInfo::join(const AliasInfo &lhs, const AliasInfo &rhs) {\n     return markAllPessimisticFixpoint(results);\n   }\n   // Join all lattice elements\n-  for (auto* result : results)\n+  for (auto *result : results)\n     propagateIfChanged(result, result->join(aliasInfo));\n }\n "}, {"filename": "lib/Analysis/Allocation.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,8 +1,8 @@\n #include \"triton/Analysis/Allocation.h\"\n+#include \"mlir/Analysis/DataFlowFramework.h\"\n #include \"mlir/Analysis/Liveness.h\"\n #include \"mlir/Analysis/SliceAnalysis.h\"\n #include \"mlir/Dialect/Tensor/IR/Tensor.h\"\n-#include \"mlir/Analysis/DataFlowFramework.h\"\n #include \"triton/Analysis/Alias.h\"\n #include \"triton/Analysis/Utility.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\""}, {"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -270,7 +270,7 @@ void AxisInfoAnalysis::visitOperation(\n   }\n \n   // join all lattice elements\n-  for (auto* result : results)\n+  for (auto *result : results)\n     propagateIfChanged(result, result->join(curr));\n }\n \n@@ -297,7 +297,7 @@ unsigned AxisInfoAnalysis::getPtrAlignment(Value ptr) {\n   auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>();\n   if (!tensorTy)\n     return 1;\n-  dataflow::Lattice<AxisInfo>* latticeElement = getLatticeElement(ptr);\n+  dataflow::Lattice<AxisInfo> *latticeElement = getLatticeElement(ptr);\n   if (!latticeElement || latticeElement->isUninitialized())\n     return 1;\n   auto axisInfo = latticeElement->getValue();"}, {"filename": "lib/Analysis/CMakeLists.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -8,4 +8,7 @@ add_mlir_library(TritonAnalysis\n   DEPENDS\n   TritonTableGen\n   TritonGPUAttrDefsIncGen\n+\n+  LINK_LIBS PUBLIC\n+  MLIRAnalysis\n )"}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "file_content_changes": "@@ -187,9 +187,10 @@ struct ConstantAnalysis : public DataFlowAnalysis {\n     Operation *op = point.get<Operation *>();\n     Attribute value;\n     if (matchPattern(op, m_Constant(&value))) {\n-      auto *constant = getOrCreate<dataflow::Lattice<dataflow::ConstantValue>>(op->getResult(0));\n-      propagateIfChanged(\n-          constant, constant->join(dataflow::ConstantValue(value, op->getDialect())));\n+      auto *constant = getOrCreate<dataflow::Lattice<dataflow::ConstantValue>>(\n+          op->getResult(0));\n+      propagateIfChanged(constant, constant->join(dataflow::ConstantValue(\n+                                       value, op->getDialect())));\n       return success();\n     }\n     setAllToUnknownConstants(op->getResults());\n@@ -202,18 +203,19 @@ struct ConstantAnalysis : public DataFlowAnalysis {\n   void setAllToUnknownConstants(ValueRange values) {\n     dataflow::ConstantValue unknownConstant(nullptr, nullptr);\n     for (Value value : values) {\n-      auto *constant = getOrCreate<dataflow::Lattice<dataflow::ConstantValue>>(value);\n+      auto *constant =\n+          getOrCreate<dataflow::Lattice<dataflow::ConstantValue>>(value);\n       propagateIfChanged(constant, constant->join(unknownConstant));\n     }\n   }\n };\n } // namespace\n \n std::unique_ptr<DataFlowSolver> createDataFlowSolver() {\n-    auto solver = std::make_unique<DataFlowSolver>();\n-    solver->load<dataflow::DeadCodeAnalysis>();\n-    solver->load<ConstantAnalysis>();\n-    return solver;\n+  auto solver = std::make_unique<DataFlowSolver>();\n+  solver->load<dataflow::DeadCodeAnalysis>();\n+  solver->load<ConstantAnalysis>();\n+  return solver;\n }\n \n } // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1310,8 +1310,8 @@ struct MMA16816ConversionHelper {\n                            Value thread, ConversionPatternRewriter &rewriter,\n                            TypeConverter *typeConverter, Location loc)\n       : mmaLayout(mmaLayout), wpt(mmaLayout.getWarpsPerCTA()), thread(thread),\n-        helper(mmaLayout), rewriter(rewriter),\n-        typeConverter(typeConverter), loc(loc), ctx(mmaLayout.getContext()) {\n+        helper(mmaLayout), rewriter(rewriter), typeConverter(typeConverter),\n+        loc(loc), ctx(mmaLayout.getContext()) {\n     helper.deduceMmaType(dotOperand);\n \n     Value _32 = i32_val(32);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "file_content_changes": "@@ -45,8 +45,7 @@ struct FuncOpConversionBase : public ConvertOpToLLVMPattern<func::FuncOp> {\n   /// Only retain those attributes that are not constructed by\n   /// `LLVMFuncOp::build`. If `filterArgAttrs` is set, also filter out argument\n   /// attributes.\n-  static void filterFuncAttributes(func::FuncOp op,\n-                                   bool filterArgAttrs,\n+  static void filterFuncAttributes(func::FuncOp op, bool filterArgAttrs,\n                                    SmallVectorImpl<NamedAttribute> &result) {\n \n     for (const auto &attr : op->getAttrs()) {\n@@ -79,15 +78,15 @@ struct FuncOpConversionBase : public ConvertOpToLLVMPattern<func::FuncOp> {\n     auto varargsAttr = funcOp->getAttrOfType<BoolAttr>(\"func.varargs\");\n     TypeConverter::SignatureConversion result(funcOp.getNumArguments());\n     auto llvmType = getTypeConverter()->convertFunctionSignature(\n-        funcOp.getFunctionType(), varargsAttr && varargsAttr.getValue(), result);\n+        funcOp.getFunctionType(), varargsAttr && varargsAttr.getValue(),\n+        result);\n     if (!llvmType)\n       return nullptr;\n \n     // Propagate argument/result attributes to all converted arguments/result\n     // obtained after converting a given original argument/result.\n     SmallVector<NamedAttribute, 4> attributes;\n-    filterFuncAttributes(funcOp, /*filterArgAttrs=*/true,\n-                         attributes);\n+    filterFuncAttributes(funcOp, /*filterArgAttrs=*/true, attributes);\n     if (ArrayAttr resAttrDicts = funcOp.getAllResultAttrs()) {\n       assert(!resAttrDicts.empty() && \"expected array to be non-empty\");\n       auto newResAttrDicts ="}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1,13 +1,13 @@\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h\"\n \n+#include \"mlir/Analysis/DataFlowFramework.h\"\n #include \"mlir/Conversion/ArithmeticToLLVM/ArithmeticToLLVM.h\"\n #include \"mlir/Conversion/GPUToNVVM/GPUToNVVMPass.h\"\n #include \"mlir/Conversion/MathToLLVM/MathToLLVM.h\"\n #include \"mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/Dialect/LLVMIR/NVVMDialect.h\"\n #include \"mlir/Pass/Pass.h\"\n-#include \"mlir/Analysis/DataFlowFramework.h\"\n #include \"triton/Analysis/Allocation.h\"\n #include \"triton/Analysis/AxisInfo.h\"\n #include \"triton/Analysis/Membar.h\"\n@@ -133,7 +133,7 @@ class ConvertTritonGPUToLLVM\n \n     // Step 2\n     if (failed(decomposeInsertSliceAsyncOp(mod)))\n-        return signalPassFailure();\n+      return signalPassFailure();\n \n     // Step 3\n     Allocation allocation(mod);"}, {"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.cpp", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "file_content_changes": "@@ -456,18 +456,19 @@ struct TritonPrintfPattern : public OpConversionPattern<triton::PrintfOp> {\n void populateTritonPatterns(TritonGPUTypeConverter &typeConverter,\n                             RewritePatternSet &patterns) {\n   MLIRContext *context = patterns.getContext();\n-  patterns.insert< // TODO: view should have custom pattern that views the layout\n-      TritonGenericPattern<triton::ViewOp>,\n-      TritonGenericPattern<triton::BitcastOp>,\n-      TritonGenericPattern<triton::FpToFpOp>,\n-      TritonGenericPattern<triton::IntToPtrOp>,\n-      TritonGenericPattern<triton::PtrToIntOp>,\n-      TritonGenericPattern<triton::SplatOp>, TritonBroadcastPattern,\n-      TritonGenericPattern<triton::AddPtrOp>, TritonCatPattern,\n-      TritonReducePattern, TritonTransPattern, TritonExpandDimsPattern,\n-      TritonMakeRangePattern, TritonDotPattern, TritonLoadPattern,\n-      TritonStorePattern, TritonExtElemwisePattern, TritonPrintfPattern,\n-      TritonAtomicRMWPattern>(typeConverter, context);\n+  patterns\n+      .insert< // TODO: view should have custom pattern that views the layout\n+          TritonGenericPattern<triton::ViewOp>,\n+          TritonGenericPattern<triton::BitcastOp>,\n+          TritonGenericPattern<triton::FpToFpOp>,\n+          TritonGenericPattern<triton::IntToPtrOp>,\n+          TritonGenericPattern<triton::PtrToIntOp>,\n+          TritonGenericPattern<triton::SplatOp>, TritonBroadcastPattern,\n+          TritonGenericPattern<triton::AddPtrOp>, TritonCatPattern,\n+          TritonReducePattern, TritonTransPattern, TritonExpandDimsPattern,\n+          TritonMakeRangePattern, TritonDotPattern, TritonLoadPattern,\n+          TritonStorePattern, TritonExtElemwisePattern, TritonPrintfPattern,\n+          TritonAtomicRMWPattern>(typeConverter, context);\n }\n \n //"}, {"filename": "lib/Dialect/Triton/Transforms/Combine.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -57,8 +57,8 @@ DenseElementsAttr getConstantValue(Builder &builder, Attribute value,\n class CombineSelectMaskedLoadPattern : public mlir::RewritePattern {\n public:\n   CombineSelectMaskedLoadPattern(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(mlir::arith::SelectOp::getOperationName(), 3, context,\n-                             {triton::LoadOp::getOperationName()}) {}\n+      : mlir::RewritePattern(mlir::arith::SelectOp::getOperationName(), 3,\n+                             context, {triton::LoadOp::getOperationName()}) {}\n \n   mlir::LogicalResult\n   matchAndRewrite(mlir::Operation *op,"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -2,12 +2,12 @@\n \n #include <numeric>\n \n-#include \"llvm/ADT/TypeSwitch.h\"\n #include \"mlir/IR/DialectImplementation.h\"\n #include \"mlir/IR/OpImplementation.h\"\n #include \"triton/Analysis/Utility.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.cpp.inc\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n+#include \"llvm/ADT/TypeSwitch.h\"\n \n using namespace mlir;\n using namespace mlir::triton::gpu;"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Coalesce.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -18,8 +18,9 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n     size_t rank = origType.getRank();\n     dataflow::Lattice<AxisInfo> *latticeElement =\n         axisInfo.getLatticeElement(ptr);\n-    AxisInfo info = latticeElement && !latticeElement->isUninitialized() ?\n-        latticeElement->getValue() : AxisInfo();\n+    AxisInfo info = latticeElement && !latticeElement->isUninitialized()\n+                        ? latticeElement->getValue()\n+                        : AxisInfo();\n     // Layout order in decreasing order of contiguity\n     SmallVector<unsigned, 4> order(rank);\n     std::iota(order.begin(), order.end(), 0);\n@@ -108,8 +109,7 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n     Operation *op = getOperation();\n     // Run axis info analysis\n     std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n-    AxisInfoAnalysis* axisInfo =\n-        solver->load<AxisInfoAnalysis>();\n+    AxisInfoAnalysis *axisInfo = solver->load<AxisInfoAnalysis>();\n     if (failed(solver->initializeAndRun(op)))\n       return signalPassFailure();\n     OpBuilder builder(op);"}, {"filename": "lib/Dialect/TritonGPU/Transforms/TritonGPUConversion.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -82,12 +82,12 @@ TritonGPUConversionTarget::TritonGPUConversionTarget(\n                scf::ReduceReturnOp>();\n \n   addDynamicallyLegalDialect<arith::ArithmeticDialect, math::MathDialect,\n-                             triton::TritonDialect,\n-                             scf::SCFDialect>([&](Operation *op) {\n-    if (typeConverter.isLegal(op))\n-      return true;\n-    return false;\n-  });\n+                             triton::TritonDialect, scf::SCFDialect>(\n+      [&](Operation *op) {\n+        if (typeConverter.isLegal(op))\n+          return true;\n+        return false;\n+      });\n \n   // We have requirements for the data layouts\n   addDynamicallyLegalOp<triton::DotOp>([](triton::DotOp dotOp) -> bool {"}, {"filename": "lib/Target/PTX/PTXTranslation.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,6 +1,6 @@\n #include \"triton/Target/PTX/PTXTranslation.h\"\n-#include <optional>\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n+#include <optional>\n \n #include \"llvm/IR/IRBuilder.h\"\n #include \"llvm/IR/LegacyPassManager.h\""}, {"filename": "test/lib/Analysis/TestAlias.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -40,7 +40,7 @@ struct TestAliasPass\n     os << op_name << \"\\n\";\n \n     std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n-    SharedMemoryAliasAnalysis* analysis =\n+    SharedMemoryAliasAnalysis *analysis =\n         solver->load<SharedMemoryAliasAnalysis>();\n     if (failed(solver->initializeAndRun(operation)))\n       return signalPassFailure();"}, {"filename": "test/lib/Analysis/TestAxisInfo.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -22,7 +22,7 @@ struct TestAxisInfoPass\n     os << \"Testing: \" << operation->getName() << \"\\n\";\n \n     std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n-    AxisInfoAnalysis* analysis = solver->load<AxisInfoAnalysis>();\n+    AxisInfoAnalysis *analysis = solver->load<AxisInfoAnalysis>();\n     if (failed(solver->initializeAndRun(operation)))\n       return signalPassFailure();\n     operation->walk([&](Operation *op) {"}]