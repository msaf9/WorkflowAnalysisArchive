[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -83,6 +83,7 @@ static Value createLLVMIntegerConstant(OpBuilder &builder, Location loc,\n \n } // namespace\n \n+// A helper function for using printf in LLVM conversion.\n void llPrintf(StringRef msg, ValueRange args,\n               ConversionPatternRewriter &rewriter);\n "}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "file_content_changes": "@@ -122,8 +122,8 @@ class SimplifyConversion : public mlir::RewritePattern {\n       rewriter.replaceOpWithNewOp<triton::gpu::InsertSliceAsyncOp>(\n           op, newType, insert_slice.src(), newArg.getResult(),\n           insert_slice.index(), insert_slice.mask(), insert_slice.other(),\n-          insert_slice.cache(), insert_slice.evict(),\n-          insert_slice.isVolatile(), insert_slice.axis());\n+          insert_slice.cache(), insert_slice.evict(), insert_slice.isVolatile(),\n+          insert_slice.axis());\n       return mlir::success();\n     }\n     // cvt(extract_slice(x), type2) -> extract_slice(cvt(x, type2))\n@@ -576,14 +576,6 @@ class BlockedToMMA : public mlir::RewritePattern {\n     auto oldRetType = dotOp.getResult().getType().cast<RankedTensorType>();\n     if (oldRetType.getEncoding().isa<triton::gpu::MmaEncodingAttr>())\n       return failure();\n-\n-    auto A = dotOp.getOperand(0).getType().cast<RankedTensorType>();\n-    auto B = dotOp.getOperand(1).getType().cast<RankedTensorType>();\n-    // for FMA, should retain the blocked layout.\n-    if (A.getElementType().isF32() && B.getElementType().isF32() &&\n-        !dotOp.allowTF32())\n-      return failure();\n-\n     // get MMA encoding for the given number of warps\n     auto retShape = oldRetType.getShape();\n     auto mod = op->getParentOfType<mlir::ModuleOp>();"}]