[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "file_content_changes": "@@ -96,13 +96,12 @@ class LoopPipeliner {\n   ///   value\n   /// }\n   /// Collect values that v depends on and are defined inside the loop\n-  LogicalResult collectDeps(Value v, int stage, MapVector<Value, int> &depStage,\n-                            DenseSet<Value> visited);\n+  LogicalResult collectDeps(Value v, int stage,\n+                            MapVector<Value, int> &depStage);\n \n   /// Associate each variable with a unique stage. If a variable is defined\n   /// at multiple stages, we don't pipeline it.\n-  LogicalResult addDep(Value v, int stage, MapVector<Value, int> &depStage,\n-                       DenseSet<Value> *visited);\n+  LogicalResult addDep(Value v, int stage, MapVector<Value, int> &depStage);\n \n   int getArgDefStage(Value v, int stage);\n \n@@ -169,24 +168,16 @@ Value LoopPipeliner::lookupOrDefault(Value origin, int stage) {\n }\n \n LogicalResult LoopPipeliner::addDep(Value v, int stage,\n-                                    MapVector<Value, int> &depStage,\n-                                    DenseSet<Value> *visited) {\n-  // If we've seen this value before while searching dependency, it means we\n-  // have found the first def op.\n-  if (visited && visited->count(v))\n-    return success();\n+                                    MapVector<Value, int> &depStage) {\n   if (!depStage.contains(v)) {\n-    if (visited)\n-      visited->insert(v);\n     depStage.insert(std::make_pair(v, stage));\n   } else if (depStage[v] != stage)\n     return failure();\n   return success();\n }\n \n LogicalResult LoopPipeliner::collectDeps(Value v, int stage,\n-                                         MapVector<Value, int> &depStage,\n-                                         DenseSet<Value> visited) {\n+                                         MapVector<Value, int> &depStage) {\n   // Loop-invariant value, skip\n   if (v.getParentRegion() != &forOp.getLoopBody())\n     return success();\n@@ -197,23 +188,23 @@ LogicalResult LoopPipeliner::collectDeps(Value v, int stage,\n     return success();\n \n   if (auto arg = v.dyn_cast<BlockArgument>()) {\n+    // Skip the first arg (loop induction variable)\n+    // Otherwise the op idx is arg.getArgNumber()-1\n     if (arg.getArgNumber() > 0) {\n-      // Skip the first arg (loop induction variable)\n-      // Otherwise the op idx is arg.getArgNumber()-1\n-      if (addDep(v, stage, depStage, &visited).failed())\n-        return failure();\n-      if (collectDeps(yieldOp->getOperand(arg.getArgNumber() - 1), stage - 1,\n-                      depStage, visited)\n-              .failed())\n-        return failure();\n+      // If we've found the first definition of this arg, we're done, don't\n+      // recurse\n+      if (addDep(v, stage, depStage).failed())\n+        if (collectDeps(yieldOp->getOperand(arg.getArgNumber() - 1), stage - 1,\n+                        depStage)\n+                .failed())\n+          return failure();\n     }\n   } else { // value\n-    // v might be in deps, but we still need to visit v.\n-    // This is because v might depend on value in previous iterations\n-    if (addDep(v, stage, depStage, &visited).failed())\n+    // An operation cannot be dependent on different stages\n+    if (addDep(v, stage, depStage).failed())\n       return failure();\n     for (Value op : v.getDefiningOp()->getOperands())\n-      if (collectDeps(op, stage, depStage, visited).failed())\n+      if (collectDeps(op, stage, depStage).failed())\n         return failure();\n   }\n   return success();\n@@ -291,8 +282,7 @@ LogicalResult LoopPipeliner::initialize() {\n   for (triton::LoadOp loadOp : validLoads) {\n     for (Value op : loadOp->getOperands()) {\n       MapVector<Value, int> operandDepStage;\n-      DenseSet<Value> visited;\n-      if (collectDeps(op, numStages - 1, operandDepStage, visited).failed())\n+      if (collectDeps(op, numStages - 1, operandDepStage).failed())\n         return failure();\n       for (auto [v, stage] : operandDepStage) {\n         auto immedidate = operandDepStage.front().first.isa<BlockArgument>();\n@@ -304,7 +294,7 @@ LogicalResult LoopPipeliner::initialize() {\n             nonImmediateDepArgs.insert(arg);\n         }\n         loadDeps[loadOp].insert(v);\n-        if (addDep(v, stage, depStage, nullptr).failed())\n+        if (addDep(v, stage, depStage).failed())\n           return failure();\n       }\n     }"}]