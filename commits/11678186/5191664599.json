[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM/SharedToDotOperandMMAv2.cpp", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "file_content_changes": "@@ -18,7 +18,8 @@ using ::mlir::triton::gpu::SharedEncodingAttr;\n // Data loader for mma.16816 instruction.\n class MMA16816SmemLoader {\n public:\n-  MMA16816SmemLoader(int wpt, ArrayRef<uint32_t> order, uint32_t kOrder,\n+  MMA16816SmemLoader(int wpt, ArrayRef<uint32_t> order,\n+                     ArrayRef<uint32_t> warpsPerCTA, uint32_t kOrder,\n                      int kWidth, ArrayRef<Value> smemStrides,\n                      ArrayRef<int64_t> tileShape, ArrayRef<int> instrShape,\n                      ArrayRef<int> matShape, int perPhase, int maxPhase,\n@@ -54,6 +55,7 @@ class MMA16816SmemLoader {\n \n private:\n   SmallVector<uint32_t> order;\n+  SmallVector<uint32_t> warpsPerCTA;\n   int kOrder;\n   int kWidth;\n   SmallVector<int64_t> tileShape;\n@@ -141,11 +143,13 @@ MMA16816SmemLoader::computeLdmatrixMatOffs(Value warpId, Value lane,\n   //          ~~~~~~~ out-of-bound access\n   Value sOff = urem(add(sOffInMat, mul(sMatOff, i32_val(sMatShape))),\n                     i32_val(tileShape[order[1]]));\n-  auto totalNumMats = i32_val(tileShape[order[0]] / matShape[order[0]]);\n+  auto totalNumMats = tileShape[order[0]] / matShape[order[0]];\n \n   for (int i = 0; i < numPtrs; ++i) {\n     Value cMatOffI = add(cMatOff, i32_val(i * pLoadStrideInMat));\n-    cMatOffI = urem(cMatOffI, totalNumMats);\n+    if (warpsPerCTA[order[0]] > totalNumMats ||\n+        totalNumMats % warpsPerCTA[order[0]] != 0)\n+      cMatOffI = urem(cMatOffI, i32_val(totalNumMats));\n     cMatOffI = add(cMatOffI, cSwizzleMatOff);\n     cMatOffI = xor_(cMatOffI, phase);\n     offs[i] = add(mul(cMatOffI, i32_val(cMatShape)), mul(sOff, sStride));\n@@ -366,13 +370,15 @@ MMA16816SmemLoader::loadX4(int mat0, int mat1, ArrayRef<Value> offs,\n }\n \n MMA16816SmemLoader::MMA16816SmemLoader(\n-    int wpt, ArrayRef<uint32_t> order, uint32_t kOrder, int kWidth,\n-    ArrayRef<Value> smemStrides, ArrayRef<int64_t> tileShape,\n-    ArrayRef<int> instrShape, ArrayRef<int> matShape, int perPhase,\n-    int maxPhase, int elemBytes, ConversionPatternRewriter &rewriter,\n+    int wpt, ArrayRef<uint32_t> order, ArrayRef<uint32_t> warpsPerCTA,\n+    uint32_t kOrder, int kWidth, ArrayRef<Value> smemStrides,\n+    ArrayRef<int64_t> tileShape, ArrayRef<int> instrShape,\n+    ArrayRef<int> matShape, int perPhase, int maxPhase, int elemBytes,\n+    ConversionPatternRewriter &rewriter,\n     TritonGPUToLLVMTypeConverter *typeConverter, const Location &loc)\n-    : order(order.begin(), order.end()), kOrder(kOrder), kWidth(kWidth),\n-      tileShape(tileShape.begin(), tileShape.end()),\n+    : order(order.begin(), order.end()),\n+      warpsPerCTA(warpsPerCTA.begin(), warpsPerCTA.end()), kOrder(kOrder),\n+      kWidth(kWidth), tileShape(tileShape.begin(), tileShape.end()),\n       instrShape(instrShape.begin(), instrShape.end()),\n       matShape(matShape.begin(), matShape.end()), perPhase(perPhase),\n       maxPhase(maxPhase), elemBytes(elemBytes), rewriter(rewriter), loc(loc),\n@@ -474,9 +480,9 @@ getLoadMatrixFn(Value tensor, const SharedMemoryObject &smemObj,\n   // (a, b) is the coordinate.\n   auto load = [=, &rewriter, &vals](int a, int b) {\n     MMA16816SmemLoader loader(\n-        wpt, sharedLayout.getOrder(), kOrder, kWidth, smemObj.strides,\n-        tensorTy.getShape() /*tileShape*/, instrShape, matShape, perPhase,\n-        maxPhase, elemBytes, rewriter, typeConverter, loc);\n+        wpt, sharedLayout.getOrder(), mmaLayout.getWarpsPerCTA(), kOrder,\n+        kWidth, smemObj.strides, tensorTy.getShape() /*tileShape*/, instrShape,\n+        matShape, perPhase, maxPhase, elemBytes, rewriter, typeConverter, loc);\n     Value cSwizzleOffset = smemObj.getCSwizzleOffset(order[0]);\n     SmallVector<Value> offs =\n         loader.computeOffsets(warpId, lane, cSwizzleOffset);"}]