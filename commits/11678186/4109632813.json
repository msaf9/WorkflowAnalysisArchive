[{"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "file_content_changes": "@@ -305,17 +305,20 @@ class DivOpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n \n   int64_t getDivisibility(OpTy op, const AxisInfo &lhs, const AxisInfo &rhs,\n                           int dim) override {\n-    // lhs = k * d_lhs = k * k' * gcd(d_lhs, d_rhs)\n-    // rhs = p * d_rhs = p * p' * gcd(d_lhs, d_rhs)\n-    // lhs / rhs = k * k' * gcd(d_lhs, d_rhs) / (p * p' * gcd(d_lhs, d_rhs))\n-    //           = k / p * k' / p'\n-    // gcd(k', p') = divisibility(d_lhs / gcd(d_lhs, d_rhs), d_rhs / gcd(d_lhs,\n-    // d_rhs))\n-    auto lhsDivisibility = lhs.getDivisibility(dim);\n-    auto rhsDivisibility = rhs.getDivisibility(dim);\n-    auto initGcd = gcd(lhsDivisibility, rhsDivisibility);\n-    return std::max(lhsDivisibility / initGcd, rhsDivisibility / initGcd);\n-  };\n+    // Case 1: lhs is 0\n+    if (lhs.getConstantValue().has_value() &&\n+        lhs.getConstantValue().value() == 0)\n+      return lhs.getDivisibility(dim);\n+    // Case 2: rhs is constant\n+    if (rhs.getConstantValue().has_value()) {\n+      auto lhsDivisibility = lhs.getDivisibility(dim);\n+      auto rhsValue = rhs.getConstantValue().value();\n+      if (lhsDivisibility % rhsValue == 0)\n+        return lhsDivisibility / rhsValue;\n+    }\n+    // Case 3: both are not constant\n+    return 1;\n+  }\n \n   std::optional<int64_t> getConstantValue(OpTy op, const AxisInfo &lhs,\n                                           const AxisInfo &rhs) override {"}, {"filename": "test/Analysis/test-alignment.mlir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -78,17 +78,17 @@ func @div() {\n   %1 = arith.constant dense<1> : tensor<128xi32>\n   // CHECK-NEXT: Contiguity: [128] ; Divisibility: [1073741824] ; Constancy: [1] ; ConstantValue: [None]\n   %2 = arith.divsi %0, %1 : tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [1073741824] ; Constancy: [1] ; ConstantValue: [None]\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [1] ; Constancy: [1] ; ConstantValue: [None]\n   %3 = arith.divui %1, %0 : tensor<128xi32>\n   // CHECK-NEXT: Contiguity: [1] ; Divisibility: [64] ; Constancy: [128] ; ConstantValue: [64]\n   %4 = arith.constant dense<64> : tensor<128xi32>\n   // CHECK-NEXT: Contiguity: [1] ; Divisibility: [16777216] ; Constancy: [64] ; ConstantValue: [None]\n   %5 = arith.divsi %0, %4 : tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [16777216] ; Constancy: [1] ; ConstantValue: [None]\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [1] ; Constancy: [1] ; ConstantValue: [None]\n   %6 = arith.divsi %4, %0 : tensor<128xi32>\n   // CHECK-NEXT: Contiguity: [1] ; Divisibility: [2] ; Constancy: [128] ; ConstantValue: [66]\n   %7 = arith.constant dense<66> : tensor<128xi32>\n-  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [536870912] ; Constancy: [2] ; ConstantValue: [None]\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [1] ; Constancy: [2] ; ConstantValue: [None]\n   %8 = arith.divui %0, %7 : tensor<128xi32>\n   return \n }"}]