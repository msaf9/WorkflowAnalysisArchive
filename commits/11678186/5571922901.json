[{"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -311,7 +311,6 @@ static SmallVector<Value> reorderValues(const SmallVector<Value> &values,\n     //   ret.push_back(values[i + 14]);\n     //   ret.push_back(values[i + 15]);\n     // }\n-    return values;\n   }\n   llvm_unreachable(\"unimplemented code path\");\n }"}, {"filename": "lib/Dialect/TritonGPU/Transforms/OptimizeDotOperands.cpp", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "file_content_changes": "@@ -86,6 +86,27 @@ class MoveOpAfterLayoutConversion : public mlir::RewritePattern {\n   matchAndRewrite(mlir::Operation *op,\n                   mlir::PatternRewriter &rewriter) const override {\n     auto cvt = cast<triton::gpu::ConvertLayoutOp>(op);\n+    // conversion should be dependent on a load\n+    // and all operations between the load and the conversion\n+    // should be layout preserving\n+    SetVector<Operation *> slice;\n+    getBackwardSlice(op, &slice);\n+    int loadIdx = -1;\n+    bool checkOp = false;\n+    for (int i = 0; i < slice.size(); i++) {\n+      Operation *op = *(slice.begin() + i);\n+      if (isa<triton::LoadOp>(op))\n+        checkOp = true;\n+      else if (checkOp) {\n+        if (!isa<triton::FpToFpOp, triton::BitcastOp>(op) &&\n+            op->getDialect()->getTypeID() !=\n+                mlir::TypeID::get<arith::ArithDialect>())\n+          return mlir::failure();\n+      }\n+    }\n+    if (!checkOp)\n+      return mlir::failure();\n+\n     auto cvtTy = cvt.getType().cast<RankedTensorType>();\n     auto cvtArgOp = cvt.getSrc().getDefiningOp();\n     if (!cvtArgOp || cvtArgOp->getNumOperands() == 0)"}]