[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "file_content_changes": "@@ -816,18 +816,19 @@ void LoopPipeliner::prefetchNextIteration(scf::ForOp newForOp,\n       builder.create<arith::ConstantIntOp>(nextIV.getLoc(), numStages, 32));\n \n   // Prefetch load deps\n-  // If a load-dependent instruction uses the value of a block argument, we\n-  // shouldn't the new mapping of the block argument in the next iteration.\n+  // If a load-dependent instruction that uses a block argument, we\n+  // shouldn't update the new mapping of the block argument in the current\n+  // iteration.\n   // For example.\n   // %a = add %arg0, %c\n   // %b = add %arg0, %d\n   //\n-  // Update %arg0 will cause the value of b to be incorrect.\n+  // Update %arg0 will cause the value of %b to be incorrect.\n   // We do need to use the next iteration value of %arg0 because it could be a\n   // immediate arg of a load op.\n   // load %arg0\n-  // %a = add %arg0,\n-  // %c yield %a\n+  // %a = add %arg0, %c\n+  // yield %a\n   //\n   // We reroder instructions so %a and yield are actually before load. load\n   // %arg0 should use the updated %arg0."}]