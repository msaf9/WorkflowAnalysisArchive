[{"filename": "include/triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "file_content_changes": "@@ -22,6 +22,11 @@ class TritonLLVMFunctionConversionTarget : public ConversionTarget {\n       MLIRContext &ctx, mlir::LLVMTypeConverter &typeConverter);\n };\n \n+namespace LLVM {\n+void vprintf(StringRef msg, ValueRange args,\n+             ConversionPatternRewriter &rewriter);\n+}\n+\n namespace triton {\n \n // Names for identifying different NVVM annotations. It is used as attribute"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotHelpers.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "file_content_changes": "@@ -1668,10 +1668,11 @@ Value DotOpFMAConversionHelper::loadA(\n \n   bool isARow = aOrder[0] == 1;\n \n-  int strideAM = isARow ? aShape[1] : 1;\n-  int strideAK = isARow ? 1 : aShape[0];\n-  int strideA0 = isARow ? strideAK : strideAM;\n-  int strideA1 = isARow ? strideAM : strideAK;\n+  auto aSmem = getSharedMemoryObjectFromStruct(loc, llA, rewriter);\n+  Value strideAM = aSmem.strides[aOrder[1]];\n+  Value strideAK = aSmem.strides[aOrder[0]];\n+  Value strideA0 = isARow ? strideAK : strideAM;\n+  Value strideA1 = isARow ? strideAM : strideAK;\n   int aNumPtr = 8;\n   int NK = aShape[1];\n \n@@ -1691,10 +1692,8 @@ Value DotOpFMAConversionHelper::loadA(\n   Value offA1 = isARow ? mul(threadIdM, mContig) : _0;\n   SmallVector<Value> aOff(aNumPtr);\n   for (int i = 0; i < aNumPtr; ++i) {\n-    aOff[i] = add(mul(offA0, i32_val(strideA0)), mul(offA1, i32_val(strideA1)));\n+    aOff[i] = add(mul(offA0, strideA0), mul(offA1, strideA1));\n   }\n-\n-  auto aSmem = getSharedMemoryObjectFromStruct(loc, llA, rewriter);\n   auto elemTy = A.getType().cast<RankedTensorType>().getElementType();\n \n   Type ptrTy = ptr_ty(elemTy);\n@@ -1712,8 +1711,9 @@ Value DotOpFMAConversionHelper::loadA(\n     for (unsigned m = 0; m < M; m += mShapePerCTA)\n       for (unsigned mm = 0; mm < mSizePerThread; ++mm)\n         if (!has.count({m + mm, k})) {\n-          Value pa = gep(ptrTy, aPtrs[0],\n-                         i32_val((m + mm) * strideAM + k * strideAK));\n+          Value offset =\n+              add(mul(i32_val(m + mm), strideAM), mul(i32_val(k), strideAK));\n+          Value pa = gep(ptrTy, aPtrs[0], offset);\n           Value va = load(pa);\n           has[{m + mm, k}] = va;\n         }\n@@ -1735,10 +1735,11 @@ Value DotOpFMAConversionHelper::loadB(\n \n   bool isBRow = bOrder[0] == 1;\n \n-  int strideBN = isBRow ? 1 : bShape[0];\n-  int strideBK = isBRow ? bShape[1] : 1;\n-  int strideB0 = isBRow ? strideBN : strideBK;\n-  int strideB1 = isBRow ? strideBK : strideBN;\n+  auto bSmem = getSharedMemoryObjectFromStruct(loc, llB, rewriter);\n+  Value strideBN = bSmem.strides[bOrder[0]];\n+  Value strideBK = bSmem.strides[bOrder[1]];\n+  Value strideB0 = isBRow ? strideBN : strideBK;\n+  Value strideB1 = isBRow ? strideBK : strideBN;\n   int bNumPtr = 8;\n   int NK = bShape[0];\n \n@@ -1757,10 +1758,8 @@ Value DotOpFMAConversionHelper::loadB(\n   Value offB1 = isBRow ? _0 : mul(threadIdN, nContig);\n   SmallVector<Value> bOff(bNumPtr);\n   for (int i = 0; i < bNumPtr; ++i) {\n-    bOff[i] = add(mul(offB0, i32_val(strideB0)), mul(offB1, i32_val(strideB1)));\n+    bOff[i] = add(mul(offB0, strideB0), mul(offB1, strideB1));\n   }\n-\n-  auto bSmem = getSharedMemoryObjectFromStruct(loc, llB, rewriter);\n   auto elemTy = B.getType().cast<RankedTensorType>().getElementType();\n \n   Type ptrTy = ptr_ty(elemTy);\n@@ -1777,8 +1776,9 @@ Value DotOpFMAConversionHelper::loadB(\n   for (unsigned k = 0; k < NK; ++k)\n     for (unsigned n = 0; n < N; n += nShapePerCTA)\n       for (unsigned nn = 0; nn < nSizePerThread; ++nn) {\n-        Value pb = gep(ptrTy, bPtrs[0],\n-                       i32_val((n + nn) * strideBN + k * strideBK));\n+        Value offset =\n+            add(mul(i32_val(n + nn), strideBN), mul(i32_val(k), strideBK));\n+        Value pb = gep(ptrTy, bPtrs[0], offset);\n         Value vb = load(pb);\n         hbs[{n + nn, k}] = vb;\n       }"}]