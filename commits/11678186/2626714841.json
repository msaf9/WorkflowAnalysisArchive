[{"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "file_content_changes": "@@ -1285,20 +1285,43 @@ void generator::visit_atomic_rmw_inst(ir::atomic_rmw_inst *atom) {\n \n   // vector size\n   int vec = 1;\n+  Value *mask = builder_->getInt1(true);\n   if(atom->get_type()->is_block_ty()){\n+    auto shape = atom->get_type()->get_block_shapes();\n     int ld = ords_.at(ptr)[0];\n     unsigned alignment = alignment_->get(ptr, ld);\n     vec = std::min<int>(layouts_->get(ptr)->to_scanline()->nts(ld), alignment);\n     vec = std::min(vec, val->get_type()->get_tile_element_ty()->is_fp16_ty() ? 2 : 1);\n+    // mask out inactive threads\n+    analysis::data_layout* layout = layouts_->get(val);\n+    auto curr_axes = a_axes_->get(val);\n+    auto layt_axes = layout->get_axes();\n+    for(unsigned k = 0; k < layt_axes.size(); k++){\n+      unsigned ax = layt_axes.at(k);\n+      distributed_axis dax = axes_.at(ax);\n+      // axis is part of the original layout: thread id should be 0\n+      // but not the current layout\n+      if(std::find(curr_axes.begin(), curr_axes.end(), ax) == curr_axes.end())\n+        mask = and_(mask, icmp_eq(dax.thread_id, i32(0)));\n+    }\n+    // last axis may spillover\n+    Value *thread_id = tgt_->get_local_id(mod_, *builder_, 0);\n+    int per_thread = 1;\n+    for(int ax: layt_axes) { per_thread *= axes_.at(ax).contiguous; }\n+    int numel = 1;\n+    for(int s: layout->get_shape()) { numel *= s; }\n+    mask = and_(mask, icmp_ult(mul(thread_id, i32(per_thread)), i32(numel)));\n   }\n \n+\n   for(int i = 0; i < idxs_.at(val).size(); i += vec){\n     auto idx = idxs_[val][i];\n     Value *rmw_val = UndefValue::get(vec_ty(vals_[val][idx]->getType(), vec));\n     for(int ii = 0; ii < vec; ii++)\n       rmw_val = insert_elt(rmw_val, vals_[val][idxs_[val][i+ii]], ii);\n     Value *rmw_ptr = vals_[ptr][idx];\n     Value *rmw_msk = vals_[msk][idx];\n+    rmw_msk = and_(rmw_msk, mask);\n     if(vec == 1)\n       rmw_val = extract_elt(rmw_val, i32(0));\n     Type* ty = rmw_val->getType();\n@@ -3400,36 +3423,36 @@ void generator::visit_layout_mma(analysis::mma_layout* layout) {\n }\n \n void generator::visit_layout_scanline(analysis::scanline_layout* layout) {\n-  Value* u_thread_id = tgt_->get_local_id(mod_, *builder_, 0);\n+  Value* thread_id = tgt_->get_local_id(mod_, *builder_, 0);\n   auto order = layout->get_order();\n   const auto& shape = layout->get_shape();\n   // Delinearize\n   size_t dim = shape.size();\n-  std::vector<Value*> thread_id(dim);\n+  std::vector<Value*> thread_ids(dim);\n   for(unsigned k = 0; k < dim - 1; k++){\n     Constant *dim_k = i32(layout->mts(order[k]));\n-    Value *rem = urem(u_thread_id, dim_k);\n-    u_thread_id = udiv(u_thread_id, dim_k);\n-    thread_id[order[k]] = rem;\n+    Value *rem = urem(thread_id, dim_k);\n+    thread_id = udiv(thread_id, dim_k);\n+    thread_ids[order[k]] = rem;\n   }\n   Constant *dim_k = i32(layout->mts(order[dim - 1]));\n-  thread_id[order[dim - 1]] = urem(u_thread_id, dim_k);\n+  thread_ids[order[dim - 1]] = urem(thread_id, dim_k);\n \n   // Create axes\n   for(unsigned k = 0; k < dim; k++) {\n     int nts = layout->nts(k);\n     int mts = layout->mts(k);\n     std::string str_k = std::to_string(k);\n     Value *contiguous_k = i32(nts);\n-    Value *scaled_thread_id = mul(thread_id[k], contiguous_k);\n+    Value *scaled_thread_ids = mul(thread_ids[k], contiguous_k);\n     unsigned per_cta  = layout->shape_per_cta(k);\n     unsigned per_thread = nts * shape[k] / per_cta;\n     std::vector<Value*> idx_list(per_thread);\n     for(unsigned n = 0 ; n < per_thread; n++){\n       unsigned offset = n / nts * per_cta + n % nts;\n-      idx_list[n] = add(scaled_thread_id, i32(offset), \"idx_\" + str_k + \"_\" + std::to_string(n));\n+      idx_list[n] = add(scaled_thread_ids, i32(offset), \"idx_\" + str_k + \"_\" + std::to_string(n));\n     }\n-    axes_[layout->get_axis(k)] = distributed_axis{nts, idx_list, thread_id[k]};\n+    axes_[layout->get_axis(k)] = distributed_axis{nts, idx_list, thread_ids[k]};\n   }\n }\n "}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "file_content_changes": "@@ -531,6 +531,27 @@ def kernel(X, Z):\n     else:\n         np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01)\n \n+@pytest.mark.parametrize(\"axis\", [0, 1])\n+def test_tensor_atomic_rmw(axis, device=\"cuda\"):\n+    shape0, shape1 = 8, 8\n+    # triton kernel\n+    @triton.jit\n+    def kernel(Z, X, AXIS: tl.constexpr, SHAPE0: tl.constexpr, SHAPE1: tl.constexpr):\n+        off0 = tl.arange(0, SHAPE0)\n+        off1 = tl.arange(0, SHAPE1)\n+        x = tl.load(X + off0[:, None]*SHAPE1 + off1[None, :])\n+        z = tl.sum(x, axis=AXIS)\n+        tl.atomic_add(Z + off0, z)\n+    rs = RandomState(17)\n+    x = numpy_random((shape0, shape1), dtype_str=\"float32\", rs=rs)\n+    # reference result\n+    z_ref = np.sum(x, axis=axis)\n+    # triton result\n+    x_tri = to_triton(x, device=device)\n+    z_tri = to_triton(np.zeros((shape0,), dtype=\"float32\"), device=device)\n+    kernel[(1,)](z_tri, x_tri, axis, shape0, shape1)\n+    np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=1e-4)\n+\n \n def test_atomic_cas():\n     # 1. make sure that atomic_cas changes the original value (Lock)"}]