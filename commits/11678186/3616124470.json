[{"filename": "lib/Conversion/TritonGPUToLLVM/DotHelpers.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "file_content_changes": "@@ -40,14 +40,6 @@ using ::mlir::triton::gpu::MmaEncodingAttr;\n using ::mlir::triton::gpu::SharedEncodingAttr;\n Value gThreadId;\n \n-// Forward declaration for functions from TritonGPUToLLVM.cpp\n-void llPrintf(StringRef msg, ValueRange args,\n-              ConversionPatternRewriter &rewriter);\n-#define vprintf LLVM::llPrintf\n-\n-void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n-                   std::string elem_repr, ConversionPatternRewriter &builder);\n-\n // Helper for conversion of DotOp with mma<version=1>, that is sm<80\n struct DotOpMmaV1ConversionHelper {\n   MmaEncodingAttr mmaLayout;\n@@ -1343,8 +1335,6 @@ Value DotOpMmaV1ConversionHelper::loadA(\n \n   Value cSwizzleOffset = smemObj.getCSwizzleOffset(order[0]);\n   Value smemBase = smemObj.getBaseBeforeSwizzle(order[0], loc, rewriter);\n-  // Value smemBase = gep(ptr_ty(f16_ty), smemBaseBeforeSwizzle,\n-  // cSwizzleOffset);\n \n   bool isARow = order[0] != 0;\n   bool isAVec4 = !isARow && shape[order[0]] <= 16; // fp16*4 = 16bytes\n@@ -1389,7 +1379,7 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   Value offA0 = isARow ? offsetAK : offsetAM;\n   Value offA1 = isARow ? offsetAM : offsetAK;\n   Value phaseA = urem(udiv(offA1, i32_val(perPhaseA)), i32_val(maxPhaseA));\n-  // offA0 = add(offA0, cSwizzleOffset);\n+  offA0 = add(offA0, cSwizzleOffset);\n   SmallVector<Value> offA(numPtrA);\n   for (int i = 0; i < numPtrA; i++) {\n     Value offA0I = add(offA0, i32_val(i * (isARow ? 4 : strideRepM)));"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "file_content_changes": "@@ -62,23 +62,11 @@ namespace LLVM {\n static StringRef getStructAttrsAttrName() { return \"llvm.struct_attrs\"; }\n \n // A helper function for using printf in LLVM conversion.\n-void llPrintf(StringRef msg, ValueRange args,\n-              ConversionPatternRewriter &rewriter);\n-void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n-                   std::string elem_repr, ConversionPatternRewriter &builder) {\n-  std::string fmt = info + \" t-%d \";\n-  std::vector<Value> new_arr({thread});\n-  for (auto v : arr) {\n-    fmt += elem_repr + \", \";\n-    new_arr.push_back(v);\n-  }\n-  fmt += \"\";\n+void vprintf(StringRef msg, ValueRange args,\n+             ConversionPatternRewriter &rewriter);\n \n-  vprintf(fmt, new_arr, builder);\n-}\n-\n-// Helper function\n-#define llprintf(fmt, ...) LLVM::llPrintf(fmt, {__VA_ARGS__}, rewriter)\n+void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n+                   std::string elem_repr, ConversionPatternRewriter &builder);\n \n } // namespace LLVM\n } // namespace mlir\n@@ -4824,11 +4812,23 @@ namespace mlir {\n \n namespace LLVM {\n \n-void llPrintf(StringRef msg, ValueRange args,\n-              ConversionPatternRewriter &rewriter) {\n+void vprintf(StringRef msg, ValueRange args,\n+             ConversionPatternRewriter &rewriter) {\n   PrintfOpConversion::llPrintf(msg, args, rewriter);\n }\n \n+void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n+                   std::string elem_repr, ConversionPatternRewriter &builder) {\n+  std::string fmt = info + \" t-%d \";\n+  std::vector<Value> new_arr({thread});\n+  for (int i = 0; i < arr.size(); ++i) {\n+    fmt += elem_repr + ((i == arr.size() - 1) ? \"\" : \", \");\n+    new_arr.push_back(arr[i]);\n+  }\n+\n+  vprintf(fmt, new_arr, builder);\n+}\n+\n } // namespace LLVM\n \n TritonLLVMConversionTarget::TritonLLVMConversionTarget("}]