[{"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 309, "deletions": 293, "changes": 602, "file_content_changes": "@@ -1,27 +1,27 @@\n /* Copyright 2015-2017 Philippe Tillet\n-*\n-* Permission is hereby granted, free of charge, to any person obtaining\n-* a copy of this software and associated documentation files\n-* (the \"Software\"), to deal in the Software without restriction,\n-* including without limitation the rights to use, copy, modify, merge,\n-* publish, distribute, sublicense, and/or sell copies of the Software,\n-* and to permit persons to whom the Software is furnished to do so,\n-* subject to the following conditions:\n-*\n-* The above copyright notice and this permission notice shall be\n-* included in all copies or substantial portions of the Software.\n-*\n-* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n-* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n-* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n-* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n-* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n-* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n-*/\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining\n+ * a copy of this software and associated documentation files\n+ * (the \"Software\"), to deal in the Software without restriction,\n+ * including without limitation the rights to use, copy, modify, merge,\n+ * publish, distribute, sublicense, and/or sell copies of the Software,\n+ * and to permit persons to whom the Software is furnished to do so,\n+ * subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be\n+ * included in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ */\n #include <fstream>\n #if __has_include(<unistd.h>)\n-    #include <unistd.h>\n+#include <unistd.h>\n #endif\n #include <memory>\n #include <regex>\n@@ -59,302 +59,318 @@\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n // end AMD stuff\n \n-extern \"C\"{\n-  int set_curterm(char* nterm){ return 0; }\n-  int del_curterm(char* nterm){ return 0; }\n+extern \"C\"\n+{\n+  int set_curterm(char *nterm) { return 0; }\n+  int del_curterm(char *nterm) { return 0; }\n   int tigetnum(char *capname) { return 0; }\n   int setupterm(char *term, int fildes, int *errret) { return 0; }\n }\n \n-namespace triton{\n-namespace driver{\n-\n-void init_llvm() {\n-  LLVMInitializeNVPTXTargetInfo();\n-  LLVMInitializeNVPTXTarget();\n-  LLVMInitializeNVPTXTargetMC();\n-  LLVMInitializeNVPTXAsmPrinter();\n-  LLVMInitializeAMDGPUTargetInfo();\n-  LLVMInitializeAMDGPUTarget();\n-  LLVMInitializeAMDGPUTargetMC();\n-  LLVMInitializeAMDGPUAsmPrinter();\n-}\n-\n-\n-/* ------------------------ */\n-//         CUDA             //\n-/* ------------------------ */\n-static bool find_and_replace(std::string& str, const std::string& begin, const std::string& end, const std::string& target){\n-  size_t start_replace = str.find(begin);\n-  size_t end_replace = str.find(end, start_replace);\n-  if(start_replace == std::string::npos)\n-    return false;\n-  str.replace(start_replace, end_replace + 1 - start_replace, target);\n-  return true;\n-}\n+namespace triton\n+{\n+  namespace driver\n+  {\n \n-std::string path_to_ptxas(int& version) {\n-  std::vector<std::string> rets;\n-  std::string ret;\n-  // search paths for ptxas\n-  std::vector<std::string> ptxas_prefixes = {\"\", \"/usr/local/cuda/bin/\"};\n-  std::string triton_ptxas = tools::getenv(\"TRITON_PTXAS_PATH\");\n-  if(!triton_ptxas.empty())\n-    ptxas_prefixes.insert(ptxas_prefixes.begin(), triton_ptxas);\n-  // see what path for ptxas are valid\n-  std::vector<std::string> working_ptxas;\n-  for(std::string prefix: ptxas_prefixes){\n-    std::string ptxas = prefix + \"ptxas\";\n-    bool works = tools::exec(ptxas + \" --version 2>&1\", ret) == 0;\n-    if(works) {\n-      working_ptxas.push_back(ptxas);\n-      rets.push_back(ret);\n+    void init_llvm()\n+    {\n+      LLVMInitializeNVPTXTargetInfo();\n+      LLVMInitializeNVPTXTarget();\n+      LLVMInitializeNVPTXTargetMC();\n+      LLVMInitializeNVPTXAsmPrinter();\n+      LLVMInitializeAMDGPUTargetInfo();\n+      LLVMInitializeAMDGPUTarget();\n+      LLVMInitializeAMDGPUTargetMC();\n+      LLVMInitializeAMDGPUAsmPrinter();\n     }\n-  }\n-  // error if no working ptxas was found\n-  if(working_ptxas.empty())\n-    throw std::runtime_error(\"`ptxas` was searched in TRITON_PTXAS_PATH, /usr/local/cuda/bin/ or PATH\"\n-                             \" but a working version could not be found.\");\n-  std::string ptxas = working_ptxas.front();\n-  // parse version\n-  std::regex version_regex(\"release (\\\\d+)\\\\.(\\\\d+)\");\n-  std::smatch match;\n-  bool found = false;\n-  // currently choosing the first ptxas. Other logics can be implemented in future\n-  for(std::string ret : rets) {\n-    if(std::regex_search(ret, match, version_regex)){\n-      int major = std::stoi(match[1]);\n-      int minor = std::stoi(match[2]);\n-      version = major*1000 + minor*10;\n-      found = true;\n-      break;\n-    }\n-  }\n-  if ( not found) {\n-    throw std::runtime_error(\"Error in parsing version\");\n-  }\n-  return ptxas;\n-}\n-\n \n-int vptx(int version){\n-  if(version >= 11040) return 74;\n-  if(version >= 11030) return 73;\n-  if(version >= 11020) return 72;\n-  if(version >= 11010) return 71;\n-  if(version >= 11000) return 70;\n-  if(version >= 10020) return 65;\n-  if(version >= 10010) return 64;\n-  if(version >= 10000) return 63;\n-  throw std::runtime_error(\"Triton requires CUDA 10+\");\n-}\n+    /* ------------------------ */\n+    //         CUDA             //\n+    /* ------------------------ */\n+    static bool find_and_replace(std::string &str, const std::string &begin, const std::string &end, const std::string &target)\n+    {\n+      size_t start_replace = str.find(begin);\n+      size_t end_replace = str.find(end, start_replace);\n+      if (start_replace == std::string::npos)\n+        return false;\n+      str.replace(start_replace, end_replace + 1 - start_replace, target);\n+      return true;\n+    }\n \n-std::string llir_to_ptx(llvm::Module* module, int cc, int version){\n-  // LLVM version in use may not officially support target hardware\n-  int max_nvvm_cc = 75;\n-  int max_nvvm_ptx = 74;\n-  // options\n-  auto options = llvm::cl::getRegisteredOptions();\n-  auto* short_ptr = static_cast<llvm::cl::opt<bool>*>(options[\"nvptx-short-ptr\"]);\n-  assert(short_ptr);\n-  short_ptr->setValue(true);\n-  // compute capability\n-  std::string sm = \"sm_\" + std::to_string(cc);\n-  // max PTX version\n-  int ptx = vptx(version);\n-  int ptx_major = ptx / 10;\n-  int ptx_minor = ptx % 10;\n-  // create\n-  llvm::SmallVector<char, 0> buffer;\n-  std::string triple = \"nvptx64-nvidia-cuda\";\n-  std::string proc = \"sm_\" + std::to_string(std::min(cc, max_nvvm_cc));\n-  std::string layout = \"\";\n-  std::string features = \"\";\n-  // std::string features = \"+ptx\" + std::to_string(std::min(ptx, max_nvvm_ptx));\n-  init_llvm();\n-  // verify and store llvm\n-  llvm::legacy::PassManager pm;\n-//  pm.add(llvm::createPrintModulePass(llvm::outs()));\n-  pm.add(llvm::createVerifierPass());\n-  pm.run(*module);\n-  // module->print(llvm::outs(), nullptr);\n+    std::string path_to_ptxas(int &version)\n+    {\n+      std::vector<std::string> rets;\n+      std::string ret;\n+      // search paths for ptxas\n+      std::vector<std::string> ptxas_prefixes = {\"\", \"/usr/local/cuda/bin/\"};\n+      std::string triton_ptxas = tools::getenv(\"TRITON_PTXAS_PATH\");\n+      if (!triton_ptxas.empty())\n+        ptxas_prefixes.insert(ptxas_prefixes.begin(), triton_ptxas);\n+      // see what path for ptxas are valid\n+      std::vector<std::string> working_ptxas;\n+      for (std::string prefix : ptxas_prefixes)\n+      {\n+        std::string ptxas = prefix + \"ptxas\";\n+        bool works = tools::exec(ptxas + \" --version 2>&1\", ret) == 0;\n+        if (works)\n+        {\n+          working_ptxas.push_back(ptxas);\n+          rets.push_back(ret);\n+        }\n+      }\n+      // error if no working ptxas was found\n+      if (working_ptxas.empty())\n+        throw std::runtime_error(\"`ptxas` was searched in TRITON_PTXAS_PATH, /usr/local/cuda/bin/ or PATH\"\n+                                 \" but a working version could not be found.\");\n+      std::string ptxas = working_ptxas.front();\n+      // parse version\n+      std::regex version_regex(\"release (\\\\d+)\\\\.(\\\\d+)\");\n+      std::smatch match;\n+      bool found = false;\n+      // currently choosing the first ptxas. Other logics can be implemented in future\n+      for (std::string ret : rets)\n+      {\n+        if (std::regex_search(ret, match, version_regex))\n+        {\n+          int major = std::stoi(match[1]);\n+          int minor = std::stoi(match[2]);\n+          version = major * 1000 + minor * 10;\n+          found = true;\n+          break;\n+        }\n+      }\n+      if (not found)\n+      {\n+        throw std::runtime_error(\"Error in parsing version\");\n+      }\n+      return ptxas;\n+    }\n \n-  // create machine\n-  module->setTargetTriple(triple);\n-  std::string error;\n-  llvm::TargetMachine* machine;\n-  auto target = llvm::TargetRegistry::lookupTarget(module->getTargetTriple(), error);\n-  llvm::TargetOptions opt;\n-  opt.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n-  opt.UnsafeFPMath = false;\n-  opt.NoInfsFPMath = false;\n-  opt.NoNaNsFPMath = true;\n-  machine = target->createTargetMachine(module->getTargetTriple(), proc, features, opt,\n-                                                             llvm::Reloc::PIC_, llvm::None, llvm::CodeGenOpt::Aggressive);\n-  // set data layout\n-  if(layout.empty())\n-    module->setDataLayout(machine->createDataLayout());\n-  else\n-    module->setDataLayout(layout);\n-  // emit machine code\n-  for (llvm::Function &f : module->functions())\n-    f.addFnAttr(llvm::Attribute::AlwaysInline);\n-  llvm::legacy::PassManager pass;\n-  llvm::raw_svector_ostream stream(buffer);\n-  // emit\n-  machine->addPassesToEmitFile(pass, stream, nullptr, llvm::CodeGenFileType::CGFT_AssemblyFile);\n-  pass.run(*module);\n+    int vptx(int version)\n+    {\n+      if (version >= 11040)\n+        return 74;\n+      // if(version >= 11030) return 73;\n+      // if(version >= 11020) return 72;\n+      // if(version >= 11010) return 71;\n+      // if(version >= 11000) return 70;\n+      // if(version >= 10020) return 65;\n+      // if(version >= 10010) return 64;\n+      // if(version >= 10000) return 63;\n+      throw std::runtime_error(\"Triton requires CUDA 11.4+\");\n+    }\n \n-  // post-process\n-  std::string result(buffer.begin(), buffer.end());\n-  find_and_replace(result, \".version\", \"\\n\", \".version \" + std::to_string(ptx_major) + \".\" + std::to_string(ptx_minor) + \"\\n\");\n-  find_and_replace(result, \".target\", \"\\n\", \".target \" + sm + \"\\n\");\n-  while(find_and_replace(result, \"\\t// begin inline asm\", \"\\n\", \"\"));\n-  while(find_and_replace(result, \"\\t// end inline asm\", \"\\n\", \"\"));\n-  return result;\n-}\n+    std::string llir_to_ptx(llvm::Module *module, int cc, int version)\n+    {\n+      // LLVM version in use may not officially support target hardware\n+      int max_nvvm_cc = 75;\n+      int max_nvvm_ptx = 74;\n+      // options\n+      auto options = llvm::cl::getRegisteredOptions();\n+      auto *short_ptr = static_cast<llvm::cl::opt<bool> *>(options[\"nvptx-short-ptr\"]);\n+      assert(short_ptr);\n+      short_ptr->setValue(true);\n+      // compute capability\n+      std::string sm = \"sm_\" + std::to_string(cc);\n+      // max PTX version\n+      int ptx = vptx(version);\n+      int ptx_major = ptx / 10;\n+      int ptx_minor = ptx % 10;\n+      // create\n+      llvm::SmallVector<char, 0> buffer;\n+      std::string triple = \"nvptx64-nvidia-cuda\";\n+      std::string proc = \"sm_\" + std::to_string(std::min(cc, max_nvvm_cc));\n+      std::string layout = \"\";\n+      std::string features = \"\";\n+      // std::string features = \"+ptx\" + std::to_string(std::min(ptx, max_nvvm_ptx));\n+      init_llvm();\n+      // verify and store llvm\n+      llvm::legacy::PassManager pm;\n+      //  pm.add(llvm::createPrintModulePass(llvm::outs()));\n+      pm.add(llvm::createVerifierPass());\n+      pm.run(*module);\n+      // module->print(llvm::outs(), nullptr);\n \n+      // create machine\n+      module->setTargetTriple(triple);\n+      std::string error;\n+      llvm::TargetMachine *machine;\n+      auto target = llvm::TargetRegistry::lookupTarget(module->getTargetTriple(), error);\n+      llvm::TargetOptions opt;\n+      opt.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n+      opt.UnsafeFPMath = false;\n+      opt.NoInfsFPMath = false;\n+      opt.NoNaNsFPMath = true;\n+      machine = target->createTargetMachine(module->getTargetTriple(), proc, features, opt,\n+                                            llvm::Reloc::PIC_, llvm::None, llvm::CodeGenOpt::Aggressive);\n+      // set data layout\n+      if (layout.empty())\n+        module->setDataLayout(machine->createDataLayout());\n+      else\n+        module->setDataLayout(layout);\n+      // emit machine code\n+      for (llvm::Function &f : module->functions())\n+        f.addFnAttr(llvm::Attribute::AlwaysInline);\n+      llvm::legacy::PassManager pass;\n+      llvm::raw_svector_ostream stream(buffer);\n+      // emit\n+      machine->addPassesToEmitFile(pass, stream, nullptr, llvm::CodeGenFileType::CGFT_AssemblyFile);\n+      pass.run(*module);\n \n-std::string ptx_to_cubin(const std::string& ptx, const std::string& ptxas, int cc) {\n-  // compile ptx with ptxas\n-  char _fsrc[L_tmpnam];\n-  char _flog[L_tmpnam];\n-  std::tmpnam(_fsrc);\n-  std::tmpnam(_flog);\n-  std::string fsrc = _fsrc;\n-  std::string flog = _flog;\n-  std::string fbin = fsrc + \".o\";\n-  const char* _fbin = fbin.c_str();\n-  std::ofstream ofs(fsrc);\n-  ofs << ptx << std::endl;\n-  ofs.close();\n-  std::string cmd;\n-  int err;\n-  cmd = ptxas + \" -v --gpu-name=sm_\" + std::to_string(cc) + \" \" + fsrc + \" -o \" + fsrc + \".o 2> \" + flog;\n-  err = system(cmd.c_str());\n-  if(err != 0){\n-    std::ifstream _log(_flog);\n-    std::string log(std::istreambuf_iterator<char>(_log), {});\n-    unlink(_fsrc);\n-    unlink(_flog);\n-    throw std::runtime_error(\"Internal Triton PTX codegen error: \\n\" + log);\n-  }\n-  std::ifstream _cubin(_fbin, std::ios::binary );\n-  std::string cubin(std::istreambuf_iterator<char>(_cubin), {});\n-  _cubin.close();\n-  unlink(_fsrc);\n-  unlink(_flog);\n-  unlink(_fbin);\n-  return cubin;\n-}\n+      // post-process\n+      std::string result(buffer.begin(), buffer.end());\n+      find_and_replace(result, \".version\", \"\\n\", \".version \" + std::to_string(ptx_major) + \".\" + std::to_string(ptx_minor) + \"\\n\");\n+      find_and_replace(result, \".target\", \"\\n\", \".target \" + sm + \"\\n\");\n+      while (find_and_replace(result, \"\\t// begin inline asm\", \"\\n\", \"\"))\n+        ;\n+      while (find_and_replace(result, \"\\t// end inline asm\", \"\\n\", \"\"))\n+        ;\n+      return result;\n+    }\n \n-/* ------------------------ */\n-//         HIP              //\n-/* ------------------------ */\n+    std::string ptx_to_cubin(const std::string &ptx, const std::string &ptxas, int cc)\n+    {\n+      // compile ptx with ptxas\n+      char _fsrc[L_tmpnam];\n+      char _flog[L_tmpnam];\n+      std::tmpnam(_fsrc);\n+      std::tmpnam(_flog);\n+      std::string fsrc = _fsrc;\n+      std::string flog = _flog;\n+      std::string fbin = fsrc + \".o\";\n+      const char *_fbin = fbin.c_str();\n+      std::ofstream ofs(fsrc);\n+      ofs << ptx << std::endl;\n+      ofs.close();\n+      std::string cmd;\n+      int err;\n+      cmd = ptxas + \" -v --gpu-name=sm_\" + std::to_string(cc) + \" \" + fsrc + \" -o \" + fsrc + \".o 2> \" + flog;\n+      err = system(cmd.c_str());\n+      if (err != 0)\n+      {\n+        std::ifstream _log(_flog);\n+        std::string log(std::istreambuf_iterator<char>(_log), {});\n+        unlink(_fsrc);\n+        unlink(_flog);\n+        throw std::runtime_error(\"Internal Triton PTX codegen error: \\n\" + log);\n+      }\n+      std::ifstream _cubin(_fbin, std::ios::binary);\n+      std::string cubin(std::istreambuf_iterator<char>(_cubin), {});\n+      _cubin.close();\n+      unlink(_fsrc);\n+      unlink(_flog);\n+      unlink(_fbin);\n+      return cubin;\n+    }\n \n-std::string llir_to_amdgpu(llvm::Module* module, const std::string& _proc) {\n-  init_llvm();\n+    /* ------------------------ */\n+    //         HIP              //\n+    /* ------------------------ */\n \n-//  proc = std::get<0>(GetFeatureStrFromGCNArchName(rocminfo));\n-//  features = std::get<1>(GetFeatureStrFromGCNArchName(rocminfo));\n+    std::string llir_to_amdgpu(llvm::Module *module, const std::string &_proc)\n+    {\n+      init_llvm();\n \n-  // create\n-  llvm::SmallVector<char, 0> buffer;\n-  std::string triple = \"amdgcn-amd-amdhsa\";\n-  std::string layout = \"\";\n-  std::string features;\n-  std::string proc = \"gfx908\";\n-  // verify and store llvm\n-  llvm::legacy::PassManager pm;\n-  pm.add(llvm::createVerifierPass());\n-  pm.run(*module);\n-  // create machine\n-  module->setTargetTriple(triple);\n-  std::string error;\n-  auto target = llvm::TargetRegistry::lookupTarget(module->getTargetTriple(), error);\n-  llvm::TargetOptions opt;\n-  opt.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n-  opt.UnsafeFPMath = false;\n-  opt.NoInfsFPMath = false;\n-  opt.NoNaNsFPMath = true;\n-  llvm::TargetMachine *machine = target->createTargetMachine(module->getTargetTriple(), proc, features, opt,\n-                                                             llvm::Reloc::PIC_, llvm::None,\n-                                                             llvm::CodeGenOpt::Aggressive);\n-  // set data layout\n-  if(layout.empty())\n-    module->setDataLayout(machine->createDataLayout());\n-  else\n-    module->setDataLayout(layout);\n-  // emit machine code\n-  for (llvm::Function &f : module->functions())\n-    f.addFnAttr(llvm::Attribute::AlwaysInline);\n-  llvm::legacy::PassManager pass;\n-  llvm::raw_svector_ostream stream(buffer);\n+      //  proc = std::get<0>(GetFeatureStrFromGCNArchName(rocminfo));\n+      //  features = std::get<1>(GetFeatureStrFromGCNArchName(rocminfo));\n \n-  // create dump files\n-  std::string module_name = module->getModuleIdentifier();\n-  std::error_code ec;\n+      // create\n+      llvm::SmallVector<char, 0> buffer;\n+      std::string triple = \"amdgcn-amd-amdhsa\";\n+      std::string layout = \"\";\n+      std::string features;\n+      std::string proc = \"gfx908\";\n+      // verify and store llvm\n+      llvm::legacy::PassManager pm;\n+      pm.add(llvm::createVerifierPass());\n+      pm.run(*module);\n+      // create machine\n+      module->setTargetTriple(triple);\n+      std::string error;\n+      auto target = llvm::TargetRegistry::lookupTarget(module->getTargetTriple(), error);\n+      llvm::TargetOptions opt;\n+      opt.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n+      opt.UnsafeFPMath = false;\n+      opt.NoInfsFPMath = false;\n+      opt.NoNaNsFPMath = true;\n+      llvm::TargetMachine *machine = target->createTargetMachine(module->getTargetTriple(), proc, features, opt,\n+                                                                 llvm::Reloc::PIC_, llvm::None,\n+                                                                 llvm::CodeGenOpt::Aggressive);\n+      // set data layout\n+      if (layout.empty())\n+        module->setDataLayout(machine->createDataLayout());\n+      else\n+        module->setDataLayout(layout);\n+      // emit machine code\n+      for (llvm::Function &f : module->functions())\n+        f.addFnAttr(llvm::Attribute::AlwaysInline);\n+      llvm::legacy::PassManager pass;\n+      llvm::raw_svector_ostream stream(buffer);\n \n-  // Save GCN ISA binary.\n-  std::string isabin_path = std::string(\"/tmp/\") + module_name + std::string(\".o\");\n-  std::unique_ptr<llvm::raw_fd_ostream> isabin_fs(\n-      new llvm::raw_fd_ostream(isabin_path, ec, llvm::sys::fs::OF_Text));\n-  if (ec)\n-  {\n-    std::cout << isabin_path << \" was not created. error code: \" << ec << std::endl;\n-  }\n+      // create dump files\n+      std::string module_name = module->getModuleIdentifier();\n+      std::error_code ec;\n \n-  // emit\n-  machine->addPassesToEmitFile(pass, *isabin_fs, nullptr, llvm::CGFT_ObjectFile);\n-  pass.run(*module);\n-  // Save GCN ISA.\n-  std::string amdgcn_path = std::string(\"/tmp/\") + module_name + std::string(\".gcn\");\n-  std::string result(buffer.begin(), buffer.end());\n-  std::ofstream amdgcn(amdgcn_path);\n-  amdgcn << result;\n-  amdgcn.close();\n+      // Save GCN ISA binary.\n+      std::string isabin_path = std::string(\"/tmp/\") + module_name + std::string(\".o\");\n+      std::unique_ptr<llvm::raw_fd_ostream> isabin_fs(\n+          new llvm::raw_fd_ostream(isabin_path, ec, llvm::sys::fs::OF_Text));\n+      if (ec)\n+      {\n+        std::cout << isabin_path << \" was not created. error code: \" << ec << std::endl;\n+      }\n \n-  // generate HASCO file\n-  std::string hsaco_path = std::string(\"/tmp/\") + module_name + std::string(\".hsaco\");\n-  std::string error_message;\n-  int lld_result =\n-      llvm::sys::ExecuteAndWait(\"/opt/rocm/llvm/bin/ld.lld\",\n-                                {\"/opt/rocm/llvm/bin/ld.lld\", \"-flavor\", \"gnu\", \"-shared\", \"-o\", hsaco_path, isabin_path},\n-                                llvm::None, {}, 0, 0, &error_message);\n-  if (lld_result)\n-  {\n-    std::cout << \"ld.lld execute fail: \" << std::endl;\n-    std::cout << error_message << std::endl;\n-    std::cout << lld_result << std::endl;\n-  }\n+      // emit\n+      machine->addPassesToEmitFile(pass, *isabin_fs, nullptr, llvm::CGFT_ObjectFile);\n+      pass.run(*module);\n+      // Save GCN ISA.\n+      std::string amdgcn_path = std::string(\"/tmp/\") + module_name + std::string(\".gcn\");\n+      std::string result(buffer.begin(), buffer.end());\n+      std::ofstream amdgcn(amdgcn_path);\n+      amdgcn << result;\n+      amdgcn.close();\n \n-  return hsaco_path;\n-}\n+      // generate HASCO file\n+      std::string hsaco_path = std::string(\"/tmp/\") + module_name + std::string(\".hsaco\");\n+      std::string error_message;\n+      int lld_result =\n+          llvm::sys::ExecuteAndWait(\"/opt/rocm/llvm/bin/ld.lld\",\n+                                    {\"/opt/rocm/llvm/bin/ld.lld\", \"-flavor\", \"gnu\", \"-shared\", \"-o\", hsaco_path, isabin_path},\n+                                    llvm::None, {}, 0, 0, &error_message);\n+      if (lld_result)\n+      {\n+        std::cout << \"ld.lld execute fail: \" << std::endl;\n+        std::cout << error_message << std::endl;\n+        std::cout << lld_result << std::endl;\n+      }\n \n+      return hsaco_path;\n+    }\n \n-hipModule_t amdgpu_to_hipmodule(const std::string& path) {\n-  // Read HSACO.\n-  std::ifstream hsaco_file(path, std::ios::binary | std::ios::ate);\n-  std::ifstream::pos_type hsaco_file_size = hsaco_file.tellg();\n+    hipModule_t amdgpu_to_hipmodule(const std::string &path)\n+    {\n+      // Read HSACO.\n+      std::ifstream hsaco_file(path, std::ios::binary | std::ios::ate);\n+      std::ifstream::pos_type hsaco_file_size = hsaco_file.tellg();\n \n-  std::vector<unsigned char> hsaco(hsaco_file_size);\n-  hsaco_file.seekg(0, std::ios::beg);\n-  hsaco_file.read(reinterpret_cast<char*>(&hsaco[0]), hsaco_file_size);\n-  hsaco_file.close();\n-  hipJitOption opt[] = {hipJitOptionErrorLogBufferSizeBytes, hipJitOptionErrorLogBuffer,\n+      std::vector<unsigned char> hsaco(hsaco_file_size);\n+      hsaco_file.seekg(0, std::ios::beg);\n+      hsaco_file.read(reinterpret_cast<char *>(&hsaco[0]), hsaco_file_size);\n+      hsaco_file.close();\n+      hipJitOption opt[] = {hipJitOptionErrorLogBufferSizeBytes, hipJitOptionErrorLogBuffer,\n                             hipJitOptionInfoLogBufferSizeBytes, hipJitOptionInfoLogBuffer,\n                             hipJitOptionLogVerbose};\n-  const unsigned int errbufsize = 8192;\n-  const unsigned int logbufsize = 8192;\n-  char _err[errbufsize];\n-  char _log[logbufsize];\n-  void* optval[] = {(void*)(uintptr_t)errbufsize,\n-                    (void*)_err, (void*)(uintptr_t)logbufsize,\n-                    (void*)_log, (void*)1};\n-  hipModule_t ret;\n-  dispatch::hipModuleLoadDataEx(&ret, hsaco.data(), 5, opt, optval);\n-  return ret;\n-}\n+      const unsigned int errbufsize = 8192;\n+      const unsigned int logbufsize = 8192;\n+      char _err[errbufsize];\n+      char _log[logbufsize];\n+      void *optval[] = {(void *)(uintptr_t)errbufsize,\n+                        (void *)_err, (void *)(uintptr_t)logbufsize,\n+                        (void *)_log, (void *)1};\n+      hipModule_t ret;\n+      dispatch::hipModuleLoadDataEx(&ret, hsaco.data(), 5, opt, optval);\n+      return ret;\n+    }\n \n-}  // namespace driver\n-}  // namespace triton\n+  } // namespace driver\n+} // namespace triton"}]