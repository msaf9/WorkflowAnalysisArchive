[{"filename": "include/triton/Conversion/TritonGPUToLLVM/PTXAsmFormat.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "file_content_changes": "@@ -144,7 +144,12 @@ struct PTXBuilder {\n \n   // Create a new operand which is written to, that is, the constraint starts\n   // with \"=\", e.g. \"=r\".\n-  Operand *newOperand(StringRef constraint);\n+  // If the operand will be used in predicated execution,\n+  // users may want to initialize it before use.\n+  // Otherwise if the register is only used in the true branch or the false\n+  // branch but not both, the register is undefined and ptxas can perform\n+  // aggressive optimizations that may lead to incorrect results.\n+  Operand *newOperand(StringRef constraint, bool init = false);\n \n   // Create a constant integer operand.\n   Operand *newConstantOperand(int64_t v);\n@@ -171,6 +176,8 @@ struct PTXBuilder {\n     return argArchive.back().get();\n   }\n \n+  void initOperand(Operand *opr);\n+\n   // Make the operands in argArchive follow the provided \\param order.\n   void reorderArgArchive(ArrayRef<Operand *> order) {\n     assert(order.size() == argArchive.size());"}, {"filename": "lib/Conversion/TritonGPUToLLVM/LoadStoreOpToLLVM.cpp", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "file_content_changes": "@@ -138,18 +138,12 @@ struct LoadOpConversion\n       const std::string writeConstraint =\n           (width == 64) ? \"=l\" : ((width == 32) ? \"=r\" : \"=c\");\n \n-      PTXInstr &init =\n-          ptxBuilder.create<>(\"mov\")->o(\"u\" + std::to_string(movWidth));\n-      PTXInstr::Operand *zero = ptxBuilder.newConstantOperand(0);\n-\n       // prepare asm operands\n       auto *dstsOpr = ptxBuilder.newListOperand();\n       for (size_t wordIdx = 0; wordIdx < nWords; ++wordIdx) {\n-        auto *opr = ptxBuilder.newOperand(writeConstraint); // =r operations\n+        auto *opr = ptxBuilder.newOperand(writeConstraint,\n+                                          /*init=*/true); // =r operations\n         dstsOpr->listAppend(opr);\n-        // Initialize the destination register, otherwise the register will\n-        // be undefined if the predicate is false.\n-        init(opr, zero);\n       }\n \n       auto *addrOpr =\n@@ -424,13 +418,12 @@ struct AtomicCASOpConversion\n \n     Value atomPtr = getSharedMemoryBase(loc, rewriter, op.getOperation());\n     atomPtr = bitcast(atomPtr, ptr_ty(valueElemTy, 3));\n-\n     Value casPtr = ptrElements[0];\n     Value casCmp = cmpElements[0];\n     Value casVal = valElements[0];\n \n     PTXBuilder ptxBuilderAtomicCAS;\n-    auto *dstOpr = ptxBuilderAtomicCAS.newOperand(\"=r\");\n+    auto *dstOpr = ptxBuilderAtomicCAS.newOperand(\"=r\", /*init=*/true);\n     auto *ptrOpr = ptxBuilderAtomicCAS.newAddrOperand(casPtr, \"l\");\n     auto *cmpOpr = ptxBuilderAtomicCAS.newOperand(casCmp, \"r\");\n     auto *valOpr = ptxBuilderAtomicCAS.newOperand(casVal, \"r\");\n@@ -441,7 +434,7 @@ struct AtomicCASOpConversion\n     barrier();\n \n     PTXBuilder ptxBuilderStore;\n-    auto *dstOprStore = ptxBuilderStore.newAddrOperand(atomPtr, \"l\");\n+    auto *dstOprStore = ptxBuilderStore.newAddrOperand(atomPtr, \"r\");\n     auto *valOprStore = ptxBuilderStore.newOperand(old, \"r\");\n     auto &st = *ptxBuilderStore.create<PTXInstr>(\"st\");\n     st.shared().o(\"b32\");\n@@ -532,7 +525,7 @@ struct AtomicRMWOpConversion\n       std::string tyId = valueElemNbits * vec == 64\n                              ? \"l\"\n                              : (valueElemNbits * vec == 32 ? \"r\" : \"h\");\n-      auto *dstOpr = ptxBuilderAtomicRMW.newOperand(\"=\" + tyId);\n+      auto *dstOpr = ptxBuilderAtomicRMW.newOperand(\"=\" + tyId, /*init=*/true);\n       auto *ptrOpr = ptxBuilderAtomicRMW.newAddrOperand(rmwPtr, \"l\");\n       auto *valOpr = ptxBuilderAtomicRMW.newOperand(rmwVal, tyId);\n \n@@ -598,7 +591,13 @@ struct AtomicRMWOpConversion\n         auto old = ptxBuilderAtomicRMW.launch(rewriter, loc, valueElemTy);\n         Value atomPtr = getSharedMemoryBase(loc, rewriter, op.getOperation());\n         atomPtr = bitcast(atomPtr, ptr_ty(valueElemTy, 3));\n-        store(old, atomPtr);\n+        // Only threads with rmwMask = True store the result\n+        PTXBuilder ptxBuilderStore;\n+        auto &storeShared = ptxBuilderStore.create<>(\"st\")->shared().o(sTy);\n+        auto *ptrOpr = ptxBuilderStore.newAddrOperand(atomPtr, \"r\");\n+        auto *valOpr = ptxBuilderStore.newOperand(old, tyId);\n+        storeShared(ptrOpr, valOpr).predicate(rmwMask);\n+        ptxBuilderStore.launch(rewriter, loc, void_ty(ctx));\n         barrier();\n         Value ret = load(atomPtr);\n         barrier();"}, {"filename": "lib/Conversion/TritonGPUToLLVM/PTXAsmFormat.cpp", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "file_content_changes": "@@ -19,12 +19,22 @@ PTXBuilder::newOperand(mlir::Value value, StringRef constraint,\n   return opr;\n }\n \n-PTXBuilder::Operand *PTXBuilder::newOperand(StringRef constraint) {\n+void PTXBuilder::initOperand(Operand *opr) {\n+  auto *zero = newConstantOperand(0);\n+  auto numBits = opr->constraint[1] == 'r' ? 32 : 64;\n+  auto &init = create<>(\"mov\")->o(\"u\" + std::to_string(numBits));\n+  init(opr, zero);\n+}\n+\n+PTXBuilder::Operand *PTXBuilder::newOperand(StringRef constraint, bool init) {\n   // Constraint should be something like \"=r\"\n   assert(!constraint.empty() && constraint[0] == '=');\n   auto *opr = newOperand();\n   opr->idx = oprCounter++;\n   opr->constraint = constraint;\n+  if (init) {\n+    initOperand(opr);\n+  }\n   return opr;\n }\n "}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "file_content_changes": "@@ -739,6 +739,17 @@ def kernel(X, Z):\n         np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=0.01)\n \n \n+def test_atomic_rmw_predicate(device=\"cuda\"):\n+    @triton.jit\n+    def kernel(X):\n+        val = tl.program_id(0)\n+        if val < 64:\n+            tl.atomic_max(X, val)\n+    x = torch.zeros((1,), device=device, dtype=torch.int32)\n+    kernel[(4096,)](x)\n+    assert x.item() == 63\n+\n+\n @pytest.mark.parametrize(\"shape, axis\",\n                          [(shape, axis) for shape in [(2, 2), (2, 8), (8, 2), (8, 8), (32, 32)] for axis in [0, 1]])\n def test_tensor_atomic_rmw(shape, axis, device=\"cuda\"):"}]