[{"filename": "python/src/triton.cc", "status": "modified", "additions": 0, "deletions": 111, "changes": 111, "file_content_changes": "@@ -1053,117 +1053,6 @@ void init_triton_ir(py::module &&m) {\n               mlir::Value &rhs) -> mlir::Value {\n              return mlir::Value(self.create<mlir::arith::ShRSIOp>(lhs, rhs));\n            })\n-      .def(\"create_shl_rocm\",\n-           [](TritonOpBuilder &self, mlir::Value &lhs,\n-              mlir::Value &rhs) -> mlir::Value {\n-             auto builder = self.getBuilder();\n-             auto loc = builder.getUnknownLoc();\n-\n-             mlir::Type elementType = getElementTypeOrSelf(lhs.getType());\n-             unsigned typeWidth = elementType.getIntOrFloatBitWidth();\n-             auto constValue = builder.create<mlir::arith::ConstantIntOp>(\n-                 loc, typeWidth, elementType);\n-             auto zeroConst = builder.create<mlir::arith::ConstantIntOp>(\n-                 loc, 0, elementType);\n-             if (lhs.getType().isIntOrIndex()) {\n-               auto cmpValue = builder.create<mlir::arith::CmpIOp>(\n-                   loc, mlir::arith::CmpIPredicate::ult, rhs, constValue);\n-               auto shiftValue =\n-                   builder.create<mlir::arith::ShLIOp>(loc, lhs, rhs);\n-               return mlir::Value(builder.create<mlir::arith::SelectOp>(\n-                   loc, cmpValue, shiftValue, zeroConst));\n-             } else {\n-               auto splatValue = builder.create<mlir::tensor::SplatOp>(\n-                   loc, lhs.getType(), constValue);\n-               auto zeroValue = builder.create<mlir::tensor::SplatOp>(\n-                   loc, lhs.getType(), zeroConst);\n-               auto cmpValue = builder.create<mlir::arith::CmpIOp>(\n-                   loc, mlir::arith::CmpIPredicate::ult, rhs, splatValue);\n-               auto shiftValue =\n-                   builder.create<mlir::arith::ShLIOp>(loc, lhs, rhs);\n-               return mlir::Value(builder.create<mlir::arith::SelectOp>(\n-                   loc, cmpValue, shiftValue, zeroValue));\n-             }\n-           })\n-      .def(\"create_lshr_rocm\",\n-           [](TritonOpBuilder &self, mlir::Value &lhs,\n-              mlir::Value &rhs) -> mlir::Value {\n-             auto builder = self.getBuilder();\n-             auto loc = builder.getUnknownLoc();\n-\n-             mlir::Type elementType = getElementTypeOrSelf(lhs.getType());\n-             unsigned typeWidth = elementType.getIntOrFloatBitWidth();\n-             auto constValue = builder.create<mlir::arith::ConstantIntOp>(\n-                 loc, typeWidth, elementType);\n-             auto zeroConst = builder.create<mlir::arith::ConstantIntOp>(\n-                 loc, 0, elementType);\n-             if (lhs.getType().isIntOrIndex()) {\n-               auto cmpValue = builder.create<mlir::arith::CmpIOp>(\n-                   loc, mlir::arith::CmpIPredicate::ult, rhs, constValue);\n-               auto shiftValue =\n-                   builder.create<mlir::arith::ShRUIOp>(loc, lhs, rhs);\n-               return mlir::Value(builder.create<mlir::arith::SelectOp>(\n-                   loc, cmpValue, shiftValue, zeroConst));\n-             } else {\n-               auto splatValue = builder.create<mlir::tensor::SplatOp>(\n-                   loc, lhs.getType(), constValue);\n-               auto zeroValue = builder.create<mlir::tensor::SplatOp>(\n-                   loc, lhs.getType(), zeroConst);\n-               auto cmpValue = builder.create<mlir::arith::CmpIOp>(\n-                   loc, mlir::arith::CmpIPredicate::ult, rhs, splatValue);\n-               auto shiftValue =\n-                   builder.create<mlir::arith::ShRUIOp>(loc, lhs, rhs);\n-               return mlir::Value(builder.create<mlir::arith::SelectOp>(\n-                   loc, cmpValue, shiftValue, zeroValue));\n-             }\n-           })\n-      .def(\"create_ashr_rocm\",\n-           [](TritonOpBuilder &self, mlir::Value &lhs,\n-              mlir::Value &rhs) -> mlir::Value {\n-             auto builder = self.getBuilder();\n-             auto loc = builder.getUnknownLoc();\n-\n-             mlir::Type elementType = getElementTypeOrSelf(lhs.getType());\n-             unsigned typeWidth = elementType.getIntOrFloatBitWidth();\n-             auto constValue = builder.create<mlir::arith::ConstantIntOp>(\n-                 loc, typeWidth, elementType);\n-             auto zeroConst = builder.create<mlir::arith::ConstantIntOp>(\n-                 loc, 0, elementType);\n-             uint64_t ones_val = 0xFFFFFFFFFFFFFFFF;\n-             auto onesConst = builder.create<mlir::arith::ConstantIntOp>(\n-                 loc, ones_val, elementType);\n-             if (lhs.getType().isIntOrIndex()) {\n-               auto negativeCmpValue = builder.create<mlir::arith::CmpIOp>(\n-                   loc, mlir::arith::CmpIPredicate::slt, lhs, zeroConst);\n-               auto otherValue =\n-                   mlir::Value(builder.create<mlir::arith::SelectOp>(\n-                       loc, negativeCmpValue, onesConst, zeroConst));\n-               auto cmpValue = builder.create<mlir::arith::CmpIOp>(\n-                   loc, mlir::arith::CmpIPredicate::ult, rhs, constValue);\n-               auto shiftValue =\n-                   builder.create<mlir::arith::ShRSIOp>(loc, lhs, rhs);\n-               return mlir::Value(builder.create<mlir::arith::SelectOp>(\n-                   loc, cmpValue, shiftValue, otherValue));\n-             } else {\n-               auto splatValue = builder.create<mlir::tensor::SplatOp>(\n-                   loc, lhs.getType(), constValue);\n-               auto zeroValue = builder.create<mlir::tensor::SplatOp>(\n-                   loc, lhs.getType(), zeroConst);\n-               auto onesValue = builder.create<mlir::tensor::SplatOp>(\n-                   loc, lhs.getType(), onesConst);\n-               auto negativeCmpValue = builder.create<mlir::arith::CmpIOp>(\n-                   loc, mlir::arith::CmpIPredicate::slt, lhs, zeroValue);\n-               auto otherValue =\n-                   mlir::Value(builder.create<mlir::arith::SelectOp>(\n-                       loc, negativeCmpValue, onesValue, zeroValue));\n-               auto cmpValue = builder.create<mlir::arith::CmpIOp>(\n-                   loc, mlir::arith::CmpIPredicate::ult, rhs, splatValue);\n-               auto shiftValue =\n-                   builder.create<mlir::arith::ShRSIOp>(loc, lhs, rhs);\n-               return mlir::Value(builder.create<mlir::arith::SelectOp>(\n-                   loc, cmpValue, shiftValue, otherValue));\n-             }\n-           })\n       // AddPtr (similar to GEP)\n       .def(\"create_addptr\",\n            [](TritonOpBuilder &self, mlir::Value &ptr,"}, {"filename": "python/triton/language/semantic.py", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "file_content_changes": "@@ -328,30 +328,21 @@ def lshr(input: tl.tensor,\n          other: tl.tensor,\n          builder: ir.builder) -> tl.tensor:\n     input, other = bitwise_op_type_checking_impl(input, other, builder)\n-    if is_hip():\n-        return tl.tensor(builder.create_lshr_rocm(input.handle, other.handle), input.type)\n-    else:\n-        return tl.tensor(builder.create_lshr(input.handle, other.handle), input.type)\n+    return tl.tensor(builder.create_lshr(input.handle, other.handle), input.type)\n \n \n def ashr(input: tl.tensor,\n          other: tl.tensor,\n          builder: ir.builder) -> tl.tensor:\n     input, other = bitwise_op_type_checking_impl(input, other, builder)\n-    if is_hip():\n-        return tl.tensor(builder.create_ashr_rocm(input.handle, other.handle), input.type)\n-    else:\n-        return tl.tensor(builder.create_ashr(input.handle, other.handle), input.type)\n+    return tl.tensor(builder.create_ashr(input.handle, other.handle), input.type)\n \n \n def shl(input: tl.tensor,\n         other: tl.tensor,\n         builder: ir.builder) -> tl.tensor:\n     input, other = bitwise_op_type_checking_impl(input, other, builder)\n-    if is_hip():\n-        return tl.tensor(builder.create_shl_rocm(input.handle, other.handle), input.type)\n-    else:\n-        return tl.tensor(builder.create_shl(input.handle, other.handle), input.type)\n+    return tl.tensor(builder.create_shl(input.handle, other.handle), input.type)\n \n # ===----------------------------------------------------------------------===//\n #                               Unary Operators\n@@ -524,11 +515,6 @@ def full(shape: List[int], value, dtype: tl.dtype, builder: ir.builder) -> tl.te\n         return tl.tensor(builder.create_splat(value, shape), ret_ty)\n \n \n-def ones(shape: List[int], dtype: tl.dtype, builder: ir.builder) -> tl.tensor:\n-    _1 = builder.get_one_value(dtype.to_ir(builder))\n-    ret_ty = tl.block_type(dtype, shape)\n-    return tl.tensor(builder.create_splat(_1, shape), ret_ty)\n-\n # ===----------------------------------------------------------------------===//\n #                               Shape Manipulation\n # ===----------------------------------------------------------------------===//"}, {"filename": "third_party/amd_hip_backend", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1 +1 @@\n-Subproject commit 8c634c339d5c31801d36c05c13742be5dd35d770\n+Subproject commit 453761040578b0916e5e3fbfec181820185f2af9"}]