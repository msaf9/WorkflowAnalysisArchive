[{"filename": "bin/triton-translate.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -14,9 +14,9 @@\n #include \"triton/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n+#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n #include \"triton/Target/PTX/PTXTranslation.h\"\n-#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"llvm/IR/LLVMContext.h\"\n #include \"llvm/Support/CommandLine.h\"\n #include \"llvm/Support/InitLLVM.h\"\n@@ -79,7 +79,8 @@ LogicalResult tritonTranslateMain(int argc, char **argv,\n       llvm::cl::init(\"-\"));\n \n   static llvm::cl::opt<std::string> targetKind(\n-      \"target\", llvm::cl::desc(\"<translation target, options: llvmir/ptx/hsaco>\"),\n+      \"target\",\n+      llvm::cl::desc(\"<translation target, options: llvmir/ptx/hsaco>\"),\n       llvm::cl::value_desc(\"target\"), llvm::cl::init(\"llvmir\"));\n \n   static llvm::cl::opt<int> SMArch(\"sm\", llvm::cl::desc(\"sm arch\"),\n@@ -132,10 +133,9 @@ LogicalResult tritonTranslateMain(int argc, char **argv,\n     llvm::outs() << ::triton::translateLLVMIRToPTX(*llvmir, SMArch.getValue(),\n                                                    ptxVersion.getValue());\n   else if (targetKind == \"hsaco\") {\n-    auto [module, hsaco] =\n-        ::triton::translateLLVMIRToHSACO(*llvmir, GCNArch.getValue(),\n-                                                  GCNTriple.getValue(),\n-                                                  GCNFeatures.getValue());\n+    auto [module, hsaco] = ::triton::translateLLVMIRToHSACO(\n+        *llvmir, GCNArch.getValue(), GCNTriple.getValue(),\n+        GCNFeatures.getValue());\n     llvm::outs() << hsaco;\n   } else {\n     llvm::errs() << \"Error: Unknown target specified: \" << targetKind << \"\\n\";"}, {"filename": "include/triton/Conversion/TritonGPUToLLVM/AsmFormat.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -16,7 +16,7 @@ namespace triton {\n using llvm::StringRef;\n \n inline std::string strJoin(llvm::ArrayRef<std::string> strs,\n-                    llvm::StringRef delimiter) {\n+                           llvm::StringRef delimiter) {\n   std::string osStr;\n   llvm::raw_string_ostream os(osStr);\n   for (size_t i = 0; !strs.empty() && i < strs.size() - 1; ++i)"}, {"filename": "include/triton/Conversion/TritonGPUToLLVM/GCNAsmFormat.h", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "file_content_changes": "@@ -48,7 +48,7 @@ struct GCNBuilder {\n     std::string dump() const;\n   };\n \n-struct Modifier {\n+  struct Modifier {\n     Value value;\n     std::string modifier;\n     std::string arg;\n@@ -191,10 +191,12 @@ struct GCNInstrCommon {\n   // clang-format on\n \n   // Set operands of this instruction.\n-  GCNInstrExecution &operator()(llvm::ArrayRef<Operand *> oprs, llvm::ArrayRef<Modifier*> mods);\n+  GCNInstrExecution &operator()(llvm::ArrayRef<Operand *> oprs,\n+                                llvm::ArrayRef<Modifier *> mods);\n \n protected:\n-  GCNInstrExecution &call(llvm::ArrayRef<Operand *> oprs, ArrayRef<Modifier *> mods);\n+  GCNInstrExecution &call(llvm::ArrayRef<Operand *> oprs,\n+                          ArrayRef<Modifier *> mods);\n \n   GCNBuilder *builder{};\n   llvm::SmallVector<std::string, 4> instrParts;\n@@ -218,17 +220,12 @@ template <class ConcreteT> struct GCNInstrBase : public GCNInstrCommon {\n   }\n };\n \n-enum VectorWidth {\n-  Byte = 8,\n-  Short = 16,\n-  Dword = 32,\n-  Qword = 64\n-};\n+enum VectorWidth { Byte = 8, Short = 16, Dword = 32, Qword = 64 };\n \n struct GCNInstr : public GCNInstrBase<GCNInstr> {\n   using GCNInstrBase<GCNInstr>::GCNInstrBase;\n \n-   GCNInstr &float_op_type(int width) {\n+  GCNInstr &float_op_type(int width) {\n     switch (width) {\n     case Byte:\n       assert(Byte != width);\n@@ -258,8 +255,10 @@ struct GCNInstrExecution {\n \n   GCNInstrExecution() = default;\n   explicit GCNInstrExecution(GCNInstrCommon *instr,\n-                             llvm::ArrayRef<Operand *> oprs, llvm::ArrayRef<Modifier *> modifiers)\n-      : instr(instr), argsInOrder(oprs.begin(), oprs.end()), mods(modifiers.begin(), modifiers.end()) {}\n+                             llvm::ArrayRef<Operand *> oprs,\n+                             llvm::ArrayRef<Modifier *> modifiers)\n+      : instr(instr), argsInOrder(oprs.begin(), oprs.end()),\n+        mods(modifiers.begin(), modifiers.end()) {}\n \n   std::string dump() const;\n \n@@ -268,8 +267,6 @@ struct GCNInstrExecution {\n   GCNInstrCommon *instr{};\n };\n \n-\n-\n struct GCNMemInstr : public GCNInstrBase<GCNMemInstr> {\n   using GCNInstrBase<GCNMemInstr>::GCNInstrBase;\n   // Add specific type suffix to instruction"}, {"filename": "include/triton/Target/HSACO/HSACOTranslation.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "file_content_changes": "@@ -12,10 +12,9 @@ class Module;\n namespace triton {\n \n // Translate TritonGPU IR to HSACO code.\n-std::tuple<std::string, std::string> translateLLVMIRToHSACO(llvm::Module& module,\n-                                                            std::string gfx_arch,\n-                                                            std::string gfx_triple,\n-                                                            std::string gfx_features);\n+std::tuple<std::string, std::string>\n+translateLLVMIRToHSACO(llvm::Module &module, std::string gfx_arch,\n+                       std::string gfx_triple, std::string gfx_features);\n \n } // namespace triton\n "}, {"filename": "include/triton/Tools/Sys/GetPlatform.hpp", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "file_content_changes": "@@ -24,23 +24,22 @@\n \n #include <algorithm>\n #include <cstdlib>\n-#include <string>\n #include <iostream>\n #include <map>\n #include <memory>\n-\n-\n+#include <string>\n \n inline std::map<std::string, bool> cache{};\n inline bool isROCM() {\n   // only need to run function once after that return cached value\n   if (cache.find(\"isROCM\") != cache.end()) {\n-      return cache[\"isROCM\"];\n+    return cache[\"isROCM\"];\n   }\n \n   // run command\n   std::string cmd = \"apt-cache show rocm-libs | grep 'Package:'\";\n-  std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), \"r\"), pclose);\n+  std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), \"r\"),\n+                                                pclose);\n   if (!pipe) {\n     std::cout << (\"cmd failed!\") << std::endl;\n   }\n@@ -54,7 +53,7 @@ inline bool isROCM() {\n \n   // check ROCM that is found\n   cache[\"isROCM\"] = result.find(\"rocm\") != std::string::npos;\n-  return cache[\"isROCM\"] ;\n+  return cache[\"isROCM\"];\n }\n \n #endif"}, {"filename": "lib/Conversion/TritonGPUToLLVM/GCNAsmFormat.cpp", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "file_content_changes": "@@ -27,7 +27,8 @@ GCNBuilder::Operand *GCNBuilder::newOperand(StringRef constraint) {\n   return opr;\n }\n \n-GCNBuilder::Modifier *GCNBuilder::newModifier(StringRef modifier, StringRef arg) {\n+GCNBuilder::Modifier *GCNBuilder::newModifier(StringRef modifier,\n+                                              StringRef arg) {\n   assert(!modifier.empty());\n   auto *mod = newModifier();\n   mod->modifier = modifier;\n@@ -134,13 +135,15 @@ std::string GCNBuilder::dump() const {\n   return strJoin(lines, \"\\n\\t\");\n }\n \n-GCNInstrExecution &GCNInstrCommon::call(ArrayRef<Operand *> oprs, ArrayRef<Modifier *> mods) {\n+GCNInstrExecution &GCNInstrCommon::call(ArrayRef<Operand *> oprs,\n+                                        ArrayRef<Modifier *> mods) {\n   builder->executions.emplace_back(\n       std::make_unique<GCNInstrExecution>(this, oprs, mods));\n   return *builder->executions.back();\n }\n \n-GCNInstrExecution &GCNInstrCommon::operator()(ArrayRef<Operand *> oprs, ArrayRef<Modifier *> mods) {\n+GCNInstrExecution &GCNInstrCommon::operator()(ArrayRef<Operand *> oprs,\n+                                              ArrayRef<Modifier *> mods) {\n   return call(oprs, mods);\n }\n \n@@ -158,7 +161,7 @@ std::string GCNInstrExecution::dump() const {\n   std::string argsRepr = strJoin(argReprs, \", \");\n \n   llvm::SmallVector<std::string, 4> modReprs;\n-  for(auto *mod : mods) {\n+  for (auto *mod : mods) {\n     modReprs.push_back(mod->dump());\n   }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/PTXAsmFormat.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,7 +1,7 @@\n #include \"triton/Conversion/TritonGPUToLLVM/PTXAsmFormat.h\"\n-#include \"triton/Conversion/TritonGPUToLLVM/AsmFormat.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/Transforms/DialectConversion.h\"\n+#include \"triton/Conversion/TritonGPUToLLVM/AsmFormat.h\"\n #include \"llvm/Support/raw_ostream.h\"\n // TODO(Superjomn): unify to llvm::raw_string_ostream\n #include <sstream>"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "file_content_changes": "@@ -120,11 +120,11 @@ struct FuncOpConversion : public FuncOpConversionBase {\n     // Set an attribute to indicate this function is a kernel entry.\n     newFuncOp->setAttr(\"nvvm.kernel\",\n                        rewriter.getIntegerAttr(type::u1Ty(ctx), 1));\n-    if(!isROCM()){\n+    if (!isROCM()) {\n       // Set an attribute for maxntidx, it could be used in latter LLVM codegen\n       // for `nvvm.annotation` metadata.\n       newFuncOp->setAttr(\"nvvm.maxntid\",\n-                        rewriter.getIntegerAttr(i32_ty, 32 * numWarps));\n+                         rewriter.getIntegerAttr(i32_ty, 32 * numWarps));\n     }\n \n     rewriter.eraseOp(funcOp);\n@@ -226,11 +226,12 @@ class ConvertTritonGPUToLLVM\n     populatePatterns1(populateLoadStoreOpToLLVMPatterns);\n     populatePatterns1(populateReduceOpToLLVMPatterns);\n     populatePatterns2(populateViewOpToLLVMPatterns);\n-   \n-     // Native lowering patterns\n+\n+    // Native lowering patterns\n     if (isROCM()) {\n-      mlir::populateGpuToROCDLConversionPatterns(typeConverter, patterns, mlir::gpu::amd::HIP);\n-    }else{\n+      mlir::populateGpuToROCDLConversionPatterns(typeConverter, patterns,\n+                                                 mlir::gpu::amd::HIP);\n+    } else {\n       mlir::populateGpuToNVVMConversionPatterns(typeConverter, patterns);\n     }\n \n@@ -244,7 +245,8 @@ class ConvertTritonGPUToLLVM\n       RewritePatternSet gcnPatterns(context);\n       populateElementwiseOpToPTXPatterns(typeConverter, gcnPatterns,\n                                          /*benefits=*/10);\n-      if (failed(applyPartialConversion(mod, gcnTarget, std::move(gcnPatterns))))\n+      if (failed(\n+              applyPartialConversion(mod, gcnTarget, std::move(gcnPatterns))))\n         return signalPassFailure();\n     } else {\n       // Use our custom converters to convert some operations to PTX to avoid\n@@ -256,10 +258,10 @@ class ConvertTritonGPUToLLVM\n       // Add patterns to convert LLVM to PTX\n       populateElementwiseOpToPTXPatterns(typeConverter, ptxPatterns,\n                                          /*benefits=*/10);\n-      if (failed(applyPartialConversion(mod, ptxTarget, std::move(ptxPatterns))))\n+      if (failed(\n+              applyPartialConversion(mod, ptxTarget, std::move(ptxPatterns))))\n         return signalPassFailure();\n     }\n-\n   }\n \n private:"}, {"filename": "lib/Target/HSACO/HSACOTranslation.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -133,12 +133,12 @@ std::string generate_hsaco(llvm::Module *module, const std::string &triple,\n   std::string hsaco_path = kernel_name + std::string(\".hsaco\");\n \n   std::string error_message;\n-  std::string lld_path = ::triton::tools::getenv(\"ROCM_PATH\") + \"/llvm/bin/ld.lld\";\n-  int lld_result =\n-      llvm::sys::ExecuteAndWait(lld_path,\n-                                {lld_path, \"-flavor\", \"gnu\",\n-                                 \"-shared\", \"-o\", hsaco_path, isabin_path},\n-                                std::nullopt, {}, 0, 0, &error_message);\n+  std::string lld_path =\n+      ::triton::tools::getenv(\"ROCM_PATH\") + \"/llvm/bin/ld.lld\";\n+  int lld_result = llvm::sys::ExecuteAndWait(\n+      lld_path,\n+      {lld_path, \"-flavor\", \"gnu\", \"-shared\", \"-o\", hsaco_path, isabin_path},\n+      std::nullopt, {}, 0, 0, &error_message);\n   if (lld_result) {\n     std::cout << \"ld.lld execute fail: \" << std::endl;\n     std::cout << error_message << std::endl;"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "file_content_changes": "@@ -16,10 +16,10 @@\n #include \"triton/Conversion/TritonGPUToLLVM/ArithToIndexPass.h\"\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h\"\n #include \"triton/Tools/Sys/GetEnv.hpp\"\n+#include \"triton/Tools/Sys/GetPlatform.hpp\"\n #include \"llvm/ADT/APInt.h\"\n #include \"llvm/ADT/STLExtras.h\"\n #include \"llvm/ADT/SmallVector.h\"\n-#include \"triton/Tools/Sys/GetPlatform.hpp\"\n #include \"llvm/IR/CallingConv.h\"\n #include \"llvm/IR/Constants.h\"\n #include \"llvm/IRReader/IRReader.h\"\n@@ -230,7 +230,7 @@ static bool linkExternLib(llvm::Module &module, llvm::StringRef name,\n   }\n \n   // check if ROCM\n-  if (!isROCM()){\n+  if (!isROCM()) {\n     if (name == \"libdevice\") {\n       linkLibdevice(module);\n     } else {\n@@ -332,9 +332,10 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n   if (::triton::tools::getBoolEnv(\"LLVM_IR_ENABLE_DUMP\")) {\n     std::string mod_string;\n     std::unique_ptr<llvm::raw_string_ostream> ir_ss(\n-           new llvm::raw_string_ostream(mod_string));\n+        new llvm::raw_string_ostream(mod_string));\n     llvmIR->print(*ir_ss, nullptr);\n-    std::cout << \"// -----// LLVM IR Dump //----- //\\n\" << mod_string << std::endl;\n+    std::cout << \"// -----// LLVM IR Dump //----- //\\n\"\n+              << mod_string << std::endl;\n   }\n \n   return llvmIR;"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "file_content_changes": "@@ -23,9 +23,9 @@\n #include \"triton/Dialect/Triton/IR/Types.h\"\n #include \"triton/Dialect/Triton/Transforms/Passes.h\"\n #include \"triton/Dialect/TritonGPU/Transforms/Passes.h\"\n+#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n #include \"triton/Target/PTX/PTXTranslation.h\"\n-#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"triton/Tools/Sys/GetEnv.hpp\"\n #include \"triton/Tools/Sys/GetPlatform.hpp\"\n \n@@ -902,22 +902,22 @@ void init_triton_ir(py::module &&m) {\n            [](mlir::OpBuilder &self, mlir::Value &lhs,\n               mlir::Value &rhs) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-               return mlir::Value(\n-                   self.create<mlir::arith::ShLIOp>(loc, lhs, rhs));\n+             return mlir::Value(\n+                 self.create<mlir::arith::ShLIOp>(loc, lhs, rhs));\n            })\n       .def(\"create_lshr\",\n            [](mlir::OpBuilder &self, mlir::Value &lhs,\n               mlir::Value &rhs) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-               return mlir::Value(\n-                   self.create<mlir::arith::ShRUIOp>(loc, lhs, rhs));\n+             return mlir::Value(\n+                 self.create<mlir::arith::ShRUIOp>(loc, lhs, rhs));\n            })\n       .def(\"create_ashr\",\n            [](mlir::OpBuilder &self, mlir::Value &lhs,\n               mlir::Value &rhs) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-               return mlir::Value(\n-                   self.create<mlir::arith::ShRSIOp>(loc, lhs, rhs));\n+             return mlir::Value(\n+                 self.create<mlir::arith::ShRSIOp>(loc, lhs, rhs));\n            })\n       // AddPtr (similar to GEP)\n       .def(\"create_addptr\",\n@@ -1592,8 +1592,8 @@ void init_triton_translation(py::module &m) {\n \n   m.def(\n       \"translate_llvmir_to_hsaco\",\n-      [](const std::string llvmIR, std::string gfx_arch, std::string gfx_triple, \n-          std::string gfx_features) -> std::tuple<std::string, std::string> {\n+      [](const std::string llvmIR, std::string gfx_arch, std::string gfx_triple,\n+         std::string gfx_features) -> std::tuple<std::string, std::string> {\n         // create LLVM module from C++\n         llvm::LLVMContext context;\n         std::unique_ptr<llvm::MemoryBuffer> buffer =\n@@ -1602,7 +1602,8 @@ void init_triton_translation(py::module &m) {\n         std::unique_ptr<llvm::Module> module =\n             llvm::parseIR(buffer->getMemBufferRef(), error, context);\n         // translate module to HSACO\n-        auto hsacoCode = triton::translateLLVMIRToHSACO(*module, gfx_arch, gfx_triple, gfx_features);\n+        auto hsacoCode = triton::translateLLVMIRToHSACO(\n+            *module, gfx_arch, gfx_triple, gfx_features);\n         return hsacoCode;\n       },\n       ret::take_ownership);"}]