[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "file_content_changes": "@@ -306,6 +306,15 @@ struct ConvertLayoutOpConversion\n         // }\n       }\n \n+#define SHOW_ACCI 1\n+#if SHOW_ACCI\n+      for (unsigned elemId = 0; elemId < accumSizePerThread; elemId++) {\n+        auto [coord, currVal] = coord2val[elemId];\n+        LLVM::vprintf(\"acci t-%d (%d %d) %f\",\n+                      {LLVM::gThreadId, coord[0], coord[1], currVal}, rewriter);\n+      }\n+#endif\n+\n       if (needTrans) {\n         auto [isARow, isBRow, isAVec4, isBVec4, mmaId] =\n             mma.decodeVoltaLayoutStates();\n@@ -315,16 +324,6 @@ struct ConvertLayoutOpConversion\n                                     isAVec4);\n         int numN = accumSizePerThread / numM;\n \n-#define SHOW_ACCI 0\n-#if SHOW_ACCI\n-        if (sliceLayout)\n-          for (unsigned elemId = 0; elemId < accumSizePerThread; elemId++) {\n-            auto [coord, currVal] = coord2val[elemId];\n-            LLVM::vprintf(\"acci t-%d (%d) %f\",\n-                          {LLVM::gThreadId, coord[0], currVal}, rewriter);\n-          }\n-#endif\n-\n         for (int r = 0; r < numM; r++) {\n           for (int c = 0; c < numN; c++) {\n             coord2valT[r * numN + c] = std::move(coord2val[c * numM + r]);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "file_content_changes": "@@ -507,6 +507,8 @@ struct DotOpMmaV1ConversionHelper {\n   getMNCoords(Value thread, ConversionPatternRewriter &rewriter,\n               ArrayRef<unsigned> wpt, ArrayRef<int64_t> shape, bool isARow,\n               bool isBRow, bool isAVec4, bool isBVec4) {\n+    printf(\"getMNCoords t-0 wpt:[%d %d] shape:[%ld %ld] %d %d %d %d\\n\", wpt[0],\n+           wpt[1], shape[0], shape[1], isARow, isBRow, isAVec4, isBVec4);\n \n     auto *ctx = thread.getContext();\n     auto loc = UnknownLoc::get(ctx);\n@@ -598,6 +600,24 @@ struct DotOpMmaV1ConversionHelper {\n         coords.push_back(std::move(idx));\n       }\n     }\n+\n+#define SHOW_COORD 0\n+#if SHOW_COORD\n+    static bool visited{};\n+    if (!visited) {\n+      std::string fmt = \"coord t-%d \";\n+      SmallVector<Value> args;\n+      args.push_back(gThreadId);\n+      for (auto &coord : coords) {\n+        fmt += \"(%d %d) \";\n+        args.push_back(coord[0]);\n+        args.push_back(coord[1]);\n+      }\n+      LLVM::vprintf(fmt, args, rewriter);\n+      visited = true;\n+    }\n+#endif\n+\n     return coords; // {M,N} in row-major\n   }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpToLLVM.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -125,6 +125,8 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n         mmaLayout.decodeVoltaLayoutStates();\n     assert(isARow == isARow_);\n     assert(isBRow == isBRow_);\n+    printf(\"mma.decode t-0 %d %d %d %d %d\\n\", isARow_, isBRow_, isAVec4_,\n+           isBVec4_, mmaId);\n \n     DotOpMmaV1ConversionHelper helper(mmaLayout);\n \n@@ -236,14 +238,12 @@ struct DotOpConversion : public ConvertTritonGPUOpToLLVMPattern<triton::DotOp> {\n           pargs.push_back(acc[idx[i]]);\n         }\n \n-        // LLVM::vprintf(\"mma t-%d [%d %d %d] A:(%f,%f) (%f,%f) B:(%f,%f)\n-        // (%f,%f) \"\n-        //               \"C:(%f,%f,%f,%f,%f,%f,%f,%f)\"\n-        //               \" D:(%f,%f,%f,%f,%f,%f,%f,%f)\",\n-        //               pargs, rewriter);\n         LLVM::vprintf(\"mma t-%d [%d %d %d] A:(%f,%f) (%f,%f) B:(%f,%f) (%f,%f) \"\n-                      \"C:(%f,%f,%f,%f,%f,%f,%f,%f)\",\n+                      \"C:(%f,%f,%f,%f,%f,%f,%f,%f)\"\n+                      \" D:(%f,%f,%f,%f,%f,%f,%f,%f)\",\n                       pargs, rewriter);\n+        // LLVM::vprintf(\"mma t-%d [%d %d %d] A:(%f,%f) (%f,%f) B:(%f,%f)\n+        // (%f,%f) \" \"C:(%f,%f,%f,%f,%f,%f,%f,%f)\", pargs, rewriter);\n       }\n #endif\n     };"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -1084,6 +1084,7 @@ class BlockedToMMA : public mlir::RewritePattern {\n \n     // for FMA, should retain the blocked layout.\n     int versionMajor = computeCapabilityToMMAVersion(computeCapability);\n+    versionMajor = 1; // DEBUG\n     if (!supportMMA(dotOp, versionMajor))\n       return failure();\n "}, {"filename": "lib/Dialect/TritonGPU/Transforms/UpdateMmaForVolta.cpp", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "file_content_changes": "@@ -241,7 +241,10 @@ class UpdateMMAForMMAv1 : public mlir::RewritePattern {\n \n     auto srcTy = op->getOperand(0).getType();\n     auto resTy = op->getResult(0).getType();\n-    if (!needUpdate(srcTy) && needUpdate(resTy)) {\n+\n+    if (needUpdate(resTy)) {\n+      //  The op-inputs' types are not necessary to update, for some\n+      //  replaceOpWithNewOp will help update them.\n       op->getResult(0).setType(\n           getUpdatedType(resTy.dyn_cast<RankedTensorType>()));\n       return success();\n@@ -317,6 +320,8 @@ class UpdateMmaForVoltaPass\n     MLIRContext *context = &getContext();\n     ModuleOp m = getOperation();\n \n+    // llvm::outs() << \"input ir:\\n\" << *m << \"\\n\";\n+\n     llvm::DenseMap<MmaEncodingAttr, MmaEncodingAttr> mmaToUpdate;\n     {\n       mlir::RewritePatternSet patterns(context);\n@@ -329,6 +334,13 @@ class UpdateMmaForVoltaPass\n         signalPassFailure();\n     }\n \n+    /*\n+    for (auto& item : mmaToUpdate) {\n+      llvm::outs() << \"updatemma t-0 \" << item.first << \" -> \" << item.second <<\n+    \"\\n\";\n+    }\n+     */\n+\n     if (!mmaToUpdate.empty()) {\n       mlir::RewritePatternSet patterns(context);\n       patterns.add<UpdateMMAForMMAv1>(context, mmaToUpdate);\n@@ -343,6 +355,8 @@ class UpdateMmaForVoltaPass\n \n       if (fixupLoops(m).failed())\n         signalPassFailure();\n+\n+      // llvm::outs() << \"output ir:\\n\" << *m << \"\\n\";\n     }\n   }\n };"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "file_content_changes": "@@ -900,11 +900,12 @@ def ttir_to_ttgir(mod, num_warps, num_stages, compute_capability):\n     pm.add_tritongpu_combine_pass(compute_capability)\n     pm.add_licm_pass()\n     pm.add_tritongpu_combine_pass(compute_capability)\n-    if compute_capability // 10 == 7:\n-        # The update_mma_for_volta pass helps to compute some information for MMA encoding specifically for MMAv1\n-        pm.add_tritongpu_update_mma_for_volta_pass()\n     pm.add_cse_pass()\n     pm.add_tritongpu_decompose_conversions_pass()\n+    if compute_capability // 10 == 7 or True:  # DEBUG\n+        # The update_mma_for_volta pass helps to compute some information for MMA encoding specifically for MMAv1\n+        # NOTE this PR should be placed after all the passes those modifies mma layout\n+        pm.add_tritongpu_update_mma_for_volta_pass()\n     pm.add_cse_pass()\n     pm.add_symbol_dce_pass()\n     pm.add_tritongpu_reorder_instructions_pass()"}]