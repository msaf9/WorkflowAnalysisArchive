[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 55, "deletions": 44, "changes": 99, "file_content_changes": "@@ -89,6 +89,14 @@ def mangle_fn(name, arg_tys, constants):\n     return ret\n \n \n+def _is_constexpr(o: Any) -> bool:\n+    return isinstance(o, triton.language.constexpr)  # TODO: fetch triton.language.constexpr to a global after circular imports untangled, saving getattr\n+\n+\n+def _unwrap_if_constexpr(o: Any):\n+    return o.value if isinstance(o, triton.language.constexpr) else o\n+\n+\n class enter_sub_region:\n     def __init__(self, generator: CodeGenerator):\n         self.generator = generator\n@@ -267,7 +275,7 @@ def visit_FunctionDef(self, node):\n         for i, arg_name in enumerate(arg_names):\n             if i in self.constants:\n                 cst = self.constants[i]\n-                if not isinstance(cst, triton.language.constexpr):\n+                if not _is_constexpr(cst):\n                     cst = triton.language.constexpr(self.constants[i])\n                 arg_values.append(cst)\n                 continue\n@@ -318,7 +326,7 @@ def visit_AnnAssign(self, node):\n             if target in self.lscope:\n                 raise ValueError(f'{target} is already defined.'\n                                  f' constexpr cannot be reassigned.')\n-            if not isinstance(value, triton.language.constexpr):\n+            if not _is_constexpr(value):\n                 value = triton.language.constexpr(value)\n             self.lscope[target] = value\n             return self.lscope[target]\n@@ -330,7 +338,7 @@ def visit_Assign(self, node):\n         for target in node.targets:\n             _names += [self.visit(target)]\n         if len(_names) > 1:\n-            raise NotImplementedError(\"Multiple assignment is not supported.\")\n+            raise UnsupportedLanguageConstruct(None, node, \"simultaneous multiple assignment is not supported.\")\n         names = _names[0]\n         values = self.visit(node.value)\n         if not isinstance(names, tuple):\n@@ -339,8 +347,7 @@ def visit_Assign(self, node):\n             values = [values]\n         for name, value in zip(names, values):\n             # by default, constexpr are assigned into python variable\n-            if isinstance(value, triton.language.constexpr):\n-                value = value.value\n+            value = _unwrap_if_constexpr(value)\n             if not isinstance(value, triton.language.tensor):\n                 value = triton.language.core._to_tensor(value, self.builder)\n             self.set_value(name, value)\n@@ -513,13 +520,17 @@ def visit_If(self, node):\n                 self.visit_if_scf(cond, node)\n             else:\n                 self.visit_if_top_level(cond, node)\n-        else:\n-            if isinstance(cond, triton.language.constexpr):\n-                cond = cond.value\n+        elif _is_constexpr(cond):\n+            try:\n+                cond = bool(cond.value)\n+            except (TypeError, ValueError):\n+                raise UnsupportedLanguageConstruct(None, node, \"the boolean value of constexpr of type {} cannot be determined\".format(type(cond.value)))\n             if cond:\n                 self.visit_compound_statement(node.body)\n             else:\n                 self.visit_compound_statement(node.orelse)\n+        else:\n+            raise UnsupportedLanguageConstruct(None, node, \"conditionals are supported only for `tensor` and `constexpr` values.\")\n \n     def visit_IfExp(self, node):\n         cond = self.visit(node.test)\n@@ -532,14 +543,10 @@ def visit_Pass(self, node):\n         pass\n \n     def visit_Compare(self, node):\n-        assert len(node.comparators) == 1\n-        assert len(node.ops) == 1\n-        lhs = self.visit(node.left)\n-        rhs = self.visit(node.comparators[0])\n-        if isinstance(lhs, triton.language.constexpr):\n-            lhs = lhs.value\n-        if isinstance(rhs, triton.language.constexpr):\n-            rhs = rhs.value\n+        if not (len(node.comparators) == 1 and len(node.ops) == 1):\n+            raise UnsupportedLanguageConstruct(None, node, \"simultaneous multiple comparison is not supported\")\n+        lhs = _unwrap_if_constexpr(self.visit(node.left))\n+        rhs = _unwrap_if_constexpr(self.visit(node.comparators[0]))\n         if type(node.ops[0]) == ast.Is:\n             return triton.language.constexpr(lhs is rhs)\n         if type(node.ops[0]) == ast.IsNot:\n@@ -684,7 +691,7 @@ def visit_For(self, node):\n         step = iter_args[2] if len(iter_args) > 2 else self.visit(ast.Num(1))\n         # handle negative constant step (not supported by scf.for in MLIR)\n         negative_step = False\n-        if isinstance(step, triton.language.constexpr) and step.value < 0:\n+        if _is_constexpr(step) and step.value < 0:\n             step = triton.language.constexpr(-step.value)\n             negative_step = True\n             lb, ub = ub, lb\n@@ -799,9 +806,7 @@ def visit_Assert(self, node) -> Any:\n         return triton.language.core.device_assert(test, msg, _builder=self.builder)\n \n     def visit_Call(self, node):\n-        fn = self.visit(node.func)\n-        if isinstance(fn, triton.language.constexpr):\n-            fn = fn.value\n+        fn = _unwrap_if_constexpr(self.visit(node.func))\n \n         static_implementation = self.statically_implemented_functions.get(fn)\n         if static_implementation is not None:\n@@ -820,7 +825,7 @@ def visit_Call(self, node):\n                     else triton.language.constexpr(arg) for arg in args]\n             # generate function def\n             attributes = dict()\n-            constexprs = [i for i, arg in enumerate(args) if isinstance(arg, triton.language.constexpr)]\n+            constexprs = [i for i, arg in enumerate(args) if _is_constexpr(arg)]\n             constants = {i: args[i] for i in constexprs}\n             # generate call\n             args = [None if i in constexprs else arg for i, arg in enumerate(args)]\n@@ -852,7 +857,7 @@ def visit_Call(self, node):\n         if (hasattr(fn, '__self__') and self.is_triton_tensor(fn.__self__)) or impl.is_builtin(fn):\n             return fn(*args, _builder=self.builder, **kws)\n         if fn in self.builtin_namespace.values():\n-            args = [arg.value if isinstance(arg, triton.language.constexpr) else arg for arg in args]\n+            args = map(_unwrap_if_constexpr, args)\n         return fn(*args, **kws)\n \n     def visit_Constant(self, node):\n@@ -907,9 +912,9 @@ def visit_JoinedStr(self, node):\n             elif isinstance(value, ast.FormattedValue):\n                 conversion_code = value.conversion\n                 evaluated = self.visit(value.value)\n-                if not isinstance(evaluated, triton.language.constexpr):\n-                    raise NotImplementedError(\"Cannot evaluate f-string containing non-constexpr conversion values,\"\n-                                              \" found conversion of type \" + str(type(evaluated)))\n+                if not _is_constexpr(evaluated):\n+                    raise UnsupportedLanguageConstruct(\n+                        None, node, \"Cannot evaluate f-string containing non-constexpr conversion values, found conversion of type \" + str(type(evaluated)))\n                 values[i] = (\"{}\" if conversion_code < 0 else \"{!\" + chr(conversion_code) + \"}\").format(evaluated.value)\n             else:\n                 raise AssertionError(\"encountered unexpected node of type {} in a JoinedStr node\".format(type(value)))\n@@ -926,19 +931,16 @@ def visit(self, node):\n             return super().visit(node)\n \n     def generic_visit(self, node):\n-        typename = type(node).__name__\n-        raise NotImplementedError(\"Unsupported node: {}\".format(typename))\n+        raise UnsupportedLanguageConstruct(None, node, \"unsupported AST node type: {}\".format(type(node).__name__))\n \n     # TODO: populate this here (rather than inside `_define_name_lookup`) once cyclic imports resolved\n     statically_implemented_functions: Dict[object, Callable[[ast.Call], Any]] = {}\n \n     def execute_static_print(self, node: ast.Call) -> None:\n         # TODO: too simplistic? Perhaps do something else with non-constexpr\n-        def unwrap(_):\n-            return _.value if isinstance(_, triton.language.constexpr) else _\n \n-        kws = {name: unwrap(value) for name, value in (self.visit(keyword) for keyword in node.keywords)}\n-        args = [unwrap(self.visit(arg)) for arg in node.args]\n+        kws = {name: _unwrap_if_constexpr(value) for name, value in (self.visit(keyword) for keyword in node.keywords)}\n+        args = [_unwrap_if_constexpr(self.visit(arg)) for arg in node.args]\n         print(*args, **kws)\n \n     def execute_static_assert(self, node: ast.Call) -> None:\n@@ -967,20 +969,29 @@ class CompilationError(Exception):\n \n     def _format_message(self) -> str:\n         node = self.node\n-        message = f'at {node.lineno}:{node.col_offset}:'\n         if self.src is None:\n-            message += \" <source unavailable>\"\n+            source_excerpt = \" <source unavailable>\"\n         else:\n-            message += '\\n'.join(self.src.split('\\n')[:node.lineno][-self.source_line_count_max_in_message:])\n-            message += '\\n' + ' ' * node.col_offset + '^'\n+            source_excerpt = self.src.split('\\n')[:node.lineno][-self.source_line_count_max_in_message:]\n+            if source_excerpt:\n+                source_excerpt.append(' ' * node.col_offset + '^')\n+                source_excerpt = '\\n'.join(source_excerpt)\n+            else:\n+                source_excerpt = \" <source empty>\"\n+\n+        message = \"at {}:{}:{}\".format(node.lineno, node.col_offset, source_excerpt)\n         if self.error_message:\n             message += '\\n' + self.error_message\n         return message\n \n-    def __init__(self, src: Optional[str], node: ast.AST, error_message: Optional[str]):\n+    def __init__(self, src: Optional[str], node: ast.AST, error_message: Union[str, 'triton.language.core.constexpr', None]):\n         self.src = src\n         self.node = node\n-        self.error_message = error_message\n+        self.error_message = _unwrap_if_constexpr(error_message)\n+        self.message = self._format_message()\n+\n+    def set_source_code(self, src: Optional[str]):\n+        self.src = src\n         self.message = self._format_message()\n \n     def __str__(self):\n@@ -996,10 +1007,11 @@ def __reduce__(self):\n \n class CompileTimeAssertionFailure(CompilationError):\n     \"\"\"Specific exception for failed tests in `static_assert` invocations\"\"\"\n+    pass\n \n-    def set_source_code(self, src: Optional[str]):\n-        self.src = src\n-        self.message = self._format_message()\n+\n+class UnsupportedLanguageConstruct(CompilationError):\n+    pass\n \n \n class OutOfResources(Exception):\n@@ -1064,11 +1076,10 @@ def build_triton_ir(fn, signature, specialization, constants, debug=False):\n     generator = CodeGenerator(context, prototype, gscope=gscope, constants=all_constants, function_name=function_name, attributes=new_attrs, is_kernel=True, debug=debug)\n     try:\n         generator.visit(fn.parse())\n-    except CompileTimeAssertionFailure as e:\n-        e.set_source_code(fn.src)\n+    except CompilationError as e:\n+        if e.src is None:\n+            e.set_source_code(fn.src)\n         raise\n-    except CompilationError:  # (can this ever happen? nobody has access to fn.src except here)\n-        raise  # unchanged\n     except Exception as e:\n         node = generator.last_node\n         if node is None:"}]