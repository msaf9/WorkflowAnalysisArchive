[{"filename": "lib/Dialect/TritonGPU/Transforms/RemoveLayoutConversions.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "file_content_changes": "@@ -354,7 +354,8 @@ class RematerializeForward : public mlir::RewritePattern {\n         // scf.for blockArgument can be conditionally optimized only if\n         // there's a single conversion use.\n         if (!argOp) {\n-          if (canMoveOutOfLoop(arg.cast<BlockArgument>(), /*allowedNumCvts=*/0)\n+          SetVector<Operation *> cvts;\n+          if (canMoveOutOfLoop(arg.cast<BlockArgument>(), /*allowedNumCvts=*/0, cvts)\n                   .failed())\n             return failure();\n         }\n@@ -502,8 +503,8 @@ class MoveConvertOutOfLoop : public mlir::RewritePattern {\n       auto arg = iterArg.value();\n       if (!arg.getType().isa<RankedTensorType>())\n         continue;\n-      SetVector<Operation *> cvts = getValidBlockArgCvts(arg);\n-      if (cvts.size() != 1)\n+      SetVector<Operation *> cvts;\n+      if (canMoveOutOfLoop(arg, /*allowedCvts=*/1, cvts).failed())\n         continue;\n       auto cvt = dyn_cast<triton::gpu::ConvertLayoutOp>(cvts.front());\n       auto newFor = rematerializeForLoop(rewriter, forOp, iterArg.index(), cvt);"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Utility.cpp", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "file_content_changes": "@@ -131,11 +131,9 @@ bool expensiveToRemat(Operation *op, Attribute &targetEncoding) {\n   return false;\n }\n \n-SetVector<Operation *> getValidBlockArgCvts(BlockArgument arg) {\n-  SetVector<Operation *> cvts;\n-  auto users = arg.getUsers();\n-  // check first condition\n-  for (auto user : users) {\n+namespace {\n+void getValidBlockArgCvts(BlockArgument arg, SetVector<Operation *> &cvts) {\n+  for (auto user : arg.getUsers()) {\n     if (isa<triton::gpu::ConvertLayoutOp>(user)) {\n       auto newType = user->getResults()[0].getType().cast<RankedTensorType>();\n       auto oldType = user->getOperand(0).getType().cast<RankedTensorType>();\n@@ -152,10 +150,11 @@ SetVector<Operation *> getValidBlockArgCvts(BlockArgument arg) {\n       cvts.insert(user);\n     }\n   }\n-  return cvts;\n }\n+} // namespace\n \n-LogicalResult canMoveOutOfLoop(BlockArgument arg, int allowedCvts) {\n+LogicalResult canMoveOutOfLoop(BlockArgument arg, int allowedCvts,\n+                               SetVector<Operation *> &cvts) {\n   // we only move `iterArg` out of the loop if\n   //   - there is only a single conversion use\n   //   - moving this conversion out of the loop will not generate\n@@ -164,8 +163,9 @@ LogicalResult canMoveOutOfLoop(BlockArgument arg, int allowedCvts) {\n   auto forOp = dyn_cast<scf::ForOp>(arg.getOwner()->getParentOp());\n   if (!forOp)\n     return success();\n-  SetVector<Operation *> cvts = getValidBlockArgCvts(arg);\n-  if (cvts.size() > allowedCvts)\n+  // check first condition\n+  getValidBlockArgCvts(arg, cvts);\n+  if (cvts.size() != allowedCvts)\n     return failure();\n   auto users = arg.getUsers();\n   // TODO: check second condition\n@@ -223,7 +223,9 @@ int simulateBackwardRematerialization(\n       // there's a single conversion use.\n       SetVector<Type> cvtTargetTypes;\n       if (!opArgI) {\n-        if (canMoveOutOfLoop(argI.cast<BlockArgument>(), /*allowedNumCvts=*/0)\n+        SetVector<Operation *> cvts;\n+        if (canMoveOutOfLoop(argI.cast<BlockArgument>(), /*allowedNumCvts=*/0,\n+                             cvts)\n                 .failed())\n           // If this is true, we add a new conversion, resulting in two\n           // conversions"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Utility.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "file_content_changes": "@@ -16,9 +16,8 @@ bool expensiveLoadOrStore(Operation *op, Attribute &targetEncoding);\n \n bool expensiveToRemat(Operation *op, Attribute &targetEncoding);\n \n-SetVector<Operation *> getValidBlockArgCvts(BlockArgument arg);\n-\n-LogicalResult canMoveOutOfLoop(BlockArgument arg, int allowedCvts);\n+LogicalResult canMoveOutOfLoop(BlockArgument arg, int allowedCvts,\n+                               SetVector<Operation *> &cvts);\n \n int simulateBackwardRematerialization(\n     Operation *initOp, SetVector<Operation *> &processed,"}]