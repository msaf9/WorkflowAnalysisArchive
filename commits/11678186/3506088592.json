[{"filename": "include/triton/Target/LLVMIR/LLVMIRTranslation.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -2,6 +2,7 @@\n #define TRITON_TARGET_LLVMIRTRANSLATION_H\n #include \"llvm/ADT/StringRef.h\"\n #include <memory>\n+#include <string>\n #include <vector>\n \n namespace llvm {"}, {"filename": "include/triton/Target/PTX/PTXTranslation.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1,7 +1,6 @@\n #ifndef TRITON_TARGET_PTXTRANSLATION_H\n #define TRITON_TARGET_PTXTRANSLATION_H\n \n-#include <memory>\n #include <string>\n \n namespace llvm {"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "file_content_changes": "@@ -5921,11 +5921,13 @@ struct AtomicRMWOpConversion\n \n     Value llPtr = adaptor.ptr();\n     Value llVal = adaptor.val();\n+    Value llMask = adaptor.mask();\n \n     auto valElements = getElementsFromStruct(loc, llVal, rewriter);\n     auto ptrElements = getElementsFromStruct(loc, llPtr, rewriter);\n+    auto maskElements = getElementsFromStruct(loc, llMask, rewriter);\n \n-    // TODO[dongdongl]: Support mask and scalar\n+    // TODO[dongdongl]: Support scalar\n \n     auto valueTy = op.getResult().getType().dyn_cast<RankedTensorType>();\n     if (!valueTy)\n@@ -5940,6 +5942,14 @@ struct AtomicRMWOpConversion\n \n     auto vecTy = vec_ty(valueElemTy, vec);\n     auto elemsPerThread = getElemsPerThread(val.getType());\n+    // mask\n+    Value mask = int_val(1, 1);\n+    auto shape = valueTy.getShape();\n+    auto numElements = product(shape);\n+    auto tid = tid_val();\n+    mask = and_(mask, icmp_slt(mul(tid, i32_val(elemsPerThread)),\n+                               i32_val(numElements)));\n+\n     SmallVector<Value> resultVals(elemsPerThread);\n     for (size_t i = 0; i < elemsPerThread; i += vec) {\n       Value rmwVal = undef(vecTy);\n@@ -5949,6 +5959,8 @@ struct AtomicRMWOpConversion\n         rmwVal = insert_element(vecTy, rmwVal, valElements[i + ii], iiVal);\n       }\n       Value rmwPtr = ptrElements[i];\n+      Value rmwMask = maskElements[i];\n+      rmwMask = and_(rmwMask, mask);\n       std::string sTy;\n       PTXBuilder ptxBuilder;\n \n@@ -5996,9 +6008,8 @@ struct AtomicRMWOpConversion\n         return failure();\n       }\n       atom.o(rmwOp).o(sTy);\n-      // TODO:[dongdongl] actual mask support\n-      Value pred = int_val(1, 1);\n-      atom(dstOpr, ptrOpr, valOpr).predicate(pred);\n+      atom(dstOpr, ptrOpr, valOpr).predicate(rmwMask);\n+\n       auto ret = ptxBuilder.launch(rewriter, loc, valueElemTy);\n       for (int ii = 0; ii < vec; ++ii) {\n         resultVals[i * vec + ii] ="}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -3,11 +3,9 @@\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/ExecutionEngine/ExecutionEngine.h\"\n #include \"mlir/ExecutionEngine/OptUtils.h\"\n-#include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/Dialect.h\"\n #include \"mlir/Pass/Pass.h\"\n #include \"mlir/Pass/PassManager.h\"\n-#include \"mlir/Support/LogicalResult.h\"\n #include \"mlir/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.h\"\n #include \"mlir/Target/LLVMIR/Dialect/NVVM/NVVMToLLVMIRTranslation.h\"\n #include \"mlir/Target/LLVMIR/Export.h\""}, {"filename": "lib/Target/PTX/PTXTranslation.cpp", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "file_content_changes": "@@ -1,46 +1,17 @@\n #include \"triton/Target/PTX/PTXTranslation.h\"\n-#include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n-#include \"mlir/ExecutionEngine/ExecutionEngine.h\"\n-#include \"mlir/ExecutionEngine/OptUtils.h\"\n-#include \"mlir/IR/BuiltinOps.h\"\n-#include \"mlir/IR/Dialect.h\"\n-#include \"mlir/Pass/Pass.h\"\n-#include \"mlir/Pass/PassManager.h\"\n-#include \"mlir/Support/LogicalResult.h\"\n-#include \"mlir/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.h\"\n-#include \"mlir/Target/LLVMIR/Export.h\"\n-#include \"mlir/Target/LLVMIR/LLVMTranslationInterface.h\"\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n \n-#include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n-#include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n #include \"llvm/IR/IRBuilder.h\"\n-#include \"llvm/IR/IRPrintingPasses.h\"\n #include \"llvm/IR/LegacyPassManager.h\"\n #include \"llvm/IR/Module.h\"\n #include \"llvm/IR/Verifier.h\"\n #include \"llvm/MC/TargetRegistry.h\"\n-#include \"llvm/Support/CodeGen.h\"\n-#include \"llvm/Support/CommandLine.h\"\n-#include \"llvm/Support/SourceMgr.h\"\n #include \"llvm/Support/TargetSelect.h\"\n-#include \"llvm/Support/raw_ostream.h\"\n #include \"llvm/Target/TargetMachine.h\"\n-#include \"llvm/Target/TargetOptions.h\"\n-#include \"llvm/Transforms/Scalar.h\"\n-#include \"llvm/Transforms/Utils/Cloning.h\"\n #include <filesystem>\n-#include <regex>\n \n namespace triton {\n \n-extern \"C\" {\n-int set_curterm(char *nterm) { return 0; }\n-int del_curterm(char *nterm) { return 0; }\n-int tigetnum(char *capname) { return 0; }\n-int setupterm(char *term, int fildes, int *errret) { return 0; }\n-}\n-\n static void init_llvm() {\n   LLVMInitializeNVPTXTargetInfo();\n   LLVMInitializeNVPTXTarget();"}, {"filename": "python/tests/test_core.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -672,7 +672,7 @@ def without_fn(X, Y, A, B, C):\n #     np.testing.assert_allclose(z_ref, to_numpy(z_tri), rtol=1e-4)\n \n def test_tensor_atomic_rmw_add_elementwise(device=\"cuda\"):\n-    shape0, shape1 = 16, 16\n+    shape0, shape1 = 2, 8\n     @triton.jit\n     def kernel(Z, X, SHAPE0: tl.constexpr, SHAPE1: tl.constexpr):\n         off0 = tl.arange(0, SHAPE0)"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -1319,7 +1319,7 @@ def make_stub(name, signature, constants):\n \n \n def convert_type_repr(x):\n-    match = re.search('!tt\\.ptr<(.*)>', x)\n+    match = re.search(r'!tt\\.ptr<(.*)>', x)\n     if match is not None:\n       return '*' + convert_type_repr(match.group(1))\n     return x\n@@ -1490,6 +1490,7 @@ def _generate_src(self):\n         #include <cuda.h>\n \n         #include \\\"cuda.h\\\"\n+        #define PY_SSIZE_T_CLEAN \n         #include <Python.h>\n \n         static inline void gpuAssert(CUresult code, const char *file, int line)"}]