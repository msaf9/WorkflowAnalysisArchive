[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "file_content_changes": "@@ -1301,23 +1301,21 @@ def _compile(fn, signature: str, device: int = -1, constants=dict(), specializat\n         return cubin, ptx, ttgir, ttir, shem_size, kernel_name\n     assert False\n \n-def read_or_execute(cache_manager, file_name, metadata,\n+def read_or_execute(cache_manager, force_compile, file_name, metadata,\n                     run_if_found: Callable[[str], bytes] = None,\n                     run_if_not_found: Callable = None):\n-    if cache_manager.has_file(file_name):\n+    if not force_compile and cache_manager.has_file(file_name):\n       module = run_if_found(cache_manager._make_path(file_name))\n       data = module if isinstance(module, bytes) else str(module).encode(\"utf-8\")\n       md5 = hashlib.md5(data).hexdigest()\n       suffix = file_name.split(\".\")[1]\n-      if metadata and md5 == metadata[\"md5\"][suffix]:\n-        return module, md5, True\n-    # print(\"Compiling %s\" % file_name)\n-    # print(metadata)\n+      has_changed = metadata and md5 != metadata[\"md5\"][suffix]\n+      return module, md5, has_changed, True\n     module = run_if_not_found()\n     data = module if isinstance(module, bytes) else str(module).encode(\"utf-8\")\n     md5 = hashlib.md5(data).hexdigest()\n     cache_manager.put(data, file_name, True)\n-    return module, md5, False\n+    return module, md5, True, False\n \n \n def compile(fn, signature: str, device: int = -1, constants=dict(), num_warps: int = 4, num_stages: int = 3, extern_libs=None, configs=None):\n@@ -1353,28 +1351,29 @@ def compile(fn, signature: str, device: int = -1, constants=dict(), num_warps: i\n       with open(fn_cache_manager._make_path(f\"{name}.json\")) as f:\n             metadata = json.load(f)\n     context = _triton.ir.context()\n+    force_compile = False\n     # ast -> triton-ir (or read from cache)\n-    ttir, ttir_md5, _ = read_or_execute(fn_cache_manager, f\"{name}.ttir\", metadata,\n+    ttir, ttir_md5, force_compile, _ = read_or_execute(fn_cache_manager, force_compile, f\"{name}.ttir\", metadata,\n                            run_if_found = lambda path: _triton.ir.parse_mlir_module(path, context),\n                            run_if_not_found = lambda: make_triton_ir(fn, signature, configs[0], constants))\n     # triton-ir -> triton-gpu-ir (or read from cache)\n-    ttgir, ttgir_md5, _ = read_or_execute(fn_cache_manager, f\"{name}.ttgir\", metadata,\n+    ttgir, ttgir_md5, force_compile, _ = read_or_execute(fn_cache_manager, force_compile, f\"{name}.ttgir\", metadata,\n                             run_if_found = lambda path: _triton.ir.parse_mlir_module(path, context),\n                             run_if_not_found = lambda: make_tritongpu_ir(ttir, num_warps, num_stages))\n     # triton-gpu-ir -> llvm-ir (or read from cache)\n-    llir, llir_md5, llvm_cached = read_or_execute(fn_cache_manager, f\"{name}.llir\", metadata,\n+    llir, llir_md5, force_compile, llvm_cached = read_or_execute(fn_cache_manager, force_compile, f\"{name}.llir\", metadata,\n                            run_if_found = lambda path: Path(path).read_bytes(),\n                            run_if_not_found = lambda: make_llvm_ir(ttgir, extern_libs))\n     if llvm_cached:\n         shmem_size = metadata[\"shared\"]\n     else:\n         shmem_size = _triton.get_shared_memory_size(ttgir)\n     # llvm-ir -> ptx (or read from cache)\n-    ptx, ptx_md5, _ = read_or_execute(fn_cache_manager, f\"{name}.ptx\", metadata,\n+    ptx, ptx_md5, force_compile, _ = read_or_execute(fn_cache_manager, force_compile, f\"{name}.ptx\", metadata,\n                           run_if_found = lambda path: Path(path).read_text(),\n                           run_if_not_found = lambda: make_ptx(llir, device))\n     # ptx -> cubin (or read from cache)\n-    cubin, cubin_md5, _ = read_or_execute(fn_cache_manager, f\"{name}.cubin\", metadata,\n+    cubin, cubin_md5, force_compile, _ = read_or_execute(fn_cache_manager, force_compile, f\"{name}.cubin\", metadata,\n                             run_if_found = lambda path: Path(path).read_bytes(),      \n                             run_if_not_found= lambda: make_cubin(ptx, device))\n     # dump new metadata"}]