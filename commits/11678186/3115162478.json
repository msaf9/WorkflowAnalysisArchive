[{"filename": ".github/workflows/integration-tests.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -57,8 +57,8 @@ jobs:\n         if: ${{ matrix.runner != 'macos-latest' }}\n         run: |\n           pip install clang-format\n-          find . -regex '.*\\.\\(cpp\\|hpp\\|h\\|cc\\)' -not -path \"./python/build/*\" -not -path \"./include/triton/external/*\" -not -path \"./third-party/*\" -print0 | xargs -0 -n1 clang-format -style=file --dry-run -Werror -i ||\n-          (echo '::error title=Style issues:: Please run `find . -regex \".*\\.\\(cpp\\|hpp\\|h\\|cc\\)\" -not -path \"./python/build/*\" -not -path \"./include/triton/external/*\" -not -path \"./third-party/*\" -print0 | xargs -0 -n1 clang-format -style=file -i`' ; exit 1)\n+          find . -regex '.*\\.\\(cpp\\|hpp\\|h\\|cc\\)' -not -path \"./python/build/*\" -not -path \"./include/triton/external/*\" -print0 | xargs -0 -n1 clang-format -style=file --dry-run -Werror -i ||\n+          (echo '::error title=Style issues:: Please run `find . -regex \".*\\.\\(cpp\\|hpp\\|h\\|cc\\)\" -not -path \"./python/build/*\" -not -path \"./include/triton/external/*\" -print0 | xargs -0 -n1 clang-format -style=file -i`' ; exit 1)\n \n       - name: Flake8\n         if: ${{ matrix.runner != 'macos-latest' }}"}, {"filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "file_content_changes": "@@ -1,6 +1,3 @@\n [submodule \"deps/dlfcn-win32\"]\n \tpath = deps/dlfcn-win32\n \turl = https://github.com/dlfcn-win32/dlfcn-win32.git\n-[submodule \"third-party/pybind11\"]\n-\tpath = third-party/pybind11\n-\turl = https://github.com/pybind/pybind11.git"}, {"filename": "CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "file_content_changes": "@@ -31,9 +31,6 @@ endif()\n # Compiler flags\n include_directories(${CMAKE_CURRENT_SOURCE_DIR}/include)\n \n-# Third-party\n-include_directories(${CMAKE_CURRENT_SOURCE_DIR}/third-party/pybind11/include)\n-\n if(WIN32)\n     SET(BUILD_SHARED_LIBS OFF)\n     include_directories(${CMAKE_CURRENT_SOURCE_DIR}/deps/dlfcn-win32/src)"}, {"filename": "python/setup.py", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "file_content_changes": "@@ -20,20 +20,6 @@ def check_env_flag(name: str, default: str = \"\") -> bool:\n     return os.getenv(name, default).upper() in [\"ON\", \"1\", \"YES\", \"TRUE\", \"Y\"]\n \n \n-def check_submodule(base_dir: str):\n-    submodule_paths = [\"{}/third-party/pybind11/include/pybind11\".format(base_dir)]\n-    if not all([os.path.exists(p) for p in submodule_paths]):\n-        print(\"initializing submodules ...\")\n-        try:\n-            cwd = os.path.abspath(os.path.dirname(__file__))\n-            subprocess.check_call([\"git\", \"submodule\", \"update\", \"--init\", \"--recursive\"], cwd=cwd)\n-            print(\"submodule initialization succeeded\")\n-        except Exception:\n-            print(\"submodule initialization failed\")\n-            print(\" Please run:\\n\\tgit submodule update --init --recursive\")\n-            exit(-1)\n-\n-\n def get_llvm():\n     # download if nothing is installed\n     system = platform.system()\n@@ -95,7 +81,6 @@ def run(self):\n             self.build_extension(ext)\n \n     def build_extension(self, ext):\n-        check_submodule(self.base_dir)\n         llvm_include_dir, llvm_library_dir = get_llvm()\n         # lit is used by the test suite\n         lit_dir = shutil.which('lit')"}, {"filename": "python/src/pybind11/attr.h", "status": "added", "additions": 601, "deletions": 0, "changes": 601, "file_content_changes": "@@ -0,0 +1,601 @@\n+/*\n+    pybind11/attr.h: Infrastructure for processing custom\n+    type and function attributes\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"cast.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+/// \\addtogroup annotations\n+/// @{\n+\n+/// Annotation for methods\n+struct is_method {\n+  handle class_;\n+  is_method(const handle &c) : class_(c) {}\n+};\n+\n+/// Annotation for operators\n+struct is_operator {};\n+\n+/// Annotation for parent scope\n+struct scope {\n+  handle value;\n+  scope(const handle &s) : value(s) {}\n+};\n+\n+/// Annotation for documentation\n+struct doc {\n+  const char *value;\n+  doc(const char *value) : value(value) {}\n+};\n+\n+/// Annotation for function names\n+struct name {\n+  const char *value;\n+  name(const char *value) : value(value) {}\n+};\n+\n+/// Annotation indicating that a function is an overload associated with a given\n+/// \"sibling\"\n+struct sibling {\n+  handle value;\n+  sibling(const handle &value) : value(value.ptr()) {}\n+};\n+\n+/// Annotation indicating that a class derives from another given type\n+template <typename T> struct base {\n+  PYBIND11_DEPRECATED(\"base<T>() was deprecated in favor of specifying 'T' as \"\n+                      \"a template argument to class_\")\n+  base() {}\n+};\n+\n+/// Keep patient alive while nurse lives\n+template <size_t Nurse, size_t Patient> struct keep_alive {};\n+\n+/// Annotation indicating that a class is involved in a multiple inheritance\n+/// relationship\n+struct multiple_inheritance {};\n+\n+/// Annotation which enables dynamic attributes, i.e. adds `__dict__` to a class\n+struct dynamic_attr {};\n+\n+/// Annotation which enables the buffer protocol for a type\n+struct buffer_protocol {};\n+\n+/// Annotation which requests that a special metaclass is created for a type\n+struct metaclass {\n+  handle value;\n+\n+  PYBIND11_DEPRECATED(\n+      \"py::metaclass() is no longer required. It's turned on by default now.\")\n+  metaclass() {}\n+\n+  /// Override pybind11's default metaclass\n+  explicit metaclass(handle value) : value(value) {}\n+};\n+\n+/// Annotation that marks a class as local to the module:\n+struct module_local {\n+  const bool value;\n+  constexpr module_local(bool v = true) : value(v) {}\n+};\n+\n+/// Annotation to mark enums as an arithmetic type\n+struct arithmetic {};\n+\n+/** \\rst\n+    A call policy which places one or more guard variables (``Ts...``) around\n+ the function call.\n+\n+    For example, this definition:\n+\n+    .. code-block:: cpp\n+\n+        m.def(\"foo\", foo, py::call_guard<T>());\n+\n+    is equivalent to the following pseudocode:\n+\n+    .. code-block:: cpp\n+\n+        m.def(\"foo\", [](args...) {\n+            T scope_guard;\n+            return foo(args...); // forwarded arguments\n+        });\n+ \\endrst */\n+template <typename... Ts> struct call_guard;\n+\n+template <> struct call_guard<> { using type = detail::void_type; };\n+\n+template <typename T> struct call_guard<T> {\n+  static_assert(std::is_default_constructible<T>::value,\n+                \"The guard type must be default constructible\");\n+\n+  using type = T;\n+};\n+\n+template <typename T, typename... Ts> struct call_guard<T, Ts...> {\n+  struct type {\n+    T guard{}; // Compose multiple guard types with left-to-right\n+               // default-constructor order\n+    typename call_guard<Ts...>::type next{};\n+  };\n+};\n+\n+/// @} annotations\n+\n+NAMESPACE_BEGIN(detail)\n+/* Forward declarations */\n+enum op_id : int;\n+enum op_type : int;\n+struct undefined_t;\n+template <op_id id, op_type ot, typename L = undefined_t,\n+          typename R = undefined_t>\n+struct op_;\n+inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call,\n+                            handle ret);\n+\n+/// Internal data structure which holds metadata about a keyword argument\n+struct argument_record {\n+  const char *name;  ///< Argument name\n+  const char *descr; ///< Human-readable version of the argument value\n+  handle value;      ///< Associated Python object\n+  bool convert : 1; ///< True if the argument is allowed to convert when loading\n+  bool none : 1;    ///< True if None is allowed when loading\n+\n+  argument_record(const char *name, const char *descr, handle value,\n+                  bool convert, bool none)\n+      : name(name), descr(descr), value(value), convert(convert), none(none) {}\n+};\n+\n+/// Internal data structure which holds metadata about a bound function\n+/// (signature, overloads, etc.)\n+struct function_record {\n+  function_record()\n+      : is_constructor(false), is_new_style_constructor(false),\n+        is_stateless(false), is_operator(false), has_args(false),\n+        has_kwargs(false), is_method(false) {}\n+\n+  /// Function name\n+  char *name = nullptr; /* why no C++ strings? They generate heavier code.. */\n+\n+  // User-specified documentation string\n+  char *doc = nullptr;\n+\n+  /// Human-readable version of the function signature\n+  char *signature = nullptr;\n+\n+  /// List of registered keyword arguments\n+  std::vector<argument_record> args;\n+\n+  /// Pointer to lambda function which converts arguments and performs the\n+  /// actual call\n+  handle (*impl)(function_call &) = nullptr;\n+\n+  /// Storage for the wrapped function pointer and captured data, if any\n+  void *data[3] = {};\n+\n+  /// Pointer to custom destructor for 'data' (if needed)\n+  void (*free_data)(function_record *ptr) = nullptr;\n+\n+  /// Return value policy associated with this function\n+  return_value_policy policy = return_value_policy::automatic;\n+\n+  /// True if name == '__init__'\n+  bool is_constructor : 1;\n+\n+  /// True if this is a new-style `__init__` defined in `detail/init.h`\n+  bool is_new_style_constructor : 1;\n+\n+  /// True if this is a stateless function pointer\n+  bool is_stateless : 1;\n+\n+  /// True if this is an operator (__add__), etc.\n+  bool is_operator : 1;\n+\n+  /// True if the function has a '*args' argument\n+  bool has_args : 1;\n+\n+  /// True if the function has a '**kwargs' argument\n+  bool has_kwargs : 1;\n+\n+  /// True if this is a method\n+  bool is_method : 1;\n+\n+  /// Number of arguments (including py::args and/or py::kwargs, if present)\n+  std::uint16_t nargs;\n+\n+  /// Python method object\n+  PyMethodDef *def = nullptr;\n+\n+  /// Python handle to the parent scope (a class or a module)\n+  handle scope;\n+\n+  /// Python handle to the sibling function representing an overload chain\n+  handle sibling;\n+\n+  /// Pointer to next overload\n+  function_record *next = nullptr;\n+};\n+\n+/// Special data structure which (temporarily) holds metadata about a bound\n+/// class\n+struct type_record {\n+  PYBIND11_NOINLINE type_record()\n+      : multiple_inheritance(false), dynamic_attr(false),\n+        buffer_protocol(false), default_holder(true), module_local(false) {}\n+\n+  /// Handle to the parent scope\n+  handle scope;\n+\n+  /// Name of the class\n+  const char *name = nullptr;\n+\n+  // Pointer to RTTI type_info data structure\n+  const std::type_info *type = nullptr;\n+\n+  /// How large is the underlying C++ type?\n+  size_t type_size = 0;\n+\n+  /// What is the alignment of the underlying C++ type?\n+  size_t type_align = 0;\n+\n+  /// How large is the type's holder?\n+  size_t holder_size = 0;\n+\n+  /// The global operator new can be overridden with a class-specific variant\n+  void *(*operator_new)(size_t) = nullptr;\n+\n+  /// Function pointer to class_<..>::init_instance\n+  void (*init_instance)(instance *, const void *) = nullptr;\n+\n+  /// Function pointer to class_<..>::dealloc\n+  void (*dealloc)(detail::value_and_holder &) = nullptr;\n+\n+  /// List of base classes of the newly created type\n+  list bases;\n+\n+  /// Optional docstring\n+  const char *doc = nullptr;\n+\n+  /// Custom metaclass (optional)\n+  handle metaclass;\n+\n+  /// Multiple inheritance marker\n+  bool multiple_inheritance : 1;\n+\n+  /// Does the class manage a __dict__?\n+  bool dynamic_attr : 1;\n+\n+  /// Does the class implement the buffer protocol?\n+  bool buffer_protocol : 1;\n+\n+  /// Is the default (unique_ptr) holder type used?\n+  bool default_holder : 1;\n+\n+  /// Is the class definition local to the module shared object?\n+  bool module_local : 1;\n+\n+  PYBIND11_NOINLINE void add_base(const std::type_info &base,\n+                                  void *(*caster)(void *)) {\n+    auto base_info = detail::get_type_info(base, false);\n+    if (!base_info) {\n+      std::string tname(base.name());\n+      detail::clean_type_id(tname);\n+      pybind11_fail(\"generic_type: type \\\"\" + std::string(name) +\n+                    \"\\\" referenced unknown base type \\\"\" + tname + \"\\\"\");\n+    }\n+\n+    if (default_holder != base_info->default_holder) {\n+      std::string tname(base.name());\n+      detail::clean_type_id(tname);\n+      pybind11_fail(\"generic_type: type \\\"\" + std::string(name) + \"\\\" \" +\n+                    (default_holder ? \"does not have\" : \"has\") +\n+                    \" a non-default holder type while its base \\\"\" + tname +\n+                    \"\\\" \" + (base_info->default_holder ? \"does not\" : \"does\"));\n+    }\n+\n+    bases.append((PyObject *)base_info->type);\n+\n+    if (base_info->type->tp_dictoffset != 0)\n+      dynamic_attr = true;\n+\n+    if (caster)\n+      base_info->implicit_casts.emplace_back(type, caster);\n+  }\n+};\n+\n+inline function_call::function_call(const function_record &f, handle p)\n+    : func(f), parent(p) {\n+  args.reserve(f.nargs);\n+  args_convert.reserve(f.nargs);\n+}\n+\n+/// Tag for a new-style `__init__` defined in `detail/init.h`\n+struct is_new_style_constructor {};\n+\n+/**\n+ * Partial template specializations to process custom attributes provided to\n+ * cpp_function_ and class_. These are either used to initialize the respective\n+ * fields in the type_record and function_record data structures or executed at\n+ * runtime to deal with custom call policies (e.g. keep_alive).\n+ */\n+template <typename T, typename SFINAE = void> struct process_attribute;\n+\n+template <typename T> struct process_attribute_default {\n+  /// Default implementation: do nothing\n+  static void init(const T &, function_record *) {}\n+  static void init(const T &, type_record *) {}\n+  static void precall(function_call &) {}\n+  static void postcall(function_call &, handle) {}\n+};\n+\n+/// Process an attribute specifying the function's name\n+template <> struct process_attribute<name> : process_attribute_default<name> {\n+  static void init(const name &n, function_record *r) {\n+    r->name = const_cast<char *>(n.value);\n+  }\n+};\n+\n+/// Process an attribute specifying the function's docstring\n+template <> struct process_attribute<doc> : process_attribute_default<doc> {\n+  static void init(const doc &n, function_record *r) {\n+    r->doc = const_cast<char *>(n.value);\n+  }\n+};\n+\n+/// Process an attribute specifying the function's docstring (provided as a\n+/// C-style string)\n+template <>\n+struct process_attribute<const char *>\n+    : process_attribute_default<const char *> {\n+  static void init(const char *d, function_record *r) {\n+    r->doc = const_cast<char *>(d);\n+  }\n+  static void init(const char *d, type_record *r) {\n+    r->doc = const_cast<char *>(d);\n+  }\n+};\n+template <>\n+struct process_attribute<char *> : process_attribute<const char *> {};\n+\n+/// Process an attribute indicating the function's return value policy\n+template <>\n+struct process_attribute<return_value_policy>\n+    : process_attribute_default<return_value_policy> {\n+  static void init(const return_value_policy &p, function_record *r) {\n+    r->policy = p;\n+  }\n+};\n+\n+/// Process an attribute which indicates that this is an overloaded function\n+/// associated with a given sibling\n+template <>\n+struct process_attribute<sibling> : process_attribute_default<sibling> {\n+  static void init(const sibling &s, function_record *r) {\n+    r->sibling = s.value;\n+  }\n+};\n+\n+/// Process an attribute which indicates that this function is a method\n+template <>\n+struct process_attribute<is_method> : process_attribute_default<is_method> {\n+  static void init(const is_method &s, function_record *r) {\n+    r->is_method = true;\n+    r->scope = s.class_;\n+  }\n+};\n+\n+/// Process an attribute which indicates the parent scope of a method\n+template <> struct process_attribute<scope> : process_attribute_default<scope> {\n+  static void init(const scope &s, function_record *r) { r->scope = s.value; }\n+};\n+\n+/// Process an attribute which indicates that this function is an operator\n+template <>\n+struct process_attribute<is_operator> : process_attribute_default<is_operator> {\n+  static void init(const is_operator &, function_record *r) {\n+    r->is_operator = true;\n+  }\n+};\n+\n+template <>\n+struct process_attribute<is_new_style_constructor>\n+    : process_attribute_default<is_new_style_constructor> {\n+  static void init(const is_new_style_constructor &, function_record *r) {\n+    r->is_new_style_constructor = true;\n+  }\n+};\n+\n+/// Process a keyword argument attribute (*without* a default value)\n+template <> struct process_attribute<arg> : process_attribute_default<arg> {\n+  static void init(const arg &a, function_record *r) {\n+    if (r->is_method && r->args.empty())\n+      r->args.emplace_back(\"self\", nullptr, handle(), true /*convert*/,\n+                           false /*none not allowed*/);\n+    r->args.emplace_back(a.name, nullptr, handle(), !a.flag_noconvert,\n+                         a.flag_none);\n+  }\n+};\n+\n+/// Process a keyword argument attribute (*with* a default value)\n+template <> struct process_attribute<arg_v> : process_attribute_default<arg_v> {\n+  static void init(const arg_v &a, function_record *r) {\n+    if (r->is_method && r->args.empty())\n+      r->args.emplace_back(\"self\", nullptr /*descr*/, handle() /*parent*/,\n+                           true /*convert*/, false /*none not allowed*/);\n+\n+    if (!a.value) {\n+#if !defined(NDEBUG)\n+      std::string descr(\"'\");\n+      if (a.name)\n+        descr += std::string(a.name) + \": \";\n+      descr += a.type + \"'\";\n+      if (r->is_method) {\n+        if (r->name)\n+          descr += \" in method '\" + (std::string)str(r->scope) + \".\" +\n+                   (std::string)r->name + \"'\";\n+        else\n+          descr += \" in method of '\" + (std::string)str(r->scope) + \"'\";\n+      } else if (r->name) {\n+        descr += \" in function '\" + (std::string)r->name + \"'\";\n+      }\n+      pybind11_fail(\"arg(): could not convert default argument \" + descr +\n+                    \" into a Python object (type not registered yet?)\");\n+#else\n+      pybind11_fail(\"arg(): could not convert default argument \"\n+                    \"into a Python object (type not registered yet?). \"\n+                    \"Compile in debug mode for more information.\");\n+#endif\n+    }\n+    r->args.emplace_back(a.name, a.descr, a.value.inc_ref(), !a.flag_noconvert,\n+                         a.flag_none);\n+  }\n+};\n+\n+/// Process a parent class attribute.  Single inheritance only (class_ itself\n+/// already guarantees that)\n+template <typename T>\n+struct process_attribute<T, enable_if_t<is_pyobject<T>::value>>\n+    : process_attribute_default<handle> {\n+  static void init(const handle &h, type_record *r) { r->bases.append(h); }\n+};\n+\n+/// Process a parent class attribute (deprecated, does not support multiple\n+/// inheritance)\n+template <typename T>\n+struct process_attribute<base<T>> : process_attribute_default<base<T>> {\n+  static void init(const base<T> &, type_record *r) {\n+    r->add_base(typeid(T), nullptr);\n+  }\n+};\n+\n+/// Process a multiple inheritance attribute\n+template <>\n+struct process_attribute<multiple_inheritance>\n+    : process_attribute_default<multiple_inheritance> {\n+  static void init(const multiple_inheritance &, type_record *r) {\n+    r->multiple_inheritance = true;\n+  }\n+};\n+\n+template <>\n+struct process_attribute<dynamic_attr>\n+    : process_attribute_default<dynamic_attr> {\n+  static void init(const dynamic_attr &, type_record *r) {\n+    r->dynamic_attr = true;\n+  }\n+};\n+\n+template <>\n+struct process_attribute<buffer_protocol>\n+    : process_attribute_default<buffer_protocol> {\n+  static void init(const buffer_protocol &, type_record *r) {\n+    r->buffer_protocol = true;\n+  }\n+};\n+\n+template <>\n+struct process_attribute<metaclass> : process_attribute_default<metaclass> {\n+  static void init(const metaclass &m, type_record *r) {\n+    r->metaclass = m.value;\n+  }\n+};\n+\n+template <>\n+struct process_attribute<module_local>\n+    : process_attribute_default<module_local> {\n+  static void init(const module_local &l, type_record *r) {\n+    r->module_local = l.value;\n+  }\n+};\n+\n+/// Process an 'arithmetic' attribute for enums (does nothing here)\n+template <>\n+struct process_attribute<arithmetic> : process_attribute_default<arithmetic> {};\n+\n+template <typename... Ts>\n+struct process_attribute<call_guard<Ts...>>\n+    : process_attribute_default<call_guard<Ts...>> {};\n+\n+/**\n+ * Process a keep_alive call policy -- invokes keep_alive_impl during the\n+ * pre-call handler if both Nurse, Patient != 0 and use the post-call handler\n+ * otherwise\n+ */\n+template <size_t Nurse, size_t Patient>\n+struct process_attribute<keep_alive<Nurse, Patient>>\n+    : public process_attribute_default<keep_alive<Nurse, Patient>> {\n+  template <size_t N = Nurse, size_t P = Patient,\n+            enable_if_t<N != 0 && P != 0, int> = 0>\n+  static void precall(function_call &call) {\n+    keep_alive_impl(Nurse, Patient, call, handle());\n+  }\n+  template <size_t N = Nurse, size_t P = Patient,\n+            enable_if_t<N != 0 && P != 0, int> = 0>\n+  static void postcall(function_call &, handle) {}\n+  template <size_t N = Nurse, size_t P = Patient,\n+            enable_if_t<N == 0 || P == 0, int> = 0>\n+  static void precall(function_call &) {}\n+  template <size_t N = Nurse, size_t P = Patient,\n+            enable_if_t<N == 0 || P == 0, int> = 0>\n+  static void postcall(function_call &call, handle ret) {\n+    keep_alive_impl(Nurse, Patient, call, ret);\n+  }\n+};\n+\n+/// Recursively iterate over variadic template arguments\n+template <typename... Args> struct process_attributes {\n+  static void init(const Args &...args, function_record *r) {\n+    int unused[] = {\n+        0, (process_attribute<typename std::decay<Args>::type>::init(args, r),\n+            0)...};\n+    ignore_unused(unused);\n+  }\n+  static void init(const Args &...args, type_record *r) {\n+    int unused[] = {\n+        0, (process_attribute<typename std::decay<Args>::type>::init(args, r),\n+            0)...};\n+    ignore_unused(unused);\n+  }\n+  static void precall(function_call &call) {\n+    int unused[] = {\n+        0, (process_attribute<typename std::decay<Args>::type>::precall(call),\n+            0)...};\n+    ignore_unused(unused);\n+  }\n+  static void postcall(function_call &call, handle fn_ret) {\n+    int unused[] = {\n+        0, (process_attribute<typename std::decay<Args>::type>::postcall(\n+                call, fn_ret),\n+            0)...};\n+    ignore_unused(unused);\n+  }\n+};\n+\n+template <typename T> using is_call_guard = is_instantiation<call_guard, T>;\n+\n+/// Extract the ``type`` from the first `call_guard` in `Extras...` (or\n+/// `void_type` if none found)\n+template <typename... Extra>\n+using extract_guard_t =\n+    typename exactly_one_t<is_call_guard, call_guard<>, Extra...>::type;\n+\n+/// Check the number of named arguments at compile time\n+template <typename... Extra,\n+          size_t named = constexpr_sum(std::is_base_of<arg, Extra>::value...),\n+          size_t self = constexpr_sum(std::is_same<is_method, Extra>::value...)>\n+constexpr bool expected_num_args(size_t nargs, bool has_args, bool has_kwargs) {\n+  return named == 0 || (self + named + has_args + has_kwargs) == nargs;\n+}\n+\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/buffer_info.h", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "file_content_changes": "@@ -0,0 +1,127 @@\n+/*\n+    pybind11/buffer_info.h: Python buffer object interface\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+/// Information record describing a Python buffer object\n+struct buffer_info {\n+  void *ptr = nullptr;        // Pointer to the underlying storage\n+  ssize_t itemsize = 0;       // Size of individual items in bytes\n+  ssize_t size = 0;           // Total number of entries\n+  std::string format;         // For homogeneous buffers, this should be set to\n+                              // format_descriptor<T>::format()\n+  ssize_t ndim = 0;           // Number of dimensions\n+  std::vector<ssize_t> shape; // Shape of the tensor (1 entry per dimension)\n+  std::vector<ssize_t> strides; // Number of entries between adjacent entries\n+                                // (for each per dimension)\n+\n+  buffer_info() {}\n+\n+  buffer_info(void *ptr, ssize_t itemsize, const std::string &format,\n+              ssize_t ndim, detail::any_container<ssize_t> shape_in,\n+              detail::any_container<ssize_t> strides_in)\n+      : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),\n+        shape(std::move(shape_in)), strides(std::move(strides_in)) {\n+    if (ndim != (ssize_t)shape.size() || ndim != (ssize_t)strides.size())\n+      pybind11_fail(\n+          \"buffer_info: ndim doesn't match shape and/or strides length\");\n+    for (size_t i = 0; i < (size_t)ndim; ++i)\n+      size *= shape[i];\n+  }\n+\n+  template <typename T>\n+  buffer_info(T *ptr, detail::any_container<ssize_t> shape_in,\n+              detail::any_container<ssize_t> strides_in)\n+      : buffer_info(private_ctr_tag(), ptr, sizeof(T),\n+                    format_descriptor<T>::format(),\n+                    static_cast<ssize_t>(shape_in->size()), std::move(shape_in),\n+                    std::move(strides_in)) {}\n+\n+  buffer_info(void *ptr, ssize_t itemsize, const std::string &format,\n+              ssize_t size)\n+      : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}) {}\n+\n+  template <typename T>\n+  buffer_info(T *ptr, ssize_t size)\n+      : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size) {}\n+\n+  explicit buffer_info(Py_buffer *view, bool ownview = true)\n+      : buffer_info(view->buf, view->itemsize, view->format, view->ndim,\n+                    {view->shape, view->shape + view->ndim},\n+                    {view->strides, view->strides + view->ndim}) {\n+    this->view = view;\n+    this->ownview = ownview;\n+  }\n+\n+  buffer_info(const buffer_info &) = delete;\n+  buffer_info &operator=(const buffer_info &) = delete;\n+\n+  buffer_info(buffer_info &&other) { (*this) = std::move(other); }\n+\n+  buffer_info &operator=(buffer_info &&rhs) {\n+    ptr = rhs.ptr;\n+    itemsize = rhs.itemsize;\n+    size = rhs.size;\n+    format = std::move(rhs.format);\n+    ndim = rhs.ndim;\n+    shape = std::move(rhs.shape);\n+    strides = std::move(rhs.strides);\n+    std::swap(view, rhs.view);\n+    std::swap(ownview, rhs.ownview);\n+    return *this;\n+  }\n+\n+  ~buffer_info() {\n+    if (view && ownview) {\n+      PyBuffer_Release(view);\n+      delete view;\n+    }\n+  }\n+\n+private:\n+  struct private_ctr_tag {};\n+\n+  buffer_info(private_ctr_tag, void *ptr, ssize_t itemsize,\n+              const std::string &format, ssize_t ndim,\n+              detail::any_container<ssize_t> &&shape_in,\n+              detail::any_container<ssize_t> &&strides_in)\n+      : buffer_info(ptr, itemsize, format, ndim, std::move(shape_in),\n+                    std::move(strides_in)) {}\n+\n+  Py_buffer *view = nullptr;\n+  bool ownview = false;\n+};\n+\n+NAMESPACE_BEGIN(detail)\n+\n+template <typename T, typename SFINAE = void> struct compare_buffer_info {\n+  static bool compare(const buffer_info &b) {\n+    return b.format == format_descriptor<T>::format() &&\n+           b.itemsize == (ssize_t)sizeof(T);\n+  }\n+};\n+\n+template <typename T>\n+struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {\n+  static bool compare(const buffer_info &b) {\n+    return (size_t)b.itemsize == sizeof(T) &&\n+           (b.format == format_descriptor<T>::value ||\n+            ((sizeof(T) == sizeof(long)) &&\n+             b.format == (std::is_unsigned<T>::value ? \"L\" : \"l\")) ||\n+            ((sizeof(T) == sizeof(size_t)) &&\n+             b.format == (std::is_unsigned<T>::value ? \"N\" : \"n\")));\n+  }\n+};\n+\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/cast.h", "status": "added", "additions": 2465, "deletions": 0, "changes": 2465, "file_content_changes": "@@ -0,0 +1,2465 @@\n+/*\n+    pybind11/cast.h: Partial template specializations to cast between\n+    C++ and Python types\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/descr.h\"\n+#include \"detail/internals.h\"\n+#include \"detail/typeid.h\"\n+#include \"pytypes.h\"\n+#include <array>\n+#include <limits>\n+#include <tuple>\n+#include <type_traits>\n+\n+#if defined(PYBIND11_CPP17)\n+#if defined(__has_include)\n+#if __has_include(<string_view>)\n+#define PYBIND11_HAS_STRING_VIEW\n+#endif\n+#elif defined(_MSC_VER)\n+#define PYBIND11_HAS_STRING_VIEW\n+#endif\n+#endif\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+#include <string_view>\n+#endif\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+/// A life support system for temporary objects created by\n+/// `type_caster::load()`. Adding a patient will keep it alive up until the\n+/// enclosing function returns.\n+class loader_life_support {\n+public:\n+  /// A new patient frame is created when a function is entered\n+  loader_life_support() {\n+    get_internals().loader_patient_stack.push_back(nullptr);\n+  }\n+\n+  /// ... and destroyed after it returns\n+  ~loader_life_support() {\n+    auto &stack = get_internals().loader_patient_stack;\n+    if (stack.empty())\n+      pybind11_fail(\"loader_life_support: internal error\");\n+\n+    auto ptr = stack.back();\n+    stack.pop_back();\n+    Py_CLEAR(ptr);\n+\n+    // A heuristic to reduce the stack's capacity (e.g. after long recursive\n+    // calls)\n+    if (stack.capacity() > 16 && stack.size() != 0 &&\n+        stack.capacity() / stack.size() > 2)\n+      stack.shrink_to_fit();\n+  }\n+\n+  /// This can only be used inside a pybind11-bound function, either by\n+  /// `argument_loader` at argument preparation time or by `py::cast()` at\n+  /// execution time.\n+  PYBIND11_NOINLINE static void add_patient(handle h) {\n+    auto &stack = get_internals().loader_patient_stack;\n+    if (stack.empty())\n+      throw cast_error(\n+          \"When called outside a bound function, py::cast() cannot \"\n+          \"do Python -> C++ conversions which require the creation \"\n+          \"of temporary values\");\n+\n+    auto &list_ptr = stack.back();\n+    if (list_ptr == nullptr) {\n+      list_ptr = PyList_New(1);\n+      if (!list_ptr)\n+        pybind11_fail(\"loader_life_support: error allocating list\");\n+      PyList_SET_ITEM(list_ptr, 0, h.inc_ref().ptr());\n+    } else {\n+      auto result = PyList_Append(list_ptr, h.ptr());\n+      if (result == -1)\n+        pybind11_fail(\"loader_life_support: error adding patient\");\n+    }\n+  }\n+};\n+\n+// Gets the cache entry for the given type, creating it if necessary.  The\n+// return value is the pair returned by emplace, i.e. an iterator for the entry\n+// and a bool set to `true` if the entry was just created.\n+inline std::pair<decltype(internals::registered_types_py)::iterator, bool>\n+all_type_info_get_cache(PyTypeObject *type);\n+\n+// Populates a just-created cache entry.\n+PYBIND11_NOINLINE inline void\n+all_type_info_populate(PyTypeObject *t, std::vector<type_info *> &bases) {\n+  std::vector<PyTypeObject *> check;\n+  for (handle parent : reinterpret_borrow<tuple>(t->tp_bases))\n+    check.push_back((PyTypeObject *)parent.ptr());\n+\n+  auto const &type_dict = get_internals().registered_types_py;\n+  for (size_t i = 0; i < check.size(); i++) {\n+    auto type = check[i];\n+    // Ignore Python2 old-style class super type:\n+    if (!PyType_Check((PyObject *)type))\n+      continue;\n+\n+    // Check `type` in the current set of registered python types:\n+    auto it = type_dict.find(type);\n+    if (it != type_dict.end()) {\n+      // We found a cache entry for it, so it's either pybind-registered or has\n+      // pre-computed pybind bases, but we have to make sure we haven't already\n+      // seen the type(s) before: we want to follow Python/virtual C++ rules\n+      // that there should only be one instance of a common base.\n+      for (auto *tinfo : it->second) {\n+        // NB: Could use a second set here, rather than doing a linear search,\n+        // but since having a large number of immediate pybind11-registered\n+        // types seems fairly unlikely, that probably isn't worthwhile.\n+        bool found = false;\n+        for (auto *known : bases) {\n+          if (known == tinfo) {\n+            found = true;\n+            break;\n+          }\n+        }\n+        if (!found)\n+          bases.push_back(tinfo);\n+      }\n+    } else if (type->tp_bases) {\n+      // It's some python type, so keep follow its bases classes to look for one\n+      // or more registered types\n+      if (i + 1 == check.size()) {\n+        // When we're at the end, we can pop off the current element to avoid\n+        // growing `check` when adding just one base (which is typical--i.e.\n+        // when there is no multiple inheritance)\n+        check.pop_back();\n+        i--;\n+      }\n+      for (handle parent : reinterpret_borrow<tuple>(type->tp_bases))\n+        check.push_back((PyTypeObject *)parent.ptr());\n+    }\n+  }\n+}\n+\n+/**\n+ * Extracts vector of type_info pointers of pybind-registered roots of the given\n+ * Python type.  Will be just 1 pybind type for the Python type of a\n+ * pybind-registered class, or for any Python-side derived class that uses\n+ * single inheritance.  Will contain as many types as required for a Python\n+ * class that uses multiple inheritance to inherit (directly or indirectly) from\n+ * multiple pybind-registered classes.  Will be empty if neither the type nor\n+ * any base classes are pybind-registered.\n+ *\n+ * The value is cached for the lifetime of the Python type.\n+ */\n+inline const std::vector<detail::type_info *> &\n+all_type_info(PyTypeObject *type) {\n+  auto ins = all_type_info_get_cache(type);\n+  if (ins.second)\n+    // New cache entry: populate it\n+    all_type_info_populate(type, ins.first->second);\n+\n+  return ins.first->second;\n+}\n+\n+/**\n+ * Gets a single pybind11 type info for a python type.  Returns nullptr if\n+ * neither the type nor any ancestors are pybind11-registered.  Throws an\n+ * exception if there are multiple bases--use `all_type_info` instead if you\n+ * want to support multiple bases.\n+ */\n+PYBIND11_NOINLINE inline detail::type_info *get_type_info(PyTypeObject *type) {\n+  auto &bases = all_type_info(type);\n+  if (bases.size() == 0)\n+    return nullptr;\n+  if (bases.size() > 1)\n+    pybind11_fail(\"pybind11::detail::get_type_info: type has multiple \"\n+                  \"pybind11-registered bases\");\n+  return bases.front();\n+}\n+\n+inline detail::type_info *get_local_type_info(const std::type_index &tp) {\n+  auto &locals = registered_local_types_cpp();\n+  auto it = locals.find(tp);\n+  if (it != locals.end())\n+    return it->second;\n+  return nullptr;\n+}\n+\n+inline detail::type_info *get_global_type_info(const std::type_index &tp) {\n+  auto &types = get_internals().registered_types_cpp;\n+  auto it = types.find(tp);\n+  if (it != types.end())\n+    return it->second;\n+  return nullptr;\n+}\n+\n+/// Return the type info for a given C++ type; on lookup failure can either\n+/// throw or return nullptr.\n+PYBIND11_NOINLINE inline detail::type_info *\n+get_type_info(const std::type_index &tp, bool throw_if_missing = false) {\n+  if (auto ltype = get_local_type_info(tp))\n+    return ltype;\n+  if (auto gtype = get_global_type_info(tp))\n+    return gtype;\n+\n+  if (throw_if_missing) {\n+    std::string tname = tp.name();\n+    detail::clean_type_id(tname);\n+    pybind11_fail(\n+        \"pybind11::detail::get_type_info: unable to find type info for \\\"\" +\n+        tname + \"\\\"\");\n+  }\n+  return nullptr;\n+}\n+\n+PYBIND11_NOINLINE inline handle get_type_handle(const std::type_info &tp,\n+                                                bool throw_if_missing) {\n+  detail::type_info *type_info = get_type_info(tp, throw_if_missing);\n+  return handle(type_info ? ((PyObject *)type_info->type) : nullptr);\n+}\n+\n+struct value_and_holder {\n+  instance *inst = nullptr;\n+  size_t index = 0u;\n+  const detail::type_info *type = nullptr;\n+  void **vh = nullptr;\n+\n+  // Main constructor for a found value/holder:\n+  value_and_holder(instance *i, const detail::type_info *type, size_t vpos,\n+                   size_t index)\n+      : inst{i}, index{index}, type{type},\n+        vh{inst->simple_layout ? inst->simple_value_holder\n+                               : &inst->nonsimple.values_and_holders[vpos]} {}\n+\n+  // Default constructor (used to signal a value-and-holder not found by\n+  // get_value_and_holder())\n+  value_and_holder() {}\n+\n+  // Used for past-the-end iterator\n+  value_and_holder(size_t index) : index{index} {}\n+\n+  template <typename V = void> V *&value_ptr() const {\n+    return reinterpret_cast<V *&>(vh[0]);\n+  }\n+  // True if this `value_and_holder` has a non-null value pointer\n+  explicit operator bool() const { return value_ptr(); }\n+\n+  template <typename H> H &holder() const {\n+    return reinterpret_cast<H &>(vh[1]);\n+  }\n+  bool holder_constructed() const {\n+    return inst->simple_layout ? inst->simple_holder_constructed\n+                               : inst->nonsimple.status[index] &\n+                                     instance::status_holder_constructed;\n+  }\n+  void set_holder_constructed(bool v = true) {\n+    if (inst->simple_layout)\n+      inst->simple_holder_constructed = v;\n+    else if (v)\n+      inst->nonsimple.status[index] |= instance::status_holder_constructed;\n+    else\n+      inst->nonsimple.status[index] &=\n+          (uint8_t)~instance::status_holder_constructed;\n+  }\n+  bool instance_registered() const {\n+    return inst->simple_layout ? inst->simple_instance_registered\n+                               : inst->nonsimple.status[index] &\n+                                     instance::status_instance_registered;\n+  }\n+  void set_instance_registered(bool v = true) {\n+    if (inst->simple_layout)\n+      inst->simple_instance_registered = v;\n+    else if (v)\n+      inst->nonsimple.status[index] |= instance::status_instance_registered;\n+    else\n+      inst->nonsimple.status[index] &=\n+          (uint8_t)~instance::status_instance_registered;\n+  }\n+};\n+\n+// Container for accessing and iterating over an instance's values/holders\n+struct values_and_holders {\n+private:\n+  instance *inst;\n+  using type_vec = std::vector<detail::type_info *>;\n+  const type_vec &tinfo;\n+\n+public:\n+  values_and_holders(instance *inst)\n+      : inst{inst}, tinfo(all_type_info(Py_TYPE(inst))) {}\n+\n+  struct iterator {\n+  private:\n+    instance *inst = nullptr;\n+    const type_vec *types = nullptr;\n+    value_and_holder curr;\n+    friend struct values_and_holders;\n+    iterator(instance *inst, const type_vec *tinfo)\n+        : inst{inst}, types{tinfo},\n+          curr(\n+              inst /* instance */,\n+              types->empty() ? nullptr : (*types)[0] /* type info */,\n+              0, /* vpos: (non-simple types only): the first vptr comes first */\n+              0 /* index */) {}\n+    // Past-the-end iterator:\n+    iterator(size_t end) : curr(end) {}\n+\n+  public:\n+    bool operator==(const iterator &other) {\n+      return curr.index == other.curr.index;\n+    }\n+    bool operator!=(const iterator &other) {\n+      return curr.index != other.curr.index;\n+    }\n+    iterator &operator++() {\n+      if (!inst->simple_layout)\n+        curr.vh += 1 + (*types)[curr.index]->holder_size_in_ptrs;\n+      ++curr.index;\n+      curr.type = curr.index < types->size() ? (*types)[curr.index] : nullptr;\n+      return *this;\n+    }\n+    value_and_holder &operator*() { return curr; }\n+    value_and_holder *operator->() { return &curr; }\n+  };\n+\n+  iterator begin() { return iterator(inst, &tinfo); }\n+  iterator end() { return iterator(tinfo.size()); }\n+\n+  iterator find(const type_info *find_type) {\n+    auto it = begin(), endit = end();\n+    while (it != endit && it->type != find_type)\n+      ++it;\n+    return it;\n+  }\n+\n+  size_t size() { return tinfo.size(); }\n+};\n+\n+/**\n+ * Extracts C++ value and holder pointer references from an instance (which may\n+ * contain multiple values/holders for python-side multiple inheritance) that\n+ * match the given type.  Throws an error if the given type (or ValueType, if\n+ * omitted) is not a pybind11 base of the given instance.  If `find_type` is\n+ * omitted (or explicitly specified as nullptr) the first value/holder are\n+ * returned, regardless of type (and the resulting .type will be nullptr).\n+ *\n+ * The returned object should be short-lived: in particular, it must not outlive\n+ * the called-upon instance.\n+ */\n+PYBIND11_NOINLINE inline value_and_holder instance::get_value_and_holder(\n+    const type_info *find_type /*= nullptr default in common.h*/,\n+    bool throw_if_missing /*= true in common.h*/) {\n+  // Optimize common case:\n+  if (!find_type || Py_TYPE(this) == find_type->type)\n+    return value_and_holder(this, find_type, 0, 0);\n+\n+  detail::values_and_holders vhs(this);\n+  auto it = vhs.find(find_type);\n+  if (it != vhs.end())\n+    return *it;\n+\n+  if (!throw_if_missing)\n+    return value_and_holder();\n+\n+#if defined(NDEBUG)\n+  pybind11_fail(\"pybind11::detail::instance::get_value_and_holder: \"\n+                \"type is not a pybind11 base of the given instance \"\n+                \"(compile in debug mode for type details)\");\n+#else\n+  pybind11_fail(\"pybind11::detail::instance::get_value_and_holder: `\" +\n+                std::string(find_type->type->tp_name) +\n+                \"' is not a pybind11 base of the given `\" +\n+                std::string(Py_TYPE(this)->tp_name) + \"' instance\");\n+#endif\n+}\n+\n+PYBIND11_NOINLINE inline void instance::allocate_layout() {\n+  auto &tinfo = all_type_info(Py_TYPE(this));\n+\n+  const size_t n_types = tinfo.size();\n+\n+  if (n_types == 0)\n+    pybind11_fail(\"instance allocation failed: new instance has no \"\n+                  \"pybind11-registered base types\");\n+\n+  simple_layout = n_types == 1 && tinfo.front()->holder_size_in_ptrs <=\n+                                      instance_simple_holder_in_ptrs();\n+\n+  // Simple path: no python-side multiple inheritance, and a small-enough holder\n+  if (simple_layout) {\n+    simple_value_holder[0] = nullptr;\n+    simple_holder_constructed = false;\n+    simple_instance_registered = false;\n+  } else { // multiple base types or a too-large holder\n+    // Allocate space to hold: [v1*][h1][v2*][h2]...[bb...] where [vN*] is a\n+    // value pointer, [hN] is the (uninitialized) holder instance for value N,\n+    // and [bb...] is a set of bool values that tracks whether each associated\n+    // holder has been initialized.  Each [block] is padded, if necessary, to an\n+    // integer multiple of sizeof(void *).\n+    size_t space = 0;\n+    for (auto t : tinfo) {\n+      space += 1;                      // value pointer\n+      space += t->holder_size_in_ptrs; // holder instance\n+    }\n+    size_t flags_at = space;\n+    space += size_in_ptrs(\n+        n_types); // status bytes (holder_constructed and instance_registered)\n+\n+    // Allocate space for flags, values, and holders, and initialize it to 0\n+    // (flags and values, in particular, need to be 0).  Use Python's memory\n+    // allocation functions: in Python 3.6 they default to using pymalloc, which\n+    // is designed to be efficient for small allocations like the one we're\n+    // doing here; in earlier versions (and for larger allocations) they are\n+    // just wrappers around malloc.\n+#if PY_VERSION_HEX >= 0x03050000\n+    nonsimple.values_and_holders = (void **)PyMem_Calloc(space, sizeof(void *));\n+    if (!nonsimple.values_and_holders)\n+      throw std::bad_alloc();\n+#else\n+    nonsimple.values_and_holders = (void **)PyMem_New(void *, space);\n+    if (!nonsimple.values_and_holders)\n+      throw std::bad_alloc();\n+    std::memset(nonsimple.values_and_holders, 0, space * sizeof(void *));\n+#endif\n+    nonsimple.status =\n+        reinterpret_cast<uint8_t *>(&nonsimple.values_and_holders[flags_at]);\n+  }\n+  owned = true;\n+}\n+\n+PYBIND11_NOINLINE inline void instance::deallocate_layout() {\n+  if (!simple_layout)\n+    PyMem_Free(nonsimple.values_and_holders);\n+}\n+\n+PYBIND11_NOINLINE inline bool isinstance_generic(handle obj,\n+                                                 const std::type_info &tp) {\n+  handle type = detail::get_type_handle(tp, false);\n+  if (!type)\n+    return false;\n+  return isinstance(obj, type);\n+}\n+\n+PYBIND11_NOINLINE inline std::string error_string() {\n+  if (!PyErr_Occurred()) {\n+    PyErr_SetString(PyExc_RuntimeError, \"Unknown internal error occurred\");\n+    return \"Unknown internal error occurred\";\n+  }\n+\n+  error_scope scope; // Preserve error state\n+\n+  std::string errorString;\n+  if (scope.type) {\n+    errorString += handle(scope.type).attr(\"__name__\").cast<std::string>();\n+    errorString += \": \";\n+  }\n+  if (scope.value)\n+    errorString += (std::string)str(scope.value);\n+\n+  PyErr_NormalizeException(&scope.type, &scope.value, &scope.trace);\n+\n+#if PY_MAJOR_VERSION >= 3\n+  if (scope.trace != nullptr)\n+    PyException_SetTraceback(scope.value, scope.trace);\n+#endif\n+\n+#if !defined(PYPY_VERSION)\n+  if (scope.trace) {\n+    PyTracebackObject *trace = (PyTracebackObject *)scope.trace;\n+\n+    /* Get the deepest trace possible */\n+    while (trace->tb_next)\n+      trace = trace->tb_next;\n+\n+    PyFrameObject *frame = trace->tb_frame;\n+    errorString += \"\\n\\nAt:\\n\";\n+    while (frame) {\n+      int lineno = PyFrame_GetLineNumber(frame);\n+      errorString +=\n+          \"  \" + handle(frame->f_code->co_filename).cast<std::string>() + \"(\" +\n+          std::to_string(lineno) +\n+          \"): \" + handle(frame->f_code->co_name).cast<std::string>() + \"\\n\";\n+      frame = frame->f_back;\n+    }\n+  }\n+#endif\n+\n+  return errorString;\n+}\n+\n+PYBIND11_NOINLINE inline handle\n+get_object_handle(const void *ptr, const detail::type_info *type) {\n+  auto &instances = get_internals().registered_instances;\n+  auto range = instances.equal_range(ptr);\n+  for (auto it = range.first; it != range.second; ++it) {\n+    for (auto vh : values_and_holders(it->second)) {\n+      if (vh.type == type)\n+        return handle((PyObject *)it->second);\n+    }\n+  }\n+  return handle();\n+}\n+\n+inline PyThreadState *get_thread_state_unchecked() {\n+#if defined(PYPY_VERSION)\n+  return PyThreadState_GET();\n+#elif PY_VERSION_HEX < 0x03000000\n+  return _PyThreadState_Current;\n+#elif PY_VERSION_HEX < 0x03050000\n+  return (PyThreadState *)_Py_atomic_load_relaxed(&_PyThreadState_Current);\n+#elif PY_VERSION_HEX < 0x03050200\n+  return (PyThreadState *)_PyThreadState_Current.value;\n+#else\n+  return _PyThreadState_UncheckedGet();\n+#endif\n+}\n+\n+// Forward declarations\n+inline void keep_alive_impl(handle nurse, handle patient);\n+inline PyObject *make_new_instance(PyTypeObject *type);\n+\n+class type_caster_generic {\n+public:\n+  PYBIND11_NOINLINE type_caster_generic(const std::type_info &type_info)\n+      : typeinfo(get_type_info(type_info)), cpptype(&type_info) {}\n+\n+  type_caster_generic(const type_info *typeinfo)\n+      : typeinfo(typeinfo), cpptype(typeinfo ? typeinfo->cpptype : nullptr) {}\n+\n+  bool load(handle src, bool convert) {\n+    return load_impl<type_caster_generic>(src, convert);\n+  }\n+\n+  PYBIND11_NOINLINE static handle\n+  cast(const void *_src, return_value_policy policy, handle parent,\n+       const detail::type_info *tinfo, void *(*copy_constructor)(const void *),\n+       void *(*move_constructor)(const void *),\n+       const void *existing_holder = nullptr) {\n+    if (!tinfo) // no type info: error will be set already\n+      return handle();\n+\n+    void *src = const_cast<void *>(_src);\n+    if (src == nullptr)\n+      return none().release();\n+\n+    auto it_instances = get_internals().registered_instances.equal_range(src);\n+    for (auto it_i = it_instances.first; it_i != it_instances.second; ++it_i) {\n+      for (auto instance_type : detail::all_type_info(Py_TYPE(it_i->second))) {\n+        if (instance_type &&\n+            same_type(*instance_type->cpptype, *tinfo->cpptype))\n+          return handle((PyObject *)it_i->second).inc_ref();\n+      }\n+    }\n+\n+    auto inst = reinterpret_steal<object>(make_new_instance(tinfo->type));\n+    auto wrapper = reinterpret_cast<instance *>(inst.ptr());\n+    wrapper->owned = false;\n+    void *&valueptr = values_and_holders(wrapper).begin()->value_ptr();\n+\n+    switch (policy) {\n+    case return_value_policy::automatic:\n+    case return_value_policy::take_ownership:\n+      valueptr = src;\n+      wrapper->owned = true;\n+      break;\n+\n+    case return_value_policy::automatic_reference:\n+    case return_value_policy::reference:\n+      valueptr = src;\n+      wrapper->owned = false;\n+      break;\n+\n+    case return_value_policy::copy:\n+      if (copy_constructor)\n+        valueptr = copy_constructor(src);\n+      else\n+        throw cast_error(\"return_value_policy = copy, but the \"\n+                         \"object is non-copyable!\");\n+      wrapper->owned = true;\n+      break;\n+\n+    case return_value_policy::move:\n+      if (move_constructor)\n+        valueptr = move_constructor(src);\n+      else if (copy_constructor)\n+        valueptr = copy_constructor(src);\n+      else\n+        throw cast_error(\"return_value_policy = move, but the \"\n+                         \"object is neither movable nor copyable!\");\n+      wrapper->owned = true;\n+      break;\n+\n+    case return_value_policy::reference_internal:\n+      valueptr = src;\n+      wrapper->owned = false;\n+      keep_alive_impl(inst, parent);\n+      break;\n+\n+    default:\n+      throw cast_error(\"unhandled return_value_policy: should not happen!\");\n+    }\n+\n+    tinfo->init_instance(wrapper, existing_holder);\n+\n+    return inst.release();\n+  }\n+\n+  // Base methods for generic caster; there are overridden in\n+  // copyable_holder_caster\n+  void load_value(value_and_holder &&v_h) {\n+    auto *&vptr = v_h.value_ptr();\n+    // Lazy allocation for unallocated values:\n+    if (vptr == nullptr) {\n+      auto *type = v_h.type ? v_h.type : typeinfo;\n+      if (type->operator_new) {\n+        vptr = type->operator_new(type->type_size);\n+      } else {\n+#if defined(PYBIND11_CPP17)\n+        if (type->type_align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n+          vptr = ::operator new(type->type_size,\n+                                (std::align_val_t)type->type_align);\n+        else\n+#endif\n+          vptr = ::operator new(type->type_size);\n+      }\n+    }\n+    value = vptr;\n+  }\n+  bool try_implicit_casts(handle src, bool convert) {\n+    for (auto &cast : typeinfo->implicit_casts) {\n+      type_caster_generic sub_caster(*cast.first);\n+      if (sub_caster.load(src, convert)) {\n+        value = cast.second(sub_caster.value);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  bool try_direct_conversions(handle src) {\n+    for (auto &converter : *typeinfo->direct_conversions) {\n+      if (converter(src.ptr(), value))\n+        return true;\n+    }\n+    return false;\n+  }\n+  void check_holder_compat() {}\n+\n+  PYBIND11_NOINLINE static void *local_load(PyObject *src,\n+                                            const type_info *ti) {\n+    auto caster = type_caster_generic(ti);\n+    if (caster.load(src, false))\n+      return caster.value;\n+    return nullptr;\n+  }\n+\n+  /// Try to load with foreign typeinfo, if available. Used when there is no\n+  /// native typeinfo, or when the native one wasn't able to produce a value.\n+  PYBIND11_NOINLINE bool try_load_foreign_module_local(handle src) {\n+    constexpr auto *local_key = PYBIND11_MODULE_LOCAL_ID;\n+    const auto pytype = src.get_type();\n+    if (!hasattr(pytype, local_key))\n+      return false;\n+\n+    type_info *foreign_typeinfo =\n+        reinterpret_borrow<capsule>(getattr(pytype, local_key));\n+    // Only consider this foreign loader if actually foreign and is a loader of\n+    // the correct cpp type\n+    if (foreign_typeinfo->module_local_load == &local_load ||\n+        (cpptype && !same_type(*cpptype, *foreign_typeinfo->cpptype)))\n+      return false;\n+\n+    if (auto result =\n+            foreign_typeinfo->module_local_load(src.ptr(), foreign_typeinfo)) {\n+      value = result;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  // Implementation of `load`; this takes the type of `this` so that it can\n+  // dispatch the relevant bits of code between here and copyable_holder_caster\n+  // where the two classes need different logic (without having to resort to\n+  // virtual inheritance).\n+  template <typename ThisT>\n+  PYBIND11_NOINLINE bool load_impl(handle src, bool convert) {\n+    if (!src)\n+      return false;\n+    if (!typeinfo)\n+      return try_load_foreign_module_local(src);\n+    if (src.is_none()) {\n+      // Defer accepting None to other overloads (if we aren't in convert mode):\n+      if (!convert)\n+        return false;\n+      value = nullptr;\n+      return true;\n+    }\n+\n+    auto &this_ = static_cast<ThisT &>(*this);\n+    this_.check_holder_compat();\n+\n+    PyTypeObject *srctype = Py_TYPE(src.ptr());\n+\n+    // Case 1: If src is an exact type match for the target type then we can\n+    // reinterpret_cast the instance's value pointer to the target type:\n+    if (srctype == typeinfo->type) {\n+      this_.load_value(\n+          reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());\n+      return true;\n+    }\n+    // Case 2: We have a derived class\n+    else if (PyType_IsSubtype(srctype, typeinfo->type)) {\n+      auto &bases = all_type_info(srctype);\n+      bool no_cpp_mi = typeinfo->simple_type;\n+\n+      // Case 2a: the python type is a Python-inherited derived class that\n+      // inherits from just one simple (no MI) pybind11 class, or is an exact\n+      // match, so the C++ instance is of the right type and we can use\n+      // reinterpret_cast. (This is essentially the same as case 2b, but because\n+      // not using multiple inheritance is extremely common, we handle it\n+      // specially to avoid the loop iterator and type pointer lookup overhead)\n+      if (bases.size() == 1 &&\n+          (no_cpp_mi || bases.front()->type == typeinfo->type)) {\n+        this_.load_value(\n+            reinterpret_cast<instance *>(src.ptr())->get_value_and_holder());\n+        return true;\n+      }\n+      // Case 2b: the python type inherits from multiple C++ bases.  Check the\n+      // bases to see if we can find an exact match (or, for a simple C++ type,\n+      // an inherited match); if so, we can safely reinterpret_cast to the\n+      // relevant pointer.\n+      else if (bases.size() > 1) {\n+        for (auto base : bases) {\n+          if (no_cpp_mi ? PyType_IsSubtype(base->type, typeinfo->type)\n+                        : base->type == typeinfo->type) {\n+            this_.load_value(\n+                reinterpret_cast<instance *>(src.ptr())->get_value_and_holder(\n+                    base));\n+            return true;\n+          }\n+        }\n+      }\n+\n+      // Case 2c: C++ multiple inheritance is involved and we couldn't find an\n+      // exact type match in the registered bases, above, so try implicit\n+      // casting (needed for proper C++ casting when MI is involved).\n+      if (this_.try_implicit_casts(src, convert))\n+        return true;\n+    }\n+\n+    // Perform an implicit conversion\n+    if (convert) {\n+      for (auto &converter : typeinfo->implicit_conversions) {\n+        auto temp =\n+            reinterpret_steal<object>(converter(src.ptr(), typeinfo->type));\n+        if (load_impl<ThisT>(temp, false)) {\n+          loader_life_support::add_patient(temp);\n+          return true;\n+        }\n+      }\n+      if (this_.try_direct_conversions(src))\n+        return true;\n+    }\n+\n+    // Failed to match local typeinfo. Try again with global.\n+    if (typeinfo->module_local) {\n+      if (auto gtype = get_global_type_info(*typeinfo->cpptype)) {\n+        typeinfo = gtype;\n+        return load(src, false);\n+      }\n+    }\n+\n+    // Global typeinfo has precedence over foreign module_local\n+    return try_load_foreign_module_local(src);\n+  }\n+\n+  // Called to do type lookup and wrap the pointer and type in a pair when a\n+  // dynamic_cast isn't needed or can't be used.  If the type is unknown, sets\n+  // the error and returns a pair with .second = nullptr.  (p.first = nullptr is\n+  // not an error: it becomes None).\n+  PYBIND11_NOINLINE static std::pair<const void *, const type_info *>\n+  src_and_type(const void *src, const std::type_info &cast_type,\n+               const std::type_info *rtti_type = nullptr) {\n+    if (auto *tpi = get_type_info(cast_type))\n+      return {src, const_cast<const type_info *>(tpi)};\n+\n+    // Not found, set error:\n+    std::string tname = rtti_type ? rtti_type->name() : cast_type.name();\n+    detail::clean_type_id(tname);\n+    std::string msg = \"Unregistered type : \" + tname;\n+    PyErr_SetString(PyExc_TypeError, msg.c_str());\n+    return {nullptr, nullptr};\n+  }\n+\n+  const type_info *typeinfo = nullptr;\n+  const std::type_info *cpptype = nullptr;\n+  void *value = nullptr;\n+};\n+\n+/**\n+ * Determine suitable casting operator for pointer-or-lvalue-casting type\n+ * casters.  The type caster needs to provide `operator T*()` and `operator\n+ * T&()` operators.\n+ *\n+ * If the type supports moving the value away via an `operator T&&() &&` method,\n+ * it should use `movable_cast_op_type` instead.\n+ */\n+template <typename T>\n+using cast_op_type =\n+    conditional_t<std::is_pointer<remove_reference_t<T>>::value,\n+                  typename std::add_pointer<intrinsic_t<T>>::type,\n+                  typename std::add_lvalue_reference<intrinsic_t<T>>::type>;\n+\n+/**\n+ * Determine suitable casting operator for a type caster with a movable value.\n+ * Such a type caster needs to provide `operator T*()`, `operator T&()`, and\n+ * `operator T&&() &&`.  The latter will be called in appropriate contexts where\n+ * the value can be moved rather than copied.\n+ *\n+ * These operator are automatically provided when using the PYBIND11_TYPE_CASTER\n+ * macro.\n+ */\n+template <typename T>\n+using movable_cast_op_type = conditional_t<\n+    std::is_pointer<typename std::remove_reference<T>::type>::value,\n+    typename std::add_pointer<intrinsic_t<T>>::type,\n+    conditional_t<std::is_rvalue_reference<T>::value,\n+                  typename std::add_rvalue_reference<intrinsic_t<T>>::type,\n+                  typename std::add_lvalue_reference<intrinsic_t<T>>::type>>;\n+\n+// std::is_copy_constructible isn't quite enough: it lets std::vector<T> (and\n+// similar) through when T is non-copyable, but code containing such a copy\n+// constructor fails to actually compile.\n+template <typename T, typename SFINAE = void>\n+struct is_copy_constructible : std::is_copy_constructible<T> {};\n+\n+// Specialization for types that appear to be copy constructible but also look\n+// like stl containers (we specifically check for: has `value_type` and\n+// `reference` with `reference = value_type&`): if so, copy constructability\n+// depends on whether the value_type is copy constructible.\n+template <typename Container>\n+struct is_copy_constructible<\n+    Container,\n+    enable_if_t<all_of<std::is_copy_constructible<Container>,\n+                       std::is_same<typename Container::value_type &,\n+                                    typename Container::reference>>::value>>\n+    : is_copy_constructible<typename Container::value_type> {};\n+\n+#if !defined(PYBIND11_CPP17)\n+// Likewise for std::pair before C++17 (which mandates that the copy constructor\n+// not exist when the two types aren't themselves copy constructible).\n+template <typename T1, typename T2>\n+struct is_copy_constructible<std::pair<T1, T2>>\n+    : all_of<is_copy_constructible<T1>, is_copy_constructible<T2>> {};\n+#endif\n+\n+NAMESPACE_END(detail)\n+\n+// polymorphic_type_hook<itype>::get(src, tinfo) determines whether the object\n+// pointed to by `src` actually is an instance of some class derived from\n+// `itype`. If so, it sets `tinfo` to point to the std::type_info representing\n+// that derived type, and returns a pointer to the start of the most-derived\n+// object of that type (in which `src` is a subobject; this will be the same\n+// address as `src` in most single inheritance cases). If not, or if `src` is\n+// nullptr, it simply returns `src` and leaves `tinfo` at its default value of\n+// nullptr.\n+//\n+// The default polymorphic_type_hook just returns src. A specialization for\n+// polymorphic types determines the runtime type of the passed object and\n+// adjusts the this-pointer appropriately via dynamic_cast<void*>. This is what\n+// enables a C++ Animal* to appear to Python as a Dog (if Dog inherits from\n+// Animal, Animal is polymorphic, Dog is registered with pybind11, and this\n+// Animal is in fact a Dog).\n+//\n+// You may specialize polymorphic_type_hook yourself for types that want to\n+// appear polymorphic to Python but do not use C++ RTTI. (This is a not uncommon\n+// pattern in performance-sensitive applications, used most notably in LLVM.)\n+template <typename itype, typename SFINAE = void> struct polymorphic_type_hook {\n+  static const void *get(const itype *src, const std::type_info *&) {\n+    return src;\n+  }\n+};\n+template <typename itype>\n+struct polymorphic_type_hook<\n+    itype, detail::enable_if_t<std::is_polymorphic<itype>::value>> {\n+  static const void *get(const itype *src, const std::type_info *&type) {\n+    type = src ? &typeid(*src) : nullptr;\n+    return dynamic_cast<const void *>(src);\n+  }\n+};\n+\n+NAMESPACE_BEGIN(detail)\n+\n+/// Generic type caster for objects stored on the heap\n+template <typename type> class type_caster_base : public type_caster_generic {\n+  using itype = intrinsic_t<type>;\n+\n+public:\n+  static constexpr auto name = _<type>();\n+\n+  type_caster_base() : type_caster_base(typeid(type)) {}\n+  explicit type_caster_base(const std::type_info &info)\n+      : type_caster_generic(info) {}\n+\n+  static handle cast(const itype &src, return_value_policy policy,\n+                     handle parent) {\n+    if (policy == return_value_policy::automatic ||\n+        policy == return_value_policy::automatic_reference)\n+      policy = return_value_policy::copy;\n+    return cast(&src, policy, parent);\n+  }\n+\n+  static handle cast(itype &&src, return_value_policy, handle parent) {\n+    return cast(&src, return_value_policy::move, parent);\n+  }\n+\n+  // Returns a (pointer, type_info) pair taking care of necessary type lookup\n+  // for a polymorphic type (using RTTI by default, but can be overridden by\n+  // specializing polymorphic_type_hook). If the instance isn't derived, returns\n+  // the base version.\n+  static std::pair<const void *, const type_info *>\n+  src_and_type(const itype *src) {\n+    auto &cast_type = typeid(itype);\n+    const std::type_info *instance_type = nullptr;\n+    const void *vsrc = polymorphic_type_hook<itype>::get(src, instance_type);\n+    if (instance_type && !same_type(cast_type, *instance_type)) {\n+      // This is a base pointer to a derived type. If the derived type is\n+      // registered with pybind11, we want to make the full derived object\n+      // available. In the typical case where itype is polymorphic, we get the\n+      // correct derived pointer (which may be != base pointer) by a\n+      // dynamic_cast to most derived type. If itype is not polymorphic, we\n+      // won't get here except via a user-provided specialization of\n+      // polymorphic_type_hook, and the user has promised that no this-pointer\n+      // adjustment is required in that case, so it's OK to use static_cast.\n+      if (const auto *tpi = get_type_info(*instance_type))\n+        return {vsrc, tpi};\n+    }\n+    // Otherwise we have either a nullptr, an `itype` pointer, or an unknown\n+    // derived pointer, so don't do a cast\n+    return type_caster_generic::src_and_type(src, cast_type, instance_type);\n+  }\n+\n+  static handle cast(const itype *src, return_value_policy policy,\n+                     handle parent) {\n+    auto st = src_and_type(src);\n+    return type_caster_generic::cast(st.first, policy, parent, st.second,\n+                                     make_copy_constructor(src),\n+                                     make_move_constructor(src));\n+  }\n+\n+  static handle cast_holder(const itype *src, const void *holder) {\n+    auto st = src_and_type(src);\n+    return type_caster_generic::cast(st.first,\n+                                     return_value_policy::take_ownership, {},\n+                                     st.second, nullptr, nullptr, holder);\n+  }\n+\n+  template <typename T> using cast_op_type = detail::cast_op_type<T>;\n+\n+  operator itype *() { return (type *)value; }\n+  operator itype &() {\n+    if (!value)\n+      throw reference_cast_error();\n+    return *((itype *)value);\n+  }\n+\n+protected:\n+  using Constructor = void *(*)(const void *);\n+\n+  /* Only enabled when the types are {copy,move}-constructible *and* when the\n+     type does not have a private operator new implementation. */\n+  template <typename T, typename = enable_if_t<is_copy_constructible<T>::value>>\n+  static auto make_copy_constructor(const T *x)\n+      -> decltype(new T(*x), Constructor{}) {\n+    return [](const void *arg) -> void * {\n+      return new T(*reinterpret_cast<const T *>(arg));\n+    };\n+  }\n+\n+  template <typename T,\n+            typename = enable_if_t<std::is_move_constructible<T>::value>>\n+  static auto make_move_constructor(const T *x)\n+      -> decltype(new T(std::move(*const_cast<T *>(x))), Constructor{}) {\n+    return [](const void *arg) -> void * {\n+      return new T(\n+          std::move(*const_cast<T *>(reinterpret_cast<const T *>(arg))));\n+    };\n+  }\n+\n+  static Constructor make_copy_constructor(...) { return nullptr; }\n+  static Constructor make_move_constructor(...) { return nullptr; }\n+};\n+\n+template <typename type, typename SFINAE = void>\n+class type_caster : public type_caster_base<type> {};\n+template <typename type> using make_caster = type_caster<intrinsic_t<type>>;\n+\n+// Shortcut for calling a caster's `cast_op_type` cast operator for casting a\n+// type_caster to a T\n+template <typename T>\n+typename make_caster<T>::template cast_op_type<T>\n+cast_op(make_caster<T> &caster) {\n+  return caster.operator typename make_caster<T>::template cast_op_type<T>();\n+}\n+template <typename T>\n+typename make_caster<T>::template cast_op_type<\n+    typename std::add_rvalue_reference<T>::type>\n+cast_op(make_caster<T> &&caster) {\n+  return std::move(caster).operator typename make_caster<T>::\n+      template cast_op_type<typename std::add_rvalue_reference<T>::type>();\n+}\n+\n+template <typename type> class type_caster<std::reference_wrapper<type>> {\n+private:\n+  using caster_t = make_caster<type>;\n+  caster_t subcaster;\n+  using subcaster_cast_op_type = typename caster_t::template cast_op_type<type>;\n+  static_assert(std::is_same<typename std::remove_const<type>::type &,\n+                             subcaster_cast_op_type>::value,\n+                \"std::reference_wrapper<T> caster requires T to have a caster \"\n+                \"with an `T &` operator\");\n+\n+public:\n+  bool load(handle src, bool convert) { return subcaster.load(src, convert); }\n+  static constexpr auto name = caster_t::name;\n+  static handle cast(const std::reference_wrapper<type> &src,\n+                     return_value_policy policy, handle parent) {\n+    // It is definitely wrong to take ownership of this pointer, so mask that\n+    // rvp\n+    if (policy == return_value_policy::take_ownership ||\n+        policy == return_value_policy::automatic)\n+      policy = return_value_policy::automatic_reference;\n+    return caster_t::cast(&src.get(), policy, parent);\n+  }\n+  template <typename T> using cast_op_type = std::reference_wrapper<type>;\n+  operator std::reference_wrapper<type>() {\n+    return subcaster.operator subcaster_cast_op_type &();\n+  }\n+};\n+\n+#define PYBIND11_TYPE_CASTER(type, py_name)                                    \\\n+protected:                                                                     \\\n+  type value;                                                                  \\\n+                                                                               \\\n+public:                                                                        \\\n+  static constexpr auto name = py_name;                                        \\\n+  template <typename T_,                                                       \\\n+            enable_if_t<std::is_same<type, remove_cv_t<T_>>::value, int> = 0>  \\\n+  static handle cast(T_ *src, return_value_policy policy, handle parent) {     \\\n+    if (!src)                                                                  \\\n+      return none().release();                                                 \\\n+    if (policy == return_value_policy::take_ownership) {                       \\\n+      auto h = cast(std::move(*src), policy, parent);                          \\\n+      delete src;                                                              \\\n+      return h;                                                                \\\n+    } else {                                                                   \\\n+      return cast(*src, policy, parent);                                       \\\n+    }                                                                          \\\n+  }                                                                            \\\n+  operator type *() { return &value; }                                         \\\n+  operator type &() { return value; }                                          \\\n+  operator type &&() && { return std::move(value); }                           \\\n+  template <typename T_>                                                       \\\n+  using cast_op_type = pybind11::detail::movable_cast_op_type<T_>\n+\n+template <typename CharT>\n+using is_std_char_type =\n+    any_of<std::is_same<CharT, char>,     /* std::string */\n+           std::is_same<CharT, char16_t>, /* std::u16string */\n+           std::is_same<CharT, char32_t>, /* std::u32string */\n+           std::is_same<CharT, wchar_t>   /* std::wstring */\n+           >;\n+\n+template <typename T>\n+struct type_caster<T, enable_if_t<std::is_arithmetic<T>::value &&\n+                                  !is_std_char_type<T>::value>> {\n+  using _py_type_0 = conditional_t<sizeof(T) <= sizeof(long), long, long long>;\n+  using _py_type_1 =\n+      conditional_t<std::is_signed<T>::value, _py_type_0,\n+                    typename std::make_unsigned<_py_type_0>::type>;\n+  using py_type =\n+      conditional_t<std::is_floating_point<T>::value, double, _py_type_1>;\n+\n+public:\n+  bool load(handle src, bool convert) {\n+    py_type py_value;\n+\n+    if (!src)\n+      return false;\n+\n+    if (std::is_floating_point<T>::value) {\n+      if (convert || PyFloat_Check(src.ptr()))\n+        py_value = (py_type)PyFloat_AsDouble(src.ptr());\n+      else\n+        return false;\n+    } else if (PyFloat_Check(src.ptr())) {\n+      return false;\n+    } else if (std::is_unsigned<py_type>::value) {\n+      py_value = as_unsigned<py_type>(src.ptr());\n+    } else { // signed integer:\n+      py_value = sizeof(T) <= sizeof(long)\n+                     ? (py_type)PyLong_AsLong(src.ptr())\n+                     : (py_type)PYBIND11_LONG_AS_LONGLONG(src.ptr());\n+    }\n+\n+    bool py_err = py_value == (py_type)-1 && PyErr_Occurred();\n+    if (py_err || (std::is_integral<T>::value && sizeof(py_type) != sizeof(T) &&\n+                   (py_value < (py_type)std::numeric_limits<T>::min() ||\n+                    py_value > (py_type)std::numeric_limits<T>::max()))) {\n+      bool type_error = py_err && PyErr_ExceptionMatches(\n+#if PY_VERSION_HEX < 0x03000000 && !defined(PYPY_VERSION)\n+                                      PyExc_SystemError\n+#else\n+                                      PyExc_TypeError\n+#endif\n+                                  );\n+      PyErr_Clear();\n+      if (type_error && convert && PyNumber_Check(src.ptr())) {\n+        auto tmp = reinterpret_steal<object>(std::is_floating_point<T>::value\n+                                                 ? PyNumber_Float(src.ptr())\n+                                                 : PyNumber_Long(src.ptr()));\n+        PyErr_Clear();\n+        return load(tmp, false);\n+      }\n+      return false;\n+    }\n+\n+    value = (T)py_value;\n+    return true;\n+  }\n+\n+  template <typename U = T>\n+  static typename std::enable_if<std::is_floating_point<U>::value, handle>::type\n+  cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+    return PyFloat_FromDouble((double)src);\n+  }\n+\n+  template <typename U = T>\n+  static typename std::enable_if<!std::is_floating_point<U>::value &&\n+                                     std::is_signed<U>::value &&\n+                                     (sizeof(U) <= sizeof(long)),\n+                                 handle>::type\n+  cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+    return PYBIND11_LONG_FROM_SIGNED((long)src);\n+  }\n+\n+  template <typename U = T>\n+  static typename std::enable_if<!std::is_floating_point<U>::value &&\n+                                     std::is_unsigned<U>::value &&\n+                                     (sizeof(U) <= sizeof(unsigned long)),\n+                                 handle>::type\n+  cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+    return PYBIND11_LONG_FROM_UNSIGNED((unsigned long)src);\n+  }\n+\n+  template <typename U = T>\n+  static typename std::enable_if<!std::is_floating_point<U>::value &&\n+                                     std::is_signed<U>::value &&\n+                                     (sizeof(U) > sizeof(long)),\n+                                 handle>::type\n+  cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+    return PyLong_FromLongLong((long long)src);\n+  }\n+\n+  template <typename U = T>\n+  static typename std::enable_if<!std::is_floating_point<U>::value &&\n+                                     std::is_unsigned<U>::value &&\n+                                     (sizeof(U) > sizeof(unsigned long)),\n+                                 handle>::type\n+  cast(U src, return_value_policy /* policy */, handle /* parent */) {\n+    return PyLong_FromUnsignedLongLong((unsigned long long)src);\n+  }\n+\n+  PYBIND11_TYPE_CASTER(T, _<std::is_integral<T>::value>(\"int\", \"float\"));\n+};\n+\n+template <typename T> struct void_caster {\n+public:\n+  bool load(handle src, bool) {\n+    if (src && src.is_none())\n+      return true;\n+    return false;\n+  }\n+  static handle cast(T, return_value_policy /* policy */, handle /* parent */) {\n+    return none().inc_ref();\n+  }\n+  PYBIND11_TYPE_CASTER(T, _(\"None\"));\n+};\n+\n+template <> class type_caster<void_type> : public void_caster<void_type> {};\n+\n+template <> class type_caster<void> : public type_caster<void_type> {\n+public:\n+  using type_caster<void_type>::cast;\n+\n+  bool load(handle h, bool) {\n+    if (!h) {\n+      return false;\n+    } else if (h.is_none()) {\n+      value = nullptr;\n+      return true;\n+    }\n+\n+    /* Check if this is a capsule */\n+    if (isinstance<capsule>(h)) {\n+      value = reinterpret_borrow<capsule>(h);\n+      return true;\n+    }\n+\n+    /* Check if this is a C++ type */\n+    auto &bases = all_type_info((PyTypeObject *)h.get_type().ptr());\n+    if (bases.size() == 1) { // Only allowing loading from a single-value type\n+      value = values_and_holders(reinterpret_cast<instance *>(h.ptr()))\n+                  .begin()\n+                  ->value_ptr();\n+      return true;\n+    }\n+\n+    /* Fail */\n+    return false;\n+  }\n+\n+  static handle cast(const void *ptr, return_value_policy /* policy */,\n+                     handle /* parent */) {\n+    if (ptr)\n+      return capsule(ptr).release();\n+    else\n+      return none().inc_ref();\n+  }\n+\n+  template <typename T> using cast_op_type = void *&;\n+  operator void *&() { return value; }\n+  static constexpr auto name = _(\"capsule\");\n+\n+private:\n+  void *value = nullptr;\n+};\n+\n+template <>\n+class type_caster<std::nullptr_t> : public void_caster<std::nullptr_t> {};\n+\n+template <> class type_caster<bool> {\n+public:\n+  bool load(handle src, bool convert) {\n+    if (!src)\n+      return false;\n+    else if (src.ptr() == Py_True) {\n+      value = true;\n+      return true;\n+    } else if (src.ptr() == Py_False) {\n+      value = false;\n+      return true;\n+    } else if (convert || !strcmp(\"numpy.bool_\", Py_TYPE(src.ptr())->tp_name)) {\n+      // (allow non-implicit conversion for numpy booleans)\n+\n+      Py_ssize_t res = -1;\n+      if (src.is_none()) {\n+        res = 0; // None is implicitly converted to False\n+      }\n+#if defined(PYPY_VERSION)\n+      // On PyPy, check that \"__bool__\" (or \"__nonzero__\" on Python 2.7) attr\n+      // exists\n+      else if (hasattr(src, PYBIND11_BOOL_ATTR)) {\n+        res = PyObject_IsTrue(src.ptr());\n+      }\n+#else\n+      // Alternate approach for CPython: this does the same as the above, but\n+      // optimized using the CPython API so as to avoid an unneeded attribute\n+      // lookup.\n+      else if (auto tp_as_number = src.ptr()->ob_type->tp_as_number) {\n+        if (PYBIND11_NB_BOOL(tp_as_number)) {\n+          res = (*PYBIND11_NB_BOOL(tp_as_number))(src.ptr());\n+        }\n+      }\n+#endif\n+      if (res == 0 || res == 1) {\n+        value = (bool)res;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  static handle cast(bool src, return_value_policy /* policy */,\n+                     handle /* parent */) {\n+    return handle(src ? Py_True : Py_False).inc_ref();\n+  }\n+  PYBIND11_TYPE_CASTER(bool, _(\"bool\"));\n+};\n+\n+// Helper class for UTF-{8,16,32} C++ stl strings:\n+template <typename StringType, bool IsView = false> struct string_caster {\n+  using CharT = typename StringType::value_type;\n+\n+  // Simplify life by being able to assume standard char sizes (the standard\n+  // only guarantees minimums, but Python requires exact sizes)\n+  static_assert(!std::is_same<CharT, char>::value || sizeof(CharT) == 1,\n+                \"Unsupported char size != 1\");\n+  static_assert(!std::is_same<CharT, char16_t>::value || sizeof(CharT) == 2,\n+                \"Unsupported char16_t size != 2\");\n+  static_assert(!std::is_same<CharT, char32_t>::value || sizeof(CharT) == 4,\n+                \"Unsupported char32_t size != 4\");\n+  // wchar_t can be either 16 bits (Windows) or 32 (everywhere else)\n+  static_assert(!std::is_same<CharT, wchar_t>::value || sizeof(CharT) == 2 ||\n+                    sizeof(CharT) == 4,\n+                \"Unsupported wchar_t size != 2/4\");\n+  static constexpr size_t UTF_N = 8 * sizeof(CharT);\n+\n+  bool load(handle src, bool) {\n+#if PY_MAJOR_VERSION < 3\n+    object temp;\n+#endif\n+    handle load_src = src;\n+    if (!src) {\n+      return false;\n+    } else if (!PyUnicode_Check(load_src.ptr())) {\n+#if PY_MAJOR_VERSION >= 3\n+      return load_bytes(load_src);\n+#else\n+      if (sizeof(CharT) == 1) {\n+        return load_bytes(load_src);\n+      }\n+\n+      // The below is a guaranteed failure in Python 3 when PyUnicode_Check\n+      // returns false\n+      if (!PYBIND11_BYTES_CHECK(load_src.ptr()))\n+        return false;\n+\n+      temp = reinterpret_steal<object>(PyUnicode_FromObject(load_src.ptr()));\n+      if (!temp) {\n+        PyErr_Clear();\n+        return false;\n+      }\n+      load_src = temp;\n+#endif\n+    }\n+\n+    object utfNbytes = reinterpret_steal<object>(\n+        PyUnicode_AsEncodedString(load_src.ptr(),\n+                                  UTF_N == 8    ? \"utf-8\"\n+                                  : UTF_N == 16 ? \"utf-16\"\n+                                                : \"utf-32\",\n+                                  nullptr));\n+    if (!utfNbytes) {\n+      PyErr_Clear();\n+      return false;\n+    }\n+\n+    const CharT *buffer = reinterpret_cast<const CharT *>(\n+        PYBIND11_BYTES_AS_STRING(utfNbytes.ptr()));\n+    size_t length =\n+        (size_t)PYBIND11_BYTES_SIZE(utfNbytes.ptr()) / sizeof(CharT);\n+    if (UTF_N > 8) {\n+      buffer++;\n+      length--;\n+    } // Skip BOM for UTF-16/32\n+    value = StringType(buffer, length);\n+\n+    // If we're loading a string_view we need to keep the encoded Python object\n+    // alive:\n+    if (IsView)\n+      loader_life_support::add_patient(utfNbytes);\n+\n+    return true;\n+  }\n+\n+  static handle cast(const StringType &src, return_value_policy /* policy */,\n+                     handle /* parent */) {\n+    const char *buffer = reinterpret_cast<const char *>(src.data());\n+    ssize_t nbytes = ssize_t(src.size() * sizeof(CharT));\n+    handle s = decode_utfN(buffer, nbytes);\n+    if (!s)\n+      throw error_already_set();\n+    return s;\n+  }\n+\n+  PYBIND11_TYPE_CASTER(StringType, _(PYBIND11_STRING_NAME));\n+\n+private:\n+  static handle decode_utfN(const char *buffer, ssize_t nbytes) {\n+#if !defined(PYPY_VERSION)\n+    return UTF_N == 8 ? PyUnicode_DecodeUTF8(buffer, nbytes, nullptr)\n+           : UTF_N == 16\n+               ? PyUnicode_DecodeUTF16(buffer, nbytes, nullptr, nullptr)\n+               : PyUnicode_DecodeUTF32(buffer, nbytes, nullptr, nullptr);\n+#else\n+    // PyPy seems to have multiple problems related to PyUnicode_UTF*: the UTF8\n+    // version sometimes segfaults for unknown reasons, while the UTF16 and 32\n+    // versions require a non-const char * arguments, which is also a nuisance,\n+    // so bypass the whole thing by just passing the encoding as a string value,\n+    // which works properly:\n+    return PyUnicode_Decode(buffer, nbytes,\n+                            UTF_N == 8    ? \"utf-8\"\n+                            : UTF_N == 16 ? \"utf-16\"\n+                                          : \"utf-32\",\n+                            nullptr);\n+#endif\n+  }\n+\n+  // When loading into a std::string or char*, accept a bytes object as-is (i.e.\n+  // without any encoding/decoding attempt).  For other C++ char sizes this is a\n+  // no-op. which supports loading a unicode from a str, doesn't take this path.\n+  template <typename C = CharT>\n+  bool load_bytes(enable_if_t<sizeof(C) == 1, handle> src) {\n+    if (PYBIND11_BYTES_CHECK(src.ptr())) {\n+      // We were passed a Python 3 raw bytes; accept it into a std::string or\n+      // char* without any encoding attempt.\n+      const char *bytes = PYBIND11_BYTES_AS_STRING(src.ptr());\n+      if (bytes) {\n+        value = StringType(bytes, (size_t)PYBIND11_BYTES_SIZE(src.ptr()));\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  template <typename C = CharT>\n+  bool load_bytes(enable_if_t<sizeof(C) != 1, handle>) {\n+    return false;\n+  }\n+};\n+\n+template <typename CharT, class Traits, class Allocator>\n+struct type_caster<std::basic_string<CharT, Traits, Allocator>,\n+                   enable_if_t<is_std_char_type<CharT>::value>>\n+    : string_caster<std::basic_string<CharT, Traits, Allocator>> {};\n+\n+#ifdef PYBIND11_HAS_STRING_VIEW\n+template <typename CharT, class Traits>\n+struct type_caster<std::basic_string_view<CharT, Traits>,\n+                   enable_if_t<is_std_char_type<CharT>::value>>\n+    : string_caster<std::basic_string_view<CharT, Traits>, true> {};\n+#endif\n+\n+// Type caster for C-style strings.  We basically use a std::string type caster,\n+// but also add the ability to use None as a nullptr char* (which the string\n+// caster doesn't allow).\n+template <typename CharT>\n+struct type_caster<CharT, enable_if_t<is_std_char_type<CharT>::value>> {\n+  using StringType = std::basic_string<CharT>;\n+  using StringCaster = type_caster<StringType>;\n+  StringCaster str_caster;\n+  bool none = false;\n+  CharT one_char = 0;\n+\n+public:\n+  bool load(handle src, bool convert) {\n+    if (!src)\n+      return false;\n+    if (src.is_none()) {\n+      // Defer accepting None to other overloads (if we aren't in convert mode):\n+      if (!convert)\n+        return false;\n+      none = true;\n+      return true;\n+    }\n+    return str_caster.load(src, convert);\n+  }\n+\n+  static handle cast(const CharT *src, return_value_policy policy,\n+                     handle parent) {\n+    if (src == nullptr)\n+      return pybind11::none().inc_ref();\n+    return StringCaster::cast(StringType(src), policy, parent);\n+  }\n+\n+  static handle cast(CharT src, return_value_policy policy, handle parent) {\n+    if (std::is_same<char, CharT>::value) {\n+      handle s = PyUnicode_DecodeLatin1((const char *)&src, 1, nullptr);\n+      if (!s)\n+        throw error_already_set();\n+      return s;\n+    }\n+    return StringCaster::cast(StringType(1, src), policy, parent);\n+  }\n+\n+  operator CharT *() {\n+    return none ? nullptr\n+                : const_cast<CharT *>(\n+                      static_cast<StringType &>(str_caster).c_str());\n+  }\n+  operator CharT &() {\n+    if (none)\n+      throw value_error(\"Cannot convert None to a character\");\n+\n+    auto &value = static_cast<StringType &>(str_caster);\n+    size_t str_len = value.size();\n+    if (str_len == 0)\n+      throw value_error(\"Cannot convert empty string to a character\");\n+\n+    // If we're in UTF-8 mode, we have two possible failures: one for a unicode\n+    // character that is too high, and one for multiple unicode characters\n+    // (caught later), so we need to figure out how long the first encoded\n+    // character is in bytes to distinguish between these two errors.  We also\n+    // allow want to allow unicode characters U+0080 through U+00FF, as those\n+    // can fit into a single char value.\n+    if (StringCaster::UTF_N == 8 && str_len > 1 && str_len <= 4) {\n+      unsigned char v0 = static_cast<unsigned char>(value[0]);\n+      size_t char0_bytes =\n+          !(v0 & 0x80) ? 1 : // low bits only: 0-127\n+              (v0 & 0xE0) == 0xC0 ? 2\n+                                  : // 0b110xxxxx - start of 2-byte sequence\n+              (v0 & 0xF0) == 0xE0 ? 3\n+                                  : // 0b1110xxxx - start of 3-byte sequence\n+              4;                    // 0b11110xxx - start of 4-byte sequence\n+\n+      if (char0_bytes == str_len) {\n+        // If we have a 128-255 value, we can decode it into a single char:\n+        if (char0_bytes == 2 && (v0 & 0xFC) == 0xC0) { // 0x110000xx 0x10xxxxxx\n+          one_char = static_cast<CharT>(\n+              ((v0 & 3) << 6) + (static_cast<unsigned char>(value[1]) & 0x3F));\n+          return one_char;\n+        }\n+        // Otherwise we have a single character, but it's > U+00FF\n+        throw value_error(\"Character code point not in range(0x100)\");\n+      }\n+    }\n+\n+    // UTF-16 is much easier: we can only have a surrogate pair for values above\n+    // U+FFFF, thus a surrogate pair with total length 2 instantly indicates a\n+    // range error (but not a \"your string was too long\" error).\n+    else if (StringCaster::UTF_N == 16 && str_len == 2) {\n+      one_char = static_cast<CharT>(value[0]);\n+      if (one_char >= 0xD800 && one_char < 0xE000)\n+        throw value_error(\"Character code point not in range(0x10000)\");\n+    }\n+\n+    if (str_len != 1)\n+      throw value_error(\n+          \"Expected a character, but multi-character string found\");\n+\n+    one_char = value[0];\n+    return one_char;\n+  }\n+\n+  static constexpr auto name = _(PYBIND11_STRING_NAME);\n+  template <typename _T>\n+  using cast_op_type = pybind11::detail::cast_op_type<_T>;\n+};\n+\n+// Base implementation for std::tuple and std::pair\n+template <template <typename...> class Tuple, typename... Ts>\n+class tuple_caster {\n+  using type = Tuple<Ts...>;\n+  static constexpr auto size = sizeof...(Ts);\n+  using indices = make_index_sequence<size>;\n+\n+public:\n+  bool load(handle src, bool convert) {\n+    if (!isinstance<sequence>(src))\n+      return false;\n+    const auto seq = reinterpret_borrow<sequence>(src);\n+    if (seq.size() != size)\n+      return false;\n+    return load_impl(seq, convert, indices{});\n+  }\n+\n+  template <typename T>\n+  static handle cast(T &&src, return_value_policy policy, handle parent) {\n+    return cast_impl(std::forward<T>(src), policy, parent, indices{});\n+  }\n+\n+  static constexpr auto name =\n+      _(\"Tuple[\") + concat(make_caster<Ts>::name...) + _(\"]\");\n+\n+  template <typename T> using cast_op_type = type;\n+\n+  operator type() & { return implicit_cast(indices{}); }\n+  operator type() && { return std::move(*this).implicit_cast(indices{}); }\n+\n+protected:\n+  template <size_t... Is> type implicit_cast(index_sequence<Is...>) & {\n+    return type(cast_op<Ts>(std::get<Is>(subcasters))...);\n+  }\n+  template <size_t... Is> type implicit_cast(index_sequence<Is...>) && {\n+    return type(cast_op<Ts>(std::move(std::get<Is>(subcasters)))...);\n+  }\n+\n+  static constexpr bool load_impl(const sequence &, bool, index_sequence<>) {\n+    return true;\n+  }\n+\n+  template <size_t... Is>\n+  bool load_impl(const sequence &seq, bool convert, index_sequence<Is...>) {\n+    for (bool r : {std::get<Is>(subcasters).load(seq[Is], convert)...})\n+      if (!r)\n+        return false;\n+    return true;\n+  }\n+\n+  /* Implementation: Convert a C++ tuple into a Python tuple */\n+  template <typename T, size_t... Is>\n+  static handle cast_impl(T &&src, return_value_policy policy, handle parent,\n+                          index_sequence<Is...>) {\n+    std::array<object, size> entries{\n+        {reinterpret_steal<object>(make_caster<Ts>::cast(\n+            std::get<Is>(std::forward<T>(src)), policy, parent))...}};\n+    for (const auto &entry : entries)\n+      if (!entry)\n+        return handle();\n+    tuple result(size);\n+    int counter = 0;\n+    for (auto &entry : entries)\n+      PyTuple_SET_ITEM(result.ptr(), counter++, entry.release().ptr());\n+    return result.release();\n+  }\n+\n+  Tuple<make_caster<Ts>...> subcasters;\n+};\n+\n+template <typename T1, typename T2>\n+class type_caster<std::pair<T1, T2>> : public tuple_caster<std::pair, T1, T2> {\n+};\n+\n+template <typename... Ts>\n+class type_caster<std::tuple<Ts...>> : public tuple_caster<std::tuple, Ts...> {\n+};\n+\n+/// Helper class which abstracts away certain actions. Users can provide\n+/// specializations for custom holders, but it's only necessary if the type has\n+/// a non-standard interface.\n+template <typename T> struct holder_helper {\n+  static auto get(const T &p) -> decltype(p.get()) { return p.get(); }\n+};\n+\n+/// Type caster for holder types like std::shared_ptr, etc.\n+template <typename type, typename holder_type>\n+struct copyable_holder_caster : public type_caster_base<type> {\n+public:\n+  using base = type_caster_base<type>;\n+  static_assert(std::is_base_of<base, type_caster<type>>::value,\n+                \"Holder classes are only supported for custom types\");\n+  using base::base;\n+  using base::cast;\n+  using base::typeinfo;\n+  using base::value;\n+\n+  bool load(handle src, bool convert) {\n+    return base::template load_impl<copyable_holder_caster<type, holder_type>>(\n+        src, convert);\n+  }\n+\n+  explicit operator type *() { return this->value; }\n+  explicit operator type &() { return *(this->value); }\n+  explicit operator holder_type *() { return std::addressof(holder); }\n+\n+// Workaround for Intel compiler bug\n+// see pybind11 issue 94\n+#if defined(__ICC) || defined(__INTEL_COMPILER)\n+  operator holder_type &() { return holder; }\n+#else\n+  explicit operator holder_type &() { return holder; }\n+#endif\n+\n+  static handle cast(const holder_type &src, return_value_policy, handle) {\n+    const auto *ptr = holder_helper<holder_type>::get(src);\n+    return type_caster_base<type>::cast_holder(ptr, &src);\n+  }\n+\n+protected:\n+  friend class type_caster_generic;\n+  void check_holder_compat() {\n+    if (typeinfo->default_holder)\n+      throw cast_error(\n+          \"Unable to load a custom holder type from a default-holder instance\");\n+  }\n+\n+  bool load_value(value_and_holder &&v_h) {\n+    if (v_h.holder_constructed()) {\n+      value = v_h.value_ptr();\n+      holder = v_h.template holder<holder_type>();\n+      return true;\n+    } else {\n+      throw cast_error(\n+          \"Unable to cast from non-held to held instance (T& to Holder<T>) \"\n+#if defined(NDEBUG)\n+          \"(compile in debug mode for type information)\");\n+#else\n+          \"of type '\" +\n+          type_id<holder_type>() + \"''\");\n+#endif\n+    }\n+  }\n+\n+  template <typename T = holder_type,\n+            detail::enable_if_t<\n+                !std::is_constructible<T, const T &, type *>::value, int> = 0>\n+  bool try_implicit_casts(handle, bool) {\n+    return false;\n+  }\n+\n+  template <typename T = holder_type,\n+            detail::enable_if_t<\n+                std::is_constructible<T, const T &, type *>::value, int> = 0>\n+  bool try_implicit_casts(handle src, bool convert) {\n+    for (auto &cast : typeinfo->implicit_casts) {\n+      copyable_holder_caster sub_caster(*cast.first);\n+      if (sub_caster.load(src, convert)) {\n+        value = cast.second(sub_caster.value);\n+        holder = holder_type(sub_caster.holder, (type *)value);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  static bool try_direct_conversions(handle) { return false; }\n+\n+  holder_type holder;\n+};\n+\n+/// Specialize for the common std::shared_ptr, so users don't need to\n+template <typename T>\n+class type_caster<std::shared_ptr<T>>\n+    : public copyable_holder_caster<T, std::shared_ptr<T>> {};\n+\n+template <typename type, typename holder_type> struct move_only_holder_caster {\n+  static_assert(\n+      std::is_base_of<type_caster_base<type>, type_caster<type>>::value,\n+      \"Holder classes are only supported for custom types\");\n+\n+  static handle cast(holder_type &&src, return_value_policy, handle) {\n+    auto *ptr = holder_helper<holder_type>::get(src);\n+    return type_caster_base<type>::cast_holder(ptr, std::addressof(src));\n+  }\n+  static constexpr auto name = type_caster_base<type>::name;\n+};\n+\n+template <typename type, typename deleter>\n+class type_caster<std::unique_ptr<type, deleter>>\n+    : public move_only_holder_caster<type, std::unique_ptr<type, deleter>> {};\n+\n+template <typename type, typename holder_type>\n+using type_caster_holder =\n+    conditional_t<is_copy_constructible<holder_type>::value,\n+                  copyable_holder_caster<type, holder_type>,\n+                  move_only_holder_caster<type, holder_type>>;\n+\n+template <typename T, bool Value = false> struct always_construct_holder {\n+  static constexpr bool value = Value;\n+};\n+\n+/// Create a specialization for custom holder types (silently ignores\n+/// std::shared_ptr)\n+#define PYBIND11_DECLARE_HOLDER_TYPE(type, holder_type, ...)                   \\\n+  namespace pybind11 {                                                         \\\n+  namespace detail {                                                           \\\n+  template <typename type>                                                     \\\n+  struct always_construct_holder<holder_type>                                  \\\n+      : always_construct_holder<void, ##__VA_ARGS__> {};                       \\\n+  template <typename type>                                                     \\\n+  class type_caster<holder_type,                                               \\\n+                    enable_if_t<!is_shared_ptr<holder_type>::value>>           \\\n+      : public type_caster_holder<type, holder_type> {};                       \\\n+  }                                                                            \\\n+  }\n+\n+// PYBIND11_DECLARE_HOLDER_TYPE holder types:\n+template <typename base, typename holder>\n+struct is_holder_type\n+    : std::is_base_of<detail::type_caster_holder<base, holder>,\n+                      detail::type_caster<holder>> {};\n+// Specialization for always-supported unique_ptr holders:\n+template <typename base, typename deleter>\n+struct is_holder_type<base, std::unique_ptr<base, deleter>> : std::true_type {};\n+\n+template <typename T> struct handle_type_name {\n+  static constexpr auto name = _<T>();\n+};\n+template <> struct handle_type_name<bytes> {\n+  static constexpr auto name = _(PYBIND11_BYTES_NAME);\n+};\n+template <> struct handle_type_name<args> {\n+  static constexpr auto name = _(\"*args\");\n+};\n+template <> struct handle_type_name<kwargs> {\n+  static constexpr auto name = _(\"**kwargs\");\n+};\n+\n+template <typename type> struct pyobject_caster {\n+  template <typename T = type,\n+            enable_if_t<std::is_same<T, handle>::value, int> = 0>\n+  bool load(handle src, bool /* convert */) {\n+    value = src;\n+    return static_cast<bool>(value);\n+  }\n+\n+  template <typename T = type,\n+            enable_if_t<std::is_base_of<object, T>::value, int> = 0>\n+  bool load(handle src, bool /* convert */) {\n+    if (!isinstance<type>(src))\n+      return false;\n+    value = reinterpret_borrow<type>(src);\n+    return true;\n+  }\n+\n+  static handle cast(const handle &src, return_value_policy /* policy */,\n+                     handle /* parent */) {\n+    return src.inc_ref();\n+  }\n+  PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name);\n+};\n+\n+template <typename T>\n+class type_caster<T, enable_if_t<is_pyobject<T>::value>>\n+    : public pyobject_caster<T> {};\n+\n+// Our conditions for enabling moving are quite restrictive:\n+// At compile time:\n+// - T needs to be a non-const, non-pointer, non-reference type\n+// - type_caster<T>::operator T&() must exist\n+// - the type must be move constructible (obviously)\n+// At run-time:\n+// - if the type is non-copy-constructible, the object must be the sole owner of\n+// the type (i.e. it\n+//   must have ref_count() == 1)h\n+// If any of the above are not satisfied, we fall back to copying.\n+template <typename T>\n+using move_is_plain_type = satisfies_none_of<T, std::is_void, std::is_pointer,\n+                                             std::is_reference, std::is_const>;\n+template <typename T, typename SFINAE = void>\n+struct move_always : std::false_type {};\n+template <typename T>\n+struct move_always<\n+    T, enable_if_t<all_of<\n+           move_is_plain_type<T>, negation<is_copy_constructible<T>>,\n+           std::is_move_constructible<T>,\n+           std::is_same<decltype(std::declval<make_caster<T>>().operator T &()),\n+                        T &>>::value>> : std::true_type {};\n+template <typename T, typename SFINAE = void>\n+struct move_if_unreferenced : std::false_type {};\n+template <typename T>\n+struct move_if_unreferenced<\n+    T, enable_if_t<all_of<\n+           move_is_plain_type<T>, negation<move_always<T>>,\n+           std::is_move_constructible<T>,\n+           std::is_same<decltype(std::declval<make_caster<T>>().operator T &()),\n+                        T &>>::value>> : std::true_type {};\n+template <typename T>\n+using move_never = none_of<move_always<T>, move_if_unreferenced<T>>;\n+\n+// Detect whether returning a `type` from a cast on type's type_caster is going\n+// to result in a reference or pointer to a local variable of the type_caster.\n+// Basically, only non-reference/pointer `type`s and reference/pointers from a\n+// type_caster_generic are safe; everything else returns a reference/pointer to\n+// a local variable.\n+template <typename type>\n+using cast_is_temporary_value_reference = bool_constant<\n+    (std::is_reference<type>::value || std::is_pointer<type>::value) &&\n+    !std::is_base_of<type_caster_generic, make_caster<type>>::value &&\n+    !std::is_same<intrinsic_t<type>, void>::value>;\n+\n+// When a value returned from a C++ function is being cast back to Python, we\n+// almost always want to force `policy = move`, regardless of the return value\n+// policy the function/method was declared with.\n+template <typename Return, typename SFINAE = void>\n+struct return_value_policy_override {\n+  static return_value_policy policy(return_value_policy p) { return p; }\n+};\n+\n+template <typename Return>\n+struct return_value_policy_override<\n+    Return, detail::enable_if_t<std::is_base_of<type_caster_generic,\n+                                                make_caster<Return>>::value,\n+                                void>> {\n+  static return_value_policy policy(return_value_policy p) {\n+    return !std::is_lvalue_reference<Return>::value &&\n+                   !std::is_pointer<Return>::value\n+               ? return_value_policy::move\n+               : p;\n+  }\n+};\n+\n+// Basic python -> C++ casting; throws if casting fails\n+template <typename T, typename SFINAE>\n+type_caster<T, SFINAE> &load_type(type_caster<T, SFINAE> &conv,\n+                                  const handle &handle) {\n+  if (!conv.load(handle, true)) {\n+#if defined(NDEBUG)\n+    throw cast_error(\"Unable to cast Python instance to C++ type (compile in \"\n+                     \"debug mode for details)\");\n+#else\n+    throw cast_error(\"Unable to cast Python instance of type \" +\n+                     (std::string)str(handle.get_type()) + \" to C++ type '\" +\n+                     type_id<T>() + \"'\");\n+#endif\n+  }\n+  return conv;\n+}\n+// Wrapper around the above that also constructs and returns a type_caster\n+template <typename T> make_caster<T> load_type(const handle &handle) {\n+  make_caster<T> conv;\n+  load_type(conv, handle);\n+  return conv;\n+}\n+\n+NAMESPACE_END(detail)\n+\n+// pytype -> C++ type\n+template <typename T,\n+          detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>\n+T cast(const handle &handle) {\n+  using namespace detail;\n+  static_assert(\n+      !cast_is_temporary_value_reference<T>::value,\n+      \"Unable to cast type to reference: value is local to type caster\");\n+  return cast_op<T>(load_type<T>(handle));\n+}\n+\n+// pytype -> pytype (calls converting constructor)\n+template <typename T,\n+          detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>\n+T cast(const handle &handle) {\n+  return T(reinterpret_borrow<object>(handle));\n+}\n+\n+// C++ type -> py::object\n+template <typename T,\n+          detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>\n+object\n+cast(const T &value,\n+     return_value_policy policy = return_value_policy::automatic_reference,\n+     handle parent = handle()) {\n+  if (policy == return_value_policy::automatic)\n+    policy = std::is_pointer<T>::value ? return_value_policy::take_ownership\n+                                       : return_value_policy::copy;\n+  else if (policy == return_value_policy::automatic_reference)\n+    policy = std::is_pointer<T>::value ? return_value_policy::reference\n+                                       : return_value_policy::copy;\n+  return reinterpret_steal<object>(\n+      detail::make_caster<T>::cast(value, policy, parent));\n+}\n+\n+template <typename T> T handle::cast() const {\n+  return pybind11::cast<T>(*this);\n+}\n+template <> inline void handle::cast() const { return; }\n+\n+template <typename T>\n+detail::enable_if_t<!detail::move_never<T>::value, T> move(object &&obj) {\n+  if (obj.ref_count() > 1)\n+#if defined(NDEBUG)\n+    throw cast_error(\"Unable to cast Python instance to C++ rvalue: instance \"\n+                     \"has multiple references\"\n+                     \" (compile in debug mode for details)\");\n+#else\n+    throw cast_error(\"Unable to move from Python \" +\n+                     (std::string)str(obj.get_type()) + \" instance to C++ \" +\n+                     type_id<T>() +\n+                     \" instance: instance has multiple references\");\n+#endif\n+\n+  // Move into a temporary and return that, because the reference may be a local\n+  // value of `conv`\n+  T ret = std::move(detail::load_type<T>(obj).operator T &());\n+  return ret;\n+}\n+\n+// Calling cast() on an rvalue calls pybind::cast with the object rvalue, which\n+// does:\n+// - If we have to move (because T has no copy constructor), do it.  This will\n+// fail if the moved\n+//   object has multiple references, but trying to copy will fail to compile.\n+// - If both movable and copyable, check ref count: if 1, move; otherwise copy\n+// - Otherwise (not movable), copy.\n+template <typename T>\n+detail::enable_if_t<detail::move_always<T>::value, T> cast(object &&object) {\n+  return move<T>(std::move(object));\n+}\n+template <typename T>\n+detail::enable_if_t<detail::move_if_unreferenced<T>::value, T>\n+cast(object &&object) {\n+  if (object.ref_count() > 1)\n+    return cast<T>(object);\n+  else\n+    return move<T>(std::move(object));\n+}\n+template <typename T>\n+detail::enable_if_t<detail::move_never<T>::value, T> cast(object &&object) {\n+  return cast<T>(object);\n+}\n+\n+template <typename T> T object::cast() const & {\n+  return pybind11::cast<T>(*this);\n+}\n+template <typename T> T object::cast() && {\n+  return pybind11::cast<T>(std::move(*this));\n+}\n+template <> inline void object::cast() const & { return; }\n+template <> inline void object::cast() && { return; }\n+\n+NAMESPACE_BEGIN(detail)\n+\n+// Declared in pytypes.h:\n+template <typename T, enable_if_t<!is_pyobject<T>::value, int>>\n+object object_or_cast(T &&o) {\n+  return pybind11::cast(std::forward<T>(o));\n+}\n+\n+struct overload_unused {}; // Placeholder type for the unneeded (and dead code)\n+                           // static variable in the OVERLOAD_INT macro\n+template <typename ret_type>\n+using overload_caster_t =\n+    conditional_t<cast_is_temporary_value_reference<ret_type>::value,\n+                  make_caster<ret_type>, overload_unused>;\n+\n+// Trampoline use: for reference/pointer types to value-converted values, we do\n+// a value cast, then store the result in the given variable.  For other types,\n+// this is a no-op.\n+template <typename T>\n+enable_if_t<cast_is_temporary_value_reference<T>::value, T>\n+cast_ref(object &&o, make_caster<T> &caster) {\n+  return cast_op<T>(load_type(caster, o));\n+}\n+template <typename T>\n+enable_if_t<!cast_is_temporary_value_reference<T>::value, T>\n+cast_ref(object &&, overload_unused &) {\n+  pybind11_fail(\"Internal error: cast_ref fallback invoked\");\n+}\n+\n+// Trampoline use: Having a pybind11::cast with an invalid reference type is\n+// going to static_assert, even though if it's in dead code, so we provide a\n+// \"trampoline\" to pybind11::cast that only does anything in cases where\n+// pybind11::cast is valid.\n+template <typename T>\n+enable_if_t<!cast_is_temporary_value_reference<T>::value, T>\n+cast_safe(object &&o) {\n+  return pybind11::cast<T>(std::move(o));\n+}\n+template <typename T>\n+enable_if_t<cast_is_temporary_value_reference<T>::value, T>\n+cast_safe(object &&) {\n+  pybind11_fail(\"Internal error: cast_safe fallback invoked\");\n+}\n+template <> inline void cast_safe<void>(object &&) {}\n+\n+NAMESPACE_END(detail)\n+\n+template <return_value_policy policy = return_value_policy::automatic_reference>\n+tuple make_tuple() {\n+  return tuple(0);\n+}\n+\n+template <return_value_policy policy = return_value_policy::automatic_reference,\n+          typename... Args>\n+tuple make_tuple(Args &&...args_) {\n+  constexpr size_t size = sizeof...(Args);\n+  std::array<object, size> args{\n+      {reinterpret_steal<object>(detail::make_caster<Args>::cast(\n+          std::forward<Args>(args_), policy, nullptr))...}};\n+  for (size_t i = 0; i < args.size(); i++) {\n+    if (!args[i]) {\n+#if defined(NDEBUG)\n+      throw cast_error(\"make_tuple(): unable to convert arguments to Python \"\n+                       \"object (compile in debug mode for details)\");\n+#else\n+      std::array<std::string, size> argtypes{{type_id<Args>()...}};\n+      throw cast_error(\"make_tuple(): unable to convert argument of type '\" +\n+                       argtypes[i] + \"' to Python object\");\n+#endif\n+    }\n+  }\n+  tuple result(size);\n+  int counter = 0;\n+  for (auto &arg_value : args)\n+    PyTuple_SET_ITEM(result.ptr(), counter++, arg_value.release().ptr());\n+  return result;\n+}\n+\n+/// \\ingroup annotations\n+/// Annotation for arguments\n+struct arg {\n+  /// Constructs an argument with the name of the argument; if null or omitted,\n+  /// this is a positional argument.\n+  constexpr explicit arg(const char *name = nullptr)\n+      : name(name), flag_noconvert(false), flag_none(true) {}\n+  /// Assign a value to this argument\n+  template <typename T> arg_v operator=(T &&value) const;\n+  /// Indicate that the type should not be converted in the type caster\n+  arg &noconvert(bool flag = true) {\n+    flag_noconvert = flag;\n+    return *this;\n+  }\n+  /// Indicates that the argument should/shouldn't allow None (e.g. for nullable\n+  /// pointer args)\n+  arg &none(bool flag = true) {\n+    flag_none = flag;\n+    return *this;\n+  }\n+\n+  const char *name;        ///< If non-null, this is a named kwargs argument\n+  bool flag_noconvert : 1; ///< If set, do not allow conversion (requires a\n+                           ///< supporting type caster!)\n+  bool flag_none : 1; ///< If set (the default), allow None to be passed to this\n+                      ///< argument\n+};\n+\n+/// \\ingroup annotations\n+/// Annotation for arguments with values\n+struct arg_v : arg {\n+private:\n+  template <typename T>\n+  arg_v(arg &&base, T &&x, const char *descr = nullptr)\n+      : arg(base), value(reinterpret_steal<object>(detail::make_caster<T>::cast(\n+                       x, return_value_policy::automatic, {}))),\n+        descr(descr)\n+#if !defined(NDEBUG)\n+        ,\n+        type(type_id<T>())\n+#endif\n+  {\n+  }\n+\n+public:\n+  /// Direct construction with name, default, and description\n+  template <typename T>\n+  arg_v(const char *name, T &&x, const char *descr = nullptr)\n+      : arg_v(arg(name), std::forward<T>(x), descr) {}\n+\n+  /// Called internally when invoking `py::arg(\"a\") = value`\n+  template <typename T>\n+  arg_v(const arg &base, T &&x, const char *descr = nullptr)\n+      : arg_v(arg(base), std::forward<T>(x), descr) {}\n+\n+  /// Same as `arg::noconvert()`, but returns *this as arg_v&, not arg&\n+  arg_v &noconvert(bool flag = true) {\n+    arg::noconvert(flag);\n+    return *this;\n+  }\n+\n+  /// Same as `arg::nonone()`, but returns *this as arg_v&, not arg&\n+  arg_v &none(bool flag = true) {\n+    arg::none(flag);\n+    return *this;\n+  }\n+\n+  /// The default value\n+  object value;\n+  /// The (optional) description of the default value\n+  const char *descr;\n+#if !defined(NDEBUG)\n+  /// The C++ type name of the default value (only available when compiled in\n+  /// debug mode)\n+  std::string type;\n+#endif\n+};\n+\n+template <typename T> arg_v arg::operator=(T &&value) const {\n+  return {std::move(*this), std::forward<T>(value)};\n+}\n+\n+/// Alias for backward compatibility -- to be removed in version 2.0\n+template <typename /*unused*/> using arg_t = arg_v;\n+\n+inline namespace literals {\n+/** \\rst\n+    String literal version of `arg`\n+ \\endrst */\n+constexpr arg operator\"\" _a(const char *name, size_t) { return arg(name); }\n+} // namespace literals\n+\n+NAMESPACE_BEGIN(detail)\n+\n+// forward declaration (definition in attr.h)\n+struct function_record;\n+\n+/// Internal data associated with a single function call\n+struct function_call {\n+  function_call(const function_record &f, handle p); // Implementation in attr.h\n+\n+  /// The function data:\n+  const function_record &func;\n+\n+  /// Arguments passed to the function:\n+  std::vector<handle> args;\n+\n+  /// The `convert` value the arguments should be loaded with\n+  std::vector<bool> args_convert;\n+\n+  /// Extra references for the optional `py::args` and/or `py::kwargs` arguments\n+  /// (which, if present, are also in `args` but without a reference).\n+  object args_ref, kwargs_ref;\n+\n+  /// The parent, if any\n+  handle parent;\n+\n+  /// If this is a call to an initializer, this argument contains `self`\n+  handle init_self;\n+};\n+\n+/// Helper class which loads arguments for C++ functions called from Python\n+template <typename... Args> class argument_loader {\n+  using indices = make_index_sequence<sizeof...(Args)>;\n+\n+  template <typename Arg>\n+  using argument_is_args = std::is_same<intrinsic_t<Arg>, args>;\n+  template <typename Arg>\n+  using argument_is_kwargs = std::is_same<intrinsic_t<Arg>, kwargs>;\n+  // Get args/kwargs argument positions relative to the end of the argument\n+  // list:\n+  static constexpr auto args_pos =\n+                            constexpr_first<argument_is_args, Args...>() -\n+                            (int)sizeof...(Args),\n+                        kwargs_pos =\n+                            constexpr_first<argument_is_kwargs, Args...>() -\n+                            (int)sizeof...(Args);\n+\n+  static constexpr bool args_kwargs_are_last =\n+      kwargs_pos >= -1 && args_pos >= kwargs_pos - 1;\n+\n+  static_assert(args_kwargs_are_last, \"py::args/py::kwargs are only permitted \"\n+                                      \"as the last argument(s) of a function\");\n+\n+public:\n+  static constexpr bool has_kwargs = kwargs_pos < 0;\n+  static constexpr bool has_args = args_pos < 0;\n+\n+  static constexpr auto arg_names =\n+      concat(type_descr(make_caster<Args>::name)...);\n+\n+  bool load_args(function_call &call) {\n+    return load_impl_sequence(call, indices{});\n+  }\n+\n+  template <typename Return, typename Guard, typename Func>\n+  enable_if_t<!std::is_void<Return>::value, Return> call(Func &&f) && {\n+    return std::move(*this).template call_impl<Return>(std::forward<Func>(f),\n+                                                       indices{}, Guard{});\n+  }\n+\n+  template <typename Return, typename Guard, typename Func>\n+  enable_if_t<std::is_void<Return>::value, void_type> call(Func &&f) && {\n+    std::move(*this).template call_impl<Return>(std::forward<Func>(f),\n+                                                indices{}, Guard{});\n+    return void_type();\n+  }\n+\n+private:\n+  static bool load_impl_sequence(function_call &, index_sequence<>) {\n+    return true;\n+  }\n+\n+  template <size_t... Is>\n+  bool load_impl_sequence(function_call &call, index_sequence<Is...>) {\n+    for (bool r : {std::get<Is>(argcasters)\n+                       .load(call.args[Is], call.args_convert[Is])...})\n+      if (!r)\n+        return false;\n+    return true;\n+  }\n+\n+  template <typename Return, typename Func, size_t... Is, typename Guard>\n+  Return call_impl(Func &&f, index_sequence<Is...>, Guard &&) {\n+    return std::forward<Func>(f)(\n+        cast_op<Args>(std::move(std::get<Is>(argcasters)))...);\n+  }\n+\n+  std::tuple<make_caster<Args>...> argcasters;\n+};\n+\n+/// Helper class which collects only positional arguments for a Python function\n+/// call. A fancier version below can collect any argument, but this one is\n+/// optimal for simple calls.\n+template <return_value_policy policy> class simple_collector {\n+public:\n+  template <typename... Ts>\n+  explicit simple_collector(Ts &&...values)\n+      : m_args(pybind11::make_tuple<policy>(std::forward<Ts>(values)...)) {}\n+\n+  const tuple &args() const & { return m_args; }\n+  dict kwargs() const { return {}; }\n+\n+  tuple args() && { return std::move(m_args); }\n+\n+  /// Call a Python function and pass the collected arguments\n+  object call(PyObject *ptr) const {\n+    PyObject *result = PyObject_CallObject(ptr, m_args.ptr());\n+    if (!result)\n+      throw error_already_set();\n+    return reinterpret_steal<object>(result);\n+  }\n+\n+private:\n+  tuple m_args;\n+};\n+\n+/// Helper class which collects positional, keyword, * and ** arguments for a\n+/// Python function call\n+template <return_value_policy policy> class unpacking_collector {\n+public:\n+  template <typename... Ts> explicit unpacking_collector(Ts &&...values) {\n+    // Tuples aren't (easily) resizable so a list is needed for collection,\n+    // but the actual function call strictly requires a tuple.\n+    auto args_list = list();\n+    int _[] = {0, (process(args_list, std::forward<Ts>(values)), 0)...};\n+    ignore_unused(_);\n+\n+    m_args = std::move(args_list);\n+  }\n+\n+  const tuple &args() const & { return m_args; }\n+  const dict &kwargs() const & { return m_kwargs; }\n+\n+  tuple args() && { return std::move(m_args); }\n+  dict kwargs() && { return std::move(m_kwargs); }\n+\n+  /// Call a Python function and pass the collected arguments\n+  object call(PyObject *ptr) const {\n+    PyObject *result = PyObject_Call(ptr, m_args.ptr(), m_kwargs.ptr());\n+    if (!result)\n+      throw error_already_set();\n+    return reinterpret_steal<object>(result);\n+  }\n+\n+private:\n+  template <typename T> void process(list &args_list, T &&x) {\n+    auto o = reinterpret_steal<object>(\n+        detail::make_caster<T>::cast(std::forward<T>(x), policy, {}));\n+    if (!o) {\n+#if defined(NDEBUG)\n+      argument_cast_error();\n+#else\n+      argument_cast_error(std::to_string(args_list.size()), type_id<T>());\n+#endif\n+    }\n+    args_list.append(o);\n+  }\n+\n+  void process(list &args_list, detail::args_proxy ap) {\n+    for (const auto &a : ap)\n+      args_list.append(a);\n+  }\n+\n+  void process(list & /*args_list*/, arg_v a) {\n+    if (!a.name)\n+#if defined(NDEBUG)\n+      nameless_argument_error();\n+#else\n+      nameless_argument_error(a.type);\n+#endif\n+\n+    if (m_kwargs.contains(a.name)) {\n+#if defined(NDEBUG)\n+      multiple_values_error();\n+#else\n+      multiple_values_error(a.name);\n+#endif\n+    }\n+    if (!a.value) {\n+#if defined(NDEBUG)\n+      argument_cast_error();\n+#else\n+      argument_cast_error(a.name, a.type);\n+#endif\n+    }\n+    m_kwargs[a.name] = a.value;\n+  }\n+\n+  void process(list & /*args_list*/, detail::kwargs_proxy kp) {\n+    if (!kp)\n+      return;\n+    for (const auto &k : reinterpret_borrow<dict>(kp)) {\n+      if (m_kwargs.contains(k.first)) {\n+#if defined(NDEBUG)\n+        multiple_values_error();\n+#else\n+        multiple_values_error(str(k.first));\n+#endif\n+      }\n+      m_kwargs[k.first] = k.second;\n+    }\n+  }\n+\n+  [[noreturn]] static void nameless_argument_error() {\n+    throw type_error(\"Got kwargs without a name; only named arguments \"\n+                     \"may be passed via py::arg() to a python function call. \"\n+                     \"(compile in debug mode for details)\");\n+  }\n+  [[noreturn]] static void nameless_argument_error(std::string type) {\n+    throw type_error(\n+        \"Got kwargs without a name of type '\" + type +\n+        \"'; only named \"\n+        \"arguments may be passed via py::arg() to a python function call. \");\n+  }\n+  [[noreturn]] static void multiple_values_error() {\n+    throw type_error(\"Got multiple values for keyword argument \"\n+                     \"(compile in debug mode for details)\");\n+  }\n+\n+  [[noreturn]] static void multiple_values_error(std::string name) {\n+    throw type_error(\"Got multiple values for keyword argument '\" + name + \"'\");\n+  }\n+\n+  [[noreturn]] static void argument_cast_error() {\n+    throw cast_error(\"Unable to convert call argument to Python object \"\n+                     \"(compile in debug mode for details)\");\n+  }\n+\n+  [[noreturn]] static void argument_cast_error(std::string name,\n+                                               std::string type) {\n+    throw cast_error(\"Unable to convert call argument '\" + name +\n+                     \"' of type '\" + type + \"' to Python object\");\n+  }\n+\n+private:\n+  tuple m_args;\n+  dict m_kwargs;\n+};\n+\n+/// Collect only positional arguments for a Python function call\n+template <return_value_policy policy, typename... Args,\n+          typename = enable_if_t<all_of<is_positional<Args>...>::value>>\n+simple_collector<policy> collect_arguments(Args &&...args) {\n+  return simple_collector<policy>(std::forward<Args>(args)...);\n+}\n+\n+/// Collect all arguments, including keywords and unpacking (only instantiated\n+/// when needed)\n+template <return_value_policy policy, typename... Args,\n+          typename = enable_if_t<!all_of<is_positional<Args>...>::value>>\n+unpacking_collector<policy> collect_arguments(Args &&...args) {\n+  // Following argument order rules for generalized unpacking according to PEP\n+  // 448\n+  static_assert(constexpr_last<is_positional, Args...>() <\n+                        constexpr_first<is_keyword_or_ds, Args...>() &&\n+                    constexpr_last<is_s_unpacking, Args...>() <\n+                        constexpr_first<is_ds_unpacking, Args...>(),\n+                \"Invalid function call: positional args must precede keywords \"\n+                \"and ** unpacking; \"\n+                \"* unpacking must precede ** unpacking\");\n+  return unpacking_collector<policy>(std::forward<Args>(args)...);\n+}\n+\n+template <typename Derived>\n+template <return_value_policy policy, typename... Args>\n+object object_api<Derived>::operator()(Args &&...args) const {\n+  return detail::collect_arguments<policy>(std::forward<Args>(args)...)\n+      .call(derived().ptr());\n+}\n+\n+template <typename Derived>\n+template <return_value_policy policy, typename... Args>\n+object object_api<Derived>::call(Args &&...args) const {\n+  return operator()<policy>(std::forward<Args>(args)...);\n+}\n+\n+NAMESPACE_END(detail)\n+\n+#define PYBIND11_MAKE_OPAQUE(...)                                              \\\n+  namespace pybind11 {                                                         \\\n+  namespace detail {                                                           \\\n+  template <>                                                                  \\\n+  class type_caster<__VA_ARGS__> : public type_caster_base<__VA_ARGS__> {};    \\\n+  }                                                                            \\\n+  }\n+\n+/// Lets you pass a type containing a `,` through a macro parameter without\n+/// needing a separate typedef, e.g.:\n+/// `PYBIND11_OVERLOAD(PYBIND11_TYPE(ReturnType<A, B>), PYBIND11_TYPE(Parent<C,\n+/// D>), f, arg)`\n+#define PYBIND11_TYPE(...) __VA_ARGS__\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/chrono.h", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "file_content_changes": "@@ -0,0 +1,187 @@\n+/*\n+    pybind11/chrono.h: Transparent conversion between std::chrono and python's\n+   datetime\n+\n+    Copyright (c) 2016 Trent Houliston <trent@houliston.me> and\n+                       Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+#include <chrono>\n+#include <cmath>\n+#include <ctime>\n+#include <datetime.h>\n+\n+// Backport the PyDateTime_DELTA functions from Python3.3 if required\n+#ifndef PyDateTime_DELTA_GET_DAYS\n+#define PyDateTime_DELTA_GET_DAYS(o) (((PyDateTime_Delta *)o)->days)\n+#endif\n+#ifndef PyDateTime_DELTA_GET_SECONDS\n+#define PyDateTime_DELTA_GET_SECONDS(o) (((PyDateTime_Delta *)o)->seconds)\n+#endif\n+#ifndef PyDateTime_DELTA_GET_MICROSECONDS\n+#define PyDateTime_DELTA_GET_MICROSECONDS(o)                                   \\\n+  (((PyDateTime_Delta *)o)->microseconds)\n+#endif\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+template <typename type> class duration_caster {\n+public:\n+  typedef typename type::rep rep;\n+  typedef typename type::period period;\n+\n+  typedef std::chrono::duration<uint_fast32_t, std::ratio<86400>> days;\n+\n+  bool load(handle src, bool) {\n+    using namespace std::chrono;\n+\n+    // Lazy initialise the PyDateTime import\n+    if (!PyDateTimeAPI) {\n+      PyDateTime_IMPORT;\n+    }\n+\n+    if (!src)\n+      return false;\n+    // If invoked with datetime.delta object\n+    if (PyDelta_Check(src.ptr())) {\n+      value = type(duration_cast<duration<rep, period>>(\n+          days(PyDateTime_DELTA_GET_DAYS(src.ptr())) +\n+          seconds(PyDateTime_DELTA_GET_SECONDS(src.ptr())) +\n+          microseconds(PyDateTime_DELTA_GET_MICROSECONDS(src.ptr()))));\n+      return true;\n+    }\n+    // If invoked with a float we assume it is seconds and convert\n+    else if (PyFloat_Check(src.ptr())) {\n+      value = type(duration_cast<duration<rep, period>>(\n+          duration<double>(PyFloat_AsDouble(src.ptr()))));\n+      return true;\n+    } else\n+      return false;\n+  }\n+\n+  // If this is a duration just return it back\n+  static const std::chrono::duration<rep, period> &\n+  get_duration(const std::chrono::duration<rep, period> &src) {\n+    return src;\n+  }\n+\n+  // If this is a time_point get the time_since_epoch\n+  template <typename Clock>\n+  static std::chrono::duration<rep, period> get_duration(\n+      const std::chrono::time_point<Clock, std::chrono::duration<rep, period>>\n+          &src) {\n+    return src.time_since_epoch();\n+  }\n+\n+  static handle cast(const type &src, return_value_policy /* policy */,\n+                     handle /* parent */) {\n+    using namespace std::chrono;\n+\n+    // Use overloaded function to get our duration from our source\n+    // Works out if it is a duration or time_point and get the duration\n+    auto d = get_duration(src);\n+\n+    // Lazy initialise the PyDateTime import\n+    if (!PyDateTimeAPI) {\n+      PyDateTime_IMPORT;\n+    }\n+\n+    // Declare these special duration types so the conversions happen with the\n+    // correct primitive types (int)\n+    using dd_t = duration<int, std::ratio<86400>>;\n+    using ss_t = duration<int, std::ratio<1>>;\n+    using us_t = duration<int, std::micro>;\n+\n+    auto dd = duration_cast<dd_t>(d);\n+    auto subd = d - dd;\n+    auto ss = duration_cast<ss_t>(subd);\n+    auto us = duration_cast<us_t>(subd - ss);\n+    return PyDelta_FromDSU(dd.count(), ss.count(), us.count());\n+  }\n+\n+  PYBIND11_TYPE_CASTER(type, _(\"datetime.timedelta\"));\n+};\n+\n+// This is for casting times on the system clock into datetime.datetime\n+// instances\n+template <typename Duration>\n+class type_caster<\n+    std::chrono::time_point<std::chrono::system_clock, Duration>> {\n+public:\n+  typedef std::chrono::time_point<std::chrono::system_clock, Duration> type;\n+  bool load(handle src, bool) {\n+    using namespace std::chrono;\n+\n+    // Lazy initialise the PyDateTime import\n+    if (!PyDateTimeAPI) {\n+      PyDateTime_IMPORT;\n+    }\n+\n+    if (!src)\n+      return false;\n+    if (PyDateTime_Check(src.ptr())) {\n+      std::tm cal;\n+      cal.tm_sec = PyDateTime_DATE_GET_SECOND(src.ptr());\n+      cal.tm_min = PyDateTime_DATE_GET_MINUTE(src.ptr());\n+      cal.tm_hour = PyDateTime_DATE_GET_HOUR(src.ptr());\n+      cal.tm_mday = PyDateTime_GET_DAY(src.ptr());\n+      cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;\n+      cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;\n+      cal.tm_isdst = -1;\n+\n+      value = system_clock::from_time_t(std::mktime(&cal)) +\n+              microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));\n+      return true;\n+    } else\n+      return false;\n+  }\n+\n+  static handle\n+  cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src,\n+       return_value_policy /* policy */, handle /* parent */) {\n+    using namespace std::chrono;\n+\n+    // Lazy initialise the PyDateTime import\n+    if (!PyDateTimeAPI) {\n+      PyDateTime_IMPORT;\n+    }\n+\n+    std::time_t tt = system_clock::to_time_t(src);\n+    // this function uses static memory so it's best to copy it out asap just in\n+    // case otherwise other code that is using localtime may break this (not\n+    // just python code)\n+    std::tm localtime = *std::localtime(&tt);\n+\n+    // Declare these special duration types so the conversions happen with the\n+    // correct primitive types (int)\n+    using us_t = duration<int, std::micro>;\n+\n+    return PyDateTime_FromDateAndTime(\n+        localtime.tm_year + 1900, localtime.tm_mon + 1, localtime.tm_mday,\n+        localtime.tm_hour, localtime.tm_min, localtime.tm_sec,\n+        (duration_cast<us_t>(src.time_since_epoch() % seconds(1))).count());\n+  }\n+  PYBIND11_TYPE_CASTER(type, _(\"datetime.datetime\"));\n+};\n+\n+// Other clocks that are not the system clock are not measured as\n+// datetime.datetime objects since they are not measured on calendar time. So\n+// instead we just make them timedeltas Or if they have passed us a time as a\n+// float we convert that\n+template <typename Clock, typename Duration>\n+class type_caster<std::chrono::time_point<Clock, Duration>>\n+    : public duration_caster<std::chrono::time_point<Clock, Duration>> {};\n+\n+template <typename Rep, typename Period>\n+class type_caster<std::chrono::duration<Rep, Period>>\n+    : public duration_caster<std::chrono::duration<Rep, Period>> {};\n+\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/common.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -0,0 +1,3 @@\n+#include \"detail/common.h\"\n+#warning                                                                       \\\n+    \"Including 'common.h' is deprecated. It will be removed in v3.0. Use 'pybind11.h'.\""}, {"filename": "python/src/pybind11/complex.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "file_content_changes": "@@ -0,0 +1,72 @@\n+/*\n+    pybind11/complex.h: Complex number support\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+#include <complex>\n+\n+/// glibc defines I as a macro which breaks things, e.g., boost template names\n+#ifdef I\n+#undef I\n+#endif\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+template <typename T>\n+struct format_descriptor<\n+    std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {\n+  static constexpr const char c = format_descriptor<T>::c;\n+  static constexpr const char value[3] = {'Z', c, '\\0'};\n+  static std::string format() { return std::string(value); }\n+};\n+\n+#ifndef PYBIND11_CPP17\n+\n+template <typename T>\n+constexpr const char format_descriptor<\n+    std::complex<T>,\n+    detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];\n+\n+#endif\n+\n+NAMESPACE_BEGIN(detail)\n+\n+template <typename T>\n+struct is_fmt_numeric<std::complex<T>,\n+                      detail::enable_if_t<std::is_floating_point<T>::value>> {\n+  static constexpr bool value = true;\n+  static constexpr int index = is_fmt_numeric<T>::index + 3;\n+};\n+\n+template <typename T> class type_caster<std::complex<T>> {\n+public:\n+  bool load(handle src, bool convert) {\n+    if (!src)\n+      return false;\n+    if (!convert && !PyComplex_Check(src.ptr()))\n+      return false;\n+    Py_complex result = PyComplex_AsCComplex(src.ptr());\n+    if (result.real == -1.0 && PyErr_Occurred()) {\n+      PyErr_Clear();\n+      return false;\n+    }\n+    value = std::complex<T>((T)result.real, (T)result.imag);\n+    return true;\n+  }\n+\n+  static handle cast(const std::complex<T> &src,\n+                     return_value_policy /* policy */, handle /* parent */) {\n+    return PyComplex_FromDoubles((double)src.real(), (double)src.imag());\n+  }\n+\n+  PYBIND11_TYPE_CASTER(std::complex<T>, _(\"complex\"));\n+};\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/class.h", "status": "added", "additions": 668, "deletions": 0, "changes": 668, "file_content_changes": "@@ -0,0 +1,668 @@\n+/*\n+    pybind11/detail/class.h: Python C API implementation details for py::class_\n+\n+    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"../attr.h\"\n+#include \"../options.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+#if PY_VERSION_HEX >= 0x03030000\n+#define PYBIND11_BUILTIN_QUALNAME\n+#define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)\n+#else\n+// In pre-3.3 Python, we still set __qualname__ so that we can produce reliable\n+// function type signatures; in 3.3+ this macro expands to nothing:\n+#define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)                              \\\n+  setattr((PyObject *)obj, \"__qualname__\", nameobj)\n+#endif\n+\n+inline PyTypeObject *type_incref(PyTypeObject *type) {\n+  Py_INCREF(type);\n+  return type;\n+}\n+\n+#if !defined(PYPY_VERSION)\n+\n+/// `pybind11_static_property.__get__()`: Always pass the class instead of the\n+/// instance.\n+extern \"C\" inline PyObject *\n+pybind11_static_get(PyObject *self, PyObject * /*ob*/, PyObject *cls) {\n+  return PyProperty_Type.tp_descr_get(self, cls, cls);\n+}\n+\n+/// `pybind11_static_property.__set__()`: Just like the above `__get__()`.\n+extern \"C\" inline int pybind11_static_set(PyObject *self, PyObject *obj,\n+                                          PyObject *value) {\n+  PyObject *cls = PyType_Check(obj) ? obj : (PyObject *)Py_TYPE(obj);\n+  return PyProperty_Type.tp_descr_set(self, cls, value);\n+}\n+\n+/** A `static_property` is the same as a `property` but the `__get__()` and\n+   `__set__()` methods are modified to always use the object type instead of a\n+   concrete instance. Return value: New reference. */\n+inline PyTypeObject *make_static_property_type() {\n+  constexpr auto *name = \"pybind11_static_property\";\n+  auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));\n+\n+  /* Danger zone: from now (and until PyType_Ready), make sure to\n+     issue no Python C API calls which could potentially invoke the\n+     garbage collector (the GC will call type_traverse(), which will in\n+     turn find the newly constructed type in an invalid state) */\n+  auto heap_type = (PyHeapTypeObject *)PyType_Type.tp_alloc(&PyType_Type, 0);\n+  if (!heap_type)\n+    pybind11_fail(\"make_static_property_type(): error allocating type!\");\n+\n+  heap_type->ht_name = name_obj.inc_ref().ptr();\n+#ifdef PYBIND11_BUILTIN_QUALNAME\n+  heap_type->ht_qualname = name_obj.inc_ref().ptr();\n+#endif\n+\n+  auto type = &heap_type->ht_type;\n+  type->tp_name = name;\n+  type->tp_base = type_incref(&PyProperty_Type);\n+  type->tp_flags =\n+      Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n+  type->tp_descr_get = pybind11_static_get;\n+  type->tp_descr_set = pybind11_static_set;\n+\n+  if (PyType_Ready(type) < 0)\n+    pybind11_fail(\"make_static_property_type(): failure in PyType_Ready()!\");\n+\n+  setattr((PyObject *)type, \"__module__\", str(\"pybind11_builtins\"));\n+  PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n+\n+  return type;\n+}\n+\n+#else // PYPY\n+\n+/** PyPy has some issues with the above C API, so we evaluate Python code\n+   instead. This function will only be called once so performance isn't really a\n+   concern. Return value: New reference. */\n+inline PyTypeObject *make_static_property_type() {\n+  auto d = dict();\n+  PyObject *result = PyRun_String(R\"(\\\n+        class pybind11_static_property(property):\n+            def __get__(self, obj, cls):\n+                return property.__get__(self, cls, cls)\n+\n+            def __set__(self, obj, value):\n+                cls = obj if isinstance(obj, type) else type(obj)\n+                property.__set__(self, cls, value)\n+        )\",\n+                                  Py_file_input, d.ptr(), d.ptr());\n+  if (result == nullptr)\n+    throw error_already_set();\n+  Py_DECREF(result);\n+  return (PyTypeObject *)d[\"pybind11_static_property\"]\n+      .cast<object>()\n+      .release()\n+      .ptr();\n+}\n+\n+#endif // PYPY\n+\n+/** Types with static properties need to handle `Type.static_prop = x` in a\n+   specific way. By default, Python replaces the `static_property` itself, but\n+   for wrapped C++ types we need to call `static_property.__set__()` in order to\n+   propagate the new value to the underlying C++ data structure. */\n+extern \"C\" inline int pybind11_meta_setattro(PyObject *obj, PyObject *name,\n+                                             PyObject *value) {\n+  // Use `_PyType_Lookup()` instead of `PyObject_GetAttr()` in order to get the\n+  // raw descriptor (`property`) instead of calling `tp_descr_get`\n+  // (`property.__get__()`).\n+  PyObject *descr = _PyType_Lookup((PyTypeObject *)obj, name);\n+\n+  // The following assignment combinations are possible:\n+  //   1. `Type.static_prop = value`             --> descr_set:\n+  //   `Type.static_prop.__set__(value)`\n+  //   2. `Type.static_prop = other_static_prop` --> setattro:  replace existing\n+  //   `static_prop`\n+  //   3. `Type.regular_attribute = value`       --> setattro:  regular\n+  //   attribute assignment\n+  const auto static_prop = (PyObject *)get_internals().static_property_type;\n+  const auto call_descr_set = descr &&\n+                              PyObject_IsInstance(descr, static_prop) &&\n+                              !PyObject_IsInstance(value, static_prop);\n+  if (call_descr_set) {\n+    // Call `static_property.__set__()` instead of replacing the\n+    // `static_property`.\n+#if !defined(PYPY_VERSION)\n+    return Py_TYPE(descr)->tp_descr_set(descr, obj, value);\n+#else\n+    if (PyObject *result =\n+            PyObject_CallMethod(descr, \"__set__\", \"OO\", obj, value)) {\n+      Py_DECREF(result);\n+      return 0;\n+    } else {\n+      return -1;\n+    }\n+#endif\n+  } else {\n+    // Replace existing attribute.\n+    return PyType_Type.tp_setattro(obj, name, value);\n+  }\n+}\n+\n+#if PY_MAJOR_VERSION >= 3\n+/**\n+ * Python 3's PyInstanceMethod_Type hides itself via its tp_descr_get, which\n+ * prevents aliasing methods via cls.attr(\"m2\") = cls.attr(\"m1\"): instead the\n+ * tp_descr_get returns a plain function, when called on a class, or a PyMethod,\n+ * when called on an instance.  Override that behaviour here to do a special\n+ * case bypass for PyInstanceMethod_Types.\n+ */\n+extern \"C\" inline PyObject *pybind11_meta_getattro(PyObject *obj,\n+                                                   PyObject *name) {\n+  PyObject *descr = _PyType_Lookup((PyTypeObject *)obj, name);\n+  if (descr && PyInstanceMethod_Check(descr)) {\n+    Py_INCREF(descr);\n+    return descr;\n+  } else {\n+    return PyType_Type.tp_getattro(obj, name);\n+  }\n+}\n+#endif\n+\n+/** This metaclass is assigned by default to all pybind11 types and is required\n+   in order for static properties to function correctly. Users may override this\n+   using `py::metaclass`. Return value: New reference. */\n+inline PyTypeObject *make_default_metaclass() {\n+  constexpr auto *name = \"pybind11_type\";\n+  auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));\n+\n+  /* Danger zone: from now (and until PyType_Ready), make sure to\n+     issue no Python C API calls which could potentially invoke the\n+     garbage collector (the GC will call type_traverse(), which will in\n+     turn find the newly constructed type in an invalid state) */\n+  auto heap_type = (PyHeapTypeObject *)PyType_Type.tp_alloc(&PyType_Type, 0);\n+  if (!heap_type)\n+    pybind11_fail(\"make_default_metaclass(): error allocating metaclass!\");\n+\n+  heap_type->ht_name = name_obj.inc_ref().ptr();\n+#ifdef PYBIND11_BUILTIN_QUALNAME\n+  heap_type->ht_qualname = name_obj.inc_ref().ptr();\n+#endif\n+\n+  auto type = &heap_type->ht_type;\n+  type->tp_name = name;\n+  type->tp_base = type_incref(&PyType_Type);\n+  type->tp_flags =\n+      Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n+\n+  type->tp_setattro = pybind11_meta_setattro;\n+#if PY_MAJOR_VERSION >= 3\n+  type->tp_getattro = pybind11_meta_getattro;\n+#endif\n+\n+  if (PyType_Ready(type) < 0)\n+    pybind11_fail(\"make_default_metaclass(): failure in PyType_Ready()!\");\n+\n+  setattr((PyObject *)type, \"__module__\", str(\"pybind11_builtins\"));\n+  PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n+\n+  return type;\n+}\n+\n+/// For multiple inheritance types we need to recursively register/deregister\n+/// base pointers for any base classes with pointers that are difference from\n+/// the instance value pointer so that we can correctly recognize an offset base\n+/// class pointer. This calls a function with any offset base ptrs.\n+inline void\n+traverse_offset_bases(void *valueptr, const detail::type_info *tinfo,\n+                      instance *self,\n+                      bool (*f)(void * /*parentptr*/, instance * /*self*/)) {\n+  for (handle h : reinterpret_borrow<tuple>(tinfo->type->tp_bases)) {\n+    if (auto parent_tinfo = get_type_info((PyTypeObject *)h.ptr())) {\n+      for (auto &c : parent_tinfo->implicit_casts) {\n+        if (c.first == tinfo->cpptype) {\n+          auto *parentptr = c.second(valueptr);\n+          if (parentptr != valueptr)\n+            f(parentptr, self);\n+          traverse_offset_bases(parentptr, parent_tinfo, self, f);\n+          break;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+inline bool register_instance_impl(void *ptr, instance *self) {\n+  get_internals().registered_instances.emplace(ptr, self);\n+  return true; // unused, but gives the same signature as the deregister func\n+}\n+inline bool deregister_instance_impl(void *ptr, instance *self) {\n+  auto &registered_instances = get_internals().registered_instances;\n+  auto range = registered_instances.equal_range(ptr);\n+  for (auto it = range.first; it != range.second; ++it) {\n+    if (Py_TYPE(self) == Py_TYPE(it->second)) {\n+      registered_instances.erase(it);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+inline void register_instance(instance *self, void *valptr,\n+                              const type_info *tinfo) {\n+  register_instance_impl(valptr, self);\n+  if (!tinfo->simple_ancestors)\n+    traverse_offset_bases(valptr, tinfo, self, register_instance_impl);\n+}\n+\n+inline bool deregister_instance(instance *self, void *valptr,\n+                                const type_info *tinfo) {\n+  bool ret = deregister_instance_impl(valptr, self);\n+  if (!tinfo->simple_ancestors)\n+    traverse_offset_bases(valptr, tinfo, self, deregister_instance_impl);\n+  return ret;\n+}\n+\n+/// Instance creation function for all pybind11 types. It allocates the internal\n+/// instance layout for holding C++ objects and holders.  Allocation is done\n+/// lazily (the first time the instance is cast to a reference or pointer), and\n+/// initialization is done by an `__init__` function.\n+inline PyObject *make_new_instance(PyTypeObject *type) {\n+#if defined(PYPY_VERSION)\n+  // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when\n+  // the first inherited object is a a plain Python type (i.e. not derived from\n+  // an extension type).  Fix it.\n+  ssize_t instance_size = static_cast<ssize_t>(sizeof(instance));\n+  if (type->tp_basicsize < instance_size) {\n+    type->tp_basicsize = instance_size;\n+  }\n+#endif\n+  PyObject *self = type->tp_alloc(type, 0);\n+  auto inst = reinterpret_cast<instance *>(self);\n+  // Allocate the value/holder internals:\n+  inst->allocate_layout();\n+\n+  inst->owned = true;\n+\n+  return self;\n+}\n+\n+/// Instance creation function for all pybind11 types. It only allocates space\n+/// for the C++ object, but doesn't call the constructor -- an `__init__`\n+/// function must do that.\n+extern \"C\" inline PyObject *pybind11_object_new(PyTypeObject *type, PyObject *,\n+                                                PyObject *) {\n+  return make_new_instance(type);\n+}\n+\n+/// An `__init__` function constructs the C++ object. Users should provide at\n+/// least one of these using `py::init` or directly with `.def(__init__, ...)`.\n+/// Otherwise, the following default function will be used which simply throws\n+/// an exception.\n+extern \"C\" inline int pybind11_object_init(PyObject *self, PyObject *,\n+                                           PyObject *) {\n+  PyTypeObject *type = Py_TYPE(self);\n+  std::string msg;\n+#if defined(PYPY_VERSION)\n+  msg += handle((PyObject *)type).attr(\"__module__\").cast<std::string>() + \".\";\n+#endif\n+  msg += type->tp_name;\n+  msg += \": No constructor defined!\";\n+  PyErr_SetString(PyExc_TypeError, msg.c_str());\n+  return -1;\n+}\n+\n+inline void add_patient(PyObject *nurse, PyObject *patient) {\n+  auto &internals = get_internals();\n+  auto instance = reinterpret_cast<detail::instance *>(nurse);\n+  instance->has_patients = true;\n+  Py_INCREF(patient);\n+  internals.patients[nurse].push_back(patient);\n+}\n+\n+inline void clear_patients(PyObject *self) {\n+  auto instance = reinterpret_cast<detail::instance *>(self);\n+  auto &internals = get_internals();\n+  auto pos = internals.patients.find(self);\n+  assert(pos != internals.patients.end());\n+  // Clearing the patients can cause more Python code to run, which\n+  // can invalidate the iterator. Extract the vector of patients\n+  // from the unordered_map first.\n+  auto patients = std::move(pos->second);\n+  internals.patients.erase(pos);\n+  instance->has_patients = false;\n+  for (PyObject *&patient : patients)\n+    Py_CLEAR(patient);\n+}\n+\n+/// Clears all internal data from the instance and removes it from registered\n+/// instances in preparation for deallocation.\n+inline void clear_instance(PyObject *self) {\n+  auto instance = reinterpret_cast<detail::instance *>(self);\n+\n+  // Deallocate any values/holders, if present:\n+  for (auto &v_h : values_and_holders(instance)) {\n+    if (v_h) {\n+\n+      // We have to deregister before we call dealloc because, for virtual MI\n+      // types, we still need to be able to get the parent pointers.\n+      if (v_h.instance_registered() &&\n+          !deregister_instance(instance, v_h.value_ptr(), v_h.type))\n+        pybind11_fail(\"pybind11_object_dealloc(): Tried to deallocate \"\n+                      \"unregistered instance!\");\n+\n+      if (instance->owned || v_h.holder_constructed())\n+        v_h.type->dealloc(v_h);\n+    }\n+  }\n+  // Deallocate the value/holder layout internals:\n+  instance->deallocate_layout();\n+\n+  if (instance->weakrefs)\n+    PyObject_ClearWeakRefs(self);\n+\n+  PyObject **dict_ptr = _PyObject_GetDictPtr(self);\n+  if (dict_ptr)\n+    Py_CLEAR(*dict_ptr);\n+\n+  if (instance->has_patients)\n+    clear_patients(self);\n+}\n+\n+/// Instance destructor function for all pybind11 types. It calls\n+/// `type_info.dealloc` to destroy the C++ object itself, while the rest is\n+/// Python bookkeeping.\n+extern \"C\" inline void pybind11_object_dealloc(PyObject *self) {\n+  clear_instance(self);\n+\n+  auto type = Py_TYPE(self);\n+  type->tp_free(self);\n+\n+  // `type->tp_dealloc != pybind11_object_dealloc` means that we're being called\n+  // as part of a derived type's dealloc, in which case we're not allowed to\n+  // decref the type here. For cross-module compatibility, we shouldn't compare\n+  // directly with `pybind11_object_dealloc`, but with the common one stashed in\n+  // internals.\n+  auto pybind11_object_type = (PyTypeObject *)get_internals().instance_base;\n+  if (type->tp_dealloc == pybind11_object_type->tp_dealloc)\n+    Py_DECREF(type);\n+}\n+\n+/** Create the type which can be used as a common base for all classes.  This is\n+    needed in order to satisfy Python's requirements for multiple inheritance.\n+    Return value: New reference. */\n+inline PyObject *make_object_base_type(PyTypeObject *metaclass) {\n+  constexpr auto *name = \"pybind11_object\";\n+  auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));\n+\n+  /* Danger zone: from now (and until PyType_Ready), make sure to\n+     issue no Python C API calls which could potentially invoke the\n+     garbage collector (the GC will call type_traverse(), which will in\n+     turn find the newly constructed type in an invalid state) */\n+  auto heap_type = (PyHeapTypeObject *)metaclass->tp_alloc(metaclass, 0);\n+  if (!heap_type)\n+    pybind11_fail(\"make_object_base_type(): error allocating type!\");\n+\n+  heap_type->ht_name = name_obj.inc_ref().ptr();\n+#ifdef PYBIND11_BUILTIN_QUALNAME\n+  heap_type->ht_qualname = name_obj.inc_ref().ptr();\n+#endif\n+\n+  auto type = &heap_type->ht_type;\n+  type->tp_name = name;\n+  type->tp_base = type_incref(&PyBaseObject_Type);\n+  type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));\n+  type->tp_flags =\n+      Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n+\n+  type->tp_new = pybind11_object_new;\n+  type->tp_init = pybind11_object_init;\n+  type->tp_dealloc = pybind11_object_dealloc;\n+\n+  /* Support weak references (needed for the keep_alive feature) */\n+  type->tp_weaklistoffset = offsetof(instance, weakrefs);\n+\n+  if (PyType_Ready(type) < 0)\n+    pybind11_fail(\"PyType_Ready failed in make_object_base_type():\" +\n+                  error_string());\n+\n+  setattr((PyObject *)type, \"__module__\", str(\"pybind11_builtins\"));\n+  PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);\n+\n+  assert(!PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));\n+  return (PyObject *)heap_type;\n+}\n+\n+/// dynamic_attr: Support for `d = instance.__dict__`.\n+extern \"C\" inline PyObject *pybind11_get_dict(PyObject *self, void *) {\n+  PyObject *&dict = *_PyObject_GetDictPtr(self);\n+  if (!dict)\n+    dict = PyDict_New();\n+  Py_XINCREF(dict);\n+  return dict;\n+}\n+\n+/// dynamic_attr: Support for `instance.__dict__ = dict()`.\n+extern \"C\" inline int pybind11_set_dict(PyObject *self, PyObject *new_dict,\n+                                        void *) {\n+  if (!PyDict_Check(new_dict)) {\n+    PyErr_Format(PyExc_TypeError,\n+                 \"__dict__ must be set to a dictionary, not a '%.200s'\",\n+                 Py_TYPE(new_dict)->tp_name);\n+    return -1;\n+  }\n+  PyObject *&dict = *_PyObject_GetDictPtr(self);\n+  Py_INCREF(new_dict);\n+  Py_CLEAR(dict);\n+  dict = new_dict;\n+  return 0;\n+}\n+\n+/// dynamic_attr: Allow the garbage collector to traverse the internal instance\n+/// `__dict__`.\n+extern \"C\" inline int pybind11_traverse(PyObject *self, visitproc visit,\n+                                        void *arg) {\n+  PyObject *&dict = *_PyObject_GetDictPtr(self);\n+  Py_VISIT(dict);\n+  return 0;\n+}\n+\n+/// dynamic_attr: Allow the GC to clear the dictionary.\n+extern \"C\" inline int pybind11_clear(PyObject *self) {\n+  PyObject *&dict = *_PyObject_GetDictPtr(self);\n+  Py_CLEAR(dict);\n+  return 0;\n+}\n+\n+/// Give instances of this type a `__dict__` and opt into garbage collection.\n+inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type) {\n+  auto type = &heap_type->ht_type;\n+#if defined(PYPY_VERSION)\n+  pybind11_fail(std::string(type->tp_name) + \": dynamic attributes are \"\n+                                             \"currently not supported in \"\n+                                             \"conjunction with PyPy!\");\n+#endif\n+  type->tp_flags |= Py_TPFLAGS_HAVE_GC;\n+  type->tp_dictoffset = type->tp_basicsize; // place dict at the end\n+  type->tp_basicsize +=\n+      (ssize_t)sizeof(PyObject *); // and allocate enough space for it\n+  type->tp_traverse = pybind11_traverse;\n+  type->tp_clear = pybind11_clear;\n+\n+  static PyGetSetDef getset[] = {{const_cast<char *>(\"__dict__\"),\n+                                  pybind11_get_dict, pybind11_set_dict, nullptr,\n+                                  nullptr},\n+                                 {nullptr, nullptr, nullptr, nullptr, nullptr}};\n+  type->tp_getset = getset;\n+}\n+\n+/// buffer_protocol: Fill in the view as specified by flags.\n+extern \"C\" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view,\n+                                         int flags) {\n+  // Look for a `get_buffer` implementation in this type's info or any bases\n+  // (following MRO).\n+  type_info *tinfo = nullptr;\n+  for (auto type : reinterpret_borrow<tuple>(Py_TYPE(obj)->tp_mro)) {\n+    tinfo = get_type_info((PyTypeObject *)type.ptr());\n+    if (tinfo && tinfo->get_buffer)\n+      break;\n+  }\n+  if (view == nullptr || !tinfo || !tinfo->get_buffer) {\n+    if (view)\n+      view->obj = nullptr;\n+    PyErr_SetString(PyExc_BufferError, \"pybind11_getbuffer(): Internal error\");\n+    return -1;\n+  }\n+  std::memset(view, 0, sizeof(Py_buffer));\n+  buffer_info *info = tinfo->get_buffer(obj, tinfo->get_buffer_data);\n+  view->obj = obj;\n+  view->ndim = 1;\n+  view->internal = info;\n+  view->buf = info->ptr;\n+  view->itemsize = info->itemsize;\n+  view->len = view->itemsize;\n+  for (auto s : info->shape)\n+    view->len *= s;\n+  if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)\n+    view->format = const_cast<char *>(info->format.c_str());\n+  if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES) {\n+    view->ndim = (int)info->ndim;\n+    view->strides = &info->strides[0];\n+    view->shape = &info->shape[0];\n+  }\n+  Py_INCREF(view->obj);\n+  return 0;\n+}\n+\n+/// buffer_protocol: Release the resources of the buffer.\n+extern \"C\" inline void pybind11_releasebuffer(PyObject *, Py_buffer *view) {\n+  delete (buffer_info *)view->internal;\n+}\n+\n+/// Give this type a buffer interface.\n+inline void enable_buffer_protocol(PyHeapTypeObject *heap_type) {\n+  heap_type->ht_type.tp_as_buffer = &heap_type->as_buffer;\n+#if PY_MAJOR_VERSION < 3\n+  heap_type->ht_type.tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;\n+#endif\n+\n+  heap_type->as_buffer.bf_getbuffer = pybind11_getbuffer;\n+  heap_type->as_buffer.bf_releasebuffer = pybind11_releasebuffer;\n+}\n+\n+/** Create a brand new Python type according to the `type_record` specification.\n+    Return value: New reference. */\n+inline PyObject *make_new_python_type(const type_record &rec) {\n+  auto name = reinterpret_steal<object>(PYBIND11_FROM_STRING(rec.name));\n+\n+  auto qualname = name;\n+  if (rec.scope && !PyModule_Check(rec.scope.ptr()) &&\n+      hasattr(rec.scope, \"__qualname__\")) {\n+#if PY_MAJOR_VERSION >= 3\n+    qualname = reinterpret_steal<object>(PyUnicode_FromFormat(\n+        \"%U.%U\", rec.scope.attr(\"__qualname__\").ptr(), name.ptr()));\n+#else\n+    qualname = str(rec.scope.attr(\"__qualname__\").cast<std::string>() + \".\" +\n+                   rec.name);\n+#endif\n+  }\n+\n+  object module;\n+  if (rec.scope) {\n+    if (hasattr(rec.scope, \"__module__\"))\n+      module = rec.scope.attr(\"__module__\");\n+    else if (hasattr(rec.scope, \"__name__\"))\n+      module = rec.scope.attr(\"__name__\");\n+  }\n+\n+  auto full_name = c_str(\n+#if !defined(PYPY_VERSION)\n+      module ? str(module).cast<std::string>() + \".\" + rec.name :\n+#endif\n+             rec.name);\n+\n+  char *tp_doc = nullptr;\n+  if (rec.doc && options::show_user_defined_docstrings()) {\n+    /* Allocate memory for docstring (using PyObject_MALLOC, since\n+       Python will free this later on) */\n+    size_t size = strlen(rec.doc) + 1;\n+    tp_doc = (char *)PyObject_MALLOC(size);\n+    memcpy((void *)tp_doc, rec.doc, size);\n+  }\n+\n+  auto &internals = get_internals();\n+  auto bases = tuple(rec.bases);\n+  auto base = (bases.size() == 0) ? internals.instance_base : bases[0].ptr();\n+\n+  /* Danger zone: from now (and until PyType_Ready), make sure to\n+     issue no Python C API calls which could potentially invoke the\n+     garbage collector (the GC will call type_traverse(), which will in\n+     turn find the newly constructed type in an invalid state) */\n+  auto metaclass = rec.metaclass.ptr() ? (PyTypeObject *)rec.metaclass.ptr()\n+                                       : internals.default_metaclass;\n+\n+  auto heap_type = (PyHeapTypeObject *)metaclass->tp_alloc(metaclass, 0);\n+  if (!heap_type)\n+    pybind11_fail(std::string(rec.name) + \": Unable to create type object!\");\n+\n+  heap_type->ht_name = name.release().ptr();\n+#ifdef PYBIND11_BUILTIN_QUALNAME\n+  heap_type->ht_qualname = qualname.inc_ref().ptr();\n+#endif\n+\n+  auto type = &heap_type->ht_type;\n+  type->tp_name = full_name;\n+  type->tp_doc = tp_doc;\n+  type->tp_base = type_incref((PyTypeObject *)base);\n+  type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));\n+  if (bases.size() > 0)\n+    type->tp_bases = bases.release().ptr();\n+\n+  /* Don't inherit base __init__ */\n+  type->tp_init = pybind11_object_init;\n+\n+  /* Supported protocols */\n+  type->tp_as_number = &heap_type->as_number;\n+  type->tp_as_sequence = &heap_type->as_sequence;\n+  type->tp_as_mapping = &heap_type->as_mapping;\n+\n+  /* Flags */\n+  type->tp_flags |=\n+      Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;\n+#if PY_MAJOR_VERSION < 3\n+  type->tp_flags |= Py_TPFLAGS_CHECKTYPES;\n+#endif\n+\n+  if (rec.dynamic_attr)\n+    enable_dynamic_attributes(heap_type);\n+\n+  if (rec.buffer_protocol)\n+    enable_buffer_protocol(heap_type);\n+\n+  if (PyType_Ready(type) < 0)\n+    pybind11_fail(std::string(rec.name) + \": PyType_Ready failed (\" +\n+                  error_string() + \")!\");\n+\n+  assert(rec.dynamic_attr ? PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC)\n+                          : !PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));\n+\n+  /* Register type with the parent scope */\n+  if (rec.scope)\n+    setattr(rec.scope, rec.name, (PyObject *)type);\n+  else\n+    Py_INCREF(type); // Keep it alive forever (reference leak)\n+\n+  if (module) // Needed by pydoc\n+    setattr((PyObject *)type, \"__module__\", module);\n+\n+  PYBIND11_SET_OLDPY_QUALNAME(type, qualname);\n+\n+  return (PyObject *)type;\n+}\n+\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/common.h", "status": "added", "additions": 945, "deletions": 0, "changes": 945, "file_content_changes": "@@ -0,0 +1,945 @@\n+/*\n+    pybind11/detail/common.h -- Basic macros\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#if !defined(NAMESPACE_BEGIN)\n+#define NAMESPACE_BEGIN(name) namespace name {\n+#endif\n+#if !defined(NAMESPACE_END)\n+#define NAMESPACE_END(name) }\n+#endif\n+\n+// Robust support for some features and loading modules compiled against\n+// different pybind versions requires forcing hidden visibility on pybind code,\n+// so we enforce this by setting the attribute on the main `pybind11` namespace.\n+#if !defined(PYBIND11_NAMESPACE)\n+#ifdef __GNUG__\n+#define PYBIND11_NAMESPACE pybind11 __attribute__((visibility(\"hidden\")))\n+#else\n+#define PYBIND11_NAMESPACE pybind11\n+#endif\n+#endif\n+\n+#if !(defined(_MSC_VER) && __cplusplus == 199711L) && !defined(__INTEL_COMPILER)\n+#if __cplusplus >= 201402L\n+#define PYBIND11_CPP14\n+#if __cplusplus >= 201703L\n+#define PYBIND11_CPP17\n+#endif\n+#endif\n+#elif defined(_MSC_VER) && __cplusplus == 199711L\n+// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard\n+// is fully implemented) Unless you use the /Zc:__cplusplus flag on Visual\n+// Studio 2017 15.7 Preview 3 or newer\n+#if _MSVC_LANG >= 201402L\n+#define PYBIND11_CPP14\n+#if _MSVC_LANG > 201402L && _MSC_VER >= 1910\n+#define PYBIND11_CPP17\n+#endif\n+#endif\n+#endif\n+\n+// Compiler version assertions\n+#if defined(__INTEL_COMPILER)\n+#if __INTEL_COMPILER < 1700\n+#error pybind11 requires Intel C++ compiler v17 or newer\n+#endif\n+#elif defined(__clang__) && !defined(__apple_build_version__)\n+#if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)\n+#error pybind11 requires clang 3.3 or newer\n+#endif\n+#elif defined(__clang__)\n+// Apple changes clang version macros to its Xcode version; the first Xcode\n+// release based on (upstream) clang 3.3 was Xcode 5:\n+#if __clang_major__ < 5\n+#error pybind11 requires Xcode/clang 5.0 or newer\n+#endif\n+#elif defined(__GNUG__)\n+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)\n+#error pybind11 requires gcc 4.8 or newer\n+#endif\n+#elif defined(_MSC_VER)\n+// Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use\n+// of some stl features (e.g. std::negation) added in 2015u3:\n+#if _MSC_FULL_VER < 190024210\n+#error pybind11 requires MSVC 2015 update 3 or newer\n+#endif\n+#endif\n+\n+#if !defined(PYBIND11_EXPORT)\n+#if defined(WIN32) || defined(_WIN32)\n+#define PYBIND11_EXPORT __declspec(dllexport)\n+#else\n+#define PYBIND11_EXPORT __attribute__((visibility(\"default\")))\n+#endif\n+#endif\n+\n+#if defined(_MSC_VER)\n+#define PYBIND11_NOINLINE __declspec(noinline)\n+#else\n+#define PYBIND11_NOINLINE __attribute__((noinline))\n+#endif\n+\n+#if defined(PYBIND11_CPP14)\n+#define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]\n+#else\n+#define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))\n+#endif\n+\n+#define PYBIND11_VERSION_MAJOR 2\n+#define PYBIND11_VERSION_MINOR 3\n+#define PYBIND11_VERSION_PATCH 0\n+\n+/// Include Python header, disable linking to pythonX_d.lib on Windows in debug\n+/// mode\n+#if defined(_MSC_VER)\n+#if (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION < 4)\n+#define HAVE_ROUND 1\n+#endif\n+#pragma warning(push)\n+#pragma warning(disable : 4510 4610 4512 4005)\n+#if defined(_DEBUG)\n+#define PYBIND11_DEBUG_MARKER\n+#undef _DEBUG\n+#endif\n+#endif\n+\n+#include <Python.h>\n+#include <frameobject.h>\n+#include <pythread.h>\n+\n+#if defined(_WIN32) && (defined(min) || defined(max))\n+#error Macro clash with min and max -- define NOMINMAX when compiling your program on Windows\n+#endif\n+\n+#if defined(isalnum)\n+#undef isalnum\n+#undef isalpha\n+#undef islower\n+#undef isspace\n+#undef isupper\n+#undef tolower\n+#undef toupper\n+#endif\n+\n+#if defined(_MSC_VER)\n+#if defined(PYBIND11_DEBUG_MARKER)\n+#define _DEBUG\n+#undef PYBIND11_DEBUG_MARKER\n+#endif\n+#pragma warning(pop)\n+#endif\n+\n+#include <cstddef>\n+#include <cstring>\n+#include <forward_list>\n+#include <memory>\n+#include <stdexcept>\n+#include <string>\n+#include <type_traits>\n+#include <typeindex>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#if PY_MAJOR_VERSION >= 3 /// Compatibility macros for various Python versions\n+#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)\n+#define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check\n+#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION\n+#define PYBIND11_BYTES_CHECK PyBytes_Check\n+#define PYBIND11_BYTES_FROM_STRING PyBytes_FromString\n+#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize\n+#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize\n+#define PYBIND11_BYTES_AS_STRING PyBytes_AsString\n+#define PYBIND11_BYTES_SIZE PyBytes_Size\n+#define PYBIND11_LONG_CHECK(o) PyLong_Check(o)\n+#define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)\n+#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t)o)\n+#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t)o)\n+#define PYBIND11_BYTES_NAME \"bytes\"\n+#define PYBIND11_STRING_NAME \"str\"\n+#define PYBIND11_SLICE_OBJECT PyObject\n+#define PYBIND11_FROM_STRING PyUnicode_FromString\n+#define PYBIND11_STR_TYPE ::pybind11::str\n+#define PYBIND11_BOOL_ATTR \"__bool__\"\n+#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)\n+#define PYBIND11_PLUGIN_IMPL(name)                                             \\\n+  extern \"C\" PYBIND11_EXPORT PyObject *PyInit_##name()\n+\n+#else\n+#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_)                              \\\n+  PyMethod_New(ptr, nullptr, class_)\n+#define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check\n+#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION\n+#define PYBIND11_BYTES_CHECK PyString_Check\n+#define PYBIND11_BYTES_FROM_STRING PyString_FromString\n+#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize\n+#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize\n+#define PYBIND11_BYTES_AS_STRING PyString_AsString\n+#define PYBIND11_BYTES_SIZE PyString_Size\n+#define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))\n+#define PYBIND11_LONG_AS_LONGLONG(o)                                           \\\n+  (PyInt_Check(o) ? (long long)PyLong_AsLong(o) : PyLong_AsLongLong(o))\n+#define PYBIND11_LONG_FROM_SIGNED(o)                                           \\\n+  PyInt_FromSsize_t((ssize_t)o) // Returns long if needed.\n+#define PYBIND11_LONG_FROM_UNSIGNED(o)                                         \\\n+  PyInt_FromSize_t((size_t)o) // Returns long if needed.\n+#define PYBIND11_BYTES_NAME \"str\"\n+#define PYBIND11_STRING_NAME \"unicode\"\n+#define PYBIND11_SLICE_OBJECT PySliceObject\n+#define PYBIND11_FROM_STRING PyString_FromString\n+#define PYBIND11_STR_TYPE ::pybind11::bytes\n+#define PYBIND11_BOOL_ATTR \"__nonzero__\"\n+#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_nonzero)\n+#define PYBIND11_PLUGIN_IMPL(name)                                             \\\n+  static PyObject *pybind11_init_wrapper();                                    \\\n+  extern \"C\" PYBIND11_EXPORT void init##name() {                               \\\n+    (void)pybind11_init_wrapper();                                             \\\n+  }                                                                            \\\n+  PyObject *pybind11_init_wrapper()\n+#endif\n+\n+#if PY_VERSION_HEX >= 0x03050000 && PY_VERSION_HEX < 0x03050200\n+extern \"C\" {\n+struct _Py_atomic_address {\n+  void *value;\n+};\n+PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;\n+}\n+#endif\n+\n+#define PYBIND11_TRY_NEXT_OVERLOAD                                             \\\n+  ((PyObject *)1) // special failure return code\n+#define PYBIND11_STRINGIFY(x) #x\n+#define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)\n+#define PYBIND11_CONCAT(first, second) first##second\n+\n+#define PYBIND11_CHECK_PYTHON_VERSION                                          \\\n+  {                                                                            \\\n+    const char *compiled_ver = PYBIND11_TOSTRING(                              \\\n+        PY_MAJOR_VERSION) \".\" PYBIND11_TOSTRING(PY_MINOR_VERSION);             \\\n+    const char *runtime_ver = Py_GetVersion();                                 \\\n+    size_t len = std::strlen(compiled_ver);                                    \\\n+    if (std::strncmp(runtime_ver, compiled_ver, len) != 0 ||                   \\\n+        (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {                \\\n+      PyErr_Format(                                                            \\\n+          PyExc_ImportError,                                                   \\\n+          \"Python version mismatch: module was compiled for Python %s, \"       \\\n+          \"but the interpreter version is incompatible: %s.\",                  \\\n+          compiled_ver, runtime_ver);                                          \\\n+      return nullptr;                                                          \\\n+    }                                                                          \\\n+  }\n+\n+#define PYBIND11_CATCH_INIT_EXCEPTIONS                                         \\\n+  catch (pybind11::error_already_set & e) {                                    \\\n+    PyErr_SetString(PyExc_ImportError, e.what());                              \\\n+    return nullptr;                                                            \\\n+  }                                                                            \\\n+  catch (const std::exception &e) {                                            \\\n+    PyErr_SetString(PyExc_ImportError, e.what());                              \\\n+    return nullptr;                                                            \\\n+  }\n+\n+/** \\rst\n+    ***Deprecated in favor of PYBIND11_MODULE***\n+\n+    This macro creates the entry point that will be invoked when the Python\n+interpreter imports a plugin library. Please create a `module` in the function\n+body and return the pointer to its underlying Python object at the end.\n+\n+    .. code-block:: cpp\n+\n+        PYBIND11_PLUGIN(example) {\n+            pybind11::module m(\"example\", \"pybind11 example plugin\");\n+            /// Set up bindings here\n+            return m.ptr();\n+        }\n+\\endrst */\n+#define PYBIND11_PLUGIN(name)                                                  \\\n+  PYBIND11_DEPRECATED(\"PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE\")    \\\n+  static PyObject *pybind11_init();                                            \\\n+  PYBIND11_PLUGIN_IMPL(name) {                                                 \\\n+    PYBIND11_CHECK_PYTHON_VERSION                                              \\\n+    try {                                                                      \\\n+      return pybind11_init();                                                  \\\n+    }                                                                          \\\n+    PYBIND11_CATCH_INIT_EXCEPTIONS                                             \\\n+  }                                                                            \\\n+  PyObject *pybind11_init()\n+\n+/** \\rst\n+    This macro creates the entry point that will be invoked when the Python\n+interpreter imports an extension module. The module name is given as the fist\n+argument and it should not be in quotes. The second macro argument defines a\n+variable of type `py::module` which can be used to initialize the module.\n+\n+    .. code-block:: cpp\n+\n+        PYBIND11_MODULE(example, m) {\n+            m.doc() = \"pybind11 example module\";\n+\n+            // Add bindings here\n+            m.def(\"foo\", []() {\n+                return \"Hello, World!\";\n+            });\n+        }\n+\\endrst */\n+#define PYBIND11_MODULE(name, variable)                                        \\\n+  static void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &);       \\\n+  PYBIND11_PLUGIN_IMPL(name) {                                                 \\\n+    PYBIND11_CHECK_PYTHON_VERSION                                              \\\n+    auto m = pybind11::module(PYBIND11_TOSTRING(name));                        \\\n+    try {                                                                      \\\n+      PYBIND11_CONCAT(pybind11_init_, name)(m);                                \\\n+      return m.ptr();                                                          \\\n+    }                                                                          \\\n+    PYBIND11_CATCH_INIT_EXCEPTIONS                                             \\\n+  }                                                                            \\\n+  void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module & variable)\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+using ssize_t = Py_ssize_t;\n+using size_t = std::size_t;\n+\n+/// Approach used to cast a previously unknown C++ instance into a Python object\n+enum class return_value_policy : uint8_t {\n+  /** This is the default return value policy, which falls back to the policy\n+      return_value_policy::take_ownership when the return value is a pointer.\n+      Otherwise, it uses return_value::move or return_value::copy for rvalue\n+      and lvalue references, respectively. See below for a description of what\n+      all of these different policies do. */\n+  automatic = 0,\n+\n+  /** As above, but use policy return_value_policy::reference when the return\n+      value is a pointer. This is the default conversion policy for function\n+      arguments when calling Python functions manually from C++ code (i.e. via\n+      handle::operator()). You probably won't need to use this. */\n+  automatic_reference,\n+\n+  /** Reference an existing object (i.e. do not create a new copy) and take\n+      ownership. Python will call the destructor and delete operator when the\n+      object\u2019s reference count reaches zero. Undefined behavior ensues when\n+      the C++ side does the same.. */\n+  take_ownership,\n+\n+  /** Create a new copy of the returned object, which will be owned by\n+      Python. This policy is comparably safe because the lifetimes of the two\n+      instances are decoupled. */\n+  copy,\n+\n+  /** Use std::move to move the return value contents into a new instance\n+      that will be owned by Python. This policy is comparably safe because the\n+      lifetimes of the two instances (move source and destination) are\n+      decoupled. */\n+  move,\n+\n+  /** Reference an existing object, but do not take ownership. The C++ side\n+      is responsible for managing the object\u2019s lifetime and deallocating it\n+      when it is no longer used. Warning: undefined behavior will ensue when\n+      the C++ side deletes an object that is still referenced and used by\n+      Python. */\n+  reference,\n+\n+  /** This policy only applies to methods and properties. It references the\n+      object without taking ownership similar to the above\n+      return_value_policy::reference policy. In contrast to that policy, the\n+      function or property\u2019s implicit this argument (called the parent) is\n+      considered to be the the owner of the return value (the child).\n+      pybind11 then couples the lifetime of the parent to the child via a\n+      reference relationship that ensures that the parent cannot be garbage\n+      collected while Python is still using the child. More advanced\n+      variations of this scheme are also possible using combinations of\n+      return_value_policy::reference and the keep_alive call policy */\n+  reference_internal\n+};\n+\n+NAMESPACE_BEGIN(detail)\n+\n+inline static constexpr int log2(size_t n, int k = 0) {\n+  return (n <= 1) ? k : log2(n >> 1, k + 1);\n+}\n+\n+// Returns the size as a multiple of sizeof(void *), rounded up.\n+inline static constexpr size_t size_in_ptrs(size_t s) {\n+  return 1 + ((s - 1) >> log2(sizeof(void *)));\n+}\n+\n+/**\n+ * The space to allocate for simple layout instance holders (see below) in\n+ * multiple of the size of a pointer (e.g.  2 means 16 bytes on 64-bit\n+ * architectures).  The default is the minimum required to holder either a\n+ * std::unique_ptr or std::shared_ptr (which is almost always\n+ * sizeof(std::shared_ptr<T>)).\n+ */\n+constexpr size_t instance_simple_holder_in_ptrs() {\n+  static_assert(sizeof(std::shared_ptr<int>) >= sizeof(std::unique_ptr<int>),\n+                \"pybind assumes std::shared_ptrs are at least as big as \"\n+                \"std::unique_ptrs\");\n+  return size_in_ptrs(sizeof(std::shared_ptr<int>));\n+}\n+\n+// Forward declarations\n+struct type_info;\n+struct value_and_holder;\n+\n+struct nonsimple_values_and_holders {\n+  void **values_and_holders;\n+  uint8_t *status;\n+};\n+\n+/// The 'instance' type which needs to be standard layout (need to be able to\n+/// use 'offsetof')\n+struct instance {\n+  PyObject_HEAD\n+      /// Storage for pointers and holder; see simple_layout, below, for a\n+      /// description\n+      union {\n+    void *simple_value_holder[1 + instance_simple_holder_in_ptrs()];\n+    nonsimple_values_and_holders nonsimple;\n+  };\n+  /// Weak references\n+  PyObject *weakrefs;\n+  /// If true, the pointer is owned which means we're free to manage it with a\n+  /// holder.\n+  bool owned : 1;\n+  /**\n+   * An instance has two possible value/holder layouts.\n+   *\n+   * Simple layout (when this flag is true), means the `simple_value_holder` is\n+   * set with a pointer and the holder object governing that pointer, i.e.\n+   * [val1*][holder].  This layout is applied whenever there is no python-side\n+   * multiple inheritance of bound C++ types *and* the type's holder will fit in\n+   * the default space (which is large enough to hold either a std::unique_ptr\n+   * or std::shared_ptr).\n+   *\n+   * Non-simple layout applies when using custom holders that require more space\n+   * than `shared_ptr` (which is typically the size of two pointers), or when\n+   * multiple inheritance is used on the python side.  Non-simple layout\n+   * allocates the required amount of memory to have multiple bound C++ classes\n+   * as parents.  Under this layout, `nonsimple.values_and_holders` is set to a\n+   * pointer to allocated space of the required space to hold a sequence of\n+   * value pointers and holders followed `status`, a set of bit flags (1 byte\n+   * each), i.e. [val1*][holder1][val2*][holder2]...[bb...]  where each [block]\n+   * is rounded up to a multiple of `sizeof(void *)`.  `nonsimple.status` is,\n+   * for convenience, a pointer to the beginning of the [bb...] block (but not\n+   * independently allocated).\n+   *\n+   * Status bits indicate whether the associated holder is constructed (&\n+   * status_holder_constructed) and whether the value pointer is registered (&\n+   * status_instance_registered) in `registered_instances`.\n+   */\n+  bool simple_layout : 1;\n+  /// For simple layout, tracks whether the holder has been constructed\n+  bool simple_holder_constructed : 1;\n+  /// For simple layout, tracks whether the instance is registered in\n+  /// `registered_instances`\n+  bool simple_instance_registered : 1;\n+  /// If true, get_internals().patients has an entry for this object\n+  bool has_patients : 1;\n+\n+  /// Initializes all of the above type/values/holders data (but not the\n+  /// instance values themselves)\n+  void allocate_layout();\n+\n+  /// Destroys/deallocates all of the above\n+  void deallocate_layout();\n+\n+  /// Returns the value_and_holder wrapper for the given type (or the first, if\n+  /// `find_type` omitted).  Returns a default-constructed (with `.inst =\n+  /// nullptr`) object on failure if `throw_if_missing` is false.\n+  value_and_holder get_value_and_holder(const type_info *find_type = nullptr,\n+                                        bool throw_if_missing = true);\n+\n+  /// Bit values for the non-simple status flags\n+  static constexpr uint8_t status_holder_constructed = 1;\n+  static constexpr uint8_t status_instance_registered = 2;\n+};\n+\n+static_assert(\n+    std::is_standard_layout<instance>::value,\n+    \"Internal error: `pybind11::detail::instance` is not standard layout!\");\n+\n+/// from __cpp_future__ import (convenient aliases from C++14/17)\n+#if defined(PYBIND11_CPP14) && (!defined(_MSC_VER) || _MSC_VER >= 1910)\n+using std::conditional_t;\n+using std::enable_if_t;\n+using std::remove_cv_t;\n+using std::remove_reference_t;\n+#else\n+template <bool B, typename T = void>\n+using enable_if_t = typename std::enable_if<B, T>::type;\n+template <bool B, typename T, typename F>\n+using conditional_t = typename std::conditional<B, T, F>::type;\n+template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;\n+template <typename T>\n+using remove_reference_t = typename std::remove_reference<T>::type;\n+#endif\n+\n+/// Index sequences\n+#if defined(PYBIND11_CPP14)\n+using std::index_sequence;\n+using std::make_index_sequence;\n+#else\n+template <size_t...> struct index_sequence {};\n+template <size_t N, size_t... S>\n+struct make_index_sequence_impl : make_index_sequence_impl<N - 1, N - 1, S...> {\n+};\n+template <size_t... S> struct make_index_sequence_impl<0, S...> {\n+  typedef index_sequence<S...> type;\n+};\n+template <size_t N>\n+using make_index_sequence = typename make_index_sequence_impl<N>::type;\n+#endif\n+\n+/// Make an index sequence of the indices of true arguments\n+template <typename ISeq, size_t, bool...> struct select_indices_impl {\n+  using type = ISeq;\n+};\n+template <size_t... IPrev, size_t I, bool B, bool... Bs>\n+struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>\n+    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>,\n+                                        index_sequence<IPrev...>>,\n+                          I + 1, Bs...> {};\n+template <bool... Bs>\n+using select_indices =\n+    typename select_indices_impl<index_sequence<>, 0, Bs...>::type;\n+\n+/// Backports of std::bool_constant and std::negation to accommodate older\n+/// compilers\n+template <bool B> using bool_constant = std::integral_constant<bool, B>;\n+template <typename T> struct negation : bool_constant<!T::value> {};\n+\n+template <typename...> struct void_t_impl { using type = void; };\n+template <typename... Ts> using void_t = typename void_t_impl<Ts...>::type;\n+\n+/// Compile-time all/any/none of that check the boolean value of all template\n+/// types\n+#if defined(__cpp_fold_expressions) && !(defined(_MSC_VER) && (_MSC_VER < 1916))\n+template <class... Ts> using all_of = bool_constant<(Ts::value && ...)>;\n+template <class... Ts> using any_of = bool_constant<(Ts::value || ...)>;\n+#elif !defined(_MSC_VER)\n+template <bool...> struct bools {};\n+template <class... Ts>\n+using all_of =\n+    std::is_same<bools<Ts::value..., true>, bools<true, Ts::value...>>;\n+template <class... Ts> using any_of = negation<all_of<negation<Ts>...>>;\n+#else\n+// MSVC has trouble with the above, but supports std::conjunction, which we can\n+// use instead (albeit at a slight loss of compilation efficiency).\n+template <class... Ts> using all_of = std::conjunction<Ts...>;\n+template <class... Ts> using any_of = std::disjunction<Ts...>;\n+#endif\n+template <class... Ts> using none_of = negation<any_of<Ts...>>;\n+\n+template <class T, template <class> class... Predicates>\n+using satisfies_all_of = all_of<Predicates<T>...>;\n+template <class T, template <class> class... Predicates>\n+using satisfies_any_of = any_of<Predicates<T>...>;\n+template <class T, template <class> class... Predicates>\n+using satisfies_none_of = none_of<Predicates<T>...>;\n+\n+/// Strip the class from a method type\n+template <typename T> struct remove_class {};\n+template <typename C, typename R, typename... A>\n+struct remove_class<R (C::*)(A...)> {\n+  typedef R type(A...);\n+};\n+template <typename C, typename R, typename... A>\n+struct remove_class<R (C::*)(A...) const> {\n+  typedef R type(A...);\n+};\n+\n+/// Helper template to strip away type modifiers\n+template <typename T> struct intrinsic_type { typedef T type; };\n+template <typename T> struct intrinsic_type<const T> {\n+  typedef typename intrinsic_type<T>::type type;\n+};\n+template <typename T> struct intrinsic_type<T *> {\n+  typedef typename intrinsic_type<T>::type type;\n+};\n+template <typename T> struct intrinsic_type<T &> {\n+  typedef typename intrinsic_type<T>::type type;\n+};\n+template <typename T> struct intrinsic_type<T &&> {\n+  typedef typename intrinsic_type<T>::type type;\n+};\n+template <typename T, size_t N> struct intrinsic_type<const T[N]> {\n+  typedef typename intrinsic_type<T>::type type;\n+};\n+template <typename T, size_t N> struct intrinsic_type<T[N]> {\n+  typedef typename intrinsic_type<T>::type type;\n+};\n+template <typename T> using intrinsic_t = typename intrinsic_type<T>::type;\n+\n+/// Helper type to replace 'void' in some expressions\n+struct void_type {};\n+\n+/// Helper template which holds a list of types\n+template <typename...> struct type_list {};\n+\n+/// Compile-time integer sum\n+#ifdef __cpp_fold_expressions\n+template <typename... Ts> constexpr size_t constexpr_sum(Ts... ns) {\n+  return (0 + ... + size_t{ns});\n+}\n+#else\n+constexpr size_t constexpr_sum() { return 0; }\n+template <typename T, typename... Ts>\n+constexpr size_t constexpr_sum(T n, Ts... ns) {\n+  return size_t{n} + constexpr_sum(ns...);\n+}\n+#endif\n+\n+NAMESPACE_BEGIN(constexpr_impl)\n+/// Implementation details for constexpr functions\n+constexpr int first(int i) { return i; }\n+template <typename T, typename... Ts>\n+constexpr int first(int i, T v, Ts... vs) {\n+  return v ? i : first(i + 1, vs...);\n+}\n+\n+constexpr int last(int /*i*/, int result) { return result; }\n+template <typename T, typename... Ts>\n+constexpr int last(int i, int result, T v, Ts... vs) {\n+  return last(i + 1, v ? i : result, vs...);\n+}\n+NAMESPACE_END(constexpr_impl)\n+\n+/// Return the index of the first type in Ts which satisfies Predicate<T>.\n+/// Returns sizeof...(Ts) if none match.\n+template <template <typename> class Predicate, typename... Ts>\n+constexpr int constexpr_first() {\n+  return constexpr_impl::first(0, Predicate<Ts>::value...);\n+}\n+\n+/// Return the index of the last type in Ts which satisfies Predicate<T>, or -1\n+/// if none match.\n+template <template <typename> class Predicate, typename... Ts>\n+constexpr int constexpr_last() {\n+  return constexpr_impl::last(0, -1, Predicate<Ts>::value...);\n+}\n+\n+/// Return the Nth element from the parameter pack\n+template <size_t N, typename T, typename... Ts> struct pack_element {\n+  using type = typename pack_element<N - 1, Ts...>::type;\n+};\n+template <typename T, typename... Ts> struct pack_element<0, T, Ts...> {\n+  using type = T;\n+};\n+\n+/// Return the one and only type which matches the predicate, or Default if none\n+/// match. If more than one type matches the predicate, fail at compile-time.\n+template <template <typename> class Predicate, typename Default, typename... Ts>\n+struct exactly_one {\n+  static constexpr auto found = constexpr_sum(Predicate<Ts>::value...);\n+  static_assert(found <= 1, \"Found more than one type matching the predicate\");\n+\n+  static constexpr auto index = found ? constexpr_first<Predicate, Ts...>() : 0;\n+  using type =\n+      conditional_t<found, typename pack_element<index, Ts...>::type, Default>;\n+};\n+template <template <typename> class P, typename Default>\n+struct exactly_one<P, Default> {\n+  using type = Default;\n+};\n+\n+template <template <typename> class Predicate, typename Default, typename... Ts>\n+using exactly_one_t = typename exactly_one<Predicate, Default, Ts...>::type;\n+\n+/// Defer the evaluation of type T until types Us are instantiated\n+template <typename T, typename... /*Us*/> struct deferred_type {\n+  using type = T;\n+};\n+template <typename T, typename... Us>\n+using deferred_t = typename deferred_type<T, Us...>::type;\n+\n+/// Like is_base_of, but requires a strict base (i.e. `is_strict_base_of<T,\n+/// T>::value == false`, unlike `std::is_base_of`)\n+template <typename Base, typename Derived>\n+using is_strict_base_of = bool_constant<std::is_base_of<Base, Derived>::value &&\n+                                        !std::is_same<Base, Derived>::value>;\n+\n+/// Like is_base_of, but also requires that the base type is accessible (i.e.\n+/// that a Derived pointer can be converted to a Base pointer)\n+template <typename Base, typename Derived>\n+using is_accessible_base_of =\n+    bool_constant<std::is_base_of<Base, Derived>::value &&\n+                  std::is_convertible<Derived *, Base *>::value>;\n+\n+template <template <typename...> class Base> struct is_template_base_of_impl {\n+  template <typename... Us> static std::true_type check(Base<Us...> *);\n+  static std::false_type check(...);\n+};\n+\n+/// Check if a template is the base of a type. For example:\n+/// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U\n+/// can be anything\n+template <template <typename...> class Base, typename T>\n+#if !defined(_MSC_VER)\n+using is_template_base_of =\n+    decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *)nullptr));\n+#else // MSVC2015 has trouble with decltype in template aliases\n+struct is_template_base_of : decltype(is_template_base_of_impl<Base>::check(\n+                                 (intrinsic_t<T> *)nullptr)) {\n+};\n+#endif\n+\n+/// Check if T is an instantiation of the template `Class`. For example:\n+/// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U\n+/// can be anything.\n+template <template <typename...> class Class, typename T>\n+struct is_instantiation : std::false_type {};\n+template <template <typename...> class Class, typename... Us>\n+struct is_instantiation<Class, Class<Us...>> : std::true_type {};\n+\n+/// Check if T is std::shared_ptr<U> where U can be anything\n+template <typename T>\n+using is_shared_ptr = is_instantiation<std::shared_ptr, T>;\n+\n+/// Check if T looks like an input iterator\n+template <typename T, typename = void>\n+struct is_input_iterator : std::false_type {};\n+template <typename T>\n+struct is_input_iterator<\n+    T, void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>\n+    : std::true_type {};\n+\n+template <typename T>\n+using is_function_pointer = bool_constant<\n+    std::is_pointer<T>::value &&\n+    std::is_function<typename std::remove_pointer<T>::type>::value>;\n+\n+template <typename F> struct strip_function_object {\n+  using type = typename remove_class<decltype(&F::operator())>::type;\n+};\n+\n+// Extracts the function signature from a function, function pointer or lambda.\n+template <typename Function, typename F = remove_reference_t<Function>>\n+using function_signature_t = conditional_t<\n+    std::is_function<F>::value, F,\n+    typename conditional_t<\n+        std::is_pointer<F>::value || std::is_member_pointer<F>::value,\n+        std::remove_pointer<F>, strip_function_object<F>>::type>;\n+\n+/// Returns true if the type looks like a lambda: that is, isn't a function,\n+/// pointer or member pointer.  Note that this can catch all sorts of other\n+/// things, too; this is intended to be used in a place where passing a lambda\n+/// makes sense.\n+template <typename T>\n+using is_lambda = satisfies_none_of<remove_reference_t<T>, std::is_function,\n+                                    std::is_pointer, std::is_member_pointer>;\n+\n+/// Ignore that a variable is unused in compiler warnings\n+inline void ignore_unused(const int *) {}\n+\n+/// Apply a function over each element of a parameter pack\n+#ifdef __cpp_fold_expressions\n+#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)\n+#else\n+using expand_side_effects = bool[];\n+#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN)                                  \\\n+  pybind11::detail::expand_side_effects { ((PATTERN), void(), false)..., false }\n+#endif\n+\n+NAMESPACE_END(detail)\n+\n+/// C++ bindings of builtin Python exceptions\n+class builtin_exception : public std::runtime_error {\n+public:\n+  using std::runtime_error::runtime_error;\n+  /// Set the error using the Python C API\n+  virtual void set_error() const = 0;\n+};\n+\n+#define PYBIND11_RUNTIME_EXCEPTION(name, type)                                 \\\n+  class name : public builtin_exception {                                      \\\n+  public:                                                                      \\\n+    using builtin_exception::builtin_exception;                                \\\n+    name() : name(\"\") {}                                                       \\\n+    void set_error() const override { PyErr_SetString(type, what()); }         \\\n+  };\n+\n+PYBIND11_RUNTIME_EXCEPTION(stop_iteration, PyExc_StopIteration)\n+PYBIND11_RUNTIME_EXCEPTION(index_error, PyExc_IndexError)\n+PYBIND11_RUNTIME_EXCEPTION(key_error, PyExc_KeyError)\n+PYBIND11_RUNTIME_EXCEPTION(value_error, PyExc_ValueError)\n+PYBIND11_RUNTIME_EXCEPTION(type_error, PyExc_TypeError)\n+PYBIND11_RUNTIME_EXCEPTION(\n+    cast_error,\n+    PyExc_RuntimeError) /// Thrown when pybind11::cast or handle::call fail due\n+                        /// to a type casting error\n+PYBIND11_RUNTIME_EXCEPTION(reference_cast_error,\n+                           PyExc_RuntimeError) /// Used internally\n+\n+[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) {\n+  throw std::runtime_error(reason);\n+}\n+[[noreturn]] PYBIND11_NOINLINE inline void\n+pybind11_fail(const std::string &reason) {\n+  throw std::runtime_error(reason);\n+}\n+\n+template <typename T, typename SFINAE = void> struct format_descriptor {};\n+\n+NAMESPACE_BEGIN(detail)\n+// Returns the index of the given type in the type char array below, and in the\n+// list in numpy.h The order here is: bool; 8 ints\n+// ((signed,unsigned)x(8,16,32,64)bits); float,double,long double; complex\n+// float,double,long double.  Note that the long double types only participate\n+// when long double is actually longer than double (it isn't under MSVC). NB:\n+// not only the string below but also complex.h and numpy.h rely on this order.\n+template <typename T, typename SFINAE = void> struct is_fmt_numeric {\n+  static constexpr bool value = false;\n+};\n+template <typename T>\n+struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {\n+  static constexpr bool value = true;\n+  static constexpr int index =\n+      std::is_same<T, bool>::value\n+          ? 0\n+          : 1 + (std::is_integral<T>::value\n+                     ? detail::log2(sizeof(T)) * 2 + std::is_unsigned<T>::value\n+                     : 8 + (std::is_same<T, double>::value        ? 1\n+                            : std::is_same<T, long double>::value ? 2\n+                                                                  : 0));\n+};\n+NAMESPACE_END(detail)\n+\n+template <typename T>\n+struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {\n+  static constexpr const char c =\n+      \"?bBhHiIqQfdg\"[detail::is_fmt_numeric<T>::index];\n+  static constexpr const char value[2] = {c, '\\0'};\n+  static std::string format() { return std::string(1, c); }\n+};\n+\n+#if !defined(PYBIND11_CPP17)\n+\n+template <typename T>\n+constexpr const char format_descriptor<\n+    T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];\n+\n+#endif\n+\n+/// RAII wrapper that temporarily clears any Python error state\n+struct error_scope {\n+  PyObject *type, *value, *trace;\n+  error_scope() { PyErr_Fetch(&type, &value, &trace); }\n+  ~error_scope() { PyErr_Restore(type, value, trace); }\n+};\n+\n+/// Dummy destructor wrapper that can be used to expose classes with a private\n+/// destructor\n+struct nodelete {\n+  template <typename T> void operator()(T *) {}\n+};\n+\n+// overload_cast requires variable templates: C++14\n+#if defined(PYBIND11_CPP14)\n+#define PYBIND11_OVERLOAD_CAST 1\n+\n+NAMESPACE_BEGIN(detail)\n+template <typename... Args> struct overload_cast_impl {\n+  constexpr overload_cast_impl() {} // MSVC 2015 needs this\n+\n+  template <typename Return>\n+  constexpr auto operator()(Return (*pf)(Args...)) const noexcept\n+      -> decltype(pf) {\n+    return pf;\n+  }\n+\n+  template <typename Return, typename Class>\n+  constexpr auto operator()(Return (Class::*pmf)(Args...),\n+                            std::false_type = {}) const noexcept\n+      -> decltype(pmf) {\n+    return pmf;\n+  }\n+\n+  template <typename Return, typename Class>\n+  constexpr auto operator()(Return (Class::*pmf)(Args...) const,\n+                            std::true_type) const noexcept -> decltype(pmf) {\n+    return pmf;\n+  }\n+};\n+NAMESPACE_END(detail)\n+\n+/// Syntax sugar for resolving overloaded function pointers:\n+///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)\n+///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)\n+template <typename... Args>\n+static constexpr detail::overload_cast_impl<Args...> overload_cast = {};\n+// MSVC 2015 only accepts this particular initialization syntax for this\n+// variable template.\n+\n+/// Const member function selector for overload_cast\n+///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)\n+///  - sweet:   overload_cast<Arg>(&Class::func, const_)\n+static constexpr auto const_ = std::true_type{};\n+\n+#else  // no overload_cast: providing something that static_assert-fails:\n+template <typename... Args> struct overload_cast {\n+  static_assert(\n+      detail::deferred_t<std::false_type, Args...>::value,\n+      \"pybind11::overload_cast<...> requires compiling in C++14 mode\");\n+};\n+#endif // overload_cast\n+\n+NAMESPACE_BEGIN(detail)\n+\n+// Adaptor for converting arbitrary container arguments into a vector;\n+// implicitly convertible from any standard container (or C-style array)\n+// supporting std::begin/std::end, any singleton arithmetic type (if T is\n+// arithmetic), or explicitly constructible from an iterator pair.\n+template <typename T> class any_container {\n+  std::vector<T> v;\n+\n+public:\n+  any_container() = default;\n+\n+  // Can construct from a pair of iterators\n+  template <typename It, typename = enable_if_t<is_input_iterator<It>::value>>\n+  any_container(It first, It last) : v(first, last) {}\n+\n+  // Implicit conversion constructor from any arbitrary container type with\n+  // values convertible to T\n+  template <\n+      typename Container,\n+      typename = enable_if_t<std::is_convertible<\n+          decltype(*std::begin(std::declval<const Container &>())), T>::value>>\n+  any_container(const Container &c)\n+      : any_container(std::begin(c), std::end(c)) {}\n+\n+  // initializer_list's aren't deducible, so don't get matched by the above\n+  // template; we need this to explicitly allow implicit conversion from one:\n+  template <typename TIn,\n+            typename = enable_if_t<std::is_convertible<TIn, T>::value>>\n+  any_container(const std::initializer_list<TIn> &c)\n+      : any_container(c.begin(), c.end()) {}\n+\n+  // Avoid copying if given an rvalue vector of the correct type.\n+  any_container(std::vector<T> &&v) : v(std::move(v)) {}\n+\n+  // Moves the vector out of an rvalue any_container\n+  operator std::vector<T> &&() && { return std::move(v); }\n+\n+  // Dereferencing obtains a reference to the underlying vector\n+  std::vector<T> &operator*() { return v; }\n+  const std::vector<T> &operator*() const { return v; }\n+\n+  // -> lets you call methods on the underlying vector\n+  std::vector<T> *operator->() { return &v; }\n+  const std::vector<T> *operator->() const { return &v; }\n+};\n+\n+NAMESPACE_END(detail)\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/descr.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "file_content_changes": "@@ -0,0 +1,118 @@\n+/*\n+    pybind11/detail/descr.h: Helper type for concatenating type signatures at\n+   compile time\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"common.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+#if !defined(_MSC_VER)\n+#define PYBIND11_DESCR_CONSTEXPR static constexpr\n+#else\n+#define PYBIND11_DESCR_CONSTEXPR const\n+#endif\n+\n+/* Concatenate type signatures at compile time */\n+template <size_t N, typename... Ts> struct descr {\n+  char text[N + 1];\n+\n+  constexpr descr() : text{'\\0'} {}\n+  constexpr descr(char const (&s)[N + 1])\n+      : descr(s, make_index_sequence<N>()) {}\n+\n+  template <size_t... Is>\n+  constexpr descr(char const (&s)[N + 1], index_sequence<Is...>)\n+      : text{s[Is]..., '\\0'} {}\n+\n+  template <typename... Chars>\n+  constexpr descr(char c, Chars... cs)\n+      : text{c, static_cast<char>(cs)..., '\\0'} {}\n+\n+  static constexpr std::array<const std::type_info *, sizeof...(Ts) + 1>\n+  types() {\n+    return {{&typeid(Ts)..., nullptr}};\n+  }\n+};\n+\n+template <size_t N1, size_t N2, typename... Ts1, typename... Ts2, size_t... Is1,\n+          size_t... Is2>\n+constexpr descr<N1 + N2, Ts1..., Ts2...>\n+plus_impl(const descr<N1, Ts1...> &a, const descr<N2, Ts2...> &b,\n+          index_sequence<Is1...>, index_sequence<Is2...>) {\n+  return {a.text[Is1]..., b.text[Is2]...};\n+}\n+\n+template <size_t N1, size_t N2, typename... Ts1, typename... Ts2>\n+constexpr descr<N1 + N2, Ts1..., Ts2...> operator+(const descr<N1, Ts1...> &a,\n+                                                   const descr<N2, Ts2...> &b) {\n+  return plus_impl(a, b, make_index_sequence<N1>(), make_index_sequence<N2>());\n+}\n+\n+template <size_t N> constexpr descr<N - 1> _(char const (&text)[N]) {\n+  return descr<N - 1>(text);\n+}\n+constexpr descr<0> _(char const (&)[1]) { return {}; }\n+\n+template <size_t Rem, size_t... Digits>\n+struct int_to_str : int_to_str<Rem / 10, Rem % 10, Digits...> {};\n+template <size_t... Digits> struct int_to_str<0, Digits...> {\n+  static constexpr auto digits = descr<sizeof...(Digits)>(('0' + Digits)...);\n+};\n+\n+// Ternary description (like std::conditional)\n+template <bool B, size_t N1, size_t N2>\n+constexpr enable_if_t<B, descr<N1 - 1>> _(char const (&text1)[N1],\n+                                          char const (&)[N2]) {\n+  return _(text1);\n+}\n+template <bool B, size_t N1, size_t N2>\n+constexpr enable_if_t<!B, descr<N2 - 1>> _(char const (&)[N1],\n+                                           char const (&text2)[N2]) {\n+  return _(text2);\n+}\n+\n+template <bool B, typename T1, typename T2>\n+constexpr enable_if_t<B, T1> _(const T1 &d, const T2 &) {\n+  return d;\n+}\n+template <bool B, typename T1, typename T2>\n+constexpr enable_if_t<!B, T2> _(const T1 &, const T2 &d) {\n+  return d;\n+}\n+\n+template <size_t Size>\n+auto constexpr _() -> decltype(int_to_str<Size / 10, Size % 10>::digits) {\n+  return int_to_str<Size / 10, Size % 10>::digits;\n+}\n+\n+template <typename Type> constexpr descr<1, Type> _() { return {'%'}; }\n+\n+constexpr descr<0> concat() { return {}; }\n+\n+template <size_t N, typename... Ts>\n+constexpr descr<N, Ts...> concat(const descr<N, Ts...> &descr) {\n+  return descr;\n+}\n+\n+template <size_t N, typename... Ts, typename... Args>\n+constexpr auto concat(const descr<N, Ts...> &d, const Args &...args)\n+    -> decltype(std::declval<descr<N + 2, Ts...>>() + concat(args...)) {\n+  return d + _(\", \") + concat(args...);\n+}\n+\n+template <size_t N, typename... Ts>\n+constexpr descr<N + 2, Ts...> type_descr(const descr<N, Ts...> &descr) {\n+  return _(\"{\") + descr + _(\"}\");\n+}\n+\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/init.h", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "file_content_changes": "@@ -0,0 +1,415 @@\n+/*\n+    pybind11/detail/init.h: init factory function implementation and support\n+   code.\n+\n+    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"class.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+template <> class type_caster<value_and_holder> {\n+public:\n+  bool load(handle h, bool) {\n+    value = reinterpret_cast<value_and_holder *>(h.ptr());\n+    return true;\n+  }\n+\n+  template <typename> using cast_op_type = value_and_holder &;\n+  operator value_and_holder &() { return *value; }\n+  static constexpr auto name = _<value_and_holder>();\n+\n+private:\n+  value_and_holder *value = nullptr;\n+};\n+\n+NAMESPACE_BEGIN(initimpl)\n+\n+inline void no_nullptr(void *ptr) {\n+  if (!ptr)\n+    throw type_error(\"pybind11::init(): factory function returned nullptr\");\n+}\n+\n+// Implementing functions for all forms of py::init<...> and py::init(...)\n+template <typename Class> using Cpp = typename Class::type;\n+template <typename Class> using Alias = typename Class::type_alias;\n+template <typename Class> using Holder = typename Class::holder_type;\n+\n+template <typename Class>\n+using is_alias_constructible =\n+    std::is_constructible<Alias<Class>, Cpp<Class> &&>;\n+\n+// Takes a Cpp pointer and returns true if it actually is a polymorphic Alias\n+// instance.\n+template <typename Class, enable_if_t<Class::has_alias, int> = 0>\n+bool is_alias(Cpp<Class> *ptr) {\n+  return dynamic_cast<Alias<Class> *>(ptr) != nullptr;\n+}\n+// Failing fallback version of the above for a no-alias class (always returns\n+// false)\n+template <typename /*Class*/> constexpr bool is_alias(void *) { return false; }\n+\n+// Constructs and returns a new object; if the given arguments don't map to a\n+// constructor, we fall back to brace aggregate initiailization so that for\n+// aggregate initialization can be used with py::init, e.g.  `py::init<int,\n+// int>` to initialize a `struct T { int a; int b; }`.  For non-aggregate types,\n+// we need to use an ordinary T(...) constructor (invoking as `T{...}` usually\n+// works, but will not do the expected thing when `T` has an\n+// `initializer_list<T>` constructor).\n+template <\n+    typename Class, typename... Args,\n+    detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>\n+inline Class *construct_or_initialize(Args &&...args) {\n+  return new Class(std::forward<Args>(args)...);\n+}\n+template <\n+    typename Class, typename... Args,\n+    detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>\n+inline Class *construct_or_initialize(Args &&...args) {\n+  return new Class{std::forward<Args>(args)...};\n+}\n+\n+// Attempts to constructs an alias using a `Alias(Cpp &&)` constructor.  This\n+// allows types with an alias to provide only a single Cpp factory function as\n+// long as the Alias can be constructed from an rvalue reference of the base Cpp\n+// type.  This means that Alias classes can, when appropriate, simply define a\n+// `Alias(Cpp &&)` constructor rather than needing to inherit all the base class\n+// constructors.\n+template <typename Class>\n+void construct_alias_from_cpp(std::true_type /*is_alias_constructible*/,\n+                              value_and_holder &v_h, Cpp<Class> &&base) {\n+  v_h.value_ptr() = new Alias<Class>(std::move(base));\n+}\n+template <typename Class>\n+[[noreturn]] void\n+construct_alias_from_cpp(std::false_type /*!is_alias_constructible*/,\n+                         value_and_holder &, Cpp<Class> &&) {\n+  throw type_error(\n+      \"pybind11::init(): unable to convert returned instance to required \"\n+      \"alias class: no `Alias<Class>(Class &&)` constructor available\");\n+}\n+\n+// Error-generating fallback for factories that don't match one of the below\n+// construction mechanisms.\n+template <typename Class> void construct(...) {\n+  static_assert(\n+      !std::is_same<Class, Class>::value /* always false */,\n+      \"pybind11::init(): init function must return a compatible pointer, \"\n+      \"holder, or value\");\n+}\n+\n+// Pointer return v1: the factory function returns a class pointer for a\n+// registered class. If we don't need an alias (because this class doesn't have\n+// one, or because the final type is inherited on the Python side) we can simply\n+// take over ownership.  Otherwise we need to try to construct an Alias from the\n+// returned base instance.\n+template <typename Class>\n+void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {\n+  no_nullptr(ptr);\n+  if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {\n+    // We're going to try to construct an alias by moving the cpp type.  Whether\n+    // or not that succeeds, we still need to destroy the original cpp pointer\n+    // (either the moved away leftover, if the alias construction works, or the\n+    // value itself if we throw an error), but we can't just call `delete ptr`:\n+    // it might have a special deleter, or might be shared_from_this.  So we\n+    // construct a holder around it as if it was a normal instance, then steal\n+    // the holder away into a local variable; thus the holder and destruction\n+    // happens when we leave the C++ scope, and the holder class gets to handle\n+    // the destruction however it likes.\n+    v_h.value_ptr() = ptr;\n+    v_h.set_instance_registered(\n+        true); // To prevent init_instance from registering it\n+    v_h.type->init_instance(v_h.inst, nullptr); // Set up the holder\n+    Holder<Class> temp_holder(\n+        std::move(v_h.holder<Holder<Class>>())); // Steal the holder\n+    v_h.type->dealloc(\n+        v_h); // Destroys the moved-out holder remains, resets value ptr to null\n+    v_h.set_instance_registered(false);\n+\n+    construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h,\n+                                    std::move(*ptr));\n+  } else {\n+    // Otherwise the type isn't inherited, so we don't need an Alias\n+    v_h.value_ptr() = ptr;\n+  }\n+}\n+\n+// Pointer return v2: a factory that always returns an alias instance ptr.  We\n+// simply take over ownership of the pointer.\n+template <typename Class, enable_if_t<Class::has_alias, int> = 0>\n+void construct(value_and_holder &v_h, Alias<Class> *alias_ptr, bool) {\n+  no_nullptr(alias_ptr);\n+  v_h.value_ptr() = static_cast<Cpp<Class> *>(alias_ptr);\n+}\n+\n+// Holder return: copy its pointer, and move or copy the returned holder into\n+// the new instance's holder.  This also handles types like std::shared_ptr<T>\n+// and std::unique_ptr<T> where T is a derived type (through those holder's\n+// implicit conversion from derived class holder constructors).\n+template <typename Class>\n+void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {\n+  auto *ptr = holder_helper<Holder<Class>>::get(holder);\n+  // If we need an alias, check that the held pointer is actually an alias\n+  // instance\n+  if (Class::has_alias && need_alias && !is_alias<Class>(ptr))\n+    throw type_error(\"pybind11::init(): construction failed: returned \"\n+                     \"holder-wrapped instance \"\n+                     \"is not an alias instance\");\n+\n+  v_h.value_ptr() = ptr;\n+  v_h.type->init_instance(v_h.inst, &holder);\n+}\n+\n+// return-by-value version 1: returning a cpp class by value.  If the class has\n+// an alias and an alias is required the alias must have an `Alias(Cpp &&)`\n+// constructor so that we can construct the alias from the base when needed\n+// (i.e. because of Python-side inheritance).  When we don't need it, we simply\n+// move-construct the cpp value into a new instance.\n+template <typename Class>\n+void construct(value_and_holder &v_h, Cpp<Class> &&result, bool need_alias) {\n+  static_assert(std::is_move_constructible<Cpp<Class>>::value,\n+                \"pybind11::init() return-by-value factory function requires a \"\n+                \"movable class\");\n+  if (Class::has_alias && need_alias)\n+    construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h,\n+                                    std::move(result));\n+  else\n+    v_h.value_ptr() = new Cpp<Class>(std::move(result));\n+}\n+\n+// return-by-value version 2: returning a value of the alias type itself.  We\n+// move-construct an Alias instance (even if no the python-side inheritance is\n+// involved).  The is intended for cases where Alias initialization is always\n+// desired.\n+template <typename Class>\n+void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {\n+  static_assert(std::is_move_constructible<Alias<Class>>::value,\n+                \"pybind11::init() return-by-alias-value factory function \"\n+                \"requires a movable alias class\");\n+  v_h.value_ptr() = new Alias<Class>(std::move(result));\n+}\n+\n+// Implementing class for py::init<...>()\n+template <typename... Args> struct constructor {\n+  template <typename Class, typename... Extra,\n+            enable_if_t<!Class::has_alias, int> = 0>\n+  static void execute(Class &cl, const Extra &...extra) {\n+    cl.def(\n+        \"__init__\",\n+        [](value_and_holder &v_h, Args... args) {\n+          v_h.value_ptr() =\n+              construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);\n+        },\n+        is_new_style_constructor(), extra...);\n+  }\n+\n+  template <typename Class, typename... Extra,\n+            enable_if_t<Class::has_alias &&\n+                            std::is_constructible<Cpp<Class>, Args...>::value,\n+                        int> = 0>\n+  static void execute(Class &cl, const Extra &...extra) {\n+    cl.def(\n+        \"__init__\",\n+        [](value_and_holder &v_h, Args... args) {\n+          if (Py_TYPE(v_h.inst) == v_h.type->type)\n+            v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(\n+                std::forward<Args>(args)...);\n+          else\n+            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(\n+                std::forward<Args>(args)...);\n+        },\n+        is_new_style_constructor(), extra...);\n+  }\n+\n+  template <typename Class, typename... Extra,\n+            enable_if_t<Class::has_alias &&\n+                            !std::is_constructible<Cpp<Class>, Args...>::value,\n+                        int> = 0>\n+  static void execute(Class &cl, const Extra &...extra) {\n+    cl.def(\n+        \"__init__\",\n+        [](value_and_holder &v_h, Args... args) {\n+          v_h.value_ptr() = construct_or_initialize<Alias<Class>>(\n+              std::forward<Args>(args)...);\n+        },\n+        is_new_style_constructor(), extra...);\n+  }\n+};\n+\n+// Implementing class for py::init_alias<...>()\n+template <typename... Args> struct alias_constructor {\n+  template <typename Class, typename... Extra,\n+            enable_if_t<Class::has_alias &&\n+                            std::is_constructible<Alias<Class>, Args...>::value,\n+                        int> = 0>\n+  static void execute(Class &cl, const Extra &...extra) {\n+    cl.def(\n+        \"__init__\",\n+        [](value_and_holder &v_h, Args... args) {\n+          v_h.value_ptr() = construct_or_initialize<Alias<Class>>(\n+              std::forward<Args>(args)...);\n+        },\n+        is_new_style_constructor(), extra...);\n+  }\n+};\n+\n+// Implementation class for py::init(Func) and py::init(Func, AliasFunc)\n+template <typename CFunc, typename AFunc = void_type (*)(),\n+          typename = function_signature_t<CFunc>,\n+          typename = function_signature_t<AFunc>>\n+struct factory;\n+\n+// Specialization for py::init(Func)\n+template <typename Func, typename Return, typename... Args>\n+struct factory<Func, void_type (*)(), Return(Args...)> {\n+  remove_reference_t<Func> class_factory;\n+\n+  factory(Func &&f) : class_factory(std::forward<Func>(f)) {}\n+\n+  // The given class either has no alias or has no separate alias factory;\n+  // this always constructs the class itself.  If the class is registered with\n+  // an alias type and an alias instance is needed (i.e. because the final type\n+  // is a Python class inheriting from the C++ type) the returned value needs to\n+  // either already be an alias instance, or the alias needs to be constructible\n+  // from a `Class &&` argument.\n+  template <typename Class, typename... Extra>\n+  void execute(Class &cl, const Extra &...extra) && {\n+#if defined(PYBIND11_CPP14)\n+    cl.def(\n+        \"__init__\",\n+        [func = std::move(class_factory)]\n+#else\n+    auto &func = class_factory;\n+    cl.def(\n+        \"__init__\",\n+        [func]\n+#endif\n+        (value_and_holder &v_h, Args... args) {\n+          construct<Class>(v_h, func(std::forward<Args>(args)...),\n+                           Py_TYPE(v_h.inst) != v_h.type->type);\n+        },\n+        is_new_style_constructor(), extra...);\n+  }\n+};\n+\n+// Specialization for py::init(Func, AliasFunc)\n+template <typename CFunc, typename AFunc, typename CReturn, typename... CArgs,\n+          typename AReturn, typename... AArgs>\n+struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {\n+  static_assert(\n+      sizeof...(CArgs) == sizeof...(AArgs),\n+      \"pybind11::init(class_factory, alias_factory): class and alias factories \"\n+      \"must have identical argument signatures\");\n+  static_assert(\n+      all_of<std::is_same<CArgs, AArgs>...>::value,\n+      \"pybind11::init(class_factory, alias_factory): class and alias factories \"\n+      \"must have identical argument signatures\");\n+\n+  remove_reference_t<CFunc> class_factory;\n+  remove_reference_t<AFunc> alias_factory;\n+\n+  factory(CFunc &&c, AFunc &&a)\n+      : class_factory(std::forward<CFunc>(c)),\n+        alias_factory(std::forward<AFunc>(a)) {}\n+\n+  // The class factory is called when the `self` type passed to `__init__` is\n+  // the direct class (i.e. not inherited), the alias factory when `self` is a\n+  // Python-side subtype.\n+  template <typename Class, typename... Extra>\n+  void execute(Class &cl, const Extra &...extra) && {\n+    static_assert(Class::has_alias,\n+                  \"The two-argument version of `py::init()` can \"\n+                  \"only be used if the class has an alias\");\n+#if defined(PYBIND11_CPP14)\n+    cl.def(\n+        \"__init__\",\n+        [class_func = std::move(class_factory),\n+         alias_func = std::move(alias_factory)]\n+#else\n+    auto &class_func = class_factory;\n+    auto &alias_func = alias_factory;\n+    cl.def(\n+        \"__init__\",\n+        [class_func, alias_func]\n+#endif\n+        (value_and_holder &v_h, CArgs... args) {\n+          if (Py_TYPE(v_h.inst) == v_h.type->type)\n+            // If the instance type equals the registered type we don't have\n+            // inheritance, so don't need the alias and can construct using the\n+            // class function:\n+            construct<Class>(v_h, class_func(std::forward<CArgs>(args)...),\n+                             false);\n+          else\n+            construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...),\n+                             true);\n+        },\n+        is_new_style_constructor(), extra...);\n+  }\n+};\n+\n+/// Set just the C++ state. Same as `__init__`.\n+template <typename Class, typename T>\n+void setstate(value_and_holder &v_h, T &&result, bool need_alias) {\n+  construct<Class>(v_h, std::forward<T>(result), need_alias);\n+}\n+\n+/// Set both the C++ and Python states\n+template <typename Class, typename T, typename O,\n+          enable_if_t<std::is_convertible<O, handle>::value, int> = 0>\n+void setstate(value_and_holder &v_h, std::pair<T, O> &&result,\n+              bool need_alias) {\n+  construct<Class>(v_h, std::move(result.first), need_alias);\n+  setattr((PyObject *)v_h.inst, \"__dict__\", result.second);\n+}\n+\n+/// Implementation for py::pickle(GetState, SetState)\n+template <typename Get, typename Set, typename = function_signature_t<Get>,\n+          typename = function_signature_t<Set>>\n+struct pickle_factory;\n+\n+template <typename Get, typename Set, typename RetState, typename Self,\n+          typename NewInstance, typename ArgState>\n+struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {\n+  static_assert(\n+      std::is_same<intrinsic_t<RetState>, intrinsic_t<ArgState>>::value,\n+      \"The type returned by `__getstate__` must be the same \"\n+      \"as the argument accepted by `__setstate__`\");\n+\n+  remove_reference_t<Get> get;\n+  remove_reference_t<Set> set;\n+\n+  pickle_factory(Get get, Set set)\n+      : get(std::forward<Get>(get)), set(std::forward<Set>(set)) {}\n+\n+  template <typename Class, typename... Extra>\n+  void execute(Class &cl, const Extra &...extra) && {\n+    cl.def(\"__getstate__\", std::move(get));\n+\n+#if defined(PYBIND11_CPP14)\n+    cl.def(\n+        \"__setstate__\",\n+        [func = std::move(set)]\n+#else\n+    auto &func = set;\n+    cl.def(\n+        \"__setstate__\",\n+        [func]\n+#endif\n+        (value_and_holder &v_h, ArgState state) {\n+          setstate<Class>(v_h, func(std::forward<ArgState>(state)),\n+                          Py_TYPE(v_h.inst) != v_h.type->type);\n+        },\n+        is_new_style_constructor(), extra...);\n+  }\n+};\n+\n+NAMESPACE_END(initimpl)\n+NAMESPACE_END(detail)\n+NAMESPACE_END(pybind11)"}, {"filename": "python/src/pybind11/detail/internals.h", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "file_content_changes": "@@ -0,0 +1,340 @@\n+/*\n+    pybind11/detail/internals.h: Internal data structure and related functions\n+\n+    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"../pytypes.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+// Forward declarations\n+inline PyTypeObject *make_static_property_type();\n+inline PyTypeObject *make_default_metaclass();\n+inline PyObject *make_object_base_type(PyTypeObject *metaclass);\n+\n+// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in\n+// favor of the new Thread Specific Storage (TSS) API.\n+#if PY_VERSION_HEX >= 0x03070000\n+#define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr\n+#define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n+#define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))\n+#define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n+#else\n+// Usually an int but a long on Cygwin64 with Python 3.x\n+#define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0\n+#define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n+#if PY_MAJOR_VERSION < 3\n+#define PYBIND11_TLS_DELETE_VALUE(key) PyThread_delete_key_value(key)\n+#define PYBIND11_TLS_REPLACE_VALUE(key, value)                                 \\\n+  do {                                                                         \\\n+    PyThread_delete_key_value((key));                                          \\\n+    PyThread_set_key_value((key), (value));                                    \\\n+  } while (false)\n+#else\n+#define PYBIND11_TLS_DELETE_VALUE(key) PyThread_set_key_value((key), nullptr)\n+#define PYBIND11_TLS_REPLACE_VALUE(key, value)                                 \\\n+  PyThread_set_key_value((key), (value))\n+#endif\n+#endif\n+\n+// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under\n+// libc++ and possibly other STLs, this means `typeid(A)` from one module won't\n+// equal `typeid(A)` from another module even when `A` is the same,\n+// non-hidden-visibility type (e.g. from a common include).  Under libstdc++,\n+// this doesn't happen: equality and the type_index hash are based on the type\n+// name, which works.  If not under a known-good stl, provide our own name-based\n+// hash and equality functions that use the type name.\n+#if defined(__GLIBCXX__)\n+inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n+  return lhs == rhs;\n+}\n+using type_hash = std::hash<std::type_index>;\n+using type_equal_to = std::equal_to<std::type_index>;\n+#else\n+inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n+  return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n+}\n+\n+struct type_hash {\n+  size_t operator()(const std::type_index &t) const {\n+    size_t hash = 5381;\n+    const char *ptr = t.name();\n+    while (auto c = static_cast<unsigned char>(*ptr++))\n+      hash = (hash * 33) ^ c;\n+    return hash;\n+  }\n+};\n+\n+struct type_equal_to {\n+  bool operator()(const std::type_index &lhs,\n+                  const std::type_index &rhs) const {\n+    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n+  }\n+};\n+#endif\n+\n+template <typename value_type>\n+using type_map =\n+    std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n+\n+struct overload_hash {\n+  inline size_t\n+  operator()(const std::pair<const PyObject *, const char *> &v) const {\n+    size_t value = std::hash<const void *>()(v.first);\n+    value ^= std::hash<const void *>()(v.second) + 0x9e3779b9 + (value << 6) +\n+             (value >> 2);\n+    return value;\n+  }\n+};\n+\n+/// Internal data structure used to track registered instances and types.\n+/// Whenever binary incompatible changes are made to this structure,\n+/// `PYBIND11_INTERNALS_VERSION` must be incremented.\n+struct internals {\n+  type_map<type_info *>\n+      registered_types_cpp; // std::type_index -> pybind11's type information\n+  std::unordered_map<PyTypeObject *, std::vector<type_info *>>\n+      registered_types_py; // PyTypeObject* -> base type_info(s)\n+  std::unordered_multimap<const void *, instance *>\n+      registered_instances; // void * -> instance*\n+  std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash>\n+      inactive_overload_cache;\n+  type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n+  std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n+  std::forward_list<void (*)(std::exception_ptr)>\n+      registered_exception_translators;\n+  std::unordered_map<std::string, void *>\n+      shared_data; // Custom data to be shared across extensions\n+  std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`\n+  std::forward_list<std::string>\n+      static_strings; // Stores the std::strings backing detail::c_str()\n+  PyTypeObject *static_property_type;\n+  PyTypeObject *default_metaclass;\n+  PyObject *instance_base;\n+#if defined(WITH_THREAD)\n+  PYBIND11_TLS_KEY_INIT(tstate);\n+  PyInterpreterState *istate = nullptr;\n+#endif\n+};\n+\n+/// Additional type information which does not fit into the PyTypeObject.\n+/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.\n+struct type_info {\n+  PyTypeObject *type;\n+  const std::type_info *cpptype;\n+  size_t type_size, type_align, holder_size_in_ptrs;\n+  void *(*operator_new)(size_t);\n+  void (*init_instance)(instance *, const void *);\n+  void (*dealloc)(value_and_holder &v_h);\n+  std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;\n+  std::vector<std::pair<const std::type_info *, void *(*)(void *)>>\n+      implicit_casts;\n+  std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n+  buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n+  void *get_buffer_data = nullptr;\n+  void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n+  /* A simple type never occurs as a (direct or indirect) parent\n+   * of a class that makes use of multiple inheritance */\n+  bool simple_type : 1;\n+  /* True if there is no multiple inheritance in this type's inheritance tree */\n+  bool simple_ancestors : 1;\n+  /* for base vs derived holder_type checks */\n+  bool default_holder : 1;\n+  /* true if this is a type registered with py::module_local */\n+  bool module_local : 1;\n+};\n+\n+/// Tracks the `internals` and `type_info` ABI version independent of the main\n+/// library version\n+#define PYBIND11_INTERNALS_VERSION 3\n+\n+#if defined(_DEBUG)\n+#define PYBIND11_BUILD_TYPE \"_debug\"\n+#else\n+#define PYBIND11_BUILD_TYPE \"\"\n+#endif\n+\n+#if defined(WITH_THREAD)\n+#define PYBIND11_INTERNALS_KIND \"\"\n+#else\n+#define PYBIND11_INTERNALS_KIND \"_without_thread\"\n+#endif\n+\n+#define PYBIND11_INTERNALS_ID                                                  \\\n+  \"__pybind11_internals_v\" PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION)       \\\n+      PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n+\n+#define PYBIND11_MODULE_LOCAL_ID                                               \\\n+  \"__pybind11_module_local_v\" PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION)    \\\n+      PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n+\n+/// Each module locally stores a pointer to the `internals` data. The data\n+/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\n+inline internals **&get_internals_pp() {\n+  static internals **internals_pp = nullptr;\n+  return internals_pp;\n+}\n+\n+/// Return a reference to the current `internals` data\n+PYBIND11_NOINLINE inline internals &get_internals() {\n+  auto **&internals_pp = get_internals_pp();\n+  if (internals_pp && *internals_pp)\n+    return **internals_pp;\n+\n+  constexpr auto *id = PYBIND11_INTERNALS_ID;\n+  auto builtins = handle(PyEval_GetBuiltins());\n+  if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n+    internals_pp = static_cast<internals **>(capsule(builtins[id]));\n+\n+    // We loaded builtins through python's builtins, which means that our\n+    // `error_already_set` and `builtin_exception` may be different local\n+    // classes than the ones set up in the initial exception translator, below,\n+    // so add another for our local exception classes.\n+    //\n+    // libstdc++ doesn't require this (types there are identified only by name)\n+#if !defined(__GLIBCXX__)\n+    (*internals_pp)\n+        ->registered_exception_translators.push_front(\n+            [](std::exception_ptr p) -> void {\n+              try {\n+                if (p)\n+                  std::rethrow_exception(p);\n+              } catch (error_already_set &e) {\n+                e.restore();\n+                return;\n+              } catch (const builtin_exception &e) {\n+                e.set_error();\n+                return;\n+              }\n+            });\n+#endif\n+  } else {\n+    if (!internals_pp)\n+      internals_pp = new internals *();\n+    auto *&internals_ptr = *internals_pp;\n+    internals_ptr = new internals();\n+#if defined(WITH_THREAD)\n+#if PY_VERSION_HEX < 0x03090000\n+    PyEval_InitThreads();\n+#endif\n+    PyThreadState *tstate = PyThreadState_Get();\n+#if PY_VERSION_HEX >= 0x03070000\n+    internals_ptr->tstate = PyThread_tss_alloc();\n+    if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))\n+      pybind11_fail(\n+          \"get_internals: could not successfully initialize the TSS key!\");\n+    PyThread_tss_set(internals_ptr->tstate, tstate);\n+#else\n+    internals_ptr->tstate = PyThread_create_key();\n+    if (internals_ptr->tstate == -1)\n+      pybind11_fail(\n+          \"get_internals: could not successfully initialize the TLS key!\");\n+    PyThread_set_key_value(internals_ptr->tstate, tstate);\n+#endif\n+    internals_ptr->istate = tstate->interp;\n+#endif\n+    builtins[id] = capsule(internals_pp);\n+    internals_ptr->registered_exception_translators.push_front(\n+        [](std::exception_ptr p) -> void {\n+          try {\n+            if (p)\n+              std::rethrow_exception(p);\n+          } catch (error_already_set &e) {\n+            e.restore();\n+            return;\n+          } catch (const builtin_exception &e) {\n+            e.set_error();\n+            return;\n+          } catch (const std::bad_alloc &e) {\n+            PyErr_SetString(PyExc_MemoryError, e.what());\n+            return;\n+          } catch (const std::domain_error &e) {\n+            PyErr_SetString(PyExc_ValueError, e.what());\n+            return;\n+          } catch (const std::invalid_argument &e) {\n+            PyErr_SetString(PyExc_ValueError, e.what());\n+            return;\n+          } catch (const std::length_error &e) {\n+            PyErr_SetString(PyExc_ValueError, e.what());\n+            return;\n+          } catch (const std::out_of_range &e) {\n+            PyErr_SetString(PyExc_IndexError, e.what());\n+            return;\n+          } catch (const std::range_error &e) {\n+            PyErr_SetString(PyExc_ValueError, e.what());\n+            return;\n+          } catch (const std::exception &e) {\n+            PyErr_SetString(PyExc_RuntimeError, e.what());\n+            return;\n+          } catch (...) {\n+            PyErr_SetString(PyExc_RuntimeError, \"Caught an unknown exception!\");\n+            return;\n+          }\n+        });\n+    internals_ptr->static_property_type = make_static_property_type();\n+    internals_ptr->default_metaclass = make_default_metaclass();\n+    internals_ptr->instance_base =\n+        make_object_base_type(internals_ptr->default_metaclass);\n+  }\n+  return **internals_pp;\n+}\n+\n+/// Works like `internals.registered_types_cpp`, but for module-local registered\n+/// types:\n+inline type_map<type_info *> &registered_local_types_cpp() {\n+  static type_map<type_info *> locals{};\n+  return locals;\n+}\n+\n+/// Constructs a std::string with the given arguments, stores it in `internals`,\n+/// and returns its `c_str()`.  Such strings objects have a long storage\n+/// duration -- the internal strings are only cleared when the program exits or\n+/// after interpreter shutdown (when embedding), and so are suitable for c-style\n+/// strings needed by Python internals (such as PyTypeObject's tp_name).\n+template <typename... Args> const char *c_str(Args &&...args) {\n+  auto &strings = get_internals().static_strings;\n+  strings.emplace_front(std::forward<Args>(args)...);\n+  return strings.front().c_str();\n+}\n+\n+NAMESPACE_END(detail)\n+\n+/// Returns a named pointer that is shared among all extension modules (using\n+/// the same pybind11 version) running in the current interpreter. Names\n+/// starting with underscores are reserved for internal usage. Returns `nullptr`\n+/// if no matching entry was found.\n+inline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n+  auto &internals = detail::get_internals();\n+  auto it = internals.shared_data.find(name);\n+  return it != internals.shared_data.end() ? it->second : nullptr;\n+}\n+\n+/// Set the shared data that can be later recovered by `get_shared_data()`.\n+inline PYBIND11_NOINLINE void *set_shared_data(const std::string &name,\n+                                               void *data) {\n+  detail::get_internals().shared_data[name] = data;\n+  return data;\n+}\n+\n+/// Returns a typed reference to a shared data entry (by using\n+/// `get_shared_data()`) if such entry exists. Otherwise, a new object of\n+/// default-constructible type `T` is added to the shared data under the given\n+/// name and a reference to it is returned.\n+template <typename T> T &get_or_create_shared_data(const std::string &name) {\n+  auto &internals = detail::get_internals();\n+  auto it = internals.shared_data.find(name);\n+  T *ptr = (T *)(it != internals.shared_data.end() ? it->second : nullptr);\n+  if (!ptr) {\n+    ptr = new T();\n+    internals.shared_data[name] = ptr;\n+  }\n+  return *ptr;\n+}\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/detail/typeid.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "file_content_changes": "@@ -0,0 +1,56 @@\n+/*\n+    pybind11/detail/typeid.h: Compiler-independent access to type identifiers\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include <cstdio>\n+#include <cstdlib>\n+\n+#if defined(__GNUG__)\n+#include <cxxabi.h>\n+#endif\n+\n+#include \"common.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+/// Erase all occurrences of a substring\n+inline void erase_all(std::string &string, const std::string &search) {\n+  for (size_t pos = 0;;) {\n+    pos = string.find(search, pos);\n+    if (pos == std::string::npos)\n+      break;\n+    string.erase(pos, search.length());\n+  }\n+}\n+\n+PYBIND11_NOINLINE inline void clean_type_id(std::string &name) {\n+#if defined(__GNUG__)\n+  int status = 0;\n+  std::unique_ptr<char, void (*)(void *)> res{\n+      abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free};\n+  if (status == 0)\n+    name = res.get();\n+#else\n+  detail::erase_all(name, \"class \");\n+  detail::erase_all(name, \"struct \");\n+  detail::erase_all(name, \"enum \");\n+#endif\n+  detail::erase_all(name, \"pybind11::\");\n+}\n+NAMESPACE_END(detail)\n+\n+/// Return a string representation of a C++ type\n+template <typename T> static std::string type_id() {\n+  std::string name(typeid(T).name());\n+  detail::clean_type_id(name);\n+  return name;\n+}\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/eigen.h", "status": "added", "additions": 724, "deletions": 0, "changes": 724, "file_content_changes": "@@ -0,0 +1,724 @@\n+/*\n+    pybind11/eigen.h: Transparent conversion for dense and sparse Eigen matrices\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"numpy.h\"\n+\n+#if defined(__INTEL_COMPILER)\n+#pragma warning(                                                               \\\n+    disable : 1682) // implicit conversion of a 64-bit integral type to a\n+                    // smaller integral type (potential portability problem)\n+#elif defined(__GNUG__) || defined(__clang__)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wconversion\"\n+#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n+#ifdef __clang__\n+//   Eigen generates a bunch of implicit-copy-constructor-is-deprecated warnings\n+//   with -Wdeprecated under Clang, so disable that warning here:\n+#pragma GCC diagnostic ignored \"-Wdeprecated\"\n+#endif\n+#if __GNUC__ >= 7\n+#pragma GCC diagnostic ignored \"-Wint-in-bool-context\"\n+#endif\n+#endif\n+\n+#if defined(_MSC_VER)\n+#pragma warning(push)\n+#pragma warning(                                                               \\\n+    disable : 4127) // warning C4127: Conditional expression is constant\n+#pragma warning(                                                               \\\n+    disable : 4996) // warning C4996: std::unary_negate is deprecated in C++17\n+#endif\n+\n+#include <Eigen/Core>\n+#include <Eigen/SparseCore>\n+\n+// Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some\n+// classes get implicit move constructors that break things.  We could detect\n+// this an explicitly copy, but an extra copy of matrices seems highly\n+// undesirable.\n+static_assert(EIGEN_VERSION_AT_LEAST(3, 2, 7),\n+              \"Eigen support in pybind11 requires Eigen >= 3.2.7\");\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+// Provide a convenience alias for easier pass-by-ref usage with fully dynamic\n+// strides:\n+using EigenDStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;\n+template <typename MatrixType>\n+using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;\n+template <typename MatrixType>\n+using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;\n+\n+NAMESPACE_BEGIN(detail)\n+\n+#if EIGEN_VERSION_AT_LEAST(3, 3, 0)\n+using EigenIndex = Eigen::Index;\n+#else\n+using EigenIndex = EIGEN_DEFAULT_DENSE_INDEX_TYPE;\n+#endif\n+\n+// Matches Eigen::Map, Eigen::Ref, blocks, etc:\n+template <typename T>\n+using is_eigen_dense_map =\n+    all_of<is_template_base_of<Eigen::DenseBase, T>,\n+           std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;\n+template <typename T>\n+using is_eigen_mutable_map =\n+    std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;\n+template <typename T>\n+using is_eigen_dense_plain =\n+    all_of<negation<is_eigen_dense_map<T>>,\n+           is_template_base_of<Eigen::PlainObjectBase, T>>;\n+template <typename T>\n+using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;\n+// Test for objects inheriting from EigenBase<Derived> that aren't captured by\n+// the above.  This basically covers anything that can be assigned to a dense\n+// matrix but that don't have a typical matrix data layout that can be copied\n+// from their .data().  For example, DiagonalMatrix and SelfAdjointView fall\n+// into this category.\n+template <typename T>\n+using is_eigen_other =\n+    all_of<is_template_base_of<Eigen::EigenBase, T>,\n+           negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>,\n+                           is_eigen_sparse<T>>>>;\n+\n+// Captures numpy/eigen conformability status (returned by\n+// EigenProps::conformable()):\n+template <bool EigenRowMajor> struct EigenConformable {\n+  bool conformable = false;\n+  EigenIndex rows = 0, cols = 0;\n+  EigenDStride stride{0, 0};    // Only valid if negativestrides is false!\n+  bool negativestrides = false; // If true, do not use stride!\n+\n+  EigenConformable(bool fits = false) : conformable{fits} {}\n+  // Matrix type:\n+  EigenConformable(EigenIndex r, EigenIndex c, EigenIndex rstride,\n+                   EigenIndex cstride)\n+      : conformable{true}, rows{r}, cols{c} {\n+    // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity.\n+    // http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747\n+    if (rstride < 0 || cstride < 0) {\n+      negativestrides = true;\n+    } else {\n+      stride = {EigenRowMajor ? rstride : cstride /* outer stride */,\n+                EigenRowMajor ? cstride : rstride /* inner stride */};\n+    }\n+  }\n+  // Vector type:\n+  EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)\n+      : EigenConformable(r, c, r == 1 ? c * stride : stride,\n+                         c == 1 ? r : r * stride) {}\n+\n+  template <typename props> bool stride_compatible() const {\n+    // To have compatible strides, we need (on both dimensions) one of fully\n+    // dynamic strides, matching strides, or a dimension size of 1 (in which\n+    // case the stride value is irrelevant)\n+    return !negativestrides &&\n+           (props::inner_stride == Eigen::Dynamic ||\n+            props::inner_stride == stride.inner() ||\n+            (EigenRowMajor ? cols : rows) == 1) &&\n+           (props::outer_stride == Eigen::Dynamic ||\n+            props::outer_stride == stride.outer() ||\n+            (EigenRowMajor ? rows : cols) == 1);\n+  }\n+  operator bool() const { return conformable; }\n+};\n+\n+template <typename Type> struct eigen_extract_stride { using type = Type; };\n+template <typename PlainObjectType, int MapOptions, typename StrideType>\n+struct eigen_extract_stride<\n+    Eigen::Map<PlainObjectType, MapOptions, StrideType>> {\n+  using type = StrideType;\n+};\n+template <typename PlainObjectType, int Options, typename StrideType>\n+struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> {\n+  using type = StrideType;\n+};\n+\n+// Helper struct for extracting information from an Eigen type\n+template <typename Type_> struct EigenProps {\n+  using Type = Type_;\n+  using Scalar = typename Type::Scalar;\n+  using StrideType = typename eigen_extract_stride<Type>::type;\n+  static constexpr EigenIndex rows = Type::RowsAtCompileTime,\n+                              cols = Type::ColsAtCompileTime,\n+                              size = Type::SizeAtCompileTime;\n+  static constexpr bool\n+      row_major = Type::IsRowMajor,\n+      vector = Type::IsVectorAtCompileTime, // At least one dimension has fixed\n+                                            // size 1\n+      fixed_rows = rows != Eigen::Dynamic, fixed_cols = cols != Eigen::Dynamic,\n+      fixed = size != Eigen::Dynamic,       // Fully-fixed size\n+      dynamic = !fixed_rows && !fixed_cols; // Fully-dynamic size\n+\n+  template <EigenIndex i, EigenIndex ifzero>\n+  using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;\n+  static constexpr EigenIndex\n+      inner_stride = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,\n+      outer_stride = if_zero < StrideType::OuterStrideAtCompileTime,\n+      vector      ? size\n+      : row_major ? cols\n+                  : rows > ::value;\n+  static constexpr bool dynamic_stride =\n+      inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;\n+  static constexpr bool requires_row_major =\n+      !dynamic_stride && !vector &&\n+      (row_major ? inner_stride : outer_stride) == 1;\n+  static constexpr bool requires_col_major =\n+      !dynamic_stride && !vector &&\n+      (row_major ? outer_stride : inner_stride) == 1;\n+\n+  // Takes an input array and determines whether we can make it fit into the\n+  // Eigen type.  If the array is a vector, we attempt to fit it into either an\n+  // Eigen 1xN or Nx1 vector (preferring the latter if it will fit in either,\n+  // i.e. for a fully dynamic matrix type).\n+  static EigenConformable<row_major> conformable(const array &a) {\n+    const auto dims = a.ndim();\n+    if (dims < 1 || dims > 2)\n+      return false;\n+\n+    if (dims == 2) { // Matrix type: require exact match (or dynamic)\n+\n+      EigenIndex np_rows = a.shape(0), np_cols = a.shape(1),\n+                 np_rstride =\n+                     a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),\n+                 np_cstride =\n+                     a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));\n+      if ((fixed_rows && np_rows != rows) || (fixed_cols && np_cols != cols))\n+        return false;\n+\n+      return {np_rows, np_cols, np_rstride, np_cstride};\n+    }\n+\n+    // Otherwise we're storing an n-vector.  Only one of the strides will be\n+    // used, but whichever is used, we want the (single) numpy stride value.\n+    const EigenIndex n = a.shape(0),\n+                     stride =\n+                         a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));\n+\n+    if (vector) { // Eigen type is a compile-time vector\n+      if (fixed && size != n)\n+        return false; // Vector size mismatch\n+      return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};\n+    } else if (fixed) {\n+      // The type has a fixed size, but is not a vector: abort\n+      return false;\n+    } else if (fixed_cols) {\n+      // Since this isn't a vector, cols must be != 1.  We allow this only if it\n+      // exactly equals the number of elements (rows is Dynamic, and so 1 row is\n+      // allowed).\n+      if (cols != n)\n+        return false;\n+      return {1, n, stride};\n+    } else {\n+      // Otherwise it's either fully dynamic, or column dynamic; both become a\n+      // column vector\n+      if (fixed_rows && rows != n)\n+        return false;\n+      return {n, 1, stride};\n+    }\n+  }\n+\n+  static constexpr bool show_writeable =\n+      is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;\n+  static constexpr bool show_order = is_eigen_dense_map<Type>::value;\n+  static constexpr bool show_c_contiguous = show_order && requires_row_major;\n+  static constexpr bool show_f_contiguous =\n+      !show_c_contiguous && show_order && requires_col_major;\n+\n+  static constexpr auto descriptor =\n+      _(\"numpy.ndarray[\") + npy_format_descriptor<Scalar>::name + _(\"[\") +\n+      _<fixed_rows>(_<(size_t)rows>(), _(\"m\")) + _(\", \") +\n+      _<fixed_cols>(_<(size_t)cols>(), _(\"n\")) + _(\"]\") +\n+      // For a reference type (e.g. Ref<MatrixXd>) we have other constraints\n+      // that might need to be satisfied: writeable=True (for a mutable\n+      // reference), and, depending on the map's stride options, possibly\n+      // f_contiguous or c_contiguous.  We include them in the descriptor output\n+      // to provide some hint as to why a TypeError is occurring (otherwise it\n+      // can be confusing to see that a function accepts a\n+      // 'numpy.ndarray[float64[3,2]]' and an error message that you *gave* a\n+      // numpy.ndarray of the right type and dimensions.\n+      _<show_writeable>(\", flags.writeable\", \"\") +\n+      _<show_c_contiguous>(\", flags.c_contiguous\", \"\") +\n+      _<show_f_contiguous>(\", flags.f_contiguous\", \"\") + _(\"]\");\n+};\n+\n+// Casts an Eigen type to numpy array.  If given a base, the numpy array\n+// references the src data, otherwise it'll make a copy.  writeable lets you\n+// turn off the writeable flag for the array.\n+template <typename props>\n+handle eigen_array_cast(typename props::Type const &src, handle base = handle(),\n+                        bool writeable = true) {\n+  constexpr ssize_t elem_size = sizeof(typename props::Scalar);\n+  array a;\n+  if (props::vector)\n+    a = array({src.size()}, {elem_size * src.innerStride()}, src.data(), base);\n+  else\n+    a = array({src.rows(), src.cols()},\n+              {elem_size * src.rowStride(), elem_size * src.colStride()},\n+              src.data(), base);\n+\n+  if (!writeable)\n+    array_proxy(a.ptr())->flags &= ~detail::npy_api::NPY_ARRAY_WRITEABLE_;\n+\n+  return a.release();\n+}\n+\n+// Takes an lvalue ref to some Eigen type and a (python) base object, creating a\n+// numpy array that reference the Eigen object's data with `base` as the\n+// python-registered base class (if omitted, the base will be set to None, and\n+// lifetime management is up to the caller).  The numpy array is non-writeable\n+// if the given type is const.\n+template <typename props, typename Type>\n+handle eigen_ref_array(Type &src, handle parent = none()) {\n+  // none here is to get past array's should-we-copy detection, which currently\n+  // always copies when there is no base.  Setting the base to None should be\n+  // harmless.\n+  return eigen_array_cast<props>(src, parent, !std::is_const<Type>::value);\n+}\n+\n+// Takes a pointer to some dense, plain Eigen type, builds a capsule around it,\n+// then returns a numpy array that references the encapsulated data with a\n+// python-side reference to the capsule to tie its destruction to that of any\n+// dependent python objects.  Const-ness is determined by whether or not the\n+// Type of the pointer given is const.\n+template <typename props, typename Type,\n+          typename = enable_if_t<is_eigen_dense_plain<Type>::value>>\n+handle eigen_encapsulate(Type *src) {\n+  capsule base(src, [](void *o) { delete static_cast<Type *>(o); });\n+  return eigen_ref_array<props>(*src, base);\n+}\n+\n+// Type caster for regular, dense matrix types (e.g. MatrixXd), but not\n+// maps/refs/etc. of dense types.\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {\n+  using Scalar = typename Type::Scalar;\n+  using props = EigenProps<Type>;\n+\n+  bool load(handle src, bool convert) {\n+    // If we're in no-convert mode, only load if given an array of the correct\n+    // type\n+    if (!convert && !isinstance<array_t<Scalar>>(src))\n+      return false;\n+\n+    // Coerce into an array, but don't do type conversion yet; the copy below\n+    // handles it.\n+    auto buf = array::ensure(src);\n+\n+    if (!buf)\n+      return false;\n+\n+    auto dims = buf.ndim();\n+    if (dims < 1 || dims > 2)\n+      return false;\n+\n+    auto fits = props::conformable(buf);\n+    if (!fits)\n+      return false;\n+\n+    // Allocate the new type, then build a numpy reference into it\n+    value = Type(fits.rows, fits.cols);\n+    auto ref = reinterpret_steal<array>(eigen_ref_array<props>(value));\n+    if (dims == 1)\n+      ref = ref.squeeze();\n+    else if (ref.ndim() == 1)\n+      buf = buf.squeeze();\n+\n+    int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());\n+\n+    if (result < 0) { // Copy failed!\n+      PyErr_Clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+private:\n+  // Cast implementation\n+  template <typename CType>\n+  static handle cast_impl(CType *src, return_value_policy policy,\n+                          handle parent) {\n+    switch (policy) {\n+    case return_value_policy::take_ownership:\n+    case return_value_policy::automatic:\n+      return eigen_encapsulate<props>(src);\n+    case return_value_policy::move:\n+      return eigen_encapsulate<props>(new CType(std::move(*src)));\n+    case return_value_policy::copy:\n+      return eigen_array_cast<props>(*src);\n+    case return_value_policy::reference:\n+    case return_value_policy::automatic_reference:\n+      return eigen_ref_array<props>(*src);\n+    case return_value_policy::reference_internal:\n+      return eigen_ref_array<props>(*src, parent);\n+    default:\n+      throw cast_error(\"unhandled return_value_policy: should not happen!\");\n+    };\n+  }\n+\n+public:\n+  // Normal returned non-reference, non-const value:\n+  static handle cast(Type &&src, return_value_policy /* policy */,\n+                     handle parent) {\n+    return cast_impl(&src, return_value_policy::move, parent);\n+  }\n+  // If you return a non-reference const, we mark the numpy array readonly:\n+  static handle cast(const Type &&src, return_value_policy /* policy */,\n+                     handle parent) {\n+    return cast_impl(&src, return_value_policy::move, parent);\n+  }\n+  // lvalue reference return; default (automatic) becomes copy\n+  static handle cast(Type &src, return_value_policy policy, handle parent) {\n+    if (policy == return_value_policy::automatic ||\n+        policy == return_value_policy::automatic_reference)\n+      policy = return_value_policy::copy;\n+    return cast_impl(&src, policy, parent);\n+  }\n+  // const lvalue reference return; default (automatic) becomes copy\n+  static handle cast(const Type &src, return_value_policy policy,\n+                     handle parent) {\n+    if (policy == return_value_policy::automatic ||\n+        policy == return_value_policy::automatic_reference)\n+      policy = return_value_policy::copy;\n+    return cast(&src, policy, parent);\n+  }\n+  // non-const pointer return\n+  static handle cast(Type *src, return_value_policy policy, handle parent) {\n+    return cast_impl(src, policy, parent);\n+  }\n+  // const pointer return\n+  static handle cast(const Type *src, return_value_policy policy,\n+                     handle parent) {\n+    return cast_impl(src, policy, parent);\n+  }\n+\n+  static constexpr auto name = props::descriptor;\n+\n+  operator Type *() { return &value; }\n+  operator Type &() { return value; }\n+  operator Type &&() && { return std::move(value); }\n+  template <typename T> using cast_op_type = movable_cast_op_type<T>;\n+\n+private:\n+  Type value;\n+};\n+\n+// Base class for casting reference/map/block/etc. objects back to python.\n+template <typename MapType> struct eigen_map_caster {\n+private:\n+  using props = EigenProps<MapType>;\n+\n+public:\n+  // Directly referencing a ref/map's data is a bit dangerous (whatever the\n+  // map/ref points to has to stay around), but we'll allow it under the\n+  // assumption that you know what you're doing (and have an appropriate\n+  // keep_alive in place).  We return a numpy array pointing directly at the\n+  // ref's data (The numpy array ends up read-only if the ref was to a const\n+  // matrix type.) Note that this means you need to ensure you don't destroy the\n+  // object in some other way (e.g. with an appropriate keep_alive, or with a\n+  // reference to a statically allocated matrix).\n+  static handle cast(const MapType &src, return_value_policy policy,\n+                     handle parent) {\n+    switch (policy) {\n+    case return_value_policy::copy:\n+      return eigen_array_cast<props>(src);\n+    case return_value_policy::reference_internal:\n+      return eigen_array_cast<props>(src, parent,\n+                                     is_eigen_mutable_map<MapType>::value);\n+    case return_value_policy::reference:\n+    case return_value_policy::automatic:\n+    case return_value_policy::automatic_reference:\n+      return eigen_array_cast<props>(src, none(),\n+                                     is_eigen_mutable_map<MapType>::value);\n+    default:\n+      // move, take_ownership don't make any sense for a ref/map:\n+      pybind11_fail(\"Invalid return_value_policy for Eigen Map/Ref/Block type\");\n+    }\n+  }\n+\n+  static constexpr auto name = props::descriptor;\n+\n+  // Explicitly delete these: support python -> C++ conversion on these (i.e.\n+  // these can be return types but not bound arguments).  We still provide them\n+  // (with an explicitly delete) so that you end up here if you try anyway.\n+  bool load(handle, bool) = delete;\n+  operator MapType() = delete;\n+  template <typename> using cast_op_type = MapType;\n+};\n+\n+// We can return any map-like object (but can only load Refs, specialized next):\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>>\n+    : eigen_map_caster<Type> {};\n+\n+// Loader for Ref<...> arguments.  See the documentation for info on how to make\n+// this work without copying (it requires some extra effort in many cases).\n+template <typename PlainObjectType, typename StrideType>\n+struct type_caster<Eigen::Ref<PlainObjectType, 0, StrideType>,\n+                   enable_if_t<is_eigen_dense_map<\n+                       Eigen::Ref<PlainObjectType, 0, StrideType>>::value>>\n+    : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {\n+private:\n+  using Type = Eigen::Ref<PlainObjectType, 0, StrideType>;\n+  using props = EigenProps<Type>;\n+  using Scalar = typename props::Scalar;\n+  using MapType = Eigen::Map<PlainObjectType, 0, StrideType>;\n+  using Array = array_t<\n+      Scalar,\n+      array::forcecast |\n+          ((props::row_major ? props::inner_stride : props::outer_stride) == 1\n+               ? array::c_style\n+           : (props::row_major ? props::outer_stride : props::inner_stride) == 1\n+               ? array::f_style\n+               : 0)>;\n+  static constexpr bool need_writeable = is_eigen_mutable_map<Type>::value;\n+  // Delay construction (these have no default constructor)\n+  std::unique_ptr<MapType> map;\n+  std::unique_ptr<Type> ref;\n+  // Our array.  When possible, this is just a numpy array pointing to the\n+  // source data, but sometimes we can't avoid copying (e.g. input is not a\n+  // numpy array at all, has an incompatible layout, or is an array of a type\n+  // that needs to be converted).  Using a numpy temporary (rather than an Eigen\n+  // temporary) saves an extra copy when we need both type conversion and\n+  // storage order conversion.  (Note that we refuse to use this temporary copy\n+  // when loading an argument for a Ref<M> with M non-const, i.e. a read-write\n+  // reference).\n+  Array copy_or_ref;\n+\n+public:\n+  bool load(handle src, bool convert) {\n+    // First check whether what we have is already an array of the right type.\n+    // If not, we can't avoid a copy (because the copy is also going to do type\n+    // conversion).\n+    bool need_copy = !isinstance<Array>(src);\n+\n+    EigenConformable<props::row_major> fits;\n+    if (!need_copy) {\n+      // We don't need a converting copy, but we also need to check whether the\n+      // strides are compatible with the Ref's stride requirements\n+      Array aref = reinterpret_borrow<Array>(src);\n+\n+      if (aref && (!need_writeable || aref.writeable())) {\n+        fits = props::conformable(aref);\n+        if (!fits)\n+          return false; // Incompatible dimensions\n+        if (!fits.template stride_compatible<props>())\n+          need_copy = true;\n+        else\n+          copy_or_ref = std::move(aref);\n+      } else {\n+        need_copy = true;\n+      }\n+    }\n+\n+    if (need_copy) {\n+      // We need to copy: If we need a mutable reference, or we're not supposed\n+      // to convert (either because we're in the no-convert overload pass, or\n+      // because we're explicitly instructed not to copy (via\n+      // `py::arg().noconvert()`) we have to fail loading.\n+      if (!convert || need_writeable)\n+        return false;\n+\n+      Array copy = Array::ensure(src);\n+      if (!copy)\n+        return false;\n+      fits = props::conformable(copy);\n+      if (!fits || !fits.template stride_compatible<props>())\n+        return false;\n+      copy_or_ref = std::move(copy);\n+      loader_life_support::add_patient(copy_or_ref);\n+    }\n+\n+    ref.reset();\n+    map.reset(\n+        new MapType(data(copy_or_ref), fits.rows, fits.cols,\n+                    make_stride(fits.stride.outer(), fits.stride.inner())));\n+    ref.reset(new Type(*map));\n+\n+    return true;\n+  }\n+\n+  operator Type *() { return ref.get(); }\n+  operator Type &() { return *ref; }\n+  template <typename _T>\n+  using cast_op_type = pybind11::detail::cast_op_type<_T>;\n+\n+private:\n+  template <typename T = Type,\n+            enable_if_t<is_eigen_mutable_map<T>::value, int> = 0>\n+  Scalar *data(Array &a) {\n+    return a.mutable_data();\n+  }\n+\n+  template <typename T = Type,\n+            enable_if_t<!is_eigen_mutable_map<T>::value, int> = 0>\n+  const Scalar *data(Array &a) {\n+    return a.data();\n+  }\n+\n+  // Attempt to figure out a constructor of `Stride` that will work.\n+  // If both strides are fixed, use a default constructor:\n+  template <typename S>\n+  using stride_ctor_default =\n+      bool_constant<S::InnerStrideAtCompileTime != Eigen::Dynamic &&\n+                    S::OuterStrideAtCompileTime != Eigen::Dynamic &&\n+                    std::is_default_constructible<S>::value>;\n+  // Otherwise, if there is a two-index constructor, assume it is (outer,inner)\n+  // like Eigen::Stride, and use it:\n+  template <typename S>\n+  using stride_ctor_dual =\n+      bool_constant<!stride_ctor_default<S>::value &&\n+                    std::is_constructible<S, EigenIndex, EigenIndex>::value>;\n+  // Otherwise, if there is a one-index constructor, and just one of the strides\n+  // is dynamic, use it (passing whichever stride is dynamic).\n+  template <typename S>\n+  using stride_ctor_outer = bool_constant<\n+      !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&\n+      S::OuterStrideAtCompileTime == Eigen::Dynamic &&\n+      S::InnerStrideAtCompileTime != Eigen::Dynamic &&\n+      std::is_constructible<S, EigenIndex>::value>;\n+  template <typename S>\n+  using stride_ctor_inner = bool_constant<\n+      !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&\n+      S::InnerStrideAtCompileTime == Eigen::Dynamic &&\n+      S::OuterStrideAtCompileTime != Eigen::Dynamic &&\n+      std::is_constructible<S, EigenIndex>::value>;\n+\n+  template <typename S = StrideType,\n+            enable_if_t<stride_ctor_default<S>::value, int> = 0>\n+  static S make_stride(EigenIndex, EigenIndex) {\n+    return S();\n+  }\n+  template <typename S = StrideType,\n+            enable_if_t<stride_ctor_dual<S>::value, int> = 0>\n+  static S make_stride(EigenIndex outer, EigenIndex inner) {\n+    return S(outer, inner);\n+  }\n+  template <typename S = StrideType,\n+            enable_if_t<stride_ctor_outer<S>::value, int> = 0>\n+  static S make_stride(EigenIndex outer, EigenIndex) {\n+    return S(outer);\n+  }\n+  template <typename S = StrideType,\n+            enable_if_t<stride_ctor_inner<S>::value, int> = 0>\n+  static S make_stride(EigenIndex, EigenIndex inner) {\n+    return S(inner);\n+  }\n+};\n+\n+// type_caster for special matrix types (e.g. DiagonalMatrix), which are\n+// EigenBase, but not EigenDense (i.e. they don't have a data(), at least not\n+// with the usual matrix layout). load() is not supported, but we can cast them\n+// into the python domain by first copying to a regular Eigen::Matrix, then\n+// casting that.\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_other<Type>::value>> {\n+protected:\n+  using Matrix = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime,\n+                               Type::ColsAtCompileTime>;\n+  using props = EigenProps<Matrix>;\n+\n+public:\n+  static handle cast(const Type &src, return_value_policy /* policy */,\n+                     handle /* parent */) {\n+    handle h = eigen_encapsulate<props>(new Matrix(src));\n+    return h;\n+  }\n+  static handle cast(const Type *src, return_value_policy policy,\n+                     handle parent) {\n+    return cast(*src, policy, parent);\n+  }\n+\n+  static constexpr auto name = props::descriptor;\n+\n+  // Explicitly delete these: support python -> C++ conversion on these (i.e.\n+  // these can be return types but not bound arguments).  We still provide them\n+  // (with an explicitly delete) so that you end up here if you try anyway.\n+  bool load(handle, bool) = delete;\n+  operator Type() = delete;\n+  template <typename> using cast_op_type = Type;\n+};\n+\n+template <typename Type>\n+struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {\n+  typedef typename Type::Scalar Scalar;\n+  typedef remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())>\n+      StorageIndex;\n+  typedef typename Type::Index Index;\n+  static constexpr bool rowMajor = Type::IsRowMajor;\n+\n+  bool load(handle src, bool) {\n+    if (!src)\n+      return false;\n+\n+    auto obj = reinterpret_borrow<object>(src);\n+    object sparse_module = module::import(\"scipy.sparse\");\n+    object matrix_type =\n+        sparse_module.attr(rowMajor ? \"csr_matrix\" : \"csc_matrix\");\n+\n+    if (!obj.get_type().is(matrix_type)) {\n+      try {\n+        obj = matrix_type(obj);\n+      } catch (const error_already_set &) {\n+        return false;\n+      }\n+    }\n+\n+    auto values = array_t<Scalar>((object)obj.attr(\"data\"));\n+    auto innerIndices = array_t<StorageIndex>((object)obj.attr(\"indices\"));\n+    auto outerIndices = array_t<StorageIndex>((object)obj.attr(\"indptr\"));\n+    auto shape = pybind11::tuple((pybind11::object)obj.attr(\"shape\"));\n+    auto nnz = obj.attr(\"nnz\").cast<Index>();\n+\n+    if (!values || !innerIndices || !outerIndices)\n+      return false;\n+\n+    value = Eigen::MappedSparseMatrix<Scalar, Type::Flags, StorageIndex>(\n+        shape[0].cast<Index>(), shape[1].cast<Index>(), nnz,\n+        outerIndices.mutable_data(), innerIndices.mutable_data(),\n+        values.mutable_data());\n+\n+    return true;\n+  }\n+\n+  static handle cast(const Type &src, return_value_policy /* policy */,\n+                     handle /* parent */) {\n+    const_cast<Type &>(src).makeCompressed();\n+\n+    object matrix_type = module::import(\"scipy.sparse\")\n+                             .attr(rowMajor ? \"csr_matrix\" : \"csc_matrix\");\n+\n+    array data(src.nonZeros(), src.valuePtr());\n+    array outerIndices((rowMajor ? src.rows() : src.cols()) + 1,\n+                       src.outerIndexPtr());\n+    array innerIndices(src.nonZeros(), src.innerIndexPtr());\n+\n+    return matrix_type(std::make_tuple(data, innerIndices, outerIndices),\n+                       std::make_pair(src.rows(), src.cols()))\n+        .release();\n+  }\n+\n+  PYBIND11_TYPE_CASTER(Type,\n+                       _<(Type::IsRowMajor) != 0>(\"scipy.sparse.csr_matrix[\",\n+                                                  \"scipy.sparse.csc_matrix[\") +\n+                           npy_format_descriptor<Scalar>::name + _(\"]\"));\n+};\n+\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)\n+\n+#if defined(__GNUG__) || defined(__clang__)\n+#pragma GCC diagnostic pop\n+#elif defined(_MSC_VER)\n+#pragma warning(pop)\n+#endif"}, {"filename": "python/src/pybind11/embed.h", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "file_content_changes": "@@ -0,0 +1,206 @@\n+/*\n+    pybind11/embed.h: Support for embedding the interpreter\n+\n+    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"eval.h\"\n+#include \"pybind11.h\"\n+\n+#if defined(PYPY_VERSION)\n+#error Embedding the interpreter is not supported with PyPy\n+#endif\n+\n+#if PY_MAJOR_VERSION >= 3\n+#define PYBIND11_EMBEDDED_MODULE_IMPL(name)                                    \\\n+  extern \"C\" PyObject *pybind11_init_impl_##name() {                           \\\n+    return pybind11_init_wrapper_##name();                                     \\\n+  }\n+#else\n+#define PYBIND11_EMBEDDED_MODULE_IMPL(name)                                    \\\n+  extern \"C\" void pybind11_init_impl_##name() {                                \\\n+    pybind11_init_wrapper_##name();                                            \\\n+  }\n+#endif\n+\n+/** \\rst\n+    Add a new module to the table of builtins for the interpreter. Must be\n+    defined in global scope. The first macro parameter is the name of the\n+    module (without quotes). The second parameter is the variable which will\n+    be used as the interface to add functions and classes to the module.\n+\n+    .. code-block:: cpp\n+\n+        PYBIND11_EMBEDDED_MODULE(example, m) {\n+            // ... initialize functions and classes here\n+            m.def(\"foo\", []() {\n+                return \"Hello, World!\";\n+            });\n+        }\n+ \\endrst */\n+#define PYBIND11_EMBEDDED_MODULE(name, variable)                               \\\n+  static void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &);       \\\n+  static PyObject PYBIND11_CONCAT(*pybind11_init_wrapper_, name)() {           \\\n+    auto m = pybind11::module(PYBIND11_TOSTRING(name));                        \\\n+    try {                                                                      \\\n+      PYBIND11_CONCAT(pybind11_init_, name)(m);                                \\\n+      return m.ptr();                                                          \\\n+    } catch (pybind11::error_already_set & e) {                                \\\n+      PyErr_SetString(PyExc_ImportError, e.what());                            \\\n+      return nullptr;                                                          \\\n+    } catch (const std::exception &e) {                                        \\\n+      PyErr_SetString(PyExc_ImportError, e.what());                            \\\n+      return nullptr;                                                          \\\n+    }                                                                          \\\n+  }                                                                            \\\n+  PYBIND11_EMBEDDED_MODULE_IMPL(name)                                          \\\n+  pybind11::detail::embedded_module name(                                      \\\n+      PYBIND11_TOSTRING(name), PYBIND11_CONCAT(pybind11_init_impl_, name));    \\\n+  void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module & variable)\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+/// Python 2.7/3.x compatible version of `PyImport_AppendInittab` and error\n+/// checks.\n+struct embedded_module {\n+#if PY_MAJOR_VERSION >= 3\n+  using init_t = PyObject *(*)();\n+#else\n+  using init_t = void (*)();\n+#endif\n+  embedded_module(const char *name, init_t init) {\n+    if (Py_IsInitialized())\n+      pybind11_fail(\n+          \"Can't add new modules after the interpreter has been initialized\");\n+\n+    auto result = PyImport_AppendInittab(name, init);\n+    if (result == -1)\n+      pybind11_fail(\"Insufficient memory to add a new module\");\n+  }\n+};\n+\n+NAMESPACE_END(detail)\n+\n+/** \\rst\n+    Initialize the Python interpreter. No other pybind11 or CPython API\n+ functions can be called before this is done; with the exception of\n+ `PYBIND11_EMBEDDED_MODULE`. The optional parameter can be used to skip the\n+ registration of signal handlers (see the `Python documentation`_ for details).\n+ Calling this function again after the interpreter has already been initialized\n+ is a fatal error.\n+\n+    If initializing the Python interpreter fails, then the program is\n+ terminated.  (This is controlled by the CPython runtime and is an exception to\n+ pybind11's normal behavior of throwing exceptions on errors.)\n+\n+    .. _Python documentation:\n+ https://docs.python.org/3/c-api/init.html#c.Py_InitializeEx \\endrst */\n+inline void initialize_interpreter(bool init_signal_handlers = true) {\n+  if (Py_IsInitialized())\n+    pybind11_fail(\"The interpreter is already running\");\n+\n+  Py_InitializeEx(init_signal_handlers ? 1 : 0);\n+\n+  // Make .py files in the working directory available by default\n+  module::import(\"sys\").attr(\"path\").cast<list>().append(\".\");\n+}\n+\n+/** \\rst\n+    Shut down the Python interpreter. No pybind11 or CPython API functions can\n+ be called after this. In addition, pybind11 objects must not outlive the\n+ interpreter:\n+\n+    .. code-block:: cpp\n+\n+        { // BAD\n+            py::initialize_interpreter();\n+            auto hello = py::str(\"Hello, World!\");\n+            py::finalize_interpreter();\n+        } // <-- BOOM, hello's destructor is called after interpreter shutdown\n+\n+        { // GOOD\n+            py::initialize_interpreter();\n+            { // scoped\n+                auto hello = py::str(\"Hello, World!\");\n+            } // <-- OK, hello is cleaned up properly\n+            py::finalize_interpreter();\n+        }\n+\n+        { // BETTER\n+            py::scoped_interpreter guard{};\n+            auto hello = py::str(\"Hello, World!\");\n+        }\n+\n+    .. warning::\n+\n+        The interpreter can be restarted by calling `initialize_interpreter`\n+ again. Modules created using pybind11 can be safely re-initialized. However,\n+ Python itself cannot completely unload binary extension modules and there are\n+ several caveats with regard to interpreter restarting. All the details can be\n+ found in the CPython documentation. In short, not all interpreter memory may be\n+        freed, either due to reference cycles or user-created global data.\n+\n+ \\endrst */\n+inline void finalize_interpreter() {\n+  handle builtins(PyEval_GetBuiltins());\n+  const char *id = PYBIND11_INTERNALS_ID;\n+\n+  // Get the internals pointer (without creating it if it doesn't exist).  It's\n+  // possible for the internals to be created during Py_Finalize() (e.g. if a\n+  // py::capsule calls `get_internals()` during destruction), so we get the\n+  // pointer-pointer here and check it after Py_Finalize().\n+  detail::internals **internals_ptr_ptr = detail::get_internals_pp();\n+  // It could also be stashed in builtins, so look there too:\n+  if (builtins.contains(id) && isinstance<capsule>(builtins[id]))\n+    internals_ptr_ptr = capsule(builtins[id]);\n+\n+  Py_Finalize();\n+\n+  if (internals_ptr_ptr) {\n+    delete *internals_ptr_ptr;\n+    *internals_ptr_ptr = nullptr;\n+  }\n+}\n+\n+/** \\rst\n+    Scope guard version of `initialize_interpreter` and `finalize_interpreter`.\n+    This a move-only guard and only a single instance can exist.\n+\n+    .. code-block:: cpp\n+\n+        #include <pybind11/embed.h>\n+\n+        int main() {\n+            py::scoped_interpreter guard{};\n+            py::print(Hello, World!);\n+        } // <-- interpreter shutdown\n+ \\endrst */\n+class scoped_interpreter {\n+public:\n+  scoped_interpreter(bool init_signal_handlers = true) {\n+    initialize_interpreter(init_signal_handlers);\n+  }\n+\n+  scoped_interpreter(const scoped_interpreter &) = delete;\n+  scoped_interpreter(scoped_interpreter &&other) noexcept {\n+    other.is_valid = false;\n+  }\n+  scoped_interpreter &operator=(const scoped_interpreter &) = delete;\n+  scoped_interpreter &operator=(scoped_interpreter &&) = delete;\n+\n+  ~scoped_interpreter() {\n+    if (is_valid)\n+      finalize_interpreter();\n+  }\n+\n+private:\n+  bool is_valid = true;\n+};\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/eval.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "file_content_changes": "@@ -0,0 +1,134 @@\n+/*\n+    pybind11/exec.h: Support for evaluating Python expressions and statements\n+    from strings and files\n+\n+    Copyright (c) 2016 Klemens Morgenstern <klemens.morgenstern@ed-chemnitz.de>\n+   and Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+enum eval_mode {\n+  /// Evaluate a string containing an isolated expression\n+  eval_expr,\n+\n+  /// Evaluate a string containing a single statement. Returns \\c none\n+  eval_single_statement,\n+\n+  /// Evaluate a string containing a sequence of statement. Returns \\c none\n+  eval_statements\n+};\n+\n+template <eval_mode mode = eval_expr>\n+object eval(str expr, object global = globals(), object local = object()) {\n+  if (!local)\n+    local = global;\n+\n+  /* PyRun_String does not accept a PyObject / encoding specifier,\n+     this seems to be the only alternative */\n+  std::string buffer = \"# -*- coding: utf-8 -*-\\n\" + (std::string)expr;\n+\n+  int start;\n+  switch (mode) {\n+  case eval_expr:\n+    start = Py_eval_input;\n+    break;\n+  case eval_single_statement:\n+    start = Py_single_input;\n+    break;\n+  case eval_statements:\n+    start = Py_file_input;\n+    break;\n+  default:\n+    pybind11_fail(\"invalid evaluation mode\");\n+  }\n+\n+  PyObject *result =\n+      PyRun_String(buffer.c_str(), start, global.ptr(), local.ptr());\n+  if (!result)\n+    throw error_already_set();\n+  return reinterpret_steal<object>(result);\n+}\n+\n+template <eval_mode mode = eval_expr, size_t N>\n+object eval(const char (&s)[N], object global = globals(),\n+            object local = object()) {\n+  /* Support raw string literals by removing common leading whitespace */\n+  auto expr = (s[0] == '\\n') ? str(module::import(\"textwrap\").attr(\"dedent\")(s))\n+                             : str(s);\n+  return eval<mode>(expr, global, local);\n+}\n+\n+inline void exec(str expr, object global = globals(), object local = object()) {\n+  eval<eval_statements>(expr, global, local);\n+}\n+\n+template <size_t N>\n+void exec(const char (&s)[N], object global = globals(),\n+          object local = object()) {\n+  eval<eval_statements>(s, global, local);\n+}\n+\n+template <eval_mode mode = eval_statements>\n+object eval_file(str fname, object global = globals(),\n+                 object local = object()) {\n+  if (!local)\n+    local = global;\n+\n+  int start;\n+  switch (mode) {\n+  case eval_expr:\n+    start = Py_eval_input;\n+    break;\n+  case eval_single_statement:\n+    start = Py_single_input;\n+    break;\n+  case eval_statements:\n+    start = Py_file_input;\n+    break;\n+  default:\n+    pybind11_fail(\"invalid evaluation mode\");\n+  }\n+\n+  int closeFile = 1;\n+  std::string fname_str = (std::string)fname;\n+#if PY_VERSION_HEX >= 0x03040000\n+  FILE *f = _Py_fopen_obj(fname.ptr(), \"r\");\n+#elif PY_VERSION_HEX >= 0x03000000\n+  FILE *f = _Py_fopen(fname.ptr(), \"r\");\n+#else\n+  /* No unicode support in open() :( */\n+  auto fobj = reinterpret_steal<object>(PyFile_FromString(\n+      const_cast<char *>(fname_str.c_str()), const_cast<char *>(\"r\")));\n+  FILE *f = nullptr;\n+  if (fobj)\n+    f = PyFile_AsFile(fobj.ptr());\n+  closeFile = 0;\n+#endif\n+  if (!f) {\n+    PyErr_Clear();\n+    pybind11_fail(\"File \\\"\" + fname_str + \"\\\" could not be opened!\");\n+  }\n+\n+#if PY_VERSION_HEX < 0x03000000 && defined(PYPY_VERSION)\n+  PyObject *result =\n+      PyRun_File(f, fname_str.c_str(), start, global.ptr(), local.ptr());\n+  (void)closeFile;\n+#else\n+  PyObject *result = PyRun_FileEx(f, fname_str.c_str(), start, global.ptr(),\n+                                  local.ptr(), closeFile);\n+#endif\n+\n+  if (!result)\n+    throw error_already_set();\n+  return reinterpret_steal<object>(result);\n+}\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/functional.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "file_content_changes": "@@ -0,0 +1,116 @@\n+/*\n+    pybind11/functional.h: std::function<> support\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+#include <functional>\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+template <typename Return, typename... Args>\n+struct type_caster<std::function<Return(Args...)>> {\n+  using type = std::function<Return(Args...)>;\n+  using retval_type =\n+      conditional_t<std::is_same<Return, void>::value, void_type, Return>;\n+  using function_type = Return (*)(Args...);\n+\n+public:\n+  bool load(handle src, bool convert) {\n+    if (src.is_none()) {\n+      // Defer accepting None to other overloads (if we aren't in convert mode):\n+      if (!convert)\n+        return false;\n+      return true;\n+    }\n+\n+    if (!isinstance<function>(src))\n+      return false;\n+\n+    auto func = reinterpret_borrow<function>(src);\n+\n+    /*\n+       When passing a C++ function as an argument to another C++\n+       function via Python, every function call would normally involve\n+       a full C++ -> Python -> C++ roundtrip, which can be prohibitive.\n+       Here, we try to at least detect the case where the function is\n+       stateless (i.e. function pointer or lambda function without\n+       captured variables), in which case the roundtrip can be avoided.\n+     */\n+    if (auto cfunc = func.cpp_function()) {\n+      auto c = reinterpret_borrow<capsule>(PyCFunction_GET_SELF(cfunc.ptr()));\n+      auto rec = (function_record *)c;\n+\n+      if (rec && rec->is_stateless &&\n+          same_type(typeid(function_type),\n+                    *reinterpret_cast<const std::type_info *>(rec->data[1]))) {\n+        struct capture {\n+          function_type f;\n+        };\n+        value = ((capture *)&rec->data)->f;\n+        return true;\n+      }\n+    }\n+\n+    // ensure GIL is held during functor destruction\n+    struct func_handle {\n+      function f;\n+      func_handle(function &&f_) : f(std::move(f_)) {}\n+      func_handle(const func_handle &) = default;\n+      ~func_handle() {\n+        gil_scoped_acquire acq;\n+        function kill_f(std::move(f));\n+      }\n+    };\n+\n+    // value = [hfunc = func_handle(std::move(func))](Args... args) -> Return {\n+    //     gil_scoped_acquire acq;\n+    //     object retval(hfunc.f(std::forward<Args>(args)...));\n+    //     /* Visual studio 2015 parser issue: need parentheses around this\n+    //     expression */ return (retval.template cast<Return>());\n+    // };\n+\n+    struct func_wrapper {\n+      func_handle hfunc;\n+      func_wrapper(func_handle &&hf) : hfunc(std::move(hf)) {}\n+      Return operator()(Args... args) const {\n+        gil_scoped_acquire acq;\n+        object retval(hfunc.f(std::forward<Args>(args)...));\n+        /* Visual studio 2015 parser issue: need parentheses around this\n+         * expression */\n+        return (retval.template cast<Return>());\n+      }\n+    };\n+\n+    value = func_wrapper(func_handle(std::move(func)));\n+\n+    return true;\n+  }\n+\n+  template <typename Func>\n+  static handle cast(Func &&f_, return_value_policy policy,\n+                     handle /* parent */) {\n+    if (!f_)\n+      return none().inc_ref();\n+\n+    auto result = f_.template target<function_type>();\n+    if (result)\n+      return cpp_function(*result, policy).release();\n+    else\n+      return cpp_function(std::forward<Func>(f_), policy).release();\n+  }\n+\n+  PYBIND11_TYPE_CASTER(type, _(\"Callable[[\") +\n+                                 concat(make_caster<Args>::name...) + _(\"], \") +\n+                                 make_caster<retval_type>::name + _(\"]\"));\n+};\n+\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/iostream.h", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "file_content_changes": "@@ -0,0 +1,201 @@\n+/*\n+    pybind11/iostream.h -- Tools to assist with redirecting cout and cerr to\n+   Python\n+\n+    Copyright (c) 2017 Henry F. Schreiner\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+#include <iostream>\n+#include <memory>\n+#include <ostream>\n+#include <streambuf>\n+#include <string>\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+// Buffer that writes to Python instead of C++\n+class pythonbuf : public std::streambuf {\n+private:\n+  using traits_type = std::streambuf::traits_type;\n+\n+  const size_t buf_size;\n+  std::unique_ptr<char[]> d_buffer;\n+  object pywrite;\n+  object pyflush;\n+\n+  int overflow(int c) {\n+    if (!traits_type::eq_int_type(c, traits_type::eof())) {\n+      *pptr() = traits_type::to_char_type(c);\n+      pbump(1);\n+    }\n+    return sync() == 0 ? traits_type::not_eof(c) : traits_type::eof();\n+  }\n+\n+  int sync() {\n+    if (pbase() != pptr()) {\n+      // This subtraction cannot be negative, so dropping the sign\n+      str line(pbase(), static_cast<size_t>(pptr() - pbase()));\n+\n+      {\n+        gil_scoped_acquire tmp;\n+        pywrite(line);\n+        pyflush();\n+      }\n+\n+      setp(pbase(), epptr());\n+    }\n+    return 0;\n+  }\n+\n+public:\n+  pythonbuf(object pyostream, size_t buffer_size = 1024)\n+      : buf_size(buffer_size), d_buffer(new char[buf_size]),\n+        pywrite(pyostream.attr(\"write\")), pyflush(pyostream.attr(\"flush\")) {\n+    setp(d_buffer.get(), d_buffer.get() + buf_size - 1);\n+  }\n+\n+  /// Sync before destroy\n+  ~pythonbuf() { sync(); }\n+};\n+\n+NAMESPACE_END(detail)\n+\n+/** \\rst\n+    This a move-only guard that redirects output.\n+\n+    .. code-block:: cpp\n+\n+        #include <pybind11/iostream.h>\n+\n+        ...\n+\n+        {\n+            py::scoped_ostream_redirect output;\n+            std::cout << \"Hello, World!\"; // Python stdout\n+        } // <-- return std::cout to normal\n+\n+    You can explicitly pass the c++ stream and the python object,\n+    for example to guard stderr instead.\n+\n+    .. code-block:: cpp\n+\n+        {\n+            py::scoped_ostream_redirect output{std::cerr,\n+ py::module::import(\"sys\").attr(\"stderr\")}; std::cerr << \"Hello, World!\";\n+        }\n+ \\endrst */\n+class scoped_ostream_redirect {\n+protected:\n+  std::streambuf *old;\n+  std::ostream &costream;\n+  detail::pythonbuf buffer;\n+\n+public:\n+  scoped_ostream_redirect(\n+      std::ostream &costream = std::cout,\n+      object pyostream = module::import(\"sys\").attr(\"stdout\"))\n+      : costream(costream), buffer(pyostream) {\n+    old = costream.rdbuf(&buffer);\n+  }\n+\n+  ~scoped_ostream_redirect() { costream.rdbuf(old); }\n+\n+  scoped_ostream_redirect(const scoped_ostream_redirect &) = delete;\n+  scoped_ostream_redirect(scoped_ostream_redirect &&other) = default;\n+  scoped_ostream_redirect &operator=(const scoped_ostream_redirect &) = delete;\n+  scoped_ostream_redirect &operator=(scoped_ostream_redirect &&) = delete;\n+};\n+\n+/** \\rst\n+    Like `scoped_ostream_redirect`, but redirects cerr by default. This class\n+    is provided primary to make ``py::call_guard`` easier to make.\n+\n+    .. code-block:: cpp\n+\n+     m.def(\"noisy_func\", &noisy_func,\n+           py::call_guard<scoped_ostream_redirect,\n+                          scoped_estream_redirect>());\n+\n+\\endrst */\n+class scoped_estream_redirect : public scoped_ostream_redirect {\n+public:\n+  scoped_estream_redirect(\n+      std::ostream &costream = std::cerr,\n+      object pyostream = module::import(\"sys\").attr(\"stderr\"))\n+      : scoped_ostream_redirect(costream, pyostream) {}\n+};\n+\n+NAMESPACE_BEGIN(detail)\n+\n+// Class to redirect output as a context manager. C++ backend.\n+class OstreamRedirect {\n+  bool do_stdout_;\n+  bool do_stderr_;\n+  std::unique_ptr<scoped_ostream_redirect> redirect_stdout;\n+  std::unique_ptr<scoped_estream_redirect> redirect_stderr;\n+\n+public:\n+  OstreamRedirect(bool do_stdout = true, bool do_stderr = true)\n+      : do_stdout_(do_stdout), do_stderr_(do_stderr) {}\n+\n+  void enter() {\n+    if (do_stdout_)\n+      redirect_stdout.reset(new scoped_ostream_redirect());\n+    if (do_stderr_)\n+      redirect_stderr.reset(new scoped_estream_redirect());\n+  }\n+\n+  void exit() {\n+    redirect_stdout.reset();\n+    redirect_stderr.reset();\n+  }\n+};\n+\n+NAMESPACE_END(detail)\n+\n+/** \\rst\n+    This is a helper function to add a C++ redirect context manager to Python\n+    instead of using a C++ guard. To use it, add the following to your binding\n+ code:\n+\n+    .. code-block:: cpp\n+\n+        #include <pybind11/iostream.h>\n+\n+        ...\n+\n+        py::add_ostream_redirect(m, \"ostream_redirect\");\n+\n+    You now have a Python context manager that redirects your output:\n+\n+    .. code-block:: python\n+\n+        with m.ostream_redirect():\n+            m.print_to_cout_function()\n+\n+    This manager can optionally be told which streams to operate on:\n+\n+    .. code-block:: python\n+\n+        with m.ostream_redirect(stdout=true, stderr=true):\n+            m.noisy_function_with_error_printing()\n+\n+ \\endrst */\n+inline class_<detail::OstreamRedirect>\n+add_ostream_redirect(module m, std::string name = \"ostream_redirect\") {\n+  return class_<detail::OstreamRedirect>(m, name.c_str(), module_local())\n+      .def(init<bool, bool>(), arg(\"stdout\") = true, arg(\"stderr\") = true)\n+      .def(\"__enter__\", &detail::OstreamRedirect::enter)\n+      .def(\"__exit__\",\n+           [](detail::OstreamRedirect &self_, args) { self_.exit(); });\n+}\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/numpy.h", "status": "added", "additions": 1789, "deletions": 0, "changes": 1789, "file_content_changes": "@@ -0,0 +1,1789 @@\n+/*\n+    pybind11/numpy.h: Basic NumPy support, vectorize() wrapper\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"complex.h\"\n+#include \"pybind11.h\"\n+#include <algorithm>\n+#include <array>\n+#include <cstdlib>\n+#include <cstring>\n+#include <functional>\n+#include <numeric>\n+#include <sstream>\n+#include <string>\n+#include <typeindex>\n+#include <utility>\n+#include <vector>\n+\n+#if defined(_MSC_VER)\n+#pragma warning(push)\n+#pragma warning(                                                               \\\n+    disable : 4127) // warning C4127: Conditional expression is constant\n+#endif\n+\n+/* This will be true on all flat address space platforms and allows us to reduce\n+   the whole npy_intp / ssize_t / Py_intptr_t business down to just ssize_t for\n+   all size and dimension types (e.g. shape, strides, indexing), instead of\n+   inflicting this upon the library user. */\n+static_assert(sizeof(ssize_t) == sizeof(Py_intptr_t), \"ssize_t != Py_intptr_t\");\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+class array; // Forward declaration\n+\n+NAMESPACE_BEGIN(detail)\n+template <typename type, typename SFINAE = void> struct npy_format_descriptor;\n+\n+struct PyArrayDescr_Proxy {\n+  PyObject_HEAD PyObject *typeobj;\n+  char kind;\n+  char type;\n+  char byteorder;\n+  char flags;\n+  int type_num;\n+  int elsize;\n+  int alignment;\n+  char *subarray;\n+  PyObject *fields;\n+  PyObject *names;\n+};\n+\n+struct PyArray_Proxy {\n+  PyObject_HEAD char *data;\n+  int nd;\n+  ssize_t *dimensions;\n+  ssize_t *strides;\n+  PyObject *base;\n+  PyObject *descr;\n+  int flags;\n+};\n+\n+struct PyVoidScalarObject_Proxy {\n+  PyObject_VAR_HEAD char *obval;\n+  PyArrayDescr_Proxy *descr;\n+  int flags;\n+  PyObject *base;\n+};\n+\n+struct numpy_type_info {\n+  PyObject *dtype_ptr;\n+  std::string format_str;\n+};\n+\n+struct numpy_internals {\n+  std::unordered_map<std::type_index, numpy_type_info> registered_dtypes;\n+\n+  numpy_type_info *get_type_info(const std::type_info &tinfo,\n+                                 bool throw_if_missing = true) {\n+    auto it = registered_dtypes.find(std::type_index(tinfo));\n+    if (it != registered_dtypes.end())\n+      return &(it->second);\n+    if (throw_if_missing)\n+      pybind11_fail(std::string(\"NumPy type info missing for \") + tinfo.name());\n+    return nullptr;\n+  }\n+\n+  template <typename T>\n+  numpy_type_info *get_type_info(bool throw_if_missing = true) {\n+    return get_type_info(typeid(typename std::remove_cv<T>::type),\n+                         throw_if_missing);\n+  }\n+};\n+\n+inline PYBIND11_NOINLINE void load_numpy_internals(numpy_internals *&ptr) {\n+  ptr = &get_or_create_shared_data<numpy_internals>(\"_numpy_internals\");\n+}\n+\n+inline numpy_internals &get_numpy_internals() {\n+  static numpy_internals *ptr = nullptr;\n+  if (!ptr)\n+    load_numpy_internals(ptr);\n+  return *ptr;\n+}\n+\n+struct npy_api {\n+  enum constants {\n+    NPY_ARRAY_C_CONTIGUOUS_ = 0x0001,\n+    NPY_ARRAY_F_CONTIGUOUS_ = 0x0002,\n+    NPY_ARRAY_OWNDATA_ = 0x0004,\n+    NPY_ARRAY_FORCECAST_ = 0x0010,\n+    NPY_ARRAY_ENSUREARRAY_ = 0x0040,\n+    NPY_ARRAY_ALIGNED_ = 0x0100,\n+    NPY_ARRAY_WRITEABLE_ = 0x0400,\n+    NPY_BOOL_ = 0,\n+    NPY_BYTE_,\n+    NPY_UBYTE_,\n+    NPY_SHORT_,\n+    NPY_USHORT_,\n+    NPY_INT_,\n+    NPY_UINT_,\n+    NPY_LONG_,\n+    NPY_ULONG_,\n+    NPY_LONGLONG_,\n+    NPY_ULONGLONG_,\n+    NPY_FLOAT_,\n+    NPY_DOUBLE_,\n+    NPY_LONGDOUBLE_,\n+    NPY_CFLOAT_,\n+    NPY_CDOUBLE_,\n+    NPY_CLONGDOUBLE_,\n+    NPY_OBJECT_ = 17,\n+    NPY_STRING_,\n+    NPY_UNICODE_,\n+    NPY_VOID_\n+  };\n+\n+  typedef struct {\n+    Py_intptr_t *ptr;\n+    int len;\n+  } PyArray_Dims;\n+\n+  static npy_api &get() {\n+    static npy_api api = lookup();\n+    return api;\n+  }\n+\n+  bool PyArray_Check_(PyObject *obj) const {\n+    return (bool)PyObject_TypeCheck(obj, PyArray_Type_);\n+  }\n+  bool PyArrayDescr_Check_(PyObject *obj) const {\n+    return (bool)PyObject_TypeCheck(obj, PyArrayDescr_Type_);\n+  }\n+\n+  unsigned int (*PyArray_GetNDArrayCFeatureVersion_)();\n+  PyObject *(*PyArray_DescrFromType_)(int);\n+  PyObject *(*PyArray_NewFromDescr_)(PyTypeObject *, PyObject *, int,\n+                                     Py_intptr_t *, Py_intptr_t *, void *, int,\n+                                     PyObject *);\n+  PyObject *(*PyArray_DescrNewFromType_)(int);\n+  int (*PyArray_CopyInto_)(PyObject *, PyObject *);\n+  PyObject *(*PyArray_NewCopy_)(PyObject *, int);\n+  PyTypeObject *PyArray_Type_;\n+  PyTypeObject *PyVoidArrType_Type_;\n+  PyTypeObject *PyArrayDescr_Type_;\n+  PyObject *(*PyArray_DescrFromScalar_)(PyObject *);\n+  PyObject *(*PyArray_FromAny_)(PyObject *, PyObject *, int, int, int,\n+                                PyObject *);\n+  int (*PyArray_DescrConverter_)(PyObject *, PyObject **);\n+  bool (*PyArray_EquivTypes_)(PyObject *, PyObject *);\n+  int (*PyArray_GetArrayParamsFromObject_)(PyObject *, PyObject *, char,\n+                                           PyObject **, int *, Py_ssize_t *,\n+                                           PyObject **, PyObject *);\n+  PyObject *(*PyArray_Squeeze_)(PyObject *);\n+  int (*PyArray_SetBaseObject_)(PyObject *, PyObject *);\n+  PyObject *(*PyArray_Resize_)(PyObject *, PyArray_Dims *, int, int);\n+\n+private:\n+  enum functions {\n+    API_PyArray_GetNDArrayCFeatureVersion = 211,\n+    API_PyArray_Type = 2,\n+    API_PyArrayDescr_Type = 3,\n+    API_PyVoidArrType_Type = 39,\n+    API_PyArray_DescrFromType = 45,\n+    API_PyArray_DescrFromScalar = 57,\n+    API_PyArray_FromAny = 69,\n+    API_PyArray_Resize = 80,\n+    API_PyArray_CopyInto = 82,\n+    API_PyArray_NewCopy = 85,\n+    API_PyArray_NewFromDescr = 94,\n+    API_PyArray_DescrNewFromType = 9,\n+    API_PyArray_DescrConverter = 174,\n+    API_PyArray_EquivTypes = 182,\n+    API_PyArray_GetArrayParamsFromObject = 278,\n+    API_PyArray_Squeeze = 136,\n+    API_PyArray_SetBaseObject = 282\n+  };\n+\n+  static npy_api lookup() {\n+    module m = module::import(\"numpy.core.multiarray\");\n+    auto c = m.attr(\"_ARRAY_API\");\n+#if PY_MAJOR_VERSION >= 3\n+    void **api_ptr = (void **)PyCapsule_GetPointer(c.ptr(), NULL);\n+#else\n+    void **api_ptr = (void **)PyCObject_AsVoidPtr(c.ptr());\n+#endif\n+    npy_api api;\n+#define DECL_NPY_API(Func)                                                     \\\n+  api.Func##_ = (decltype(api.Func##_))api_ptr[API_##Func];\n+    DECL_NPY_API(PyArray_GetNDArrayCFeatureVersion);\n+    if (api.PyArray_GetNDArrayCFeatureVersion_() < 0x7)\n+      pybind11_fail(\"pybind11 numpy support requires numpy >= 1.7.0\");\n+    DECL_NPY_API(PyArray_Type);\n+    DECL_NPY_API(PyVoidArrType_Type);\n+    DECL_NPY_API(PyArrayDescr_Type);\n+    DECL_NPY_API(PyArray_DescrFromType);\n+    DECL_NPY_API(PyArray_DescrFromScalar);\n+    DECL_NPY_API(PyArray_FromAny);\n+    DECL_NPY_API(PyArray_Resize);\n+    DECL_NPY_API(PyArray_CopyInto);\n+    DECL_NPY_API(PyArray_NewCopy);\n+    DECL_NPY_API(PyArray_NewFromDescr);\n+    DECL_NPY_API(PyArray_DescrNewFromType);\n+    DECL_NPY_API(PyArray_DescrConverter);\n+    DECL_NPY_API(PyArray_EquivTypes);\n+    DECL_NPY_API(PyArray_GetArrayParamsFromObject);\n+    DECL_NPY_API(PyArray_Squeeze);\n+    DECL_NPY_API(PyArray_SetBaseObject);\n+#undef DECL_NPY_API\n+    return api;\n+  }\n+};\n+\n+inline PyArray_Proxy *array_proxy(void *ptr) {\n+  return reinterpret_cast<PyArray_Proxy *>(ptr);\n+}\n+\n+inline const PyArray_Proxy *array_proxy(const void *ptr) {\n+  return reinterpret_cast<const PyArray_Proxy *>(ptr);\n+}\n+\n+inline PyArrayDescr_Proxy *array_descriptor_proxy(PyObject *ptr) {\n+  return reinterpret_cast<PyArrayDescr_Proxy *>(ptr);\n+}\n+\n+inline const PyArrayDescr_Proxy *array_descriptor_proxy(const PyObject *ptr) {\n+  return reinterpret_cast<const PyArrayDescr_Proxy *>(ptr);\n+}\n+\n+inline bool check_flags(const void *ptr, int flag) {\n+  return (flag == (array_proxy(ptr)->flags & flag));\n+}\n+\n+template <typename T> struct is_std_array : std::false_type {};\n+template <typename T, size_t N>\n+struct is_std_array<std::array<T, N>> : std::true_type {};\n+template <typename T> struct is_complex : std::false_type {};\n+template <typename T> struct is_complex<std::complex<T>> : std::true_type {};\n+\n+template <typename T> struct array_info_scalar {\n+  typedef T type;\n+  static constexpr bool is_array = false;\n+  static constexpr bool is_empty = false;\n+  static constexpr auto extents = _(\"\");\n+  static void append_extents(list & /* shape */) {}\n+};\n+// Computes underlying type and a comma-separated list of extents for array\n+// types (any mix of std::array and built-in arrays). An array of char is\n+// treated as scalar because it gets special handling.\n+template <typename T> struct array_info : array_info_scalar<T> {};\n+template <typename T, size_t N> struct array_info<std::array<T, N>> {\n+  using type = typename array_info<T>::type;\n+  static constexpr bool is_array = true;\n+  static constexpr bool is_empty = (N == 0) || array_info<T>::is_empty;\n+  static constexpr size_t extent = N;\n+\n+  // appends the extents to shape\n+  static void append_extents(list &shape) {\n+    shape.append(N);\n+    array_info<T>::append_extents(shape);\n+  }\n+\n+  static constexpr auto extents = _<array_info<T>::is_array>(\n+      concat(_<N>(), array_info<T>::extents), _<N>());\n+};\n+// For numpy we have special handling for arrays of characters, so we don't\n+// include the size in the array extents.\n+template <size_t N> struct array_info<char[N]> : array_info_scalar<char[N]> {};\n+template <size_t N>\n+struct array_info<std::array<char, N>>\n+    : array_info_scalar<std::array<char, N>> {};\n+template <typename T, size_t N>\n+struct array_info<T[N]> : array_info<std::array<T, N>> {};\n+template <typename T> using remove_all_extents_t = typename array_info<T>::type;\n+\n+template <typename T>\n+using is_pod_struct =\n+    all_of<std::is_standard_layout<T>, // since we're accessing directly in\n+                                       // memory we need a standard layout type\n+#if !defined(__GNUG__) || defined(_LIBCPP_VERSION) ||                          \\\n+    defined(_GLIBCXX_USE_CXX11_ABI)\n+           // _GLIBCXX_USE_CXX11_ABI indicates that we're using libstdc++ from\n+           // GCC 5 or newer, independent of the actual compiler (Clang can also\n+           // use libstdc++, but it always defines __GNUC__ == 4).\n+           std::is_trivially_copyable<T>,\n+#else\n+           // GCC 4 doesn't implement is_trivially_copyable, so approximate it\n+           std::is_trivially_destructible<T>,\n+           satisfies_any_of<T, std::has_trivial_copy_constructor,\n+                            std::has_trivial_copy_assign>,\n+#endif\n+           satisfies_none_of<T, std::is_reference, std::is_array, is_std_array,\n+                             std::is_arithmetic, is_complex, std::is_enum>>;\n+\n+template <ssize_t Dim = 0, typename Strides>\n+ssize_t byte_offset_unsafe(const Strides &) {\n+  return 0;\n+}\n+template <ssize_t Dim = 0, typename Strides, typename... Ix>\n+ssize_t byte_offset_unsafe(const Strides &strides, ssize_t i, Ix... index) {\n+  return i * strides[Dim] + byte_offset_unsafe<Dim + 1>(strides, index...);\n+}\n+\n+/**\n+ * Proxy class providing unsafe, unchecked const access to array data.  This is\n+ * constructed through the `unchecked<T, N>()` method of `array` or the\n+ * `unchecked<N>()` method of `array_t<T>`.  `Dims` will be -1 for dimensions\n+ * determined at runtime.\n+ */\n+template <typename T, ssize_t Dims> class unchecked_reference {\n+protected:\n+  static constexpr bool Dynamic = Dims < 0;\n+  const unsigned char *data_;\n+  // Storing the shape & strides in local variables (i.e. these arrays) allows\n+  // the compiler to make large performance gains on big, nested loops, but\n+  // requires compile-time dimensions\n+  conditional_t<Dynamic, const ssize_t *, std::array<ssize_t, (size_t)Dims>>\n+      shape_, strides_;\n+  const ssize_t dims_;\n+\n+  friend class pybind11::array;\n+  // Constructor for compile-time dimensions:\n+  template <bool Dyn = Dynamic>\n+  unchecked_reference(const void *data, const ssize_t *shape,\n+                      const ssize_t *strides, enable_if_t<!Dyn, ssize_t>)\n+      : data_{reinterpret_cast<const unsigned char *>(data)}, dims_{Dims} {\n+    for (size_t i = 0; i < (size_t)dims_; i++) {\n+      shape_[i] = shape[i];\n+      strides_[i] = strides[i];\n+    }\n+  }\n+  // Constructor for runtime dimensions:\n+  template <bool Dyn = Dynamic>\n+  unchecked_reference(const void *data, const ssize_t *shape,\n+                      const ssize_t *strides, enable_if_t<Dyn, ssize_t> dims)\n+      : data_{reinterpret_cast<const unsigned char *>(data)}, shape_{shape},\n+        strides_{strides}, dims_{dims} {}\n+\n+public:\n+  /**\n+   * Unchecked const reference access to data at the given indices.  For a\n+   * compile-time known number of dimensions, this requires the correct number\n+   * of arguments; for run-time dimensionality, this is not checked (and so is\n+   * up to the caller to use safely).\n+   */\n+  template <typename... Ix> const T &operator()(Ix... index) const {\n+    static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,\n+                  \"Invalid number of indices for unchecked array reference\");\n+    return *reinterpret_cast<const T *>(\n+        data_ + byte_offset_unsafe(strides_, ssize_t(index)...));\n+  }\n+  /**\n+   * Unchecked const reference access to data; this operator only participates\n+   * if the reference is to a 1-dimensional array.  When present, this is\n+   * exactly equivalent to `obj(index)`.\n+   */\n+  template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>\n+  const T &operator[](ssize_t index) const {\n+    return operator()(index);\n+  }\n+\n+  /// Pointer access to the data at the given indices.\n+  template <typename... Ix> const T *data(Ix... ix) const {\n+    return &operator()(ssize_t(ix)...);\n+  }\n+\n+  /// Returns the item size, i.e. sizeof(T)\n+  constexpr static ssize_t itemsize() { return sizeof(T); }\n+\n+  /// Returns the shape (i.e. size) of dimension `dim`\n+  ssize_t shape(ssize_t dim) const { return shape_[(size_t)dim]; }\n+\n+  /// Returns the number of dimensions of the array\n+  ssize_t ndim() const { return dims_; }\n+\n+  /// Returns the total number of elements in the referenced array, i.e. the\n+  /// product of the shapes\n+  template <bool Dyn = Dynamic> enable_if_t<!Dyn, ssize_t> size() const {\n+    return std::accumulate(shape_.begin(), shape_.end(), (ssize_t)1,\n+                           std::multiplies<ssize_t>());\n+  }\n+  template <bool Dyn = Dynamic> enable_if_t<Dyn, ssize_t> size() const {\n+    return std::accumulate(shape_, shape_ + ndim(), (ssize_t)1,\n+                           std::multiplies<ssize_t>());\n+  }\n+\n+  /// Returns the total number of bytes used by the referenced data.  Note that\n+  /// the actual span in memory may be larger if the referenced array has\n+  /// non-contiguous strides (e.g. for a slice).\n+  ssize_t nbytes() const { return size() * itemsize(); }\n+};\n+\n+template <typename T, ssize_t Dims>\n+class unchecked_mutable_reference : public unchecked_reference<T, Dims> {\n+  friend class pybind11::array;\n+  using ConstBase = unchecked_reference<T, Dims>;\n+  using ConstBase::ConstBase;\n+  using ConstBase::Dynamic;\n+\n+public:\n+  /// Mutable, unchecked access to data at the given indices.\n+  template <typename... Ix> T &operator()(Ix... index) {\n+    static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,\n+                  \"Invalid number of indices for unchecked array reference\");\n+    return const_cast<T &>(ConstBase::operator()(index...));\n+  }\n+  /**\n+   * Mutable, unchecked access data at the given index; this operator only\n+   * participates if the reference is to a 1-dimensional array (or has runtime\n+   * dimensions).  When present, this is exactly equivalent to `obj(index)`.\n+   */\n+  template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>\n+  T &operator[](ssize_t index) {\n+    return operator()(index);\n+  }\n+\n+  /// Mutable pointer access to the data at the given indices.\n+  template <typename... Ix> T *mutable_data(Ix... ix) {\n+    return &operator()(ssize_t(ix)...);\n+  }\n+};\n+\n+template <typename T, ssize_t Dim>\n+struct type_caster<unchecked_reference<T, Dim>> {\n+  static_assert(Dim == 0 && Dim > 0 /* always fail */,\n+                \"unchecked array proxy object is not castable\");\n+};\n+template <typename T, ssize_t Dim>\n+struct type_caster<unchecked_mutable_reference<T, Dim>>\n+    : type_caster<unchecked_reference<T, Dim>> {};\n+\n+NAMESPACE_END(detail)\n+\n+class dtype : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(dtype, object,\n+                          detail::npy_api::get().PyArrayDescr_Check_);\n+\n+  explicit dtype(const buffer_info &info) {\n+    dtype descr(_dtype_from_pep3118()(PYBIND11_STR_TYPE(info.format)));\n+    // If info.itemsize == 0, use the value calculated from the format string\n+    m_ptr =\n+        descr.strip_padding(info.itemsize ? info.itemsize : descr.itemsize())\n+            .release()\n+            .ptr();\n+  }\n+\n+  explicit dtype(const std::string &format) {\n+    m_ptr = from_args(pybind11::str(format)).release().ptr();\n+  }\n+\n+  dtype(const char *format) : dtype(std::string(format)) {}\n+\n+  dtype(list names, list formats, list offsets, ssize_t itemsize) {\n+    dict args;\n+    args[\"names\"] = names;\n+    args[\"formats\"] = formats;\n+    args[\"offsets\"] = offsets;\n+    args[\"itemsize\"] = pybind11::int_(itemsize);\n+    m_ptr = from_args(args).release().ptr();\n+  }\n+\n+  /// This is essentially the same as calling numpy.dtype(args) in Python.\n+  static dtype from_args(object args) {\n+    PyObject *ptr = nullptr;\n+    if (!detail::npy_api::get().PyArray_DescrConverter_(args.ptr(), &ptr) ||\n+        !ptr)\n+      throw error_already_set();\n+    return reinterpret_steal<dtype>(ptr);\n+  }\n+\n+  /// Return dtype associated with a C++ type.\n+  template <typename T> static dtype of() {\n+    return detail::npy_format_descriptor<\n+        typename std::remove_cv<T>::type>::dtype();\n+  }\n+\n+  /// Size of the data type in bytes.\n+  ssize_t itemsize() const {\n+    return detail::array_descriptor_proxy(m_ptr)->elsize;\n+  }\n+\n+  /// Returns true for structured data types.\n+  bool has_fields() const {\n+    return detail::array_descriptor_proxy(m_ptr)->names != nullptr;\n+  }\n+\n+  /// Single-character type code.\n+  char kind() const { return detail::array_descriptor_proxy(m_ptr)->kind; }\n+\n+private:\n+  static object _dtype_from_pep3118() {\n+    static PyObject *obj = module::import(\"numpy.core._internal\")\n+                               .attr(\"_dtype_from_pep3118\")\n+                               .cast<object>()\n+                               .release()\n+                               .ptr();\n+    return reinterpret_borrow<object>(obj);\n+  }\n+\n+  dtype strip_padding(ssize_t itemsize) {\n+    // Recursively strip all void fields with empty names that are generated for\n+    // padding fields (as of NumPy v1.11).\n+    if (!has_fields())\n+      return *this;\n+\n+    struct field_descr {\n+      PYBIND11_STR_TYPE name;\n+      object format;\n+      pybind11::int_ offset;\n+    };\n+    std::vector<field_descr> field_descriptors;\n+\n+    for (auto field : attr(\"fields\").attr(\"items\")()) {\n+      auto spec = field.cast<tuple>();\n+      auto name = spec[0].cast<pybind11::str>();\n+      auto format = spec[1].cast<tuple>()[0].cast<dtype>();\n+      auto offset = spec[1].cast<tuple>()[1].cast<pybind11::int_>();\n+      if (!len(name) && format.kind() == 'V')\n+        continue;\n+      field_descriptors.push_back({(PYBIND11_STR_TYPE)name,\n+                                   format.strip_padding(format.itemsize()),\n+                                   offset});\n+    }\n+\n+    std::sort(field_descriptors.begin(), field_descriptors.end(),\n+              [](const field_descr &a, const field_descr &b) {\n+                return a.offset.cast<int>() < b.offset.cast<int>();\n+              });\n+\n+    list names, formats, offsets;\n+    for (auto &descr : field_descriptors) {\n+      names.append(descr.name);\n+      formats.append(descr.format);\n+      offsets.append(descr.offset);\n+    }\n+    return dtype(names, formats, offsets, itemsize);\n+  }\n+};\n+\n+class array : public buffer {\n+public:\n+  PYBIND11_OBJECT_CVT(array, buffer, detail::npy_api::get().PyArray_Check_,\n+                      raw_array)\n+\n+  enum {\n+    c_style = detail::npy_api::NPY_ARRAY_C_CONTIGUOUS_,\n+    f_style = detail::npy_api::NPY_ARRAY_F_CONTIGUOUS_,\n+    forcecast = detail::npy_api::NPY_ARRAY_FORCECAST_\n+  };\n+\n+  array() : array({{0}}, static_cast<const double *>(nullptr)) {}\n+\n+  using ShapeContainer = detail::any_container<ssize_t>;\n+  using StridesContainer = detail::any_container<ssize_t>;\n+\n+  // Constructs an array taking shape/strides from arbitrary container types\n+  array(const pybind11::dtype &dt, ShapeContainer shape,\n+        StridesContainer strides, const void *ptr = nullptr,\n+        handle base = handle()) {\n+\n+    if (strides->empty())\n+      *strides = c_strides(*shape, dt.itemsize());\n+\n+    auto ndim = shape->size();\n+    if (ndim != strides->size())\n+      pybind11_fail(\"NumPy: shape ndim doesn't match strides ndim\");\n+    auto descr = dt;\n+\n+    int flags = 0;\n+    if (base && ptr) {\n+      if (isinstance<array>(base))\n+        /* Copy flags from base (except ownership bit) */\n+        flags = reinterpret_borrow<array>(base).flags() &\n+                ~detail::npy_api::NPY_ARRAY_OWNDATA_;\n+      else\n+        /* Writable by default, easy to downgrade later on if needed */\n+        flags = detail::npy_api::NPY_ARRAY_WRITEABLE_;\n+    }\n+\n+    auto &api = detail::npy_api::get();\n+    auto tmp = reinterpret_steal<object>(api.PyArray_NewFromDescr_(\n+        api.PyArray_Type_, descr.release().ptr(), (int)ndim, shape->data(),\n+        strides->data(), const_cast<void *>(ptr), flags, nullptr));\n+    if (!tmp)\n+      throw error_already_set();\n+    if (ptr) {\n+      if (base) {\n+        api.PyArray_SetBaseObject_(tmp.ptr(), base.inc_ref().ptr());\n+      } else {\n+        tmp = reinterpret_steal<object>(\n+            api.PyArray_NewCopy_(tmp.ptr(), -1 /* any order */));\n+      }\n+    }\n+    m_ptr = tmp.release().ptr();\n+  }\n+\n+  array(const pybind11::dtype &dt, ShapeContainer shape,\n+        const void *ptr = nullptr, handle base = handle())\n+      : array(dt, std::move(shape), {}, ptr, base) {}\n+\n+  template <typename T,\n+            typename = detail::enable_if_t<std::is_integral<T>::value &&\n+                                           !std::is_same<bool, T>::value>>\n+  array(const pybind11::dtype &dt, T count, const void *ptr = nullptr,\n+        handle base = handle())\n+      : array(dt, {{count}}, ptr, base) {}\n+\n+  template <typename T>\n+  array(ShapeContainer shape, StridesContainer strides, const T *ptr,\n+        handle base = handle())\n+      : array(pybind11::dtype::of<T>(), std::move(shape), std::move(strides),\n+              ptr, base) {}\n+\n+  template <typename T>\n+  array(ShapeContainer shape, const T *ptr, handle base = handle())\n+      : array(std::move(shape), {}, ptr, base) {}\n+\n+  template <typename T>\n+  explicit array(ssize_t count, const T *ptr, handle base = handle())\n+      : array({count}, {}, ptr, base) {}\n+\n+  explicit array(const buffer_info &info)\n+      : array(pybind11::dtype(info), info.shape, info.strides, info.ptr) {}\n+\n+  /// Array descriptor (dtype)\n+  pybind11::dtype dtype() const {\n+    return reinterpret_borrow<pybind11::dtype>(\n+        detail::array_proxy(m_ptr)->descr);\n+  }\n+\n+  /// Total number of elements\n+  ssize_t size() const {\n+    return std::accumulate(shape(), shape() + ndim(), (ssize_t)1,\n+                           std::multiplies<ssize_t>());\n+  }\n+\n+  /// Byte size of a single element\n+  ssize_t itemsize() const {\n+    return detail::array_descriptor_proxy(detail::array_proxy(m_ptr)->descr)\n+        ->elsize;\n+  }\n+\n+  /// Total number of bytes\n+  ssize_t nbytes() const { return size() * itemsize(); }\n+\n+  /// Number of dimensions\n+  ssize_t ndim() const { return detail::array_proxy(m_ptr)->nd; }\n+\n+  /// Base object\n+  object base() const {\n+    return reinterpret_borrow<object>(detail::array_proxy(m_ptr)->base);\n+  }\n+\n+  /// Dimensions of the array\n+  const ssize_t *shape() const {\n+    return detail::array_proxy(m_ptr)->dimensions;\n+  }\n+\n+  /// Dimension along a given axis\n+  ssize_t shape(ssize_t dim) const {\n+    if (dim >= ndim())\n+      fail_dim_check(dim, \"invalid axis\");\n+    return shape()[dim];\n+  }\n+\n+  /// Strides of the array\n+  const ssize_t *strides() const { return detail::array_proxy(m_ptr)->strides; }\n+\n+  /// Stride along a given axis\n+  ssize_t strides(ssize_t dim) const {\n+    if (dim >= ndim())\n+      fail_dim_check(dim, \"invalid axis\");\n+    return strides()[dim];\n+  }\n+\n+  /// Return the NumPy array flags\n+  int flags() const { return detail::array_proxy(m_ptr)->flags; }\n+\n+  /// If set, the array is writeable (otherwise the buffer is read-only)\n+  bool writeable() const {\n+    return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_WRITEABLE_);\n+  }\n+\n+  /// If set, the array owns the data (will be freed when the array is deleted)\n+  bool owndata() const {\n+    return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_OWNDATA_);\n+  }\n+\n+  /// Pointer to the contained data. If index is not provided, points to the\n+  /// beginning of the buffer. May throw if the index would lead to out of\n+  /// bounds access.\n+  template <typename... Ix> const void *data(Ix... index) const {\n+    return static_cast<const void *>(detail::array_proxy(m_ptr)->data +\n+                                     offset_at(index...));\n+  }\n+\n+  /// Mutable pointer to the contained data. If index is not provided, points to\n+  /// the beginning of the buffer. May throw if the index would lead to out of\n+  /// bounds access. May throw if the array is not writeable.\n+  template <typename... Ix> void *mutable_data(Ix... index) {\n+    check_writeable();\n+    return static_cast<void *>(detail::array_proxy(m_ptr)->data +\n+                               offset_at(index...));\n+  }\n+\n+  /// Byte offset from beginning of the array to a given index (full or\n+  /// partial). May throw if the index would lead to out of bounds access.\n+  template <typename... Ix> ssize_t offset_at(Ix... index) const {\n+    if ((ssize_t)sizeof...(index) > ndim())\n+      fail_dim_check(sizeof...(index), \"too many indices for an array\");\n+    return byte_offset(ssize_t(index)...);\n+  }\n+\n+  ssize_t offset_at() const { return 0; }\n+\n+  /// Item count from beginning of the array to a given index (full or partial).\n+  /// May throw if the index would lead to out of bounds access.\n+  template <typename... Ix> ssize_t index_at(Ix... index) const {\n+    return offset_at(index...) / itemsize();\n+  }\n+\n+  /**\n+   * Returns a proxy object that provides access to the array's data without\n+   * bounds or dimensionality checking.  Will throw if the array is missing the\n+   * `writeable` flag.  Use with care: the array must not be destroyed or\n+   * reshaped for the duration of the returned object, and the caller must take\n+   * care not to access invalid dimensions or dimension indices.\n+   */\n+  template <typename T, ssize_t Dims = -1>\n+  detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {\n+    if (Dims >= 0 && ndim() != Dims)\n+      throw std::domain_error(\"array has incorrect number of dimensions: \" +\n+                              std::to_string(ndim()) + \"; expected \" +\n+                              std::to_string(Dims));\n+    return detail::unchecked_mutable_reference<T, Dims>(mutable_data(), shape(),\n+                                                        strides(), ndim());\n+  }\n+\n+  /**\n+   * Returns a proxy object that provides const access to the array's data\n+   * without bounds or dimensionality checking.  Unlike `mutable_unchecked()`,\n+   * this does not require that the underlying array have the `writable` flag.\n+   * Use with care: the array must not be destroyed or reshaped for the duration\n+   * of the returned object, and the caller must take care not to access invalid\n+   * dimensions or dimension indices.\n+   */\n+  template <typename T, ssize_t Dims = -1>\n+  detail::unchecked_reference<T, Dims> unchecked() const & {\n+    if (Dims >= 0 && ndim() != Dims)\n+      throw std::domain_error(\"array has incorrect number of dimensions: \" +\n+                              std::to_string(ndim()) + \"; expected \" +\n+                              std::to_string(Dims));\n+    return detail::unchecked_reference<T, Dims>(data(), shape(), strides(),\n+                                                ndim());\n+  }\n+\n+  /// Return a new view with all of the dimensions of length 1 removed\n+  array squeeze() {\n+    auto &api = detail::npy_api::get();\n+    return reinterpret_steal<array>(api.PyArray_Squeeze_(m_ptr));\n+  }\n+\n+  /// Resize array to given shape\n+  /// If refcheck is true and more that one reference exist to this array\n+  /// then resize will succeed only if it makes a reshape, i.e. original size\n+  /// doesn't change\n+  void resize(ShapeContainer new_shape, bool refcheck = true) {\n+    detail::npy_api::PyArray_Dims d = {new_shape->data(),\n+                                       int(new_shape->size())};\n+    // try to resize, set ordering param to -1 cause it's not used anyway\n+    object new_array = reinterpret_steal<object>(\n+        detail::npy_api::get().PyArray_Resize_(m_ptr, &d, int(refcheck), -1));\n+    if (!new_array)\n+      throw error_already_set();\n+    if (isinstance<array>(new_array)) {\n+      *this = std::move(new_array);\n+    }\n+  }\n+\n+  /// Ensure that the argument is a NumPy array\n+  /// In case of an error, nullptr is returned and the Python error is cleared.\n+  static array ensure(handle h, int ExtraFlags = 0) {\n+    auto result = reinterpret_steal<array>(raw_array(h.ptr(), ExtraFlags));\n+    if (!result)\n+      PyErr_Clear();\n+    return result;\n+  }\n+\n+protected:\n+  template <typename, typename> friend struct detail::npy_format_descriptor;\n+\n+  void fail_dim_check(ssize_t dim, const std::string &msg) const {\n+    throw index_error(msg + \": \" + std::to_string(dim) +\n+                      \" (ndim = \" + std::to_string(ndim()) + \")\");\n+  }\n+\n+  template <typename... Ix> ssize_t byte_offset(Ix... index) const {\n+    check_dimensions(index...);\n+    return detail::byte_offset_unsafe(strides(), ssize_t(index)...);\n+  }\n+\n+  void check_writeable() const {\n+    if (!writeable())\n+      throw std::domain_error(\"array is not writeable\");\n+  }\n+\n+  // Default, C-style strides\n+  static std::vector<ssize_t> c_strides(const std::vector<ssize_t> &shape,\n+                                        ssize_t itemsize) {\n+    auto ndim = shape.size();\n+    std::vector<ssize_t> strides(ndim, itemsize);\n+    if (ndim > 0)\n+      for (size_t i = ndim - 1; i > 0; --i)\n+        strides[i - 1] = strides[i] * shape[i];\n+    return strides;\n+  }\n+\n+  // F-style strides; default when constructing an array_t with `ExtraFlags &\n+  // f_style`\n+  static std::vector<ssize_t> f_strides(const std::vector<ssize_t> &shape,\n+                                        ssize_t itemsize) {\n+    auto ndim = shape.size();\n+    std::vector<ssize_t> strides(ndim, itemsize);\n+    for (size_t i = 1; i < ndim; ++i)\n+      strides[i] = strides[i - 1] * shape[i - 1];\n+    return strides;\n+  }\n+\n+  template <typename... Ix> void check_dimensions(Ix... index) const {\n+    check_dimensions_impl(ssize_t(0), shape(), ssize_t(index)...);\n+  }\n+\n+  void check_dimensions_impl(ssize_t, const ssize_t *) const {}\n+\n+  template <typename... Ix>\n+  void check_dimensions_impl(ssize_t axis, const ssize_t *shape, ssize_t i,\n+                             Ix... index) const {\n+    if (i >= *shape) {\n+      throw index_error(std::string(\"index \") + std::to_string(i) +\n+                        \" is out of bounds for axis \" + std::to_string(axis) +\n+                        \" with size \" + std::to_string(*shape));\n+    }\n+    check_dimensions_impl(axis + 1, shape + 1, index...);\n+  }\n+\n+  /// Create array from any object -- always returns a new reference\n+  static PyObject *raw_array(PyObject *ptr, int ExtraFlags = 0) {\n+    if (ptr == nullptr) {\n+      PyErr_SetString(PyExc_ValueError,\n+                      \"cannot create a pybind11::array from a nullptr\");\n+      return nullptr;\n+    }\n+    return detail::npy_api::get().PyArray_FromAny_(\n+        ptr, nullptr, 0, 0,\n+        detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);\n+  }\n+};\n+\n+template <typename T, int ExtraFlags = array::forcecast>\n+class array_t : public array {\n+private:\n+  struct private_ctor {};\n+  // Delegating constructor needed when both moving and accessing in the same\n+  // constructor\n+  array_t(private_ctor, ShapeContainer &&shape, StridesContainer &&strides,\n+          const T *ptr, handle base)\n+      : array(std::move(shape), std::move(strides), ptr, base) {}\n+\n+public:\n+  static_assert(!detail::array_info<T>::is_array,\n+                \"Array types cannot be used with array_t\");\n+\n+  using value_type = T;\n+\n+  array_t() : array(0, static_cast<const T *>(nullptr)) {}\n+  array_t(handle h, borrowed_t) : array(h, borrowed_t{}) {}\n+  array_t(handle h, stolen_t) : array(h, stolen_t{}) {}\n+\n+  PYBIND11_DEPRECATED(\"Use array_t<T>::ensure() instead\")\n+  array_t(handle h, bool is_borrowed)\n+      : array(raw_array_t(h.ptr()), stolen_t{}) {\n+    if (!m_ptr)\n+      PyErr_Clear();\n+    if (!is_borrowed)\n+      Py_XDECREF(h.ptr());\n+  }\n+\n+  array_t(const object &o) : array(raw_array_t(o.ptr()), stolen_t{}) {\n+    if (!m_ptr)\n+      throw error_already_set();\n+  }\n+\n+  explicit array_t(const buffer_info &info) : array(info) {}\n+\n+  array_t(ShapeContainer shape, StridesContainer strides,\n+          const T *ptr = nullptr, handle base = handle())\n+      : array(std::move(shape), std::move(strides), ptr, base) {}\n+\n+  explicit array_t(ShapeContainer shape, const T *ptr = nullptr,\n+                   handle base = handle())\n+      : array_t(private_ctor{}, std::move(shape),\n+                ExtraFlags & f_style ? f_strides(*shape, itemsize())\n+                                     : c_strides(*shape, itemsize()),\n+                ptr, base) {}\n+\n+  explicit array_t(size_t count, const T *ptr = nullptr, handle base = handle())\n+      : array({count}, {}, ptr, base) {}\n+\n+  constexpr ssize_t itemsize() const { return sizeof(T); }\n+\n+  template <typename... Ix> ssize_t index_at(Ix... index) const {\n+    return offset_at(index...) / itemsize();\n+  }\n+\n+  template <typename... Ix> const T *data(Ix... index) const {\n+    return static_cast<const T *>(array::data(index...));\n+  }\n+\n+  template <typename... Ix> T *mutable_data(Ix... index) {\n+    return static_cast<T *>(array::mutable_data(index...));\n+  }\n+\n+  // Reference to element at a given index\n+  template <typename... Ix> const T &at(Ix... index) const {\n+    if ((ssize_t)sizeof...(index) != ndim())\n+      fail_dim_check(sizeof...(index), \"index dimension mismatch\");\n+    return *(static_cast<const T *>(array::data()) +\n+             byte_offset(ssize_t(index)...) / itemsize());\n+  }\n+\n+  // Mutable reference to element at a given index\n+  template <typename... Ix> T &mutable_at(Ix... index) {\n+    if ((ssize_t)sizeof...(index) != ndim())\n+      fail_dim_check(sizeof...(index), \"index dimension mismatch\");\n+    return *(static_cast<T *>(array::mutable_data()) +\n+             byte_offset(ssize_t(index)...) / itemsize());\n+  }\n+\n+  /**\n+   * Returns a proxy object that provides access to the array's data without\n+   * bounds or dimensionality checking.  Will throw if the array is missing the\n+   * `writeable` flag.  Use with care: the array must not be destroyed or\n+   * reshaped for the duration of the returned object, and the caller must take\n+   * care not to access invalid dimensions or dimension indices.\n+   */\n+  template <ssize_t Dims = -1>\n+  detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {\n+    return array::mutable_unchecked<T, Dims>();\n+  }\n+\n+  /**\n+   * Returns a proxy object that provides const access to the array's data\n+   * without bounds or dimensionality checking.  Unlike `unchecked()`, this does\n+   * not require that the underlying array have the `writable` flag.  Use with\n+   * care: the array must not be destroyed or reshaped for the duration of the\n+   * returned object, and the caller must take care not to access invalid\n+   * dimensions or dimension indices.\n+   */\n+  template <ssize_t Dims = -1>\n+  detail::unchecked_reference<T, Dims> unchecked() const & {\n+    return array::unchecked<T, Dims>();\n+  }\n+\n+  /// Ensure that the argument is a NumPy array of the correct dtype (and if\n+  /// not, try to convert it).  In case of an error, nullptr is returned and the\n+  /// Python error is cleared.\n+  static array_t ensure(handle h) {\n+    auto result = reinterpret_steal<array_t>(raw_array_t(h.ptr()));\n+    if (!result)\n+      PyErr_Clear();\n+    return result;\n+  }\n+\n+  static bool check_(handle h) {\n+    const auto &api = detail::npy_api::get();\n+    return api.PyArray_Check_(h.ptr()) &&\n+           api.PyArray_EquivTypes_(detail::array_proxy(h.ptr())->descr,\n+                                   dtype::of<T>().ptr());\n+  }\n+\n+protected:\n+  /// Create array from any object -- always returns a new reference\n+  static PyObject *raw_array_t(PyObject *ptr) {\n+    if (ptr == nullptr) {\n+      PyErr_SetString(PyExc_ValueError,\n+                      \"cannot create a pybind11::array_t from a nullptr\");\n+      return nullptr;\n+    }\n+    return detail::npy_api::get().PyArray_FromAny_(\n+        ptr, dtype::of<T>().release().ptr(), 0, 0,\n+        detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);\n+  }\n+};\n+\n+template <typename T>\n+struct format_descriptor<T,\n+                         detail::enable_if_t<detail::is_pod_struct<T>::value>> {\n+  static std::string format() {\n+    return detail::npy_format_descriptor<\n+        typename std::remove_cv<T>::type>::format();\n+  }\n+};\n+\n+template <size_t N> struct format_descriptor<char[N]> {\n+  static std::string format() { return std::to_string(N) + \"s\"; }\n+};\n+template <size_t N> struct format_descriptor<std::array<char, N>> {\n+  static std::string format() { return std::to_string(N) + \"s\"; }\n+};\n+\n+template <typename T>\n+struct format_descriptor<T, detail::enable_if_t<std::is_enum<T>::value>> {\n+  static std::string format() {\n+    return format_descriptor<typename std::remove_cv<\n+        typename std::underlying_type<T>::type>::type>::format();\n+  }\n+};\n+\n+template <typename T>\n+struct format_descriptor<T,\n+                         detail::enable_if_t<detail::array_info<T>::is_array>> {\n+  static std::string format() {\n+    using namespace detail;\n+    static constexpr auto extents = _(\"(\") + array_info<T>::extents + _(\")\");\n+    return extents.text + format_descriptor<remove_all_extents_t<T>>::format();\n+  }\n+};\n+\n+NAMESPACE_BEGIN(detail)\n+template <typename T, int ExtraFlags>\n+struct pyobject_caster<array_t<T, ExtraFlags>> {\n+  using type = array_t<T, ExtraFlags>;\n+\n+  bool load(handle src, bool convert) {\n+    if (!convert && !type::check_(src))\n+      return false;\n+    value = type::ensure(src);\n+    return static_cast<bool>(value);\n+  }\n+\n+  static handle cast(const handle &src, return_value_policy /* policy */,\n+                     handle /* parent */) {\n+    return src.inc_ref();\n+  }\n+  PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name);\n+};\n+\n+template <typename T>\n+struct compare_buffer_info<\n+    T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {\n+  static bool compare(const buffer_info &b) {\n+    return npy_api::get().PyArray_EquivTypes_(dtype::of<T>().ptr(),\n+                                              dtype(b).ptr());\n+  }\n+};\n+\n+template <typename T, typename = void> struct npy_format_descriptor_name;\n+\n+template <typename T>\n+struct npy_format_descriptor_name<T, enable_if_t<std::is_integral<T>::value>> {\n+  static constexpr auto name = _<std::is_same<T, bool>::value>(\n+      _(\"bool\"),\n+      _<std::is_signed<T>::value>(\"int\", \"uint\") + _<sizeof(T) * 8>());\n+};\n+\n+template <typename T>\n+struct npy_format_descriptor_name<\n+    T, enable_if_t<std::is_floating_point<T>::value>> {\n+  static constexpr auto name = _ < std::is_same<T, float>::value ||\n+                               std::is_same<T, double>::value >\n+                                   (_(\"float\") + _<sizeof(T) * 8>(),\n+                                    _(\"longdouble\"));\n+};\n+\n+template <typename T>\n+struct npy_format_descriptor_name<T, enable_if_t<is_complex<T>::value>> {\n+  static constexpr auto\n+      name = _ < std::is_same<typename T::value_type, float>::value ||\n+             std::is_same<typename T::value_type, double>::value >\n+                 (_(\"complex\") + _<sizeof(typename T::value_type) * 16>(),\n+                  _(\"longcomplex\"));\n+};\n+\n+template <typename T>\n+struct npy_format_descriptor<\n+    T, enable_if_t<satisfies_any_of<T, std::is_arithmetic, is_complex>::value>>\n+    : npy_format_descriptor_name<T> {\n+private:\n+  // NB: the order here must match the one in common.h\n+  constexpr static const int values[15] = {\n+      npy_api::NPY_BOOL_,   npy_api::NPY_BYTE_,     npy_api::NPY_UBYTE_,\n+      npy_api::NPY_SHORT_,  npy_api::NPY_USHORT_,   npy_api::NPY_INT_,\n+      npy_api::NPY_UINT_,   npy_api::NPY_LONGLONG_, npy_api::NPY_ULONGLONG_,\n+      npy_api::NPY_FLOAT_,  npy_api::NPY_DOUBLE_,   npy_api::NPY_LONGDOUBLE_,\n+      npy_api::NPY_CFLOAT_, npy_api::NPY_CDOUBLE_,  npy_api::NPY_CLONGDOUBLE_};\n+\n+public:\n+  static constexpr int value = values[detail::is_fmt_numeric<T>::index];\n+\n+  static pybind11::dtype dtype() {\n+    if (auto ptr = npy_api::get().PyArray_DescrFromType_(value))\n+      return reinterpret_borrow<pybind11::dtype>(ptr);\n+    pybind11_fail(\"Unsupported buffer format!\");\n+  }\n+};\n+\n+#define PYBIND11_DECL_CHAR_FMT                                                 \\\n+  static constexpr auto name = _(\"S\") + _<N>();                                \\\n+  static pybind11::dtype dtype() {                                             \\\n+    return pybind11::dtype(std::string(\"S\") + std::to_string(N));              \\\n+  }\n+template <size_t N> struct npy_format_descriptor<char[N]> {\n+  PYBIND11_DECL_CHAR_FMT\n+};\n+template <size_t N> struct npy_format_descriptor<std::array<char, N>> {\n+  PYBIND11_DECL_CHAR_FMT\n+};\n+#undef PYBIND11_DECL_CHAR_FMT\n+\n+template <typename T>\n+struct npy_format_descriptor<T, enable_if_t<array_info<T>::is_array>> {\n+private:\n+  using base_descr = npy_format_descriptor<typename array_info<T>::type>;\n+\n+public:\n+  static_assert(!array_info<T>::is_empty,\n+                \"Zero-sized arrays are not supported\");\n+\n+  static constexpr auto name =\n+      _(\"(\") + array_info<T>::extents + _(\")\") + base_descr::name;\n+  static pybind11::dtype dtype() {\n+    list shape;\n+    array_info<T>::append_extents(shape);\n+    return pybind11::dtype::from_args(\n+        pybind11::make_tuple(base_descr::dtype(), shape));\n+  }\n+};\n+\n+template <typename T>\n+struct npy_format_descriptor<T, enable_if_t<std::is_enum<T>::value>> {\n+private:\n+  using base_descr =\n+      npy_format_descriptor<typename std::underlying_type<T>::type>;\n+\n+public:\n+  static constexpr auto name = base_descr::name;\n+  static pybind11::dtype dtype() { return base_descr::dtype(); }\n+};\n+\n+struct field_descriptor {\n+  const char *name;\n+  ssize_t offset;\n+  ssize_t size;\n+  std::string format;\n+  dtype descr;\n+};\n+\n+inline PYBIND11_NOINLINE void\n+register_structured_dtype(any_container<field_descriptor> fields,\n+                          const std::type_info &tinfo, ssize_t itemsize,\n+                          bool (*direct_converter)(PyObject *, void *&)) {\n+\n+  auto &numpy_internals = get_numpy_internals();\n+  if (numpy_internals.get_type_info(tinfo, false))\n+    pybind11_fail(\"NumPy: dtype is already registered\");\n+\n+  list names, formats, offsets;\n+  for (auto field : *fields) {\n+    if (!field.descr)\n+      pybind11_fail(std::string(\"NumPy: unsupported field dtype: `\") +\n+                    field.name + \"` @ \" + tinfo.name());\n+    names.append(PYBIND11_STR_TYPE(field.name));\n+    formats.append(field.descr);\n+    offsets.append(pybind11::int_(field.offset));\n+  }\n+  auto dtype_ptr =\n+      pybind11::dtype(names, formats, offsets, itemsize).release().ptr();\n+\n+  // There is an existing bug in NumPy (as of v1.11): trailing bytes are\n+  // not encoded explicitly into the format string. This will supposedly\n+  // get fixed in v1.12; for further details, see these:\n+  // - https://github.com/numpy/numpy/issues/7797\n+  // - https://github.com/numpy/numpy/pull/7798\n+  // Because of this, we won't use numpy's logic to generate buffer format\n+  // strings and will just do it ourselves.\n+  std::vector<field_descriptor> ordered_fields(std::move(fields));\n+  std::sort(ordered_fields.begin(), ordered_fields.end(),\n+            [](const field_descriptor &a, const field_descriptor &b) {\n+              return a.offset < b.offset;\n+            });\n+  ssize_t offset = 0;\n+  std::ostringstream oss;\n+  // mark the structure as unaligned with '^', because numpy and C++ don't\n+  // always agree about alignment (particularly for complex), and we're\n+  // explicitly listing all our padding. This depends on none of the fields\n+  // overriding the endianness. Putting the ^ in front of individual fields\n+  // isn't guaranteed to work due to https://github.com/numpy/numpy/issues/9049\n+  oss << \"^T{\";\n+  for (auto &field : ordered_fields) {\n+    if (field.offset > offset)\n+      oss << (field.offset - offset) << 'x';\n+    oss << field.format << ':' << field.name << ':';\n+    offset = field.offset + field.size;\n+  }\n+  if (itemsize > offset)\n+    oss << (itemsize - offset) << 'x';\n+  oss << '}';\n+  auto format_str = oss.str();\n+\n+  // Sanity check: verify that NumPy properly parses our buffer format string\n+  auto &api = npy_api::get();\n+  auto arr = array(buffer_info(nullptr, itemsize, format_str, 1));\n+  if (!api.PyArray_EquivTypes_(dtype_ptr, arr.dtype().ptr()))\n+    pybind11_fail(\"NumPy: invalid buffer descriptor!\");\n+\n+  auto tindex = std::type_index(tinfo);\n+  numpy_internals.registered_dtypes[tindex] = {dtype_ptr, format_str};\n+  get_internals().direct_conversions[tindex].push_back(direct_converter);\n+}\n+\n+template <typename T, typename SFINAE> struct npy_format_descriptor {\n+  static_assert(\n+      is_pod_struct<T>::value,\n+      \"Attempt to use a non-POD or unimplemented POD type as a numpy dtype\");\n+\n+  static constexpr auto name = make_caster<T>::name;\n+\n+  static pybind11::dtype dtype() {\n+    return reinterpret_borrow<pybind11::dtype>(dtype_ptr());\n+  }\n+\n+  static std::string format() {\n+    static auto format_str =\n+        get_numpy_internals().get_type_info<T>(true)->format_str;\n+    return format_str;\n+  }\n+\n+  static void register_dtype(any_container<field_descriptor> fields) {\n+    register_structured_dtype(std::move(fields),\n+                              typeid(typename std::remove_cv<T>::type),\n+                              sizeof(T), &direct_converter);\n+  }\n+\n+private:\n+  static PyObject *dtype_ptr() {\n+    static PyObject *ptr =\n+        get_numpy_internals().get_type_info<T>(true)->dtype_ptr;\n+    return ptr;\n+  }\n+\n+  static bool direct_converter(PyObject *obj, void *&value) {\n+    auto &api = npy_api::get();\n+    if (!PyObject_TypeCheck(obj, api.PyVoidArrType_Type_))\n+      return false;\n+    if (auto descr =\n+            reinterpret_steal<object>(api.PyArray_DescrFromScalar_(obj))) {\n+      if (api.PyArray_EquivTypes_(dtype_ptr(), descr.ptr())) {\n+        value = ((PyVoidScalarObject_Proxy *)obj)->obval;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+};\n+\n+#ifdef __CLION_IDE__ // replace heavy macro with dummy code for the IDE (doesn't\n+                     // affect code)\n+#define PYBIND11_NUMPY_DTYPE(Type, ...) ((void)0)\n+#define PYBIND11_NUMPY_DTYPE_EX(Type, ...) ((void)0)\n+#else\n+\n+#define PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, Name)                           \\\n+  ::pybind11::detail::field_descriptor {                                       \\\n+    Name, offsetof(T, Field), sizeof(decltype(std::declval<T>().Field)),       \\\n+        ::pybind11::format_descriptor<                                         \\\n+            decltype(std::declval<T>().Field)>::format(),                      \\\n+        ::pybind11::detail::npy_format_descriptor<                             \\\n+            decltype(std::declval<T>().Field)>::dtype()                        \\\n+  }\n+\n+// Extract name, offset and format descriptor for a struct field\n+#define PYBIND11_FIELD_DESCRIPTOR(T, Field)                                    \\\n+  PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, #Field)\n+\n+// The main idea of this macro is borrowed from\n+// https://github.com/swansontec/map-macro (C) William Swanson, Paul Fultz\n+#define PYBIND11_EVAL0(...) __VA_ARGS__\n+#define PYBIND11_EVAL1(...)                                                    \\\n+  PYBIND11_EVAL0(PYBIND11_EVAL0(PYBIND11_EVAL0(__VA_ARGS__)))\n+#define PYBIND11_EVAL2(...)                                                    \\\n+  PYBIND11_EVAL1(PYBIND11_EVAL1(PYBIND11_EVAL1(__VA_ARGS__)))\n+#define PYBIND11_EVAL3(...)                                                    \\\n+  PYBIND11_EVAL2(PYBIND11_EVAL2(PYBIND11_EVAL2(__VA_ARGS__)))\n+#define PYBIND11_EVAL4(...)                                                    \\\n+  PYBIND11_EVAL3(PYBIND11_EVAL3(PYBIND11_EVAL3(__VA_ARGS__)))\n+#define PYBIND11_EVAL(...)                                                     \\\n+  PYBIND11_EVAL4(PYBIND11_EVAL4(PYBIND11_EVAL4(__VA_ARGS__)))\n+#define PYBIND11_MAP_END(...)\n+#define PYBIND11_MAP_OUT\n+#define PYBIND11_MAP_COMMA ,\n+#define PYBIND11_MAP_GET_END() 0, PYBIND11_MAP_END\n+#define PYBIND11_MAP_NEXT0(test, next, ...) next PYBIND11_MAP_OUT\n+#define PYBIND11_MAP_NEXT1(test, next) PYBIND11_MAP_NEXT0(test, next, 0)\n+#define PYBIND11_MAP_NEXT(test, next)                                          \\\n+  PYBIND11_MAP_NEXT1(PYBIND11_MAP_GET_END test, next)\n+#ifdef _MSC_VER // MSVC is not as eager to expand macros, hence this workaround\n+#define PYBIND11_MAP_LIST_NEXT1(test, next)                                    \\\n+  PYBIND11_EVAL0(PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0))\n+#else\n+#define PYBIND11_MAP_LIST_NEXT1(test, next)                                    \\\n+  PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0)\n+#endif\n+#define PYBIND11_MAP_LIST_NEXT(test, next)                                     \\\n+  PYBIND11_MAP_LIST_NEXT1(PYBIND11_MAP_GET_END test, next)\n+#define PYBIND11_MAP_LIST0(f, t, x, peek, ...)                                 \\\n+  f(t, x) PYBIND11_MAP_LIST_NEXT(peek, PYBIND11_MAP_LIST1)(f, t, peek,         \\\n+                                                           __VA_ARGS__)\n+#define PYBIND11_MAP_LIST1(f, t, x, peek, ...)                                 \\\n+  f(t, x) PYBIND11_MAP_LIST_NEXT(peek, PYBIND11_MAP_LIST0)(f, t, peek,         \\\n+                                                           __VA_ARGS__)\n+// PYBIND11_MAP_LIST(f, t, a1, a2, ...) expands to f(t, a1), f(t, a2), ...\n+#define PYBIND11_MAP_LIST(f, t, ...)                                           \\\n+  PYBIND11_EVAL(PYBIND11_MAP_LIST1(f, t, __VA_ARGS__, (), 0))\n+\n+#define PYBIND11_NUMPY_DTYPE(Type, ...)                                        \\\n+  ::pybind11::detail::npy_format_descriptor<Type>::register_dtype(             \\\n+      ::std::vector<::pybind11::detail::field_descriptor>{                     \\\n+          PYBIND11_MAP_LIST(PYBIND11_FIELD_DESCRIPTOR, Type, __VA_ARGS__)})\n+\n+#ifdef _MSC_VER\n+#define PYBIND11_MAP2_LIST_NEXT1(test, next)                                   \\\n+  PYBIND11_EVAL0(PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0))\n+#else\n+#define PYBIND11_MAP2_LIST_NEXT1(test, next)                                   \\\n+  PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0)\n+#endif\n+#define PYBIND11_MAP2_LIST_NEXT(test, next)                                    \\\n+  PYBIND11_MAP2_LIST_NEXT1(PYBIND11_MAP_GET_END test, next)\n+#define PYBIND11_MAP2_LIST0(f, t, x1, x2, peek, ...)                           \\\n+  f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT(peek, PYBIND11_MAP2_LIST1)(f, t, peek,  \\\n+                                                                  __VA_ARGS__)\n+#define PYBIND11_MAP2_LIST1(f, t, x1, x2, peek, ...)                           \\\n+  f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT(peek, PYBIND11_MAP2_LIST0)(f, t, peek,  \\\n+                                                                  __VA_ARGS__)\n+// PYBIND11_MAP2_LIST(f, t, a1, a2, ...) expands to f(t, a1, a2), f(t, a3, a4),\n+// ...\n+#define PYBIND11_MAP2_LIST(f, t, ...)                                          \\\n+  PYBIND11_EVAL(PYBIND11_MAP2_LIST1(f, t, __VA_ARGS__, (), 0))\n+\n+#define PYBIND11_NUMPY_DTYPE_EX(Type, ...)                                     \\\n+  ::pybind11::detail::npy_format_descriptor<Type>::register_dtype(             \\\n+      ::std::vector<::pybind11::detail::field_descriptor>{PYBIND11_MAP2_LIST(  \\\n+          PYBIND11_FIELD_DESCRIPTOR_EX, Type, __VA_ARGS__)})\n+\n+#endif // __CLION_IDE__\n+\n+template <class T> using array_iterator = typename std::add_pointer<T>::type;\n+\n+template <class T> array_iterator<T> array_begin(const buffer_info &buffer) {\n+  return array_iterator<T>(reinterpret_cast<T *>(buffer.ptr));\n+}\n+\n+template <class T> array_iterator<T> array_end(const buffer_info &buffer) {\n+  return array_iterator<T>(reinterpret_cast<T *>(buffer.ptr) + buffer.size);\n+}\n+\n+class common_iterator {\n+public:\n+  using container_type = std::vector<ssize_t>;\n+  using value_type = container_type::value_type;\n+  using size_type = container_type::size_type;\n+\n+  common_iterator() : p_ptr(0), m_strides() {}\n+\n+  common_iterator(void *ptr, const container_type &strides,\n+                  const container_type &shape)\n+      : p_ptr(reinterpret_cast<char *>(ptr)), m_strides(strides.size()) {\n+    m_strides.back() = static_cast<value_type>(strides.back());\n+    for (size_type i = m_strides.size() - 1; i != 0; --i) {\n+      size_type j = i - 1;\n+      value_type s = static_cast<value_type>(shape[i]);\n+      m_strides[j] = strides[j] + m_strides[i] - strides[i] * s;\n+    }\n+  }\n+\n+  void increment(size_type dim) { p_ptr += m_strides[dim]; }\n+\n+  void *data() const { return p_ptr; }\n+\n+private:\n+  char *p_ptr;\n+  container_type m_strides;\n+};\n+\n+template <size_t N> class multi_array_iterator {\n+public:\n+  using container_type = std::vector<ssize_t>;\n+\n+  multi_array_iterator(const std::array<buffer_info, N> &buffers,\n+                       const container_type &shape)\n+      : m_shape(shape.size()), m_index(shape.size(), 0), m_common_iterator() {\n+\n+    // Manual copy to avoid conversion warning if using std::copy\n+    for (size_t i = 0; i < shape.size(); ++i)\n+      m_shape[i] = shape[i];\n+\n+    container_type strides(shape.size());\n+    for (size_t i = 0; i < N; ++i)\n+      init_common_iterator(buffers[i], shape, m_common_iterator[i], strides);\n+  }\n+\n+  multi_array_iterator &operator++() {\n+    for (size_t j = m_index.size(); j != 0; --j) {\n+      size_t i = j - 1;\n+      if (++m_index[i] != m_shape[i]) {\n+        increment_common_iterator(i);\n+        break;\n+      } else {\n+        m_index[i] = 0;\n+      }\n+    }\n+    return *this;\n+  }\n+\n+  template <size_t K, class T = void> T *data() const {\n+    return reinterpret_cast<T *>(m_common_iterator[K].data());\n+  }\n+\n+private:\n+  using common_iter = common_iterator;\n+\n+  void init_common_iterator(const buffer_info &buffer,\n+                            const container_type &shape, common_iter &iterator,\n+                            container_type &strides) {\n+    auto buffer_shape_iter = buffer.shape.rbegin();\n+    auto buffer_strides_iter = buffer.strides.rbegin();\n+    auto shape_iter = shape.rbegin();\n+    auto strides_iter = strides.rbegin();\n+\n+    while (buffer_shape_iter != buffer.shape.rend()) {\n+      if (*shape_iter == *buffer_shape_iter)\n+        *strides_iter = *buffer_strides_iter;\n+      else\n+        *strides_iter = 0;\n+\n+      ++buffer_shape_iter;\n+      ++buffer_strides_iter;\n+      ++shape_iter;\n+      ++strides_iter;\n+    }\n+\n+    std::fill(strides_iter, strides.rend(), 0);\n+    iterator = common_iter(buffer.ptr, strides, shape);\n+  }\n+\n+  void increment_common_iterator(size_t dim) {\n+    for (auto &iter : m_common_iterator)\n+      iter.increment(dim);\n+  }\n+\n+  container_type m_shape;\n+  container_type m_index;\n+  std::array<common_iter, N> m_common_iterator;\n+};\n+\n+enum class broadcast_trivial { non_trivial, c_trivial, f_trivial };\n+\n+// Populates the shape and number of dimensions for the set of buffers.  Returns\n+// a broadcast_trivial enum value indicating whether the broadcast is\n+// \"trivial\"--that is, has each buffer being either a singleton or a full-size,\n+// C-contiguous (`c_trivial`) or Fortran-contiguous (`f_trivial`) storage\n+// buffer; returns `non_trivial` otherwise.\n+template <size_t N>\n+broadcast_trivial broadcast(const std::array<buffer_info, N> &buffers,\n+                            ssize_t &ndim, std::vector<ssize_t> &shape) {\n+  ndim = std::accumulate(buffers.begin(), buffers.end(), ssize_t(0),\n+                         [](ssize_t res, const buffer_info &buf) {\n+                           return std::max(res, buf.ndim);\n+                         });\n+\n+  shape.clear();\n+  shape.resize((size_t)ndim, 1);\n+\n+  // Figure out the output size, and make sure all input arrays conform (i.e.\n+  // are either size 1 or the full size).\n+  for (size_t i = 0; i < N; ++i) {\n+    auto res_iter = shape.rbegin();\n+    auto end = buffers[i].shape.rend();\n+    for (auto shape_iter = buffers[i].shape.rbegin(); shape_iter != end;\n+         ++shape_iter, ++res_iter) {\n+      const auto &dim_size_in = *shape_iter;\n+      auto &dim_size_out = *res_iter;\n+\n+      // Each input dimension can either be 1 or `n`, but `n` values must match\n+      // across buffers\n+      if (dim_size_out == 1)\n+        dim_size_out = dim_size_in;\n+      else if (dim_size_in != 1 && dim_size_in != dim_size_out)\n+        pybind11_fail(\n+            \"pybind11::vectorize: incompatible size/dimension of inputs!\");\n+    }\n+  }\n+\n+  bool trivial_broadcast_c = true;\n+  bool trivial_broadcast_f = true;\n+  for (size_t i = 0; i < N && (trivial_broadcast_c || trivial_broadcast_f);\n+       ++i) {\n+    if (buffers[i].size == 1)\n+      continue;\n+\n+    // Require the same number of dimensions:\n+    if (buffers[i].ndim != ndim)\n+      return broadcast_trivial::non_trivial;\n+\n+    // Require all dimensions be full-size:\n+    if (!std::equal(buffers[i].shape.cbegin(), buffers[i].shape.cend(),\n+                    shape.cbegin()))\n+      return broadcast_trivial::non_trivial;\n+\n+    // Check for C contiguity (but only if previous inputs were also C\n+    // contiguous)\n+    if (trivial_broadcast_c) {\n+      ssize_t expect_stride = buffers[i].itemsize;\n+      auto end = buffers[i].shape.crend();\n+      for (auto shape_iter = buffers[i].shape.crbegin(),\n+                stride_iter = buffers[i].strides.crbegin();\n+           trivial_broadcast_c && shape_iter != end;\n+           ++shape_iter, ++stride_iter) {\n+        if (expect_stride == *stride_iter)\n+          expect_stride *= *shape_iter;\n+        else\n+          trivial_broadcast_c = false;\n+      }\n+    }\n+\n+    // Check for Fortran contiguity (if previous inputs were also F contiguous)\n+    if (trivial_broadcast_f) {\n+      ssize_t expect_stride = buffers[i].itemsize;\n+      auto end = buffers[i].shape.cend();\n+      for (auto shape_iter = buffers[i].shape.cbegin(),\n+                stride_iter = buffers[i].strides.cbegin();\n+           trivial_broadcast_f && shape_iter != end;\n+           ++shape_iter, ++stride_iter) {\n+        if (expect_stride == *stride_iter)\n+          expect_stride *= *shape_iter;\n+        else\n+          trivial_broadcast_f = false;\n+      }\n+    }\n+  }\n+\n+  return trivial_broadcast_c   ? broadcast_trivial::c_trivial\n+         : trivial_broadcast_f ? broadcast_trivial::f_trivial\n+                               : broadcast_trivial::non_trivial;\n+}\n+\n+template <typename T> struct vectorize_arg {\n+  static_assert(\n+      !std::is_rvalue_reference<T>::value,\n+      \"Functions with rvalue reference arguments cannot be vectorized\");\n+  // The wrapped function gets called with this type:\n+  using call_type = remove_reference_t<T>;\n+  // Is this a vectorized argument?\n+  static constexpr bool vectorize =\n+      satisfies_any_of<call_type, std::is_arithmetic, is_complex,\n+                       std::is_pod>::value &&\n+      satisfies_none_of<call_type, std::is_pointer, std::is_array, is_std_array,\n+                        std::is_enum>::value &&\n+      (!std::is_reference<T>::value ||\n+       (std::is_lvalue_reference<T>::value && std::is_const<call_type>::value));\n+  // Accept this type: an array for vectorized types, otherwise the type as-is:\n+  using type =\n+      conditional_t<vectorize,\n+                    array_t<remove_cv_t<call_type>, array::forcecast>, T>;\n+};\n+\n+template <typename Func, typename Return, typename... Args>\n+struct vectorize_helper {\n+private:\n+  static constexpr size_t N = sizeof...(Args);\n+  static constexpr size_t NVectorized =\n+      constexpr_sum(vectorize_arg<Args>::vectorize...);\n+  static_assert(NVectorized >= 1,\n+                \"pybind11::vectorize(...) requires a function with at least \"\n+                \"one vectorizable argument\");\n+\n+public:\n+  template <typename T>\n+  explicit vectorize_helper(T &&f) : f(std::forward<T>(f)) {}\n+\n+  object operator()(typename vectorize_arg<Args>::type... args) {\n+    return run(args..., make_index_sequence<N>(),\n+               select_indices<vectorize_arg<Args>::vectorize...>(),\n+               make_index_sequence<NVectorized>());\n+  }\n+\n+private:\n+  remove_reference_t<Func> f;\n+\n+  // Internal compiler error in MSVC 19.16.27025.1 (Visual Studio 2017 15.9.4),\n+  // when compiling with \"/permissive-\" flag when arg_call_types is manually\n+  // inlined.\n+  using arg_call_types = std::tuple<typename vectorize_arg<Args>::call_type...>;\n+  template <size_t Index>\n+  using param_n_t = typename std::tuple_element<Index, arg_call_types>::type;\n+\n+  // Runs a vectorized function given arguments tuple and three index sequences:\n+  //     - Index is the full set of 0 ... (N-1) argument indices;\n+  //     - VIndex is the subset of argument indices with vectorized parameters,\n+  //     letting us access\n+  //       vectorized arguments (anything not in this sequence is passed\n+  //       through)\n+  //     - BIndex is a incremental sequence (beginning at 0) of the same size as\n+  //     VIndex, so that\n+  //       we can store vectorized buffer_infos in an array (argument VIndex has\n+  //       its buffer at index BIndex in the array).\n+  template <size_t... Index, size_t... VIndex, size_t... BIndex>\n+  object run(typename vectorize_arg<Args>::type &...args,\n+             index_sequence<Index...> i_seq, index_sequence<VIndex...> vi_seq,\n+             index_sequence<BIndex...> bi_seq) {\n+\n+    // Pointers to values the function was called with; the vectorized ones set\n+    // here will start out as array_t<T> pointers, but they will be changed them\n+    // to T pointers before we make call the wrapped function.  Non-vectorized\n+    // pointers are left as-is.\n+    std::array<void *, N> params{{&args...}};\n+\n+    // The array of `buffer_info`s of vectorized arguments:\n+    std::array<buffer_info, NVectorized> buffers{\n+        {reinterpret_cast<array *>(params[VIndex])->request()...}};\n+\n+    /* Determine dimensions parameters of output array */\n+    ssize_t nd = 0;\n+    std::vector<ssize_t> shape(0);\n+    auto trivial = broadcast(buffers, nd, shape);\n+    size_t ndim = (size_t)nd;\n+\n+    size_t size = std::accumulate(shape.begin(), shape.end(), (size_t)1,\n+                                  std::multiplies<size_t>());\n+\n+    // If all arguments are 0-dimension arrays (i.e. single values) return a\n+    // plain value (i.e. not wrapped in an array).\n+    if (size == 1 && ndim == 0) {\n+      PYBIND11_EXPAND_SIDE_EFFECTS(params[VIndex] = buffers[BIndex].ptr);\n+      return cast(f(*reinterpret_cast<param_n_t<Index> *>(params[Index])...));\n+    }\n+\n+    array_t<Return> result;\n+    if (trivial == broadcast_trivial::f_trivial)\n+      result = array_t<Return, array::f_style>(shape);\n+    else\n+      result = array_t<Return>(shape);\n+\n+    if (size == 0)\n+      return std::move(result);\n+\n+    /* Call the function */\n+    if (trivial == broadcast_trivial::non_trivial)\n+      apply_broadcast(buffers, params, result, i_seq, vi_seq, bi_seq);\n+    else\n+      apply_trivial(buffers, params, result.mutable_data(), size, i_seq, vi_seq,\n+                    bi_seq);\n+\n+    return std::move(result);\n+  }\n+\n+  template <size_t... Index, size_t... VIndex, size_t... BIndex>\n+  void apply_trivial(std::array<buffer_info, NVectorized> &buffers,\n+                     std::array<void *, N> &params, Return *out, size_t size,\n+                     index_sequence<Index...>, index_sequence<VIndex...>,\n+                     index_sequence<BIndex...>) {\n+\n+    // Initialize an array of mutable byte references and sizes with references\n+    // set to the appropriate pointer in `params`; as we iterate, we'll\n+    // increment each pointer by its size (except for singletons, which get an\n+    // increment of 0).\n+    std::array<std::pair<unsigned char *&, const size_t>, NVectorized>\n+        vecparams{{std::pair<unsigned char *&, const size_t>(\n+            reinterpret_cast<unsigned char *&>(params[VIndex] =\n+                                                   buffers[BIndex].ptr),\n+            buffers[BIndex].size == 1 ? 0 : sizeof(param_n_t<VIndex>))...}};\n+\n+    for (size_t i = 0; i < size; ++i) {\n+      out[i] = f(*reinterpret_cast<param_n_t<Index> *>(params[Index])...);\n+      for (auto &x : vecparams)\n+        x.first += x.second;\n+    }\n+  }\n+\n+  template <size_t... Index, size_t... VIndex, size_t... BIndex>\n+  void apply_broadcast(std::array<buffer_info, NVectorized> &buffers,\n+                       std::array<void *, N> &params,\n+                       array_t<Return> &output_array, index_sequence<Index...>,\n+                       index_sequence<VIndex...>, index_sequence<BIndex...>) {\n+\n+    buffer_info output = output_array.request();\n+    multi_array_iterator<NVectorized> input_iter(buffers, output.shape);\n+\n+    for (array_iterator<Return> iter = array_begin<Return>(output),\n+                                end = array_end<Return>(output);\n+         iter != end; ++iter, ++input_iter) {\n+      PYBIND11_EXPAND_SIDE_EFFECTS(\n+          (params[VIndex] = input_iter.template data<BIndex>()));\n+      *iter =\n+          f(*reinterpret_cast<param_n_t<Index> *>(std::get<Index>(params))...);\n+    }\n+  }\n+};\n+\n+template <typename Func, typename Return, typename... Args>\n+vectorize_helper<Func, Return, Args...>\n+vectorize_extractor(const Func &f, Return (*)(Args...)) {\n+  return detail::vectorize_helper<Func, Return, Args...>(f);\n+}\n+\n+template <typename T, int Flags> struct handle_type_name<array_t<T, Flags>> {\n+  static constexpr auto name =\n+      _(\"numpy.ndarray[\") + npy_format_descriptor<T>::name + _(\"]\");\n+};\n+\n+NAMESPACE_END(detail)\n+\n+// Vanilla pointer vectorizer:\n+template <typename Return, typename... Args>\n+detail::vectorize_helper<Return (*)(Args...), Return, Args...>\n+vectorize(Return (*f)(Args...)) {\n+  return detail::vectorize_helper<Return (*)(Args...), Return, Args...>(f);\n+}\n+\n+// lambda vectorizer:\n+template <typename Func,\n+          detail::enable_if_t<detail::is_lambda<Func>::value, int> = 0>\n+auto vectorize(Func &&f) -> decltype(detail::vectorize_extractor(\n+    std::forward<Func>(f), (detail::function_signature_t<Func> *)nullptr)) {\n+  return detail::vectorize_extractor(\n+      std::forward<Func>(f), (detail::function_signature_t<Func> *)nullptr);\n+}\n+\n+// Vectorize a class method (non-const):\n+template <typename Return, typename Class, typename... Args,\n+          typename Helper = detail::vectorize_helper<\n+              decltype(std::mem_fn(std::declval<Return (Class::*)(Args...)>())),\n+              Return, Class *, Args...>>\n+Helper vectorize(Return (Class::*f)(Args...)) {\n+  return Helper(std::mem_fn(f));\n+}\n+\n+// Vectorize a class method (const):\n+template <\n+    typename Return, typename Class, typename... Args,\n+    typename Helper = detail::vectorize_helper<\n+        decltype(std::mem_fn(std::declval<Return (Class::*)(Args...) const>())),\n+        Return, const Class *, Args...>>\n+Helper vectorize(Return (Class::*f)(Args...) const) {\n+  return Helper(std::mem_fn(f));\n+}\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)\n+\n+#if defined(_MSC_VER)\n+#pragma warning(pop)\n+#endif"}, {"filename": "python/src/pybind11/operators.h", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "file_content_changes": "@@ -0,0 +1,228 @@\n+/*\n+    pybind11/operator.h: Metatemplates for operator overloading\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+\n+#if defined(__clang__) && !defined(__INTEL_COMPILER)\n+#pragma clang diagnostic ignored                                               \\\n+    \"-Wunsequenced\" // multiple unsequenced modifications to 'self' (when using\n+                    // def(py::self OP Type()))\n+#elif defined(_MSC_VER)\n+#pragma warning(push)\n+#pragma warning(                                                               \\\n+    disable : 4127) // warning C4127: Conditional expression is constant\n+#endif\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+/// Enumeration with all supported operator types\n+enum op_id : int {\n+  op_add,\n+  op_sub,\n+  op_mul,\n+  op_div,\n+  op_mod,\n+  op_divmod,\n+  op_pow,\n+  op_lshift,\n+  op_rshift,\n+  op_and,\n+  op_xor,\n+  op_or,\n+  op_neg,\n+  op_pos,\n+  op_abs,\n+  op_invert,\n+  op_int,\n+  op_long,\n+  op_float,\n+  op_str,\n+  op_cmp,\n+  op_gt,\n+  op_ge,\n+  op_lt,\n+  op_le,\n+  op_eq,\n+  op_ne,\n+  op_iadd,\n+  op_isub,\n+  op_imul,\n+  op_idiv,\n+  op_imod,\n+  op_ilshift,\n+  op_irshift,\n+  op_iand,\n+  op_ixor,\n+  op_ior,\n+  op_complex,\n+  op_bool,\n+  op_nonzero,\n+  op_repr,\n+  op_truediv,\n+  op_itruediv,\n+  op_hash\n+};\n+\n+enum op_type : int {\n+  op_l, /* base type on left */\n+  op_r, /* base type on right */\n+  op_u  /* unary operator */\n+};\n+\n+struct self_t {};\n+static const self_t self = self_t();\n+\n+/// Type for an unused type slot\n+struct undefined_t {};\n+\n+/// Don't warn about an unused variable\n+inline self_t __self() { return self; }\n+\n+/// base template of operator implementations\n+template <op_id, op_type, typename B, typename L, typename R> struct op_impl {};\n+\n+/// Operator implementation generator\n+template <op_id id, op_type ot, typename L, typename R> struct op_ {\n+  template <typename Class, typename... Extra>\n+  void execute(Class &cl, const Extra &...extra) const {\n+    using Base = typename Class::type;\n+    using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;\n+    using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;\n+    using op = op_impl<id, ot, Base, L_type, R_type>;\n+    cl.def(op::name(), &op::execute, is_operator(), extra...);\n+#if PY_MAJOR_VERSION < 3\n+    if (id == op_truediv || id == op_itruediv)\n+      cl.def(id == op_itruediv ? \"__idiv__\"\n+             : ot == op_l      ? \"__div__\"\n+                               : \"__rdiv__\",\n+             &op::execute, is_operator(), extra...);\n+#endif\n+  }\n+  template <typename Class, typename... Extra>\n+  void execute_cast(Class &cl, const Extra &...extra) const {\n+    using Base = typename Class::type;\n+    using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;\n+    using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;\n+    using op = op_impl<id, ot, Base, L_type, R_type>;\n+    cl.def(op::name(), &op::execute_cast, is_operator(), extra...);\n+#if PY_MAJOR_VERSION < 3\n+    if (id == op_truediv || id == op_itruediv)\n+      cl.def(id == op_itruediv ? \"__idiv__\"\n+             : ot == op_l      ? \"__div__\"\n+                               : \"__rdiv__\",\n+             &op::execute, is_operator(), extra...);\n+#endif\n+  }\n+};\n+\n+#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                            \\\n+  template <typename B, typename L, typename R>                                \\\n+  struct op_impl<op_##id, op_l, B, L, R> {                                     \\\n+    static char const *name() { return \"__\" #id \"__\"; }                        \\\n+    static auto execute(const L &l, const R &r) -> decltype(expr) {            \\\n+      return (expr);                                                           \\\n+    }                                                                          \\\n+    static B execute_cast(const L &l, const R &r) { return B(expr); }          \\\n+  };                                                                           \\\n+  template <typename B, typename L, typename R>                                \\\n+  struct op_impl<op_##id, op_r, B, L, R> {                                     \\\n+    static char const *name() { return \"__\" #rid \"__\"; }                       \\\n+    static auto execute(const R &r, const L &l) -> decltype(expr) {            \\\n+      return (expr);                                                           \\\n+    }                                                                          \\\n+    static B execute_cast(const R &r, const L &l) { return B(expr); }          \\\n+  };                                                                           \\\n+  inline op_<op_##id, op_l, self_t, self_t> op(const self_t &,                 \\\n+                                               const self_t &) {               \\\n+    return op_<op_##id, op_l, self_t, self_t>();                               \\\n+  }                                                                            \\\n+  template <typename T>                                                        \\\n+  op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                \\\n+    return op_<op_##id, op_l, self_t, T>();                                    \\\n+  }                                                                            \\\n+  template <typename T>                                                        \\\n+  op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {                \\\n+    return op_<op_##id, op_r, T, self_t>();                                    \\\n+  }\n+\n+#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                \\\n+  template <typename B, typename L, typename R>                                \\\n+  struct op_impl<op_##id, op_l, B, L, R> {                                     \\\n+    static char const *name() { return \"__\" #id \"__\"; }                        \\\n+    static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }   \\\n+    static B execute_cast(L &l, const R &r) { return B(expr); }                \\\n+  };                                                                           \\\n+  template <typename T>                                                        \\\n+  op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                \\\n+    return op_<op_##id, op_l, self_t, T>();                                    \\\n+  }\n+\n+#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                  \\\n+  template <typename B, typename L>                                            \\\n+  struct op_impl<op_##id, op_u, B, L, undefined_t> {                           \\\n+    static char const *name() { return \"__\" #id \"__\"; }                        \\\n+    static auto execute(const L &l) -> decltype(expr) { return expr; }         \\\n+    static B execute_cast(const L &l) { return B(expr); }                      \\\n+  };                                                                           \\\n+  inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {          \\\n+    return op_<op_##id, op_u, self_t, undefined_t>();                          \\\n+  }\n+\n+PYBIND11_BINARY_OPERATOR(sub, rsub, operator-, l - r)\n+PYBIND11_BINARY_OPERATOR(add, radd, operator+, l + r)\n+PYBIND11_BINARY_OPERATOR(mul, rmul, operator*, l *r)\n+PYBIND11_BINARY_OPERATOR(truediv, rtruediv, operator/, l / r)\n+PYBIND11_BINARY_OPERATOR(mod, rmod, operator%, l % r)\n+PYBIND11_BINARY_OPERATOR(lshift, rlshift, operator<<, l << r)\n+PYBIND11_BINARY_OPERATOR(rshift, rrshift, operator>>, l >> r)\n+PYBIND11_BINARY_OPERATOR(and, rand, operator&, l &r)\n+PYBIND11_BINARY_OPERATOR(xor, rxor, operator^, l ^ r)\n+PYBIND11_BINARY_OPERATOR(eq, eq, operator==, l == r)\n+PYBIND11_BINARY_OPERATOR(ne, ne, operator!=, l != r)\n+PYBIND11_BINARY_OPERATOR(or, ror, operator|, l | r)\n+PYBIND11_BINARY_OPERATOR(gt, lt, operator>, l > r)\n+PYBIND11_BINARY_OPERATOR(ge, le, operator>=, l >= r)\n+PYBIND11_BINARY_OPERATOR(lt, gt, operator<, l < r)\n+PYBIND11_BINARY_OPERATOR(le, ge, operator<=, l <= r)\n+// PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,\n+// r))\n+PYBIND11_INPLACE_OPERATOR(iadd, operator+=, l += r)\n+PYBIND11_INPLACE_OPERATOR(isub, operator-=, l -= r)\n+PYBIND11_INPLACE_OPERATOR(imul, operator*=, l *= r)\n+PYBIND11_INPLACE_OPERATOR(itruediv, operator/=, l /= r)\n+PYBIND11_INPLACE_OPERATOR(imod, operator%=, l %= r)\n+PYBIND11_INPLACE_OPERATOR(ilshift, operator<<=, l <<= r)\n+PYBIND11_INPLACE_OPERATOR(irshift, operator>>=, l >>= r)\n+PYBIND11_INPLACE_OPERATOR(iand, operator&=, l &= r)\n+PYBIND11_INPLACE_OPERATOR(ixor, operator^=, l ^= r)\n+PYBIND11_INPLACE_OPERATOR(ior, operator|=, l |= r)\n+PYBIND11_UNARY_OPERATOR(neg, operator-, -l)\n+PYBIND11_UNARY_OPERATOR(pos, operator+, +l)\n+PYBIND11_UNARY_OPERATOR(abs, abs, std::abs(l))\n+PYBIND11_UNARY_OPERATOR(hash, hash, std::hash<L>()(l))\n+PYBIND11_UNARY_OPERATOR(invert, operator~, (~l))\n+PYBIND11_UNARY_OPERATOR(bool, operator!, !!l)\n+PYBIND11_UNARY_OPERATOR(int, int_, (int)l)\n+PYBIND11_UNARY_OPERATOR(float, float_, (double)l)\n+\n+#undef PYBIND11_BINARY_OPERATOR\n+#undef PYBIND11_INPLACE_OPERATOR\n+#undef PYBIND11_UNARY_OPERATOR\n+NAMESPACE_END(detail)\n+\n+using detail::self;\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)\n+\n+#if defined(_MSC_VER)\n+#pragma warning(pop)\n+#endif"}, {"filename": "python/src/pybind11/options.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "file_content_changes": "@@ -0,0 +1,79 @@\n+/*\n+    pybind11/options.h: global settings that are configurable at runtime.\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+class options {\n+public:\n+  // Default RAII constructor, which leaves settings as they currently are.\n+  options() : previous_state(global_state()) {}\n+\n+  // Class is non-copyable.\n+  options(const options &) = delete;\n+  options &operator=(const options &) = delete;\n+\n+  // Destructor, which restores settings that were in effect before.\n+  ~options() { global_state() = previous_state; }\n+\n+  // Setter methods (affect the global state):\n+\n+  options &disable_user_defined_docstrings() & {\n+    global_state().show_user_defined_docstrings = false;\n+    return *this;\n+  }\n+\n+  options &enable_user_defined_docstrings() & {\n+    global_state().show_user_defined_docstrings = true;\n+    return *this;\n+  }\n+\n+  options &disable_function_signatures() & {\n+    global_state().show_function_signatures = false;\n+    return *this;\n+  }\n+\n+  options &enable_function_signatures() & {\n+    global_state().show_function_signatures = true;\n+    return *this;\n+  }\n+\n+  // Getter methods (return the global state):\n+\n+  static bool show_user_defined_docstrings() {\n+    return global_state().show_user_defined_docstrings;\n+  }\n+\n+  static bool show_function_signatures() {\n+    return global_state().show_function_signatures;\n+  }\n+\n+  // This type is not meant to be allocated on the heap.\n+  void *operator new(size_t) = delete;\n+\n+private:\n+  struct state {\n+    bool show_user_defined_docstrings =\n+        true; //< Include user-supplied texts in docstrings.\n+    bool show_function_signatures =\n+        true; //< Include auto-generated function signatures in docstrings.\n+  };\n+\n+  static state &global_state() {\n+    static state instance;\n+    return instance;\n+  }\n+\n+  state previous_state;\n+};\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/pybind11.h", "status": "added", "additions": 2438, "deletions": 0, "changes": 2438, "file_content_changes": "@@ -0,0 +1,2438 @@\n+/*\n+    pybind11/pybind11.h: Main header file of the C++11 python\n+    binding generator library\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#if defined(__INTEL_COMPILER)\n+#pragma warning push\n+#pragma warning disable 68 // integer conversion resulted in a change of sign\n+#pragma warning                                                                \\\n+    disable 186 // pointless comparison of unsigned integer with zero\n+#pragma warning disable 878 // incompatible exception specifications\n+#pragma warning                                                                \\\n+    disable 1334 // the \"template\" keyword used for syntactic disambiguation may\n+                 // only be used within a template\n+#pragma warning                                                                \\\n+    disable 1682 // implicit conversion of a 64-bit integral type to a smaller\n+                 // integral type (potential portability problem)\n+#pragma warning disable 1786 // function \"strdup\" was declared deprecated\n+#pragma warning disable 1875 // offsetof applied to non-POD (Plain Old Data)\n+                             // types is nonstandard\n+#pragma warning                                                                \\\n+    disable 2196 // warning #2196: routine is both \"inline\" and \"noinline\"\n+#elif defined(_MSC_VER)\n+#pragma warning(push)\n+#pragma warning(disable : 4100) // warning C4100: Unreferenced formal parameter\n+#pragma warning(                                                               \\\n+    disable : 4127) // warning C4127: Conditional expression is constant\n+#pragma warning(disable : 4512) // warning C4512: Assignment operator was\n+                                // implicitly defined as deleted\n+#pragma warning(disable : 4800) // warning C4800: 'int': forcing value to bool\n+                                // 'true' or 'false' (performance warning)\n+#pragma warning(disable : 4996) // warning C4996: The POSIX name for this item\n+                                // is deprecated. Instead, use the ISO C and C++\n+                                // conformant name\n+#pragma warning(disable : 4702) // warning C4702: unreachable code\n+#pragma warning(                                                               \\\n+    disable : 4522) // warning C4522: multiple assignment operators specified\n+#elif defined(__GNUG__) && !defined(__clang__)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-but-set-parameter\"\n+#pragma GCC diagnostic ignored \"-Wunused-but-set-variable\"\n+#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"\n+#pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n+#pragma GCC diagnostic ignored \"-Wattributes\"\n+#if __GNUC__ >= 7\n+#pragma GCC diagnostic ignored \"-Wnoexcept-type\"\n+#endif\n+#endif\n+\n+#if defined(__GNUG__) && !defined(__clang__)\n+#include <cxxabi.h>\n+#endif\n+\n+#include \"attr.h\"\n+#include \"detail/class.h\"\n+#include \"detail/init.h\"\n+#include \"options.h\"\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+/// Wraps an arbitrary C++ function/method/lambda function/.. into a callable\n+/// Python object\n+class cpp_function : public function {\n+public:\n+  cpp_function() {}\n+  cpp_function(std::nullptr_t) {}\n+\n+  /// Construct a cpp_function from a vanilla function pointer\n+  template <typename Return, typename... Args, typename... Extra>\n+  cpp_function(Return (*f)(Args...), const Extra &...extra) {\n+    initialize(f, f, extra...);\n+  }\n+\n+  /// Construct a cpp_function from a lambda function (possibly with internal\n+  /// state)\n+  template <typename Func, typename... Extra,\n+            typename = detail::enable_if_t<detail::is_lambda<Func>::value>>\n+  cpp_function(Func &&f, const Extra &...extra) {\n+    initialize(std::forward<Func>(f),\n+               (detail::function_signature_t<Func> *)nullptr, extra...);\n+  }\n+\n+  /// Construct a cpp_function from a class method (non-const)\n+  template <typename Return, typename Class, typename... Arg, typename... Extra>\n+  cpp_function(Return (Class::*f)(Arg...), const Extra &...extra) {\n+    initialize(\n+        [f](Class *c, Arg... args) -> Return { return (c->*f)(args...); },\n+        (Return(*)(Class *, Arg...)) nullptr, extra...);\n+  }\n+\n+  /// Construct a cpp_function from a class method (const)\n+  template <typename Return, typename Class, typename... Arg, typename... Extra>\n+  cpp_function(Return (Class::*f)(Arg...) const, const Extra &...extra) {\n+    initialize(\n+        [f](const Class *c, Arg... args) -> Return { return (c->*f)(args...); },\n+        (Return(*)(const Class *, Arg...)) nullptr, extra...);\n+  }\n+\n+  /// Return the function name\n+  object name() const { return attr(\"__name__\"); }\n+\n+protected:\n+  /// Space optimization: don't inline this frequently instantiated fragment\n+  PYBIND11_NOINLINE detail::function_record *make_function_record() {\n+    return new detail::function_record();\n+  }\n+\n+  /// Special internal constructor for functors, lambda functions, etc.\n+  template <typename Func, typename Return, typename... Args, typename... Extra>\n+  void initialize(Func &&f, Return (*)(Args...), const Extra &...extra) {\n+    using namespace detail;\n+    struct capture {\n+      remove_reference_t<Func> f;\n+    };\n+\n+    /* Store the function including any extra state it might have (e.g. a lambda\n+     * capture object) */\n+    auto rec = make_function_record();\n+\n+    /* Store the capture object directly in the function record if there is\n+     * enough space */\n+    if (sizeof(capture) <= sizeof(rec->data)) {\n+      /* Without these pragmas, GCC warns that there might not be\n+         enough space to use the placement new operator. However, the\n+         'if' statement above ensures that this is the case. */\n+#if defined(__GNUG__) && !defined(__clang__) && __GNUC__ >= 6\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wplacement-new\"\n+#endif\n+      new ((capture *)&rec->data) capture{std::forward<Func>(f)};\n+#if defined(__GNUG__) && !defined(__clang__) && __GNUC__ >= 6\n+#pragma GCC diagnostic pop\n+#endif\n+      if (!std::is_trivially_destructible<Func>::value)\n+        rec->free_data = [](function_record *r) {\n+          ((capture *)&r->data)->~capture();\n+        };\n+    } else {\n+      rec->data[0] = new capture{std::forward<Func>(f)};\n+      rec->free_data = [](function_record *r) {\n+        delete ((capture *)r->data[0]);\n+      };\n+    }\n+\n+    /* Type casters for the function arguments and return value */\n+    using cast_in = argument_loader<Args...>;\n+    using cast_out = make_caster<\n+        conditional_t<std::is_void<Return>::value, void_type, Return>>;\n+\n+    static_assert(expected_num_args<Extra...>(\n+                      sizeof...(Args), cast_in::has_args, cast_in::has_kwargs),\n+                  \"The number of argument annotations does not match the \"\n+                  \"number of function arguments\");\n+\n+    /* Dispatch code which converts function arguments and performs the actual\n+     * function call */\n+    rec->impl = [](function_call &call) -> handle {\n+      cast_in args_converter;\n+\n+      /* Try to cast the function arguments into the C++ domain */\n+      if (!args_converter.load_args(call))\n+        return PYBIND11_TRY_NEXT_OVERLOAD;\n+\n+      /* Invoke call policy pre-call hook */\n+      process_attributes<Extra...>::precall(call);\n+\n+      /* Get a pointer to the capture object */\n+      auto data =\n+          (sizeof(capture) <= sizeof(call.func.data) ? &call.func.data\n+                                                     : call.func.data[0]);\n+      capture *cap =\n+          const_cast<capture *>(reinterpret_cast<const capture *>(data));\n+\n+      /* Override policy for rvalues -- usually to enforce rvp::move on an\n+       * rvalue */\n+      return_value_policy policy =\n+          return_value_policy_override<Return>::policy(call.func.policy);\n+\n+      /* Function scope guard -- defaults to the compile-to-nothing `void_type`\n+       */\n+      using Guard = extract_guard_t<Extra...>;\n+\n+      /* Perform the function call */\n+      handle result = cast_out::cast(\n+          std::move(args_converter).template call<Return, Guard>(cap->f),\n+          policy, call.parent);\n+\n+      /* Invoke call policy post-call hook */\n+      process_attributes<Extra...>::postcall(call, result);\n+\n+      return result;\n+    };\n+\n+    /* Process any user-provided function attributes */\n+    process_attributes<Extra...>::init(extra..., rec);\n+\n+    /* Generate a readable signature describing the function's arguments and\n+     * return value types */\n+    static constexpr auto signature =\n+        _(\"(\") + cast_in::arg_names + _(\") -> \") + cast_out::name;\n+    PYBIND11_DESCR_CONSTEXPR auto types = decltype(signature)::types();\n+\n+    /* Register the function with Python from generic (non-templated) code */\n+    initialize_generic(rec, signature.text, types.data(), sizeof...(Args));\n+\n+    if (cast_in::has_args)\n+      rec->has_args = true;\n+    if (cast_in::has_kwargs)\n+      rec->has_kwargs = true;\n+\n+    /* Stash some additional information used by an important optimization in\n+     * 'functional.h' */\n+    using FunctionType = Return (*)(Args...);\n+    constexpr bool is_function_ptr =\n+        std::is_convertible<Func, FunctionType>::value &&\n+        sizeof(capture) == sizeof(void *);\n+    if (is_function_ptr) {\n+      rec->is_stateless = true;\n+      rec->data[1] = const_cast<void *>(\n+          reinterpret_cast<const void *>(&typeid(FunctionType)));\n+    }\n+  }\n+\n+  /// Register a function call with Python (generic non-templated code goes\n+  /// here)\n+  void initialize_generic(detail::function_record *rec, const char *text,\n+                          const std::type_info *const *types, size_t args) {\n+\n+    /* Create copies of all referenced C-style strings */\n+    rec->name = strdup(rec->name ? rec->name : \"\");\n+    if (rec->doc)\n+      rec->doc = strdup(rec->doc);\n+    for (auto &a : rec->args) {\n+      if (a.name)\n+        a.name = strdup(a.name);\n+      if (a.descr)\n+        a.descr = strdup(a.descr);\n+      else if (a.value)\n+        a.descr =\n+            strdup(a.value.attr(\"__repr__\")().cast<std::string>().c_str());\n+    }\n+\n+    rec->is_constructor =\n+        !strcmp(rec->name, \"__init__\") || !strcmp(rec->name, \"__setstate__\");\n+\n+#if !defined(NDEBUG) && !defined(PYBIND11_DISABLE_NEW_STYLE_INIT_WARNING)\n+    if (rec->is_constructor && !rec->is_new_style_constructor) {\n+      const auto class_name =\n+          std::string(((PyTypeObject *)rec->scope.ptr())->tp_name);\n+      const auto func_name = std::string(rec->name);\n+      PyErr_WarnEx(\n+          PyExc_FutureWarning,\n+          (\"pybind11-bound class '\" + class_name +\n+           \"' is using an old-style \"\n+           \"placement-new '\" +\n+           func_name +\n+           \"' which has been deprecated. See \"\n+           \"the upgrade guide in pybind11's docs. This message is only visible \"\n+           \"when compiled in debug mode.\")\n+              .c_str(),\n+          0);\n+    }\n+#endif\n+\n+    /* Generate a proper function signature */\n+    std::string signature;\n+    size_t type_index = 0, arg_index = 0;\n+    for (auto *pc = text; *pc != '\\0'; ++pc) {\n+      const auto c = *pc;\n+\n+      if (c == '{') {\n+        // Write arg name for everything except *args and **kwargs.\n+        if (*(pc + 1) == '*')\n+          continue;\n+\n+        if (arg_index < rec->args.size() && rec->args[arg_index].name) {\n+          signature += rec->args[arg_index].name;\n+        } else if (arg_index == 0 && rec->is_method) {\n+          signature += \"self\";\n+        } else {\n+          signature +=\n+              \"arg\" + std::to_string(arg_index - (rec->is_method ? 1 : 0));\n+        }\n+        signature += \": \";\n+      } else if (c == '}') {\n+        // Write default value if available.\n+        if (arg_index < rec->args.size() && rec->args[arg_index].descr) {\n+          signature += \" = \";\n+          signature += rec->args[arg_index].descr;\n+        }\n+        arg_index++;\n+      } else if (c == '%') {\n+        const std::type_info *t = types[type_index++];\n+        if (!t)\n+          pybind11_fail(\"Internal error while parsing type signature (1)\");\n+        if (auto tinfo = detail::get_type_info(*t)) {\n+          handle th((PyObject *)tinfo->type);\n+          signature += th.attr(\"__module__\").cast<std::string>() + \".\" +\n+                       th.attr(\"__qualname__\")\n+                           .cast<std::string>(); // Python 3.3+, but we backport\n+                                                 // it to earlier versions\n+        } else if (rec->is_new_style_constructor && arg_index == 0) {\n+          // A new-style `__init__` takes `self` as `value_and_holder`.\n+          // Rewrite it to the proper class type.\n+          signature += rec->scope.attr(\"__module__\").cast<std::string>() + \".\" +\n+                       rec->scope.attr(\"__qualname__\").cast<std::string>();\n+        } else {\n+          std::string tname(t->name());\n+          detail::clean_type_id(tname);\n+          signature += tname;\n+        }\n+      } else {\n+        signature += c;\n+      }\n+    }\n+    if (arg_index != args || types[type_index] != nullptr)\n+      pybind11_fail(\"Internal error while parsing type signature (2)\");\n+\n+#if PY_MAJOR_VERSION < 3\n+    if (strcmp(rec->name, \"__next__\") == 0) {\n+      std::free(rec->name);\n+      rec->name = strdup(\"next\");\n+    } else if (strcmp(rec->name, \"__bool__\") == 0) {\n+      std::free(rec->name);\n+      rec->name = strdup(\"__nonzero__\");\n+    }\n+#endif\n+    rec->signature = strdup(signature.c_str());\n+    rec->args.shrink_to_fit();\n+    rec->nargs = (std::uint16_t)args;\n+\n+    if (rec->sibling && PYBIND11_INSTANCE_METHOD_CHECK(rec->sibling.ptr()))\n+      rec->sibling = PYBIND11_INSTANCE_METHOD_GET_FUNCTION(rec->sibling.ptr());\n+\n+    detail::function_record *chain = nullptr, *chain_start = rec;\n+    if (rec->sibling) {\n+      if (PyCFunction_Check(rec->sibling.ptr())) {\n+        auto rec_capsule = reinterpret_borrow<capsule>(\n+            PyCFunction_GET_SELF(rec->sibling.ptr()));\n+        chain = (detail::function_record *)rec_capsule;\n+        /* Never append a method to an overload chain of a parent class;\n+           instead, hide the parent's overloads in this case */\n+        if (!chain->scope.is(rec->scope))\n+          chain = nullptr;\n+      }\n+      // Don't trigger for things like the default __init__, which are\n+      // wrapper_descriptors that we are intentionally replacing\n+      else if (!rec->sibling.is_none() && rec->name[0] != '_')\n+        pybind11_fail(\"Cannot overload existing non-function object \\\"\" +\n+                      std::string(rec->name) +\n+                      \"\\\" with a function of the same name\");\n+    }\n+\n+    if (!chain) {\n+      /* No existing overload was found, create a new function object */\n+      rec->def = new PyMethodDef();\n+      std::memset(rec->def, 0, sizeof(PyMethodDef));\n+      rec->def->ml_name = rec->name;\n+      rec->def->ml_meth = reinterpret_cast<PyCFunction>(\n+          reinterpret_cast<void (*)(void)>(*dispatcher));\n+      rec->def->ml_flags = METH_VARARGS | METH_KEYWORDS;\n+\n+      capsule rec_capsule(\n+          rec, [](void *ptr) { destruct((detail::function_record *)ptr); });\n+\n+      object scope_module;\n+      if (rec->scope) {\n+        if (hasattr(rec->scope, \"__module__\")) {\n+          scope_module = rec->scope.attr(\"__module__\");\n+        } else if (hasattr(rec->scope, \"__name__\")) {\n+          scope_module = rec->scope.attr(\"__name__\");\n+        }\n+      }\n+\n+      m_ptr =\n+          PyCFunction_NewEx(rec->def, rec_capsule.ptr(), scope_module.ptr());\n+      if (!m_ptr)\n+        pybind11_fail(\n+            \"cpp_function::cpp_function(): Could not allocate function object\");\n+    } else {\n+      /* Append at the end of the overload chain */\n+      m_ptr = rec->sibling.ptr();\n+      inc_ref();\n+      chain_start = chain;\n+      if (chain->is_method != rec->is_method)\n+        pybind11_fail(\"overloading a method with both static and instance \"\n+                      \"methods is not supported; \"\n+#if defined(NDEBUG)\n+                      \"compile in debug mode for more details\"\n+#else\n+                      \"error while attempting to bind \" +\n+                      std::string(rec->is_method ? \"instance\" : \"static\") +\n+                      \" method \" +\n+                      std::string(pybind11::str(rec->scope.attr(\"__name__\"))) +\n+                      \".\" + std::string(rec->name) + signature\n+#endif\n+        );\n+      while (chain->next)\n+        chain = chain->next;\n+      chain->next = rec;\n+    }\n+\n+    std::string signatures;\n+    int index = 0;\n+    /* Create a nice pydoc rec including all signatures and\n+       docstrings of the functions in the overload chain */\n+    if (chain && options::show_function_signatures()) {\n+      // First a generic signature\n+      signatures += rec->name;\n+      signatures += \"(*args, **kwargs)\\n\";\n+      signatures += \"Overloaded function.\\n\\n\";\n+    }\n+    // Then specific overload signatures\n+    bool first_user_def = true;\n+    for (auto it = chain_start; it != nullptr; it = it->next) {\n+      if (options::show_function_signatures()) {\n+        if (index > 0)\n+          signatures += \"\\n\";\n+        if (chain)\n+          signatures += std::to_string(++index) + \". \";\n+        signatures += rec->name;\n+        signatures += it->signature;\n+        signatures += \"\\n\";\n+      }\n+      if (it->doc && strlen(it->doc) > 0 &&\n+          options::show_user_defined_docstrings()) {\n+        // If we're appending another docstring, and aren't printing function\n+        // signatures, we need to append a newline first:\n+        if (!options::show_function_signatures()) {\n+          if (first_user_def)\n+            first_user_def = false;\n+          else\n+            signatures += \"\\n\";\n+        }\n+        if (options::show_function_signatures())\n+          signatures += \"\\n\";\n+        signatures += it->doc;\n+        if (options::show_function_signatures())\n+          signatures += \"\\n\";\n+      }\n+    }\n+\n+    /* Install docstring */\n+    PyCFunctionObject *func = (PyCFunctionObject *)m_ptr;\n+    if (func->m_ml->ml_doc)\n+      std::free(const_cast<char *>(func->m_ml->ml_doc));\n+    func->m_ml->ml_doc = strdup(signatures.c_str());\n+\n+    if (rec->is_method) {\n+      m_ptr = PYBIND11_INSTANCE_METHOD_NEW(m_ptr, rec->scope.ptr());\n+      if (!m_ptr)\n+        pybind11_fail(\"cpp_function::cpp_function(): Could not allocate \"\n+                      \"instance method object\");\n+      Py_DECREF(func);\n+    }\n+  }\n+\n+  /// When a cpp_function is GCed, release any memory allocated by pybind11\n+  static void destruct(detail::function_record *rec) {\n+    while (rec) {\n+      detail::function_record *next = rec->next;\n+      if (rec->free_data)\n+        rec->free_data(rec);\n+      std::free((char *)rec->name);\n+      std::free((char *)rec->doc);\n+      std::free((char *)rec->signature);\n+      for (auto &arg : rec->args) {\n+        std::free(const_cast<char *>(arg.name));\n+        std::free(const_cast<char *>(arg.descr));\n+        arg.value.dec_ref();\n+      }\n+      if (rec->def) {\n+        std::free(const_cast<char *>(rec->def->ml_doc));\n+        delete rec->def;\n+      }\n+      delete rec;\n+      rec = next;\n+    }\n+  }\n+\n+  /// Main dispatch logic for calls to functions bound using pybind11\n+  static PyObject *dispatcher(PyObject *self, PyObject *args_in,\n+                              PyObject *kwargs_in) {\n+    using namespace detail;\n+\n+    /* Iterator over the list of potentially admissible overloads */\n+    const function_record *overloads = (function_record *)PyCapsule_GetPointer(\n+                              self, nullptr),\n+                          *it = overloads;\n+\n+    /* Need to know how many arguments + keyword arguments there are to pick the\n+     * right overload */\n+    const size_t n_args_in = (size_t)PyTuple_GET_SIZE(args_in);\n+\n+    handle parent = n_args_in > 0 ? PyTuple_GET_ITEM(args_in, 0) : nullptr,\n+           result = PYBIND11_TRY_NEXT_OVERLOAD;\n+\n+    auto self_value_and_holder = value_and_holder();\n+    if (overloads->is_constructor) {\n+      const auto tinfo = get_type_info((PyTypeObject *)overloads->scope.ptr());\n+      const auto pi = reinterpret_cast<instance *>(parent.ptr());\n+      self_value_and_holder = pi->get_value_and_holder(tinfo, false);\n+\n+      if (!self_value_and_holder.type || !self_value_and_holder.inst) {\n+        PyErr_SetString(\n+            PyExc_TypeError,\n+            \"__init__(self, ...) called with invalid `self` argument\");\n+        return nullptr;\n+      }\n+\n+      // If this value is already registered it must mean __init__ is invoked\n+      // multiple times; we really can't support that in C++, so just ignore the\n+      // second __init__.\n+      if (self_value_and_holder.instance_registered())\n+        return none().release().ptr();\n+    }\n+\n+    try {\n+      // We do this in two passes: in the first pass, we load arguments with\n+      // `convert=false`; in the second, we allow conversion (except for\n+      // arguments with an explicit py::arg().noconvert()).  This lets us prefer\n+      // calls without conversion, with conversion as a fallback.\n+      std::vector<function_call> second_pass;\n+\n+      // However, if there are no overloads, we can just skip the no-convert\n+      // pass entirely\n+      const bool overloaded = it != nullptr && it->next != nullptr;\n+\n+      for (; it != nullptr; it = it->next) {\n+\n+        /* For each overload:\n+           1. Copy all positional arguments we were given, also checking to make\n+           sure that named positional arguments weren't *also* specified via\n+           kwarg.\n+           2. If we weren't given enough, try to make up the omitted ones by\n+           checking whether they were provided by a kwarg matching the\n+           `py::arg(\"name\")` name.  If so, use it (and remove it from kwargs; if\n+           not, see if the function binding provided a default that we can use.\n+           3. Ensure that either all keyword arguments were \"consumed\", or that\n+           the function takes a kwargs argument to accept unconsumed kwargs.\n+           4. Any positional arguments still left get put into a tuple (for\n+           args), and any leftover kwargs get put into a dict.\n+           5. Pack everything into a vector; if we have py::args or py::kwargs,\n+           they are an extra tuple or dict at the end of the positional\n+           arguments.\n+           6. Call the function call dispatcher (function_record::impl)\n+\n+           If one of these fail, move on to the next overload and keep trying\n+           until we get a result other than PYBIND11_TRY_NEXT_OVERLOAD.\n+         */\n+\n+        const function_record &func = *it;\n+        size_t pos_args =\n+            func.nargs; // Number of positional arguments that we need\n+        if (func.has_args)\n+          --pos_args; // (but don't count py::args\n+        if (func.has_kwargs)\n+          --pos_args; //  or py::kwargs)\n+\n+        if (!func.has_args && n_args_in > pos_args)\n+          continue; // Too many arguments for this overload\n+\n+        if (n_args_in < pos_args && func.args.size() < pos_args)\n+          continue; // Not enough arguments given, and not enough defaults to\n+                    // fill in the blanks\n+\n+        function_call call(func, parent);\n+\n+        size_t args_to_copy = std::min(pos_args, n_args_in);\n+        size_t args_copied = 0;\n+\n+        // 0. Inject new-style `self` argument\n+        if (func.is_new_style_constructor) {\n+          // The `value` may have been preallocated by an old-style `__init__`\n+          // if it was a preceding candidate for overload resolution.\n+          if (self_value_and_holder)\n+            self_value_and_holder.type->dealloc(self_value_and_holder);\n+\n+          call.init_self = PyTuple_GET_ITEM(args_in, 0);\n+          call.args.push_back(\n+              reinterpret_cast<PyObject *>(&self_value_and_holder));\n+          call.args_convert.push_back(false);\n+          ++args_copied;\n+        }\n+\n+        // 1. Copy any position arguments given.\n+        bool bad_arg = false;\n+        for (; args_copied < args_to_copy; ++args_copied) {\n+          const argument_record *arg_rec = args_copied < func.args.size()\n+                                               ? &func.args[args_copied]\n+                                               : nullptr;\n+          if (kwargs_in && arg_rec && arg_rec->name &&\n+              PyDict_GetItemString(kwargs_in, arg_rec->name)) {\n+            bad_arg = true;\n+            break;\n+          }\n+\n+          handle arg(PyTuple_GET_ITEM(args_in, args_copied));\n+          if (arg_rec && !arg_rec->none && arg.is_none()) {\n+            bad_arg = true;\n+            break;\n+          }\n+          call.args.push_back(arg);\n+          call.args_convert.push_back(arg_rec ? arg_rec->convert : true);\n+        }\n+        if (bad_arg)\n+          continue; // Maybe it was meant for another overload (issue #688)\n+\n+        // We'll need to copy this if we steal some kwargs for defaults\n+        dict kwargs = reinterpret_borrow<dict>(kwargs_in);\n+\n+        // 2. Check kwargs and, failing that, defaults that may help complete\n+        // the list\n+        if (args_copied < pos_args) {\n+          bool copied_kwargs = false;\n+\n+          for (; args_copied < pos_args; ++args_copied) {\n+            const auto &arg = func.args[args_copied];\n+\n+            handle value;\n+            if (kwargs_in && arg.name)\n+              value = PyDict_GetItemString(kwargs.ptr(), arg.name);\n+\n+            if (value) {\n+              // Consume a kwargs value\n+              if (!copied_kwargs) {\n+                kwargs = reinterpret_steal<dict>(PyDict_Copy(kwargs.ptr()));\n+                copied_kwargs = true;\n+              }\n+              PyDict_DelItemString(kwargs.ptr(), arg.name);\n+            } else if (arg.value) {\n+              value = arg.value;\n+            }\n+\n+            if (value) {\n+              call.args.push_back(value);\n+              call.args_convert.push_back(arg.convert);\n+            } else\n+              break;\n+          }\n+\n+          if (args_copied < pos_args)\n+            continue; // Not enough arguments, defaults, or kwargs to fill the\n+                      // positional arguments\n+        }\n+\n+        // 3. Check everything was consumed (unless we have a kwargs arg)\n+        if (kwargs && kwargs.size() > 0 && !func.has_kwargs)\n+          continue; // Unconsumed kwargs, but no py::kwargs argument to accept\n+                    // them\n+\n+        // 4a. If we have a py::args argument, create a new tuple with leftovers\n+        if (func.has_args) {\n+          tuple extra_args;\n+          if (args_to_copy == 0) {\n+            // We didn't copy out any position arguments from the args_in tuple,\n+            // so we can reuse it directly without copying:\n+            extra_args = reinterpret_borrow<tuple>(args_in);\n+          } else if (args_copied >= n_args_in) {\n+            extra_args = tuple(0);\n+          } else {\n+            size_t args_size = n_args_in - args_copied;\n+            extra_args = tuple(args_size);\n+            for (size_t i = 0; i < args_size; ++i) {\n+              extra_args[i] = PyTuple_GET_ITEM(args_in, args_copied + i);\n+            }\n+          }\n+          call.args.push_back(extra_args);\n+          call.args_convert.push_back(false);\n+          call.args_ref = std::move(extra_args);\n+        }\n+\n+        // 4b. If we have a py::kwargs, pass on any remaining kwargs\n+        if (func.has_kwargs) {\n+          if (!kwargs.ptr())\n+            kwargs = dict(); // If we didn't get one, send an empty one\n+          call.args.push_back(kwargs);\n+          call.args_convert.push_back(false);\n+          call.kwargs_ref = std::move(kwargs);\n+        }\n+\n+// 5. Put everything in a vector.  Not technically step 5, we've been building\n+// it in `call.args` all along.\n+#if !defined(NDEBUG)\n+        if (call.args.size() != func.nargs ||\n+            call.args_convert.size() != func.nargs)\n+          pybind11_fail(\"Internal error: function call dispatcher inserted \"\n+                        \"wrong number of arguments!\");\n+#endif\n+\n+        std::vector<bool> second_pass_convert;\n+        if (overloaded) {\n+          // We're in the first no-convert pass, so swap out the conversion\n+          // flags for a set of all-false flags.  If the call fails, we'll swap\n+          // the flags back in for the conversion-allowed call below.\n+          second_pass_convert.resize(func.nargs, false);\n+          call.args_convert.swap(second_pass_convert);\n+        }\n+\n+        // 6. Call the function.\n+        try {\n+          loader_life_support guard{};\n+          result = func.impl(call);\n+        } catch (reference_cast_error &) {\n+          result = PYBIND11_TRY_NEXT_OVERLOAD;\n+        }\n+\n+        if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD)\n+          break;\n+\n+        if (overloaded) {\n+          // The (overloaded) call failed; if the call has at least one argument\n+          // that permits conversion (i.e. it hasn't been explicitly specified\n+          // `.noconvert()`) then add this call to the list of second pass\n+          // overloads to try.\n+          for (size_t i = func.is_method ? 1 : 0; i < pos_args; i++) {\n+            if (second_pass_convert[i]) {\n+              // Found one: swap the converting flags back in and store the call\n+              // for the second pass.\n+              call.args_convert.swap(second_pass_convert);\n+              second_pass.push_back(std::move(call));\n+              break;\n+            }\n+          }\n+        }\n+      }\n+\n+      if (overloaded && !second_pass.empty() &&\n+          result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {\n+        // The no-conversion pass finished without success, try again with\n+        // conversion allowed\n+        for (auto &call : second_pass) {\n+          try {\n+            loader_life_support guard{};\n+            result = call.func.impl(call);\n+          } catch (reference_cast_error &) {\n+            result = PYBIND11_TRY_NEXT_OVERLOAD;\n+          }\n+\n+          if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD) {\n+            // The error reporting logic below expects 'it' to be valid, as it\n+            // would be if we'd encountered this failure in the first-pass loop.\n+            if (!result)\n+              it = &call.func;\n+            break;\n+          }\n+        }\n+      }\n+    } catch (error_already_set &e) {\n+      e.restore();\n+      return nullptr;\n+#if defined(__GNUG__) && !defined(__clang__)\n+    } catch (abi::__forced_unwind &) {\n+      throw;\n+#endif\n+    } catch (...) {\n+      /* When an exception is caught, give each registered exception\n+         translator a chance to translate it to a Python exception\n+         in reverse order of registration.\n+\n+         A translator may choose to do one of the following:\n+\n+          - catch the exception and call PyErr_SetString or PyErr_SetObject\n+            to set a standard (or custom) Python exception, or\n+          - do nothing and let the exception fall through to the next\n+         translator, or\n+          - delegate translation to the next translator by throwing a new type\n+         of exception. */\n+\n+      auto last_exception = std::current_exception();\n+      auto &registered_exception_translators =\n+          get_internals().registered_exception_translators;\n+      for (auto &translator : registered_exception_translators) {\n+        try {\n+          translator(last_exception);\n+        } catch (...) {\n+          last_exception = std::current_exception();\n+          continue;\n+        }\n+        return nullptr;\n+      }\n+      PyErr_SetString(PyExc_SystemError,\n+                      \"Exception escaped from default exception translator!\");\n+      return nullptr;\n+    }\n+\n+    auto append_note_if_missing_header_is_suspected = [](std::string &msg) {\n+      if (msg.find(\"std::\") != std::string::npos) {\n+        msg += \"\\n\\n\"\n+               \"Did you forget to `#include <pybind11/stl.h>`? Or \"\n+               \"<pybind11/complex.h>,\\n\"\n+               \"<pybind11/functional.h>, <pybind11/chrono.h>, etc. Some \"\n+               \"automatic\\n\"\n+               \"conversions are optional and require extra headers to be \"\n+               \"included\\n\"\n+               \"when compiling your pybind11 module.\";\n+      }\n+    };\n+\n+    if (result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {\n+      if (overloads->is_operator)\n+        return handle(Py_NotImplemented).inc_ref().ptr();\n+\n+      std::string msg =\n+          std::string(overloads->name) + \"(): incompatible \" +\n+          std::string(overloads->is_constructor ? \"constructor\" : \"function\") +\n+          \" arguments. The following argument types are supported:\\n\";\n+\n+      int ctr = 0;\n+      for (const function_record *it2 = overloads; it2 != nullptr;\n+           it2 = it2->next) {\n+        msg += \"    \" + std::to_string(++ctr) + \". \";\n+\n+        bool wrote_sig = false;\n+        if (overloads->is_constructor) {\n+          // For a constructor, rewrite `(self: Object, arg0, ...) -> NoneType`\n+          // as `Object(arg0, ...)`\n+          std::string sig = it2->signature;\n+          size_t start = sig.find('(') + 7; // skip \"(self: \"\n+          if (start < sig.size()) {\n+            // End at the , for the next argument\n+            size_t end = sig.find(\", \"), next = end + 2;\n+            size_t ret = sig.rfind(\" -> \");\n+            // Or the ), if there is no comma:\n+            if (end >= sig.size())\n+              next = end = sig.find(')');\n+            if (start < end && next < sig.size()) {\n+              msg.append(sig, start, end - start);\n+              msg += '(';\n+              msg.append(sig, next, ret - next);\n+              wrote_sig = true;\n+            }\n+          }\n+        }\n+        if (!wrote_sig)\n+          msg += it2->signature;\n+\n+        msg += \"\\n\";\n+      }\n+      msg += \"\\nInvoked with: \";\n+      auto args_ = reinterpret_borrow<tuple>(args_in);\n+      bool some_args = false;\n+      for (size_t ti = overloads->is_constructor ? 1 : 0; ti < args_.size();\n+           ++ti) {\n+        if (!some_args)\n+          some_args = true;\n+        else\n+          msg += \", \";\n+        msg += pybind11::repr(args_[ti]);\n+      }\n+      if (kwargs_in) {\n+        auto kwargs = reinterpret_borrow<dict>(kwargs_in);\n+        if (kwargs.size() > 0) {\n+          if (some_args)\n+            msg += \"; \";\n+          msg += \"kwargs: \";\n+          bool first = true;\n+          for (auto kwarg : kwargs) {\n+            if (first)\n+              first = false;\n+            else\n+              msg += \", \";\n+            msg += pybind11::str(\"{}={!r}\").format(kwarg.first, kwarg.second);\n+          }\n+        }\n+      }\n+\n+      append_note_if_missing_header_is_suspected(msg);\n+      PyErr_SetString(PyExc_TypeError, msg.c_str());\n+      return nullptr;\n+    } else if (!result) {\n+      std::string msg = \"Unable to convert function return value to a \"\n+                        \"Python type! The signature was\\n\\t\";\n+      msg += it->signature;\n+      append_note_if_missing_header_is_suspected(msg);\n+      PyErr_SetString(PyExc_TypeError, msg.c_str());\n+      return nullptr;\n+    } else {\n+      if (overloads->is_constructor &&\n+          !self_value_and_holder.holder_constructed()) {\n+        auto *pi = reinterpret_cast<instance *>(parent.ptr());\n+        self_value_and_holder.type->init_instance(pi, nullptr);\n+      }\n+      return result.ptr();\n+    }\n+  }\n+};\n+\n+/// Wrapper for Python extension modules\n+class module : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(module, object, PyModule_Check)\n+\n+  /// Create a new top-level Python module with the given name and docstring\n+  explicit module(const char *name, const char *doc = nullptr) {\n+    if (!options::show_user_defined_docstrings())\n+      doc = nullptr;\n+#if PY_MAJOR_VERSION >= 3\n+    PyModuleDef *def = new PyModuleDef();\n+    std::memset(def, 0, sizeof(PyModuleDef));\n+    def->m_name = name;\n+    def->m_doc = doc;\n+    def->m_size = -1;\n+    Py_INCREF(def);\n+    m_ptr = PyModule_Create(def);\n+#else\n+    m_ptr = Py_InitModule3(name, nullptr, doc);\n+#endif\n+    if (m_ptr == nullptr)\n+      pybind11_fail(\"Internal error in module::module()\");\n+    inc_ref();\n+  }\n+\n+  /** \\rst\n+      Create Python binding for a new function within the module scope. ``Func``\n+      can be a plain C++ function, a function pointer, or a lambda function. For\n+      details on the ``Extra&& ... extra`` argument, see section :ref:`extras`.\n+  \\endrst */\n+  template <typename Func, typename... Extra>\n+  module &def(const char *name_, Func &&f, const Extra &...extra) {\n+    cpp_function func(std::forward<Func>(f), name(name_), scope(*this),\n+                      sibling(getattr(*this, name_, none())), extra...);\n+    // NB: allow overwriting here because cpp_function sets up a chain with the\n+    // intention of overwriting (and has already checked internally that it\n+    // isn't overwriting non-functions).\n+    add_object(name_, func, true /* overwrite */);\n+    return *this;\n+  }\n+\n+  /** \\rst\n+      Create and return a new Python submodule with the given name and\n+  docstring. This also works recursively, i.e.\n+\n+      .. code-block:: cpp\n+\n+          py::module m(\"example\", \"pybind11 example plugin\");\n+          py::module m2 = m.def_submodule(\"sub\", \"A submodule of 'example'\");\n+          py::module m3 = m2.def_submodule(\"subsub\", \"A submodule of\n+  'example.sub'\"); \\endrst */\n+  module def_submodule(const char *name, const char *doc = nullptr) {\n+    std::string full_name = std::string(PyModule_GetName(m_ptr)) +\n+                            std::string(\".\") + std::string(name);\n+    auto result =\n+        reinterpret_borrow<module>(PyImport_AddModule(full_name.c_str()));\n+    if (doc && options::show_user_defined_docstrings())\n+      result.attr(\"__doc__\") = pybind11::str(doc);\n+    attr(name) = result;\n+    return result;\n+  }\n+\n+  /// Import and return a module or throws `error_already_set`.\n+  static module import(const char *name) {\n+    PyObject *obj = PyImport_ImportModule(name);\n+    if (!obj)\n+      throw error_already_set();\n+    return reinterpret_steal<module>(obj);\n+  }\n+\n+  /// Reload the module or throws `error_already_set`.\n+  void reload() {\n+    PyObject *obj = PyImport_ReloadModule(ptr());\n+    if (!obj)\n+      throw error_already_set();\n+    *this = reinterpret_steal<module>(obj);\n+  }\n+\n+  // Adds an object to the module using the given name.  Throws if an object\n+  // with the given name already exists.\n+  //\n+  // overwrite should almost always be false: attempting to overwrite objects\n+  // that pybind11 has established will, in most cases, break things.\n+  PYBIND11_NOINLINE void add_object(const char *name, handle obj,\n+                                    bool overwrite = false) {\n+    if (!overwrite && hasattr(*this, name))\n+      pybind11_fail(\"Error during initialization: multiple incompatible \"\n+                    \"definitions with name \\\"\" +\n+                    std::string(name) + \"\\\"\");\n+\n+    PyModule_AddObject(ptr(), name,\n+                       obj.inc_ref().ptr() /* steals a reference */);\n+  }\n+};\n+\n+/// \\ingroup python_builtins\n+/// Return a dictionary representing the global variables in the current\n+/// execution frame, or ``__main__.__dict__`` if there is no frame (usually when\n+/// the interpreter is embedded).\n+inline dict globals() {\n+  PyObject *p = PyEval_GetGlobals();\n+  return reinterpret_borrow<dict>(\n+      p ? p : module::import(\"__main__\").attr(\"__dict__\").ptr());\n+}\n+\n+NAMESPACE_BEGIN(detail)\n+/// Generic support for creating new Python heap types\n+class generic_type : public object {\n+  template <typename...> friend class class_;\n+\n+public:\n+  PYBIND11_OBJECT_DEFAULT(generic_type, object, PyType_Check)\n+protected:\n+  void initialize(const type_record &rec) {\n+    if (rec.scope && hasattr(rec.scope, rec.name))\n+      pybind11_fail(\"generic_type: cannot initialize type \\\"\" +\n+                    std::string(rec.name) +\n+                    \"\\\": an object with that name is already defined\");\n+\n+    if (rec.module_local ? get_local_type_info(*rec.type)\n+                         : get_global_type_info(*rec.type))\n+      pybind11_fail(\"generic_type: type \\\"\" + std::string(rec.name) +\n+                    \"\\\" is already registered!\");\n+\n+    m_ptr = make_new_python_type(rec);\n+\n+    /* Register supplemental type information in C++ dict */\n+    auto *tinfo = new detail::type_info();\n+    tinfo->type = (PyTypeObject *)m_ptr;\n+    tinfo->cpptype = rec.type;\n+    tinfo->type_size = rec.type_size;\n+    tinfo->type_align = rec.type_align;\n+    tinfo->operator_new = rec.operator_new;\n+    tinfo->holder_size_in_ptrs = size_in_ptrs(rec.holder_size);\n+    tinfo->init_instance = rec.init_instance;\n+    tinfo->dealloc = rec.dealloc;\n+    tinfo->simple_type = true;\n+    tinfo->simple_ancestors = true;\n+    tinfo->default_holder = rec.default_holder;\n+    tinfo->module_local = rec.module_local;\n+\n+    auto &internals = get_internals();\n+    auto tindex = std::type_index(*rec.type);\n+    tinfo->direct_conversions = &internals.direct_conversions[tindex];\n+    if (rec.module_local)\n+      registered_local_types_cpp()[tindex] = tinfo;\n+    else\n+      internals.registered_types_cpp[tindex] = tinfo;\n+    internals.registered_types_py[(PyTypeObject *)m_ptr] = {tinfo};\n+\n+    if (rec.bases.size() > 1 || rec.multiple_inheritance) {\n+      mark_parents_nonsimple(tinfo->type);\n+      tinfo->simple_ancestors = false;\n+    } else if (rec.bases.size() == 1) {\n+      auto parent_tinfo = get_type_info((PyTypeObject *)rec.bases[0].ptr());\n+      tinfo->simple_ancestors = parent_tinfo->simple_ancestors;\n+    }\n+\n+    if (rec.module_local) {\n+      // Stash the local typeinfo and loader so that external modules can access\n+      // it.\n+      tinfo->module_local_load = &type_caster_generic::local_load;\n+      setattr(m_ptr, PYBIND11_MODULE_LOCAL_ID, capsule(tinfo));\n+    }\n+  }\n+\n+  /// Helper function which tags all parents of a type using mult. inheritance\n+  void mark_parents_nonsimple(PyTypeObject *value) {\n+    auto t = reinterpret_borrow<tuple>(value->tp_bases);\n+    for (handle h : t) {\n+      auto tinfo2 = get_type_info((PyTypeObject *)h.ptr());\n+      if (tinfo2)\n+        tinfo2->simple_type = false;\n+      mark_parents_nonsimple((PyTypeObject *)h.ptr());\n+    }\n+  }\n+\n+  void install_buffer_funcs(buffer_info *(*get_buffer)(PyObject *, void *),\n+                            void *get_buffer_data) {\n+    PyHeapTypeObject *type = (PyHeapTypeObject *)m_ptr;\n+    auto tinfo = detail::get_type_info(&type->ht_type);\n+\n+    if (!type->ht_type.tp_as_buffer)\n+      pybind11_fail(\n+          \"To be able to register buffer protocol support for the type '\" +\n+          std::string(tinfo->type->tp_name) +\n+          \"' the associated class<>(..) invocation must \"\n+          \"include the pybind11::buffer_protocol() annotation!\");\n+\n+    tinfo->get_buffer = get_buffer;\n+    tinfo->get_buffer_data = get_buffer_data;\n+  }\n+\n+  // rec_func must be set for either fget or fset.\n+  void def_property_static_impl(const char *name, handle fget, handle fset,\n+                                detail::function_record *rec_func) {\n+    const auto is_static =\n+        rec_func && !(rec_func->is_method && rec_func->scope);\n+    const auto has_doc = rec_func && rec_func->doc &&\n+                         pybind11::options::show_user_defined_docstrings();\n+    auto property =\n+        handle((PyObject *)(is_static ? get_internals().static_property_type\n+                                      : &PyProperty_Type));\n+    attr(name) = property(\n+        fget.ptr() ? fget : none(), fset.ptr() ? fset : none(),\n+        /*deleter*/ none(), pybind11::str(has_doc ? rec_func->doc : \"\"));\n+  }\n+};\n+\n+/// Set the pointer to operator new if it exists. The cast is needed because it\n+/// can be overloaded.\n+template <typename T, typename = void_t<decltype(static_cast<void *(*)(size_t)>(\n+                          T::operator new))>>\n+void set_operator_new(type_record *r) {\n+  r->operator_new = &T::operator new;\n+}\n+\n+template <typename> void set_operator_new(...) {}\n+\n+template <typename T, typename SFINAE = void>\n+struct has_operator_delete : std::false_type {};\n+template <typename T>\n+struct has_operator_delete<\n+    T, void_t<decltype(static_cast<void (*)(void *)>(T::operator delete))>>\n+    : std::true_type {};\n+template <typename T, typename SFINAE = void>\n+struct has_operator_delete_size : std::false_type {};\n+template <typename T>\n+struct has_operator_delete_size<\n+    T,\n+    void_t<decltype(static_cast<void (*)(void *, size_t)>(T::operator delete))>>\n+    : std::true_type {};\n+/// Call class-specific delete if it exists or global otherwise. Can also be an\n+/// overload set.\n+template <typename T, enable_if_t<has_operator_delete<T>::value, int> = 0>\n+void call_operator_delete(T *p, size_t, size_t) {\n+  T::operator delete(p);\n+}\n+template <typename T, enable_if_t<!has_operator_delete<T>::value &&\n+                                      has_operator_delete_size<T>::value,\n+                                  int> = 0>\n+void call_operator_delete(T *p, size_t s, size_t) {\n+  T::operator delete(p, s);\n+}\n+\n+inline void call_operator_delete(void *p, size_t s, size_t a) {\n+  (void)s;\n+  (void)a;\n+#if defined(PYBIND11_CPP17)\n+  if (a > __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n+    ::operator delete(p, s, std::align_val_t(a));\n+  else\n+    ::operator delete(p, s);\n+#else\n+  ::operator delete(p);\n+#endif\n+}\n+\n+NAMESPACE_END(detail)\n+\n+/// Given a pointer to a member function, cast it to its `Derived` version.\n+/// Forward everything else unchanged.\n+template <typename /*Derived*/, typename F>\n+auto method_adaptor(F &&f) -> decltype(std::forward<F>(f)) {\n+  return std::forward<F>(f);\n+}\n+\n+template <typename Derived, typename Return, typename Class, typename... Args>\n+auto method_adaptor(Return (Class::*pmf)(Args...))\n+    -> Return (Derived::*)(Args...) {\n+  static_assert(detail::is_accessible_base_of<Class, Derived>::value,\n+                \"Cannot bind an inaccessible base class method; use a lambda \"\n+                \"definition instead\");\n+  return pmf;\n+}\n+\n+template <typename Derived, typename Return, typename Class, typename... Args>\n+auto method_adaptor(Return (Class::*pmf)(Args...) const)\n+    -> Return (Derived::*)(Args...) const {\n+  static_assert(detail::is_accessible_base_of<Class, Derived>::value,\n+                \"Cannot bind an inaccessible base class method; use a lambda \"\n+                \"definition instead\");\n+  return pmf;\n+}\n+\n+template <typename type_, typename... options>\n+class class_ : public detail::generic_type {\n+  template <typename T> using is_holder = detail::is_holder_type<type_, T>;\n+  template <typename T> using is_subtype = detail::is_strict_base_of<type_, T>;\n+  template <typename T> using is_base = detail::is_strict_base_of<T, type_>;\n+  // struct instead of using here to help MSVC:\n+  template <typename T>\n+  struct is_valid_class_option\n+      : detail::any_of<is_holder<T>, is_subtype<T>, is_base<T>> {};\n+\n+public:\n+  using type = type_;\n+  using type_alias = detail::exactly_one_t<is_subtype, void, options...>;\n+  constexpr static bool has_alias = !std::is_void<type_alias>::value;\n+  using holder_type =\n+      detail::exactly_one_t<is_holder, std::unique_ptr<type>, options...>;\n+\n+  static_assert(detail::all_of<is_valid_class_option<options>...>::value,\n+                \"Unknown/invalid class_ template parameters provided\");\n+\n+  static_assert(!has_alias || std::is_polymorphic<type>::value,\n+                \"Cannot use an alias class with a non-polymorphic type\");\n+\n+  PYBIND11_OBJECT(class_, generic_type, PyType_Check)\n+\n+  template <typename... Extra>\n+  class_(handle scope, const char *name, const Extra &...extra) {\n+    using namespace detail;\n+\n+    // MI can only be specified via class_ template options, not constructor\n+    // parameters\n+    static_assert(\n+        none_of<is_pyobject<Extra>...>::value || // no base class arguments, or:\n+            (constexpr_sum(is_pyobject<Extra>::value...) ==\n+                 1 && // Exactly one base\n+             constexpr_sum(is_base<options>::value...) ==\n+                 0 && // no template option bases\n+             none_of<std::is_same<multiple_inheritance, Extra>...>::\n+                 value), // no multiple_inheritance attr\n+        \"Error: multiple inheritance bases must be specified via class_ \"\n+        \"template options\");\n+\n+    type_record record;\n+    record.scope = scope;\n+    record.name = name;\n+    record.type = &typeid(type);\n+    record.type_size = sizeof(conditional_t<has_alias, type_alias, type>);\n+    record.type_align = alignof(conditional_t<has_alias, type_alias, type> &);\n+    record.holder_size = sizeof(holder_type);\n+    record.init_instance = init_instance;\n+    record.dealloc = dealloc;\n+    record.default_holder =\n+        detail::is_instantiation<std::unique_ptr, holder_type>::value;\n+\n+    set_operator_new<type>(&record);\n+\n+    /* Register base classes specified via template arguments to class_, if any\n+     */\n+    PYBIND11_EXPAND_SIDE_EFFECTS(add_base<options>(record));\n+\n+    /* Process optional arguments, if any */\n+    process_attributes<Extra...>::init(extra..., &record);\n+\n+    generic_type::initialize(record);\n+\n+    if (has_alias) {\n+      auto &instances = record.module_local\n+                            ? registered_local_types_cpp()\n+                            : get_internals().registered_types_cpp;\n+      instances[std::type_index(typeid(type_alias))] =\n+          instances[std::type_index(typeid(type))];\n+    }\n+  }\n+\n+  template <typename Base, detail::enable_if_t<is_base<Base>::value, int> = 0>\n+  static void add_base(detail::type_record &rec) {\n+    rec.add_base(typeid(Base), [](void *src) -> void * {\n+      return static_cast<Base *>(reinterpret_cast<type *>(src));\n+    });\n+  }\n+\n+  template <typename Base, detail::enable_if_t<!is_base<Base>::value, int> = 0>\n+  static void add_base(detail::type_record &) {}\n+\n+  template <typename Func, typename... Extra>\n+  class_ &def(const char *name_, Func &&f, const Extra &...extra) {\n+    cpp_function cf(method_adaptor<type>(std::forward<Func>(f)), name(name_),\n+                    is_method(*this), sibling(getattr(*this, name_, none())),\n+                    extra...);\n+    attr(cf.name()) = cf;\n+    return *this;\n+  }\n+\n+  template <typename Func, typename... Extra>\n+  class_ &def_static(const char *name_, Func &&f, const Extra &...extra) {\n+    static_assert(\n+        !std::is_member_function_pointer<Func>::value,\n+        \"def_static(...) called with a non-static member function pointer\");\n+    cpp_function cf(std::forward<Func>(f), name(name_), scope(*this),\n+                    sibling(getattr(*this, name_, none())), extra...);\n+    attr(cf.name()) = staticmethod(cf);\n+    return *this;\n+  }\n+\n+  template <detail::op_id id, detail::op_type ot, typename L, typename R,\n+            typename... Extra>\n+  class_ &def(const detail::op_<id, ot, L, R> &op, const Extra &...extra) {\n+    op.execute(*this, extra...);\n+    return *this;\n+  }\n+\n+  template <detail::op_id id, detail::op_type ot, typename L, typename R,\n+            typename... Extra>\n+  class_ &def_cast(const detail::op_<id, ot, L, R> &op, const Extra &...extra) {\n+    op.execute_cast(*this, extra...);\n+    return *this;\n+  }\n+\n+  template <typename... Args, typename... Extra>\n+  class_ &def(const detail::initimpl::constructor<Args...> &init,\n+              const Extra &...extra) {\n+    init.execute(*this, extra...);\n+    return *this;\n+  }\n+\n+  template <typename... Args, typename... Extra>\n+  class_ &def(const detail::initimpl::alias_constructor<Args...> &init,\n+              const Extra &...extra) {\n+    init.execute(*this, extra...);\n+    return *this;\n+  }\n+\n+  template <typename... Args, typename... Extra>\n+  class_ &def(detail::initimpl::factory<Args...> &&init,\n+              const Extra &...extra) {\n+    std::move(init).execute(*this, extra...);\n+    return *this;\n+  }\n+\n+  template <typename... Args, typename... Extra>\n+  class_ &def(detail::initimpl::pickle_factory<Args...> &&pf,\n+              const Extra &...extra) {\n+    std::move(pf).execute(*this, extra...);\n+    return *this;\n+  }\n+\n+  template <typename Func> class_ &def_buffer(Func &&func) {\n+    struct capture {\n+      Func func;\n+    };\n+    capture *ptr = new capture{std::forward<Func>(func)};\n+    install_buffer_funcs(\n+        [](PyObject *obj, void *ptr) -> buffer_info * {\n+          detail::make_caster<type> caster;\n+          if (!caster.load(obj, false))\n+            return nullptr;\n+          return new buffer_info(((capture *)ptr)->func(caster));\n+        },\n+        ptr);\n+    return *this;\n+  }\n+\n+  template <typename Return, typename Class, typename... Args>\n+  class_ &def_buffer(Return (Class::*func)(Args...)) {\n+    return def_buffer([func](type &obj) { return (obj.*func)(); });\n+  }\n+\n+  template <typename Return, typename Class, typename... Args>\n+  class_ &def_buffer(Return (Class::*func)(Args...) const) {\n+    return def_buffer([func](const type &obj) { return (obj.*func)(); });\n+  }\n+\n+  template <typename C, typename D, typename... Extra>\n+  class_ &def_readwrite(const char *name, D C::*pm, const Extra &...extra) {\n+    static_assert(\n+        std::is_same<C, type>::value || std::is_base_of<C, type>::value,\n+        \"def_readwrite() requires a class member (or base class member)\");\n+    cpp_function fget([pm](const type &c) -> const D & { return c.*pm; },\n+                      is_method(*this)),\n+        fset([pm](type &c, const D &value) { c.*pm = value; },\n+             is_method(*this));\n+    def_property(name, fget, fset, return_value_policy::reference_internal,\n+                 extra...);\n+    return *this;\n+  }\n+\n+  template <typename C, typename D, typename... Extra>\n+  class_ &def_readonly(const char *name, const D C::*pm,\n+                       const Extra &...extra) {\n+    static_assert(\n+        std::is_same<C, type>::value || std::is_base_of<C, type>::value,\n+        \"def_readonly() requires a class member (or base class member)\");\n+    cpp_function fget([pm](const type &c) -> const D & { return c.*pm; },\n+                      is_method(*this));\n+    def_property_readonly(name, fget, return_value_policy::reference_internal,\n+                          extra...);\n+    return *this;\n+  }\n+\n+  template <typename D, typename... Extra>\n+  class_ &def_readwrite_static(const char *name, D *pm, const Extra &...extra) {\n+    cpp_function fget([pm](object) -> const D & { return *pm; }, scope(*this)),\n+        fset([pm](object, const D &value) { *pm = value; }, scope(*this));\n+    def_property_static(name, fget, fset, return_value_policy::reference,\n+                        extra...);\n+    return *this;\n+  }\n+\n+  template <typename D, typename... Extra>\n+  class_ &def_readonly_static(const char *name, const D *pm,\n+                              const Extra &...extra) {\n+    cpp_function fget([pm](object) -> const D & { return *pm; }, scope(*this));\n+    def_property_readonly_static(name, fget, return_value_policy::reference,\n+                                 extra...);\n+    return *this;\n+  }\n+\n+  /// Uses return_value_policy::reference_internal by default\n+  template <typename Getter, typename... Extra>\n+  class_ &def_property_readonly(const char *name, const Getter &fget,\n+                                const Extra &...extra) {\n+    return def_property_readonly(name, cpp_function(method_adaptor<type>(fget)),\n+                                 return_value_policy::reference_internal,\n+                                 extra...);\n+  }\n+\n+  /// Uses cpp_function's return_value_policy by default\n+  template <typename... Extra>\n+  class_ &def_property_readonly(const char *name, const cpp_function &fget,\n+                                const Extra &...extra) {\n+    return def_property(name, fget, nullptr, extra...);\n+  }\n+\n+  /// Uses return_value_policy::reference by default\n+  template <typename Getter, typename... Extra>\n+  class_ &def_property_readonly_static(const char *name, const Getter &fget,\n+                                       const Extra &...extra) {\n+    return def_property_readonly_static(\n+        name, cpp_function(fget), return_value_policy::reference, extra...);\n+  }\n+\n+  /// Uses cpp_function's return_value_policy by default\n+  template <typename... Extra>\n+  class_ &def_property_readonly_static(const char *name,\n+                                       const cpp_function &fget,\n+                                       const Extra &...extra) {\n+    return def_property_static(name, fget, nullptr, extra...);\n+  }\n+\n+  /// Uses return_value_policy::reference_internal by default\n+  template <typename Getter, typename Setter, typename... Extra>\n+  class_ &def_property(const char *name, const Getter &fget, const Setter &fset,\n+                       const Extra &...extra) {\n+    return def_property(name, fget, cpp_function(method_adaptor<type>(fset)),\n+                        extra...);\n+  }\n+  template <typename Getter, typename... Extra>\n+  class_ &def_property(const char *name, const Getter &fget,\n+                       const cpp_function &fset, const Extra &...extra) {\n+    return def_property(name, cpp_function(method_adaptor<type>(fget)), fset,\n+                        return_value_policy::reference_internal, extra...);\n+  }\n+\n+  /// Uses cpp_function's return_value_policy by default\n+  template <typename... Extra>\n+  class_ &def_property(const char *name, const cpp_function &fget,\n+                       const cpp_function &fset, const Extra &...extra) {\n+    return def_property_static(name, fget, fset, is_method(*this), extra...);\n+  }\n+\n+  /// Uses return_value_policy::reference by default\n+  template <typename Getter, typename... Extra>\n+  class_ &def_property_static(const char *name, const Getter &fget,\n+                              const cpp_function &fset, const Extra &...extra) {\n+    return def_property_static(name, cpp_function(fget), fset,\n+                               return_value_policy::reference, extra...);\n+  }\n+\n+  /// Uses cpp_function's return_value_policy by default\n+  template <typename... Extra>\n+  class_ &def_property_static(const char *name, const cpp_function &fget,\n+                              const cpp_function &fset, const Extra &...extra) {\n+    static_assert(\n+        0 == detail::constexpr_sum(std::is_base_of<arg, Extra>::value...),\n+        \"Argument annotations are not allowed for properties\");\n+    auto rec_fget = get_function_record(fget),\n+         rec_fset = get_function_record(fset);\n+    auto *rec_active = rec_fget;\n+    if (rec_fget) {\n+      char *doc_prev =\n+          rec_fget->doc; /* 'extra' field may include a property-specific\n+                            documentation string */\n+      detail::process_attributes<Extra...>::init(extra..., rec_fget);\n+      if (rec_fget->doc && rec_fget->doc != doc_prev) {\n+        free(doc_prev);\n+        rec_fget->doc = strdup(rec_fget->doc);\n+      }\n+    }\n+    if (rec_fset) {\n+      char *doc_prev = rec_fset->doc;\n+      detail::process_attributes<Extra...>::init(extra..., rec_fset);\n+      if (rec_fset->doc && rec_fset->doc != doc_prev) {\n+        free(doc_prev);\n+        rec_fset->doc = strdup(rec_fset->doc);\n+      }\n+      if (!rec_active)\n+        rec_active = rec_fset;\n+    }\n+    def_property_static_impl(name, fget, fset, rec_active);\n+    return *this;\n+  }\n+\n+private:\n+  /// Initialize holder object, variant 1: object derives from\n+  /// enable_shared_from_this\n+  template <typename T>\n+  static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,\n+                          const holder_type * /* unused */,\n+                          const std::enable_shared_from_this<T> * /* dummy */) {\n+    try {\n+      auto sh = std::dynamic_pointer_cast<typename holder_type::element_type>(\n+          v_h.value_ptr<type>()->shared_from_this());\n+      if (sh) {\n+        new (std::addressof(v_h.holder<holder_type>()))\n+            holder_type(std::move(sh));\n+        v_h.set_holder_constructed();\n+      }\n+    } catch (const std::bad_weak_ptr &) {\n+    }\n+\n+    if (!v_h.holder_constructed() && inst->owned) {\n+      new (std::addressof(v_h.holder<holder_type>()))\n+          holder_type(v_h.value_ptr<type>());\n+      v_h.set_holder_constructed();\n+    }\n+  }\n+\n+  static void\n+  init_holder_from_existing(const detail::value_and_holder &v_h,\n+                            const holder_type *holder_ptr,\n+                            std::true_type /*is_copy_constructible*/) {\n+    new (std::addressof(v_h.holder<holder_type>()))\n+        holder_type(*reinterpret_cast<const holder_type *>(holder_ptr));\n+  }\n+\n+  static void\n+  init_holder_from_existing(const detail::value_and_holder &v_h,\n+                            const holder_type *holder_ptr,\n+                            std::false_type /*is_copy_constructible*/) {\n+    new (std::addressof(v_h.holder<holder_type>()))\n+        holder_type(std::move(*const_cast<holder_type *>(holder_ptr)));\n+  }\n+\n+  /// Initialize holder object, variant 2: try to construct from existing holder\n+  /// object, if possible\n+  static void\n+  init_holder(detail::instance *inst, detail::value_and_holder &v_h,\n+              const holder_type *holder_ptr,\n+              const void * /* dummy -- not enable_shared_from_this<T>) */) {\n+    if (holder_ptr) {\n+      init_holder_from_existing(v_h, holder_ptr,\n+                                std::is_copy_constructible<holder_type>());\n+      v_h.set_holder_constructed();\n+    } else if (inst->owned ||\n+               detail::always_construct_holder<holder_type>::value) {\n+      new (std::addressof(v_h.holder<holder_type>()))\n+          holder_type(v_h.value_ptr<type>());\n+      v_h.set_holder_constructed();\n+    }\n+  }\n+\n+  /// Performs instance initialization including constructing a holder and\n+  /// registering the known instance.  Should be called as soon as the `type`\n+  /// value_ptr is set for an instance.  Takes an optional pointer to an\n+  /// existing holder to use; if not specified and the instance is\n+  /// `.owned`, a new holder will be constructed to manage the value pointer.\n+  static void init_instance(detail::instance *inst, const void *holder_ptr) {\n+    auto v_h = inst->get_value_and_holder(detail::get_type_info(typeid(type)));\n+    if (!v_h.instance_registered()) {\n+      register_instance(inst, v_h.value_ptr(), v_h.type);\n+      v_h.set_instance_registered();\n+    }\n+    init_holder(inst, v_h, (const holder_type *)holder_ptr,\n+                v_h.value_ptr<type>());\n+  }\n+\n+  /// Deallocates an instance; via holder, if constructed; otherwise via\n+  /// operator delete.\n+  static void dealloc(detail::value_and_holder &v_h) {\n+    if (v_h.holder_constructed()) {\n+      v_h.holder<holder_type>().~holder_type();\n+      v_h.set_holder_constructed(false);\n+    } else {\n+      detail::call_operator_delete(v_h.value_ptr<type>(), v_h.type->type_size,\n+                                   v_h.type->type_align);\n+    }\n+    v_h.value_ptr() = nullptr;\n+  }\n+\n+  static detail::function_record *get_function_record(handle h) {\n+    h = detail::get_function(h);\n+    return h ? (detail::function_record *)reinterpret_borrow<capsule>(\n+                   PyCFunction_GET_SELF(h.ptr()))\n+             : nullptr;\n+  }\n+};\n+\n+/// Binds an existing constructor taking arguments Args...\n+template <typename... Args> detail::initimpl::constructor<Args...> init() {\n+  return {};\n+}\n+/// Like `init<Args...>()`, but the instance is always constructed through the\n+/// alias class (even when not inheriting on the Python side).\n+template <typename... Args>\n+detail::initimpl::alias_constructor<Args...> init_alias() {\n+  return {};\n+}\n+\n+/// Binds a factory function as a constructor\n+template <typename Func, typename Ret = detail::initimpl::factory<Func>>\n+Ret init(Func &&f) {\n+  return {std::forward<Func>(f)};\n+}\n+\n+/// Dual-argument factory function: the first function is called when no alias\n+/// is needed, the second when an alias is needed (i.e. due to python-side\n+/// inheritance).  Arguments must be identical.\n+template <typename CFunc, typename AFunc,\n+          typename Ret = detail::initimpl::factory<CFunc, AFunc>>\n+Ret init(CFunc &&c, AFunc &&a) {\n+  return {std::forward<CFunc>(c), std::forward<AFunc>(a)};\n+}\n+\n+/// Binds pickling functions `__getstate__` and `__setstate__` and ensures that\n+/// the type returned by `__getstate__` is the same as the argument accepted by\n+/// `__setstate__`.\n+template <typename GetState, typename SetState>\n+detail::initimpl::pickle_factory<GetState, SetState> pickle(GetState &&g,\n+                                                            SetState &&s) {\n+  return {std::forward<GetState>(g), std::forward<SetState>(s)};\n+}\n+\n+NAMESPACE_BEGIN(detail)\n+struct enum_base {\n+  enum_base(handle base, handle parent) : m_base(base), m_parent(parent) {}\n+\n+  PYBIND11_NOINLINE void init(bool is_arithmetic, bool is_convertible) {\n+    m_base.attr(\"__entries\") = dict();\n+    auto property = handle((PyObject *)&PyProperty_Type);\n+    auto static_property =\n+        handle((PyObject *)get_internals().static_property_type);\n+\n+    m_base.attr(\"__repr__\") = cpp_function(\n+        [](handle arg) -> str {\n+          handle type = arg.get_type();\n+          object type_name = type.attr(\"__name__\");\n+          dict entries = type.attr(\"__entries\");\n+          for (const auto &kv : entries) {\n+            object other = kv.second[int_(0)];\n+            if (other.equal(arg))\n+              return pybind11::str(\"{}.{}\").format(type_name, kv.first);\n+          }\n+          return pybind11::str(\"{}.???\").format(type_name);\n+        },\n+        is_method(m_base));\n+\n+    m_base.attr(\"name\") = property(cpp_function(\n+        [](handle arg) -> str {\n+          dict entries = arg.get_type().attr(\"__entries\");\n+          for (const auto &kv : entries) {\n+            if (handle(kv.second[int_(0)]).equal(arg))\n+              return pybind11::str(kv.first);\n+          }\n+          return \"???\";\n+        },\n+        is_method(m_base)));\n+\n+    m_base.attr(\"__doc__\") = static_property(\n+        cpp_function([](handle arg) -> std::string {\n+          std::string docstring;\n+          dict entries = arg.attr(\"__entries\");\n+          if (((PyTypeObject *)arg.ptr())->tp_doc)\n+            docstring +=\n+                std::string(((PyTypeObject *)arg.ptr())->tp_doc) + \"\\n\\n\";\n+          docstring += \"Members:\";\n+          for (const auto &kv : entries) {\n+            auto key = std::string(pybind11::str(kv.first));\n+            auto comment = kv.second[int_(1)];\n+            docstring += \"\\n\\n  \" + key;\n+            if (!comment.is_none())\n+              docstring += \" : \" + (std::string)pybind11::str(comment);\n+          }\n+          return docstring;\n+        }),\n+        none(), none(), \"\");\n+\n+    m_base.attr(\"__members__\") =\n+        static_property(cpp_function([](handle arg) -> dict {\n+                          dict entries = arg.attr(\"__entries\"), m;\n+                          for (const auto &kv : entries)\n+                            m[kv.first] = kv.second[int_(0)];\n+                          return m;\n+                        }),\n+                        none(), none(), \"\");\n+\n+#define PYBIND11_ENUM_OP_STRICT(op, expr, strict_behavior)                     \\\n+  m_base.attr(op) = cpp_function(                                              \\\n+      [](object a, object b) {                                                 \\\n+        if (!a.get_type().is(b.get_type()))                                    \\\n+          strict_behavior;                                                     \\\n+        return expr;                                                           \\\n+      },                                                                       \\\n+      is_method(m_base))\n+\n+#define PYBIND11_ENUM_OP_CONV(op, expr)                                        \\\n+  m_base.attr(op) = cpp_function(                                              \\\n+      [](object a_, object b_) {                                               \\\n+        int_ a(a_), b(b_);                                                     \\\n+        return expr;                                                           \\\n+      },                                                                       \\\n+      is_method(m_base))\n+\n+    if (is_convertible) {\n+      PYBIND11_ENUM_OP_CONV(\"__eq__\", !b.is_none() && a.equal(b));\n+      PYBIND11_ENUM_OP_CONV(\"__ne__\", b.is_none() || !a.equal(b));\n+\n+      if (is_arithmetic) {\n+        PYBIND11_ENUM_OP_CONV(\"__lt__\", a < b);\n+        PYBIND11_ENUM_OP_CONV(\"__gt__\", a > b);\n+        PYBIND11_ENUM_OP_CONV(\"__le__\", a <= b);\n+        PYBIND11_ENUM_OP_CONV(\"__ge__\", a >= b);\n+        PYBIND11_ENUM_OP_CONV(\"__and__\", a & b);\n+        PYBIND11_ENUM_OP_CONV(\"__rand__\", a & b);\n+        PYBIND11_ENUM_OP_CONV(\"__or__\", a | b);\n+        PYBIND11_ENUM_OP_CONV(\"__ror__\", a | b);\n+        PYBIND11_ENUM_OP_CONV(\"__xor__\", a ^ b);\n+        PYBIND11_ENUM_OP_CONV(\"__rxor__\", a ^ b);\n+      }\n+    } else {\n+      PYBIND11_ENUM_OP_STRICT(\"__eq__\", int_(a).equal(int_(b)), return false);\n+      PYBIND11_ENUM_OP_STRICT(\"__ne__\", !int_(a).equal(int_(b)), return true);\n+\n+      if (is_arithmetic) {\n+#define PYBIND11_THROW                                                         \\\n+  throw type_error(\"Expected an enumeration of matching type!\");\n+        PYBIND11_ENUM_OP_STRICT(\"__lt__\", int_(a) < int_(b), PYBIND11_THROW);\n+        PYBIND11_ENUM_OP_STRICT(\"__gt__\", int_(a) > int_(b), PYBIND11_THROW);\n+        PYBIND11_ENUM_OP_STRICT(\"__le__\", int_(a) <= int_(b), PYBIND11_THROW);\n+        PYBIND11_ENUM_OP_STRICT(\"__ge__\", int_(a) >= int_(b), PYBIND11_THROW);\n+#undef PYBIND11_THROW\n+      }\n+    }\n+\n+#undef PYBIND11_ENUM_OP_CONV\n+#undef PYBIND11_ENUM_OP_STRICT\n+\n+    object getstate =\n+        cpp_function([](object arg) { return int_(arg); }, is_method(m_base));\n+\n+    m_base.attr(\"__getstate__\") = getstate;\n+    m_base.attr(\"__hash__\") = getstate;\n+  }\n+\n+  PYBIND11_NOINLINE void value(char const *name_, object value,\n+                               const char *doc = nullptr) {\n+    dict entries = m_base.attr(\"__entries\");\n+    str name(name_);\n+    if (entries.contains(name)) {\n+      std::string type_name = (std::string)str(m_base.attr(\"__name__\"));\n+      throw value_error(type_name + \": element \\\"\" + std::string(name_) +\n+                        \"\\\" already exists!\");\n+    }\n+\n+    entries[name] = std::make_pair(value, doc);\n+    m_base.attr(name) = value;\n+  }\n+\n+  PYBIND11_NOINLINE void export_values() {\n+    dict entries = m_base.attr(\"__entries\");\n+    for (const auto &kv : entries)\n+      m_parent.attr(kv.first) = kv.second[int_(0)];\n+  }\n+\n+  handle m_base;\n+  handle m_parent;\n+};\n+\n+NAMESPACE_END(detail)\n+\n+/// Binds C++ enumerations and enumeration classes to Python\n+template <typename Type> class enum_ : public class_<Type> {\n+public:\n+  using Base = class_<Type>;\n+  using Base::attr;\n+  using Base::def;\n+  using Base::def_property_readonly;\n+  using Base::def_property_readonly_static;\n+  using Scalar = typename std::underlying_type<Type>::type;\n+\n+  template <typename... Extra>\n+  enum_(const handle &scope, const char *name, const Extra &...extra)\n+      : class_<Type>(scope, name, extra...), m_base(*this, scope) {\n+    constexpr bool is_arithmetic =\n+        detail::any_of<std::is_same<arithmetic, Extra>...>::value;\n+    constexpr bool is_convertible = std::is_convertible<Type, Scalar>::value;\n+    m_base.init(is_arithmetic, is_convertible);\n+\n+    def(init([](Scalar i) { return static_cast<Type>(i); }));\n+    def(\"__int__\", [](Type value) { return (Scalar)value; });\n+#if PY_MAJOR_VERSION < 3\n+    def(\"__long__\", [](Type value) { return (Scalar)value; });\n+#endif\n+    cpp_function setstate(\n+        [](Type &value, Scalar arg) { value = static_cast<Type>(arg); },\n+        is_method(*this));\n+    attr(\"__setstate__\") = setstate;\n+  }\n+\n+  /// Export enumeration entries into the parent scope\n+  enum_ &export_values() {\n+    m_base.export_values();\n+    return *this;\n+  }\n+\n+  /// Add an enumeration entry\n+  enum_ &value(char const *name, Type value, const char *doc = nullptr) {\n+    m_base.value(name, pybind11::cast(value, return_value_policy::copy), doc);\n+    return *this;\n+  }\n+\n+private:\n+  detail::enum_base m_base;\n+};\n+\n+NAMESPACE_BEGIN(detail)\n+\n+inline void keep_alive_impl(handle nurse, handle patient) {\n+  if (!nurse || !patient)\n+    pybind11_fail(\"Could not activate keep_alive!\");\n+\n+  if (patient.is_none() || nurse.is_none())\n+    return; /* Nothing to keep alive or nothing to be kept alive by */\n+\n+  auto tinfo = all_type_info(Py_TYPE(nurse.ptr()));\n+  if (!tinfo.empty()) {\n+    /* It's a pybind-registered type, so we can store the patient in the\n+     * internal list. */\n+    add_patient(nurse.ptr(), patient.ptr());\n+  } else {\n+    /* Fall back to clever approach based on weak references taken from\n+     * Boost.Python. This is not used for pybind-registered types because\n+     * the objects can be destroyed out-of-order in a GC pass. */\n+    cpp_function disable_lifesupport([patient](handle weakref) {\n+      patient.dec_ref();\n+      weakref.dec_ref();\n+    });\n+\n+    weakref wr(nurse, disable_lifesupport);\n+\n+    patient.inc_ref(); /* reference patient and leak the weak reference */\n+    (void)wr.release();\n+  }\n+}\n+\n+PYBIND11_NOINLINE inline void keep_alive_impl(size_t Nurse, size_t Patient,\n+                                              function_call &call, handle ret) {\n+  auto get_arg = [&](size_t n) {\n+    if (n == 0)\n+      return ret;\n+    else if (n == 1 && call.init_self)\n+      return call.init_self;\n+    else if (n <= call.args.size())\n+      return call.args[n - 1];\n+    return handle();\n+  };\n+\n+  keep_alive_impl(get_arg(Nurse), get_arg(Patient));\n+}\n+\n+inline std::pair<decltype(internals::registered_types_py)::iterator, bool>\n+all_type_info_get_cache(PyTypeObject *type) {\n+  auto res = get_internals()\n+                 .registered_types_py\n+#ifdef __cpp_lib_unordered_map_try_emplace\n+                 .try_emplace(type);\n+#else\n+                 .emplace(type, std::vector<detail::type_info *>());\n+#endif\n+  if (res.second) {\n+    // New cache entry created; set up a weak reference to automatically remove\n+    // it if the type gets destroyed:\n+    weakref((PyObject *)type, cpp_function([type](handle wr) {\n+              get_internals().registered_types_py.erase(type);\n+              wr.dec_ref();\n+            }))\n+        .release();\n+  }\n+\n+  return res;\n+}\n+\n+template <typename Iterator, typename Sentinel, bool KeyIterator,\n+          return_value_policy Policy>\n+struct iterator_state {\n+  Iterator it;\n+  Sentinel end;\n+  bool first_or_done;\n+};\n+\n+NAMESPACE_END(detail)\n+\n+/// Makes a python iterator from a first and past-the-end C++ InputIterator.\n+template <return_value_policy Policy = return_value_policy::reference_internal,\n+          typename Iterator, typename Sentinel,\n+          typename ValueType = decltype(*std::declval<Iterator>()),\n+          typename... Extra>\n+iterator make_iterator(Iterator first, Sentinel last, Extra &&...extra) {\n+  typedef detail::iterator_state<Iterator, Sentinel, false, Policy> state;\n+\n+  if (!detail::get_type_info(typeid(state), false)) {\n+    class_<state>(handle(), \"iterator\", pybind11::module_local())\n+        .def(\"__iter__\", [](state &s) -> state & { return s; })\n+        .def(\n+            \"__next__\",\n+            [](state &s) -> ValueType {\n+              if (!s.first_or_done)\n+                ++s.it;\n+              else\n+                s.first_or_done = false;\n+              if (s.it == s.end) {\n+                s.first_or_done = true;\n+                throw stop_iteration();\n+              }\n+              return *s.it;\n+            },\n+            std::forward<Extra>(extra)..., Policy);\n+  }\n+\n+  return cast(state{first, last, true});\n+}\n+\n+/// Makes an python iterator over the keys (`.first`) of a iterator over pairs\n+/// from a first and past-the-end InputIterator.\n+template <return_value_policy Policy = return_value_policy::reference_internal,\n+          typename Iterator, typename Sentinel,\n+          typename KeyType = decltype((*std::declval<Iterator>()).first),\n+          typename... Extra>\n+iterator make_key_iterator(Iterator first, Sentinel last, Extra &&...extra) {\n+  typedef detail::iterator_state<Iterator, Sentinel, true, Policy> state;\n+\n+  if (!detail::get_type_info(typeid(state), false)) {\n+    class_<state>(handle(), \"iterator\", pybind11::module_local())\n+        .def(\"__iter__\", [](state &s) -> state & { return s; })\n+        .def(\n+            \"__next__\",\n+            [](state &s) -> KeyType {\n+              if (!s.first_or_done)\n+                ++s.it;\n+              else\n+                s.first_or_done = false;\n+              if (s.it == s.end) {\n+                s.first_or_done = true;\n+                throw stop_iteration();\n+              }\n+              return (*s.it).first;\n+            },\n+            std::forward<Extra>(extra)..., Policy);\n+  }\n+\n+  return cast(state{first, last, true});\n+}\n+\n+/// Makes an iterator over values of an stl container or other container\n+/// supporting `std::begin()`/`std::end()`\n+template <return_value_policy Policy = return_value_policy::reference_internal,\n+          typename Type, typename... Extra>\n+iterator make_iterator(Type &value, Extra &&...extra) {\n+  return make_iterator<Policy>(std::begin(value), std::end(value), extra...);\n+}\n+\n+/// Makes an iterator over the keys (`.first`) of a stl map-like container\n+/// supporting `std::begin()`/`std::end()`\n+template <return_value_policy Policy = return_value_policy::reference_internal,\n+          typename Type, typename... Extra>\n+iterator make_key_iterator(Type &value, Extra &&...extra) {\n+  return make_key_iterator<Policy>(std::begin(value), std::end(value),\n+                                   extra...);\n+}\n+\n+template <typename InputType, typename OutputType>\n+void implicitly_convertible() {\n+  struct set_flag {\n+    bool &flag;\n+    set_flag(bool &flag) : flag(flag) { flag = true; }\n+    ~set_flag() { flag = false; }\n+  };\n+  auto implicit_caster = [](PyObject *obj, PyTypeObject *type) -> PyObject * {\n+    static bool currently_used = false;\n+    if (currently_used) // implicit conversions are non-reentrant\n+      return nullptr;\n+    set_flag flag_helper(currently_used);\n+    if (!detail::make_caster<InputType>().load(obj, false))\n+      return nullptr;\n+    tuple args(1);\n+    args[0] = obj;\n+    PyObject *result = PyObject_Call((PyObject *)type, args.ptr(), nullptr);\n+    if (result == nullptr)\n+      PyErr_Clear();\n+    return result;\n+  };\n+\n+  if (auto tinfo = detail::get_type_info(typeid(OutputType)))\n+    tinfo->implicit_conversions.push_back(implicit_caster);\n+  else\n+    pybind11_fail(\"implicitly_convertible: Unable to find type \" +\n+                  type_id<OutputType>());\n+}\n+\n+template <typename ExceptionTranslator>\n+void register_exception_translator(ExceptionTranslator &&translator) {\n+  detail::get_internals().registered_exception_translators.push_front(\n+      std::forward<ExceptionTranslator>(translator));\n+}\n+\n+/**\n+ * Wrapper to generate a new Python exception type.\n+ *\n+ * This should only be used with PyErr_SetString for now.\n+ * It is not (yet) possible to use as a py::base.\n+ * Template type argument is reserved for future use.\n+ */\n+template <typename type> class exception : public object {\n+public:\n+  exception() = default;\n+  exception(handle scope, const char *name, PyObject *base = PyExc_Exception) {\n+    std::string full_name =\n+        scope.attr(\"__name__\").cast<std::string>() + std::string(\".\") + name;\n+    m_ptr =\n+        PyErr_NewException(const_cast<char *>(full_name.c_str()), base, NULL);\n+    if (hasattr(scope, name))\n+      pybind11_fail(\"Error during initialization: multiple incompatible \"\n+                    \"definitions with name \\\"\" +\n+                    std::string(name) + \"\\\"\");\n+    scope.attr(name) = *this;\n+  }\n+\n+  // Sets the current python exception to this exception object with the given\n+  // message\n+  void operator()(const char *message) { PyErr_SetString(m_ptr, message); }\n+};\n+\n+NAMESPACE_BEGIN(detail)\n+// Returns a reference to a function-local static exception object used in the\n+// simple register_exception approach below.  (It would be simpler to have the\n+// static local variable directly in register_exception, but that makes clang\n+// <3.5 segfault - issue #1349).\n+template <typename CppException>\n+exception<CppException> &get_exception_object() {\n+  static exception<CppException> ex;\n+  return ex;\n+}\n+NAMESPACE_END(detail)\n+\n+/**\n+ * Registers a Python exception in `m` of the given `name` and installs an\n+ * exception translator to translate the C++ exception to the created Python\n+ * exception using the exceptions what() method. This is intended for simple\n+ * exception translations; for more complex translation, register the exception\n+ * object and translator directly.\n+ */\n+template <typename CppException>\n+exception<CppException> &register_exception(handle scope, const char *name,\n+                                            PyObject *base = PyExc_Exception) {\n+  auto &ex = detail::get_exception_object<CppException>();\n+  if (!ex)\n+    ex = exception<CppException>(scope, name, base);\n+\n+  register_exception_translator([](std::exception_ptr p) {\n+    if (!p)\n+      return;\n+    try {\n+      std::rethrow_exception(p);\n+    } catch (const CppException &e) {\n+      detail::get_exception_object<CppException>()(e.what());\n+    }\n+  });\n+  return ex;\n+}\n+\n+NAMESPACE_BEGIN(detail)\n+PYBIND11_NOINLINE inline void print(tuple args, dict kwargs) {\n+  auto strings = tuple(args.size());\n+  for (size_t i = 0; i < args.size(); ++i) {\n+    strings[i] = str(args[i]);\n+  }\n+  auto sep = kwargs.contains(\"sep\") ? kwargs[\"sep\"] : cast(\" \");\n+  auto line = sep.attr(\"join\")(strings);\n+\n+  object file;\n+  if (kwargs.contains(\"file\")) {\n+    file = kwargs[\"file\"].cast<object>();\n+  } else {\n+    try {\n+      file = module::import(\"sys\").attr(\"stdout\");\n+    } catch (const error_already_set &) {\n+      /* If print() is called from code that is executed as\n+         part of garbage collection during interpreter shutdown,\n+         importing 'sys' can fail. Give up rather than crashing the\n+         interpreter in this case. */\n+      return;\n+    }\n+  }\n+\n+  auto write = file.attr(\"write\");\n+  write(line);\n+  write(kwargs.contains(\"end\") ? kwargs[\"end\"] : cast(\"\\n\"));\n+\n+  if (kwargs.contains(\"flush\") && kwargs[\"flush\"].cast<bool>())\n+    file.attr(\"flush\")();\n+}\n+NAMESPACE_END(detail)\n+\n+template <return_value_policy policy = return_value_policy::automatic_reference,\n+          typename... Args>\n+void print(Args &&...args) {\n+  auto c = detail::collect_arguments<policy>(std::forward<Args>(args)...);\n+  detail::print(c.args(), c.kwargs());\n+}\n+\n+#if defined(WITH_THREAD) && !defined(PYPY_VERSION)\n+\n+/* The functions below essentially reproduce the PyGILState_* API using a RAII\n+ * pattern, but there are a few important differences:\n+ *\n+ * 1. When acquiring the GIL from an non-main thread during the finalization\n+ *    phase, the GILState API blindly terminates the calling thread, which\n+ *    is often not what is wanted. This API does not do this.\n+ *\n+ * 2. The gil_scoped_release function can optionally cut the relationship\n+ *    of a PyThreadState and its associated thread, which allows moving it to\n+ *    another thread (this is a fairly rare/advanced use case).\n+ *\n+ * 3. The reference count of an acquired thread state can be controlled. This\n+ *    can be handy to prevent cases where callbacks issued from an external\n+ *    thread would otherwise constantly construct and destroy thread state data\n+ *    structures.\n+ *\n+ * See the Python bindings of NanoGUI (http://github.com/wjakob/nanogui) for an\n+ * example which uses features 2 and 3 to migrate the Python thread of\n+ * execution to another thread (to run the event loop on the original thread,\n+ * in this case).\n+ */\n+\n+class gil_scoped_acquire {\n+public:\n+  PYBIND11_NOINLINE gil_scoped_acquire() {\n+    auto const &internals = detail::get_internals();\n+    tstate = (PyThreadState *)PYBIND11_TLS_GET_VALUE(internals.tstate);\n+\n+    if (!tstate) {\n+      /* Check if the GIL was acquired using the PyGILState_* API instead (e.g.\n+         if calling from a Python thread). Since we use a different key, this\n+         ensures we don't create a new thread state and deadlock in\n+         PyEval_AcquireThread below. Note we don't save this state with\n+         internals.tstate, since we don't create it we would fail to clear it\n+         (its reference count should be > 0). */\n+      tstate = PyGILState_GetThisThreadState();\n+    }\n+\n+    if (!tstate) {\n+      tstate = PyThreadState_New(internals.istate);\n+#if !defined(NDEBUG)\n+      if (!tstate)\n+        pybind11_fail(\"scoped_acquire: could not create thread state!\");\n+#endif\n+      tstate->gilstate_counter = 0;\n+      PYBIND11_TLS_REPLACE_VALUE(internals.tstate, tstate);\n+    } else {\n+      release = detail::get_thread_state_unchecked() != tstate;\n+    }\n+\n+    if (release) {\n+/* Work around an annoying assertion in PyThreadState_Swap */\n+#if defined(Py_DEBUG)\n+      PyInterpreterState *interp = tstate->interp;\n+      tstate->interp = nullptr;\n+#endif\n+      PyEval_AcquireThread(tstate);\n+#if defined(Py_DEBUG)\n+      tstate->interp = interp;\n+#endif\n+    }\n+\n+    inc_ref();\n+  }\n+\n+  void inc_ref() { ++tstate->gilstate_counter; }\n+\n+  PYBIND11_NOINLINE void dec_ref() {\n+    --tstate->gilstate_counter;\n+#if !defined(NDEBUG)\n+    if (detail::get_thread_state_unchecked() != tstate)\n+      pybind11_fail(\"scoped_acquire::dec_ref(): thread state must be current!\");\n+    if (tstate->gilstate_counter < 0)\n+      pybind11_fail(\"scoped_acquire::dec_ref(): reference count underflow!\");\n+#endif\n+    if (tstate->gilstate_counter == 0) {\n+#if !defined(NDEBUG)\n+      if (!release)\n+        pybind11_fail(\"scoped_acquire::dec_ref(): internal error!\");\n+#endif\n+      PyThreadState_Clear(tstate);\n+      PyThreadState_DeleteCurrent();\n+      PYBIND11_TLS_DELETE_VALUE(detail::get_internals().tstate);\n+      release = false;\n+    }\n+  }\n+\n+  PYBIND11_NOINLINE ~gil_scoped_acquire() {\n+    dec_ref();\n+    if (release)\n+      PyEval_SaveThread();\n+  }\n+\n+private:\n+  PyThreadState *tstate = nullptr;\n+  bool release = true;\n+};\n+\n+class gil_scoped_release {\n+public:\n+  explicit gil_scoped_release(bool disassoc = false) : disassoc(disassoc) {\n+    // `get_internals()` must be called here unconditionally in order to\n+    // initialize `internals.tstate` for subsequent `gil_scoped_acquire` calls.\n+    // Otherwise, an initialization race could occur as multiple threads try\n+    // `gil_scoped_acquire`.\n+    const auto &internals = detail::get_internals();\n+    tstate = PyEval_SaveThread();\n+    if (disassoc) {\n+      auto key = internals.tstate;\n+      PYBIND11_TLS_DELETE_VALUE(key);\n+    }\n+  }\n+  ~gil_scoped_release() {\n+    if (!tstate)\n+      return;\n+    PyEval_RestoreThread(tstate);\n+    if (disassoc) {\n+      auto key = detail::get_internals().tstate;\n+      PYBIND11_TLS_REPLACE_VALUE(key, tstate);\n+    }\n+  }\n+\n+private:\n+  PyThreadState *tstate;\n+  bool disassoc;\n+};\n+#elif defined(PYPY_VERSION)\n+class gil_scoped_acquire {\n+  PyGILState_STATE state;\n+\n+public:\n+  gil_scoped_acquire() { state = PyGILState_Ensure(); }\n+  ~gil_scoped_acquire() { PyGILState_Release(state); }\n+};\n+\n+class gil_scoped_release {\n+  PyThreadState *state;\n+\n+public:\n+  gil_scoped_release() { state = PyEval_SaveThread(); }\n+  ~gil_scoped_release() { PyEval_RestoreThread(state); }\n+};\n+#else\n+class gil_scoped_acquire {};\n+class gil_scoped_release {};\n+#endif\n+\n+error_already_set::~error_already_set() {\n+  if (m_type) {\n+    error_scope scope;\n+    gil_scoped_acquire gil;\n+    m_type.release().dec_ref();\n+    m_value.release().dec_ref();\n+    m_trace.release().dec_ref();\n+  }\n+}\n+\n+inline function get_type_overload(const void *this_ptr,\n+                                  const detail::type_info *this_type,\n+                                  const char *name) {\n+  handle self = detail::get_object_handle(this_ptr, this_type);\n+  if (!self)\n+    return function();\n+  handle type = self.get_type();\n+  auto key = std::make_pair(type.ptr(), name);\n+\n+  /* Cache functions that aren't overloaded in Python to avoid\n+     many costly Python dictionary lookups below */\n+  auto &cache = detail::get_internals().inactive_overload_cache;\n+  if (cache.find(key) != cache.end())\n+    return function();\n+\n+  function overload = getattr(self, name, function());\n+  if (overload.is_cpp_function()) {\n+    cache.insert(key);\n+    return function();\n+  }\n+\n+  /* Don't call dispatch code if invoked from overridden function.\n+     Unfortunately this doesn't work on PyPy. */\n+#if !defined(PYPY_VERSION)\n+  PyFrameObject *frame = PyThreadState_Get()->frame;\n+  if (frame && (std::string)str(frame->f_code->co_name) == name &&\n+      frame->f_code->co_argcount > 0) {\n+    PyFrame_FastToLocals(frame);\n+    PyObject *self_caller = PyDict_GetItem(\n+        frame->f_locals, PyTuple_GET_ITEM(frame->f_code->co_varnames, 0));\n+    if (self_caller == self.ptr())\n+      return function();\n+  }\n+#else\n+  /* PyPy currently doesn't provide a detailed cpyext emulation of\n+     frame objects, so we have to emulate this using Python. This\n+     is going to be slow..*/\n+  dict d;\n+  d[\"self\"] = self;\n+  d[\"name\"] = pybind11::str(name);\n+  PyObject *result = PyRun_String(\n+      \"import inspect\\n\"\n+      \"frame = inspect.currentframe()\\n\"\n+      \"if frame is not None:\\n\"\n+      \"    frame = frame.f_back\\n\"\n+      \"    if frame is not None and str(frame.f_code.co_name) == name and \"\n+      \"frame.f_code.co_argcount > 0:\\n\"\n+      \"        self_caller = frame.f_locals[frame.f_code.co_varnames[0]]\\n\"\n+      \"        if self_caller == self:\\n\"\n+      \"            self = None\\n\",\n+      Py_file_input, d.ptr(), d.ptr());\n+  if (result == nullptr)\n+    throw error_already_set();\n+  if (d[\"self\"].is_none())\n+    return function();\n+  Py_DECREF(result);\n+#endif\n+\n+  return overload;\n+}\n+\n+/** \\rst\n+  Try to retrieve a python method by the provided name from the instance pointed\n+ to by the this_ptr.\n+\n+  :this_ptr: The pointer to the object the overload should be retrieved for.\n+ This should be the first non-trampoline class encountered in the inheritance\n+ chain. :name: The name of the overloaded Python method to retrieve. :return:\n+ The Python method by this name from the object or an empty function wrapper.\n+ \\endrst */\n+template <class T> function get_overload(const T *this_ptr, const char *name) {\n+  auto tinfo = detail::get_type_info(typeid(T));\n+  return tinfo ? get_type_overload(this_ptr, tinfo, name) : function();\n+}\n+\n+#define PYBIND11_OVERLOAD_INT(ret_type, cname, name, ...)                      \\\n+  {                                                                            \\\n+    pybind11::gil_scoped_acquire gil;                                          \\\n+    pybind11::function overload =                                              \\\n+        pybind11::get_overload(static_cast<const cname *>(this), name);        \\\n+    if (overload) {                                                            \\\n+      auto o = overload(__VA_ARGS__);                                          \\\n+      if (pybind11::detail::cast_is_temporary_value_reference<                 \\\n+              ret_type>::value) {                                              \\\n+        static pybind11::detail::overload_caster_t<ret_type> caster;           \\\n+        return pybind11::detail::cast_ref<ret_type>(std::move(o), caster);     \\\n+      } else                                                                   \\\n+        return pybind11::detail::cast_safe<ret_type>(std::move(o));            \\\n+    }                                                                          \\\n+  }\n+\n+/** \\rst\n+    Macro to populate the virtual method in the trampoline class. This macro\n+tries to look up a method named 'fn' from the Python side, deals with the\n+:ref:`gil` and necessary argument conversions to call this method and return the\n+appropriate type. See :ref:`overriding_virtuals` for more information. This\n+macro should be used when the method name in C is not the same as the method\n+name in Python. For example with `__str__`.\n+\n+    .. code-block:: cpp\n+\n+      std::string toString() override {\n+        PYBIND11_OVERLOAD_NAME(\n+            std::string, // Return type (ret_type)\n+            Animal,      // Parent class (cname)\n+            toString,    // Name of function in C++ (name)\n+            \"__str__\",   // Name of method in Python (fn)\n+        );\n+      }\n+\\endrst */\n+#define PYBIND11_OVERLOAD_NAME(ret_type, cname, name, fn, ...)                 \\\n+  PYBIND11_OVERLOAD_INT(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name,   \\\n+                        __VA_ARGS__)                                           \\\n+  return cname::fn(__VA_ARGS__)\n+\n+/** \\rst\n+    Macro for pure virtual functions, this function is identical to\n+:c:macro:`PYBIND11_OVERLOAD_NAME`, except that it throws if no overload can be\n+found. \\endrst */\n+#define PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, name, fn, ...)            \\\n+  PYBIND11_OVERLOAD_INT(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name,   \\\n+                        __VA_ARGS__)                                           \\\n+  pybind11::pybind11_fail(                                                     \\\n+      \"Tried to call pure virtual function \\\"\" PYBIND11_STRINGIFY(             \\\n+          cname) \"::\" name \"\\\"\");\n+\n+/** \\rst\n+    Macro to populate the virtual method in the trampoline class. This macro\n+tries to look up the method from the Python side, deals with the :ref:`gil` and\n+necessary argument conversions to call this method and return the appropriate\n+type. This macro should be used if the method name in C and in Python are\n+identical. See :ref:`overriding_virtuals` for more information.\n+\n+    .. code-block:: cpp\n+\n+      class PyAnimal : public Animal {\n+      public:\n+          // Inherit the constructors\n+          using Animal::Animal;\n+\n+          // Trampoline (need one for each virtual function)\n+          std::string go(int n_times) override {\n+              PYBIND11_OVERLOAD_PURE(\n+                  std::string, // Return type (ret_type)\n+                  Animal,      // Parent class (cname)\n+                  go,          // Name of function in C++ (must match Python\n+name) (fn) n_times      // Argument(s) (...)\n+              );\n+          }\n+      };\n+\\endrst */\n+#define PYBIND11_OVERLOAD(ret_type, cname, fn, ...)                            \\\n+  PYBIND11_OVERLOAD_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn,   \\\n+                         fn, __VA_ARGS__)\n+\n+/** \\rst\n+    Macro for pure virtual functions, this function is identical to\n+:c:macro:`PYBIND11_OVERLOAD`, except that it throws if no overload can be found.\n+\\endrst */\n+#define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...)                       \\\n+  PYBIND11_OVERLOAD_PURE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname),   \\\n+                              #fn, fn, __VA_ARGS__)\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)\n+\n+#if defined(_MSC_VER) && !defined(__INTEL_COMPILER)\n+#pragma warning(pop)\n+#elif defined(__GNUG__) && !defined(__clang__)\n+#pragma GCC diagnostic pop\n+#endif"}, {"filename": "python/src/pybind11/pytypes.h", "status": "added", "additions": 1733, "deletions": 0, "changes": 1733, "file_content_changes": "@@ -0,0 +1,1733 @@\n+/*\n+    pybind11/pytypes.h: Convenience wrapper classes for basic Python types\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"buffer_info.h\"\n+#include \"detail/common.h\"\n+#include <type_traits>\n+#include <utility>\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+\n+/* A few forward declarations */\n+class handle;\n+class object;\n+class str;\n+class iterator;\n+struct arg;\n+struct arg_v;\n+\n+NAMESPACE_BEGIN(detail)\n+class args_proxy;\n+inline bool isinstance_generic(handle obj, const std::type_info &tp);\n+\n+// Accessor forward declarations\n+template <typename Policy> class accessor;\n+namespace accessor_policies {\n+struct obj_attr;\n+struct str_attr;\n+struct generic_item;\n+struct sequence_item;\n+struct list_item;\n+struct tuple_item;\n+} // namespace accessor_policies\n+using obj_attr_accessor = accessor<accessor_policies::obj_attr>;\n+using str_attr_accessor = accessor<accessor_policies::str_attr>;\n+using item_accessor = accessor<accessor_policies::generic_item>;\n+using sequence_accessor = accessor<accessor_policies::sequence_item>;\n+using list_accessor = accessor<accessor_policies::list_item>;\n+using tuple_accessor = accessor<accessor_policies::tuple_item>;\n+\n+/// Tag and check to identify a class which implements the Python object API\n+class pyobject_tag {};\n+template <typename T>\n+using is_pyobject = std::is_base_of<pyobject_tag, remove_reference_t<T>>;\n+\n+/** \\rst\n+    A mixin class which adds common functions to `handle`, `object` and various\n+accessors. The only requirement for `Derived` is to implement ``PyObject\n+*Derived::ptr() const``. \\endrst */\n+template <typename Derived> class object_api : public pyobject_tag {\n+  const Derived &derived() const { return static_cast<const Derived &>(*this); }\n+\n+public:\n+  /** \\rst\n+      Return an iterator equivalent to calling ``iter()`` in Python. The object\n+      must be a collection which supports the iteration protocol.\n+  \\endrst */\n+  iterator begin() const;\n+  /// Return a sentinel which ends iteration.\n+  iterator end() const;\n+\n+  /** \\rst\n+      Return an internal functor to invoke the object's sequence protocol.\n+  Casting the returned ``detail::item_accessor`` instance to a `handle` or\n+  `object` subclass causes a corresponding call to ``__getitem__``. Assigning a\n+  `handle` or `object` subclass causes a call to ``__setitem__``. \\endrst */\n+  item_accessor operator[](handle key) const;\n+  /// See above (the only difference is that they key is provided as a string\n+  /// literal)\n+  item_accessor operator[](const char *key) const;\n+\n+  /** \\rst\n+      Return an internal functor to access the object's attributes. Casting the\n+      returned ``detail::obj_attr_accessor`` instance to a `handle` or `object`\n+      subclass causes a corresponding call to ``getattr``. Assigning a `handle`\n+      or `object` subclass causes a call to ``setattr``.\n+  \\endrst */\n+  obj_attr_accessor attr(handle key) const;\n+  /// See above (the only difference is that they key is provided as a string\n+  /// literal)\n+  str_attr_accessor attr(const char *key) const;\n+\n+  /** \\rst\n+      Matches * unpacking in Python, e.g. to unpack arguments out of a ``tuple``\n+      or ``list`` for a function call. Applying another * to the result yields\n+      ** unpacking, e.g. to unpack a dict as function keyword arguments.\n+      See :ref:`calling_python_functions`.\n+  \\endrst */\n+  args_proxy operator*() const;\n+\n+  /// Check if the given item is contained within this object, i.e. ``item in\n+  /// obj``.\n+  template <typename T> bool contains(T &&item) const;\n+\n+  /** \\rst\n+      Assuming the Python object is a function or implements the ``__call__``\n+      protocol, ``operator()`` invokes the underlying function, passing an\n+      arbitrary set of parameters. The result is returned as a `object` and\n+      may need to be converted back into a Python object using `handle::cast()`.\n+\n+      When some of the arguments cannot be converted to Python objects, the\n+      function will throw a `cast_error` exception. When the Python function\n+      call fails, a `error_already_set` exception is thrown.\n+  \\endrst */\n+  template <\n+      return_value_policy policy = return_value_policy::automatic_reference,\n+      typename... Args>\n+  object operator()(Args &&...args) const;\n+  template <\n+      return_value_policy policy = return_value_policy::automatic_reference,\n+      typename... Args>\n+  PYBIND11_DEPRECATED(\"call(...) was deprecated in favor of operator()(...)\")\n+  object call(Args &&...args) const;\n+\n+  /// Equivalent to ``obj is other`` in Python.\n+  bool is(object_api const &other) const {\n+    return derived().ptr() == other.derived().ptr();\n+  }\n+  /// Equivalent to ``obj is None`` in Python.\n+  bool is_none() const { return derived().ptr() == Py_None; }\n+  /// Equivalent to obj == other in Python\n+  bool equal(object_api const &other) const {\n+    return rich_compare(other, Py_EQ);\n+  }\n+  bool not_equal(object_api const &other) const {\n+    return rich_compare(other, Py_NE);\n+  }\n+  bool operator<(object_api const &other) const {\n+    return rich_compare(other, Py_LT);\n+  }\n+  bool operator<=(object_api const &other) const {\n+    return rich_compare(other, Py_LE);\n+  }\n+  bool operator>(object_api const &other) const {\n+    return rich_compare(other, Py_GT);\n+  }\n+  bool operator>=(object_api const &other) const {\n+    return rich_compare(other, Py_GE);\n+  }\n+\n+  object operator-() const;\n+  object operator~() const;\n+  object operator+(object_api const &other) const;\n+  object operator+=(object_api const &other) const;\n+  object operator-(object_api const &other) const;\n+  object operator-=(object_api const &other) const;\n+  object operator*(object_api const &other) const;\n+  object operator*=(object_api const &other) const;\n+  object operator/(object_api const &other) const;\n+  object operator/=(object_api const &other) const;\n+  object operator|(object_api const &other) const;\n+  object operator|=(object_api const &other) const;\n+  object operator&(object_api const &other) const;\n+  object operator&=(object_api const &other) const;\n+  object operator^(object_api const &other) const;\n+  object operator^=(object_api const &other) const;\n+  object operator<<(object_api const &other) const;\n+  object operator<<=(object_api const &other) const;\n+  object operator>>(object_api const &other) const;\n+  object operator>>=(object_api const &other) const;\n+\n+  PYBIND11_DEPRECATED(\"Use py::str(obj) instead\")\n+  pybind11::str str() const;\n+\n+  /// Get or set the object's docstring, i.e. ``obj.__doc__``.\n+  str_attr_accessor doc() const;\n+\n+  /// Return the object's current reference count\n+  int ref_count() const { return static_cast<int>(Py_REFCNT(derived().ptr())); }\n+  /// Return a handle to the Python type object underlying the instance\n+  handle get_type() const;\n+\n+private:\n+  bool rich_compare(object_api const &other, int value) const;\n+};\n+\n+NAMESPACE_END(detail)\n+\n+/** \\rst\n+    Holds a reference to a Python object (no reference counting)\n+\n+    The `handle` class is a thin wrapper around an arbitrary Python object (i.e.\n+a\n+    ``PyObject *`` in Python's C API). It does not perform any automatic\n+reference counting and merely provides a basic C++ interface to various Python\n+API functions.\n+\n+    .. seealso::\n+        The `object` class inherits from `handle` and adds automatic reference\n+        counting features.\n+\\endrst */\n+class handle : public detail::object_api<handle> {\n+public:\n+  /// The default constructor creates a handle with a ``nullptr``-valued pointer\n+  handle() = default;\n+  /// Creates a ``handle`` from the given raw Python object pointer\n+  handle(PyObject *ptr)\n+      : m_ptr(ptr) {} // Allow implicit conversion from PyObject*\n+\n+  /// Return the underlying ``PyObject *`` pointer\n+  PyObject *ptr() const { return m_ptr; }\n+  PyObject *&ptr() { return m_ptr; }\n+\n+  /** \\rst\n+      Manually increase the reference count of the Python object. Usually, it is\n+      preferable to use the `object` class which derives from `handle` and calls\n+      this function automatically. Returns a reference to itself.\n+  \\endrst */\n+  const handle &inc_ref() const & {\n+    Py_XINCREF(m_ptr);\n+    return *this;\n+  }\n+\n+  /** \\rst\n+      Manually decrease the reference count of the Python object. Usually, it is\n+      preferable to use the `object` class which derives from `handle` and calls\n+      this function automatically. Returns a reference to itself.\n+  \\endrst */\n+  const handle &dec_ref() const & {\n+    Py_XDECREF(m_ptr);\n+    return *this;\n+  }\n+\n+  /** \\rst\n+      Attempt to cast the Python object into the given C++ type. A `cast_error`\n+      will be throw upon failure.\n+  \\endrst */\n+  template <typename T> T cast() const;\n+  /// Return ``true`` when the `handle` wraps a valid Python object\n+  explicit operator bool() const { return m_ptr != nullptr; }\n+  /** \\rst\n+      Deprecated: Check that the underlying pointers are the same.\n+      Equivalent to ``obj1 is obj2`` in Python.\n+  \\endrst */\n+  PYBIND11_DEPRECATED(\"Use obj1.is(obj2) instead\")\n+  bool operator==(const handle &h) const { return m_ptr == h.m_ptr; }\n+  PYBIND11_DEPRECATED(\"Use !obj1.is(obj2) instead\")\n+  bool operator!=(const handle &h) const { return m_ptr != h.m_ptr; }\n+  PYBIND11_DEPRECATED(\"Use handle::operator bool() instead\")\n+  bool check() const { return m_ptr != nullptr; }\n+\n+protected:\n+  PyObject *m_ptr = nullptr;\n+};\n+\n+/** \\rst\n+    Holds a reference to a Python object (with reference counting)\n+\n+    Like `handle`, the `object` class is a thin wrapper around an arbitrary\n+Python object (i.e. a ``PyObject *`` in Python's C API). In contrast to\n+`handle`, it optionally increases the object's reference count upon\n+construction, and it *always* decreases the reference count when the `object`\n+instance goes out of scope and is destructed. When using `object` instances\n+consistently, it is much easier to get reference counting right at the first\n+attempt. \\endrst */\n+class object : public handle {\n+public:\n+  object() = default;\n+  PYBIND11_DEPRECATED(\n+      \"Use reinterpret_borrow<object>() or reinterpret_steal<object>()\")\n+  object(handle h, bool is_borrowed) : handle(h) {\n+    if (is_borrowed)\n+      inc_ref();\n+  }\n+  /// Copy constructor; always increases the reference count\n+  object(const object &o) : handle(o) { inc_ref(); }\n+  /// Move constructor; steals the object from ``other`` and preserves its\n+  /// reference count\n+  object(object &&other) noexcept {\n+    m_ptr = other.m_ptr;\n+    other.m_ptr = nullptr;\n+  }\n+  /// Destructor; automatically calls `handle::dec_ref()`\n+  ~object() { dec_ref(); }\n+\n+  /** \\rst\n+      Resets the internal pointer to ``nullptr`` without without decreasing the\n+      object's reference count. The function returns a raw handle to the\n+  original Python object. \\endrst */\n+  handle release() {\n+    PyObject *tmp = m_ptr;\n+    m_ptr = nullptr;\n+    return handle(tmp);\n+  }\n+\n+  object &operator=(const object &other) {\n+    other.inc_ref();\n+    dec_ref();\n+    m_ptr = other.m_ptr;\n+    return *this;\n+  }\n+\n+  object &operator=(object &&other) noexcept {\n+    if (this != &other) {\n+      handle temp(m_ptr);\n+      m_ptr = other.m_ptr;\n+      other.m_ptr = nullptr;\n+      temp.dec_ref();\n+    }\n+    return *this;\n+  }\n+\n+  // Calling cast() on an object lvalue just copies (via handle::cast)\n+  template <typename T> T cast() const &;\n+  // Calling on an object rvalue does a move, if needed and/or possible\n+  template <typename T> T cast() &&;\n+\n+protected:\n+  // Tags for choosing constructors from raw PyObject *\n+  struct borrowed_t {};\n+  struct stolen_t {};\n+\n+  template <typename T> friend T reinterpret_borrow(handle);\n+  template <typename T> friend T reinterpret_steal(handle);\n+\n+public:\n+  // Only accessible from derived classes and the reinterpret_* functions\n+  object(handle h, borrowed_t) : handle(h) { inc_ref(); }\n+  object(handle h, stolen_t) : handle(h) {}\n+};\n+\n+/** \\rst\n+    Declare that a `handle` or ``PyObject *`` is a certain type and borrow the\n+reference. The target type ``T`` must be `object` or one of its derived classes.\n+The function doesn't do any conversions or checks. It's up to the user to make\n+sure that the target type is correct.\n+\n+    .. code-block:: cpp\n+\n+        PyObject *p = PyList_GetItem(obj, index);\n+        py::object o = reinterpret_borrow<py::object>(p);\n+        // or\n+        py::tuple t = reinterpret_borrow<py::tuple>(p); // <-- `p` must be\n+already be a `tuple` \\endrst */\n+template <typename T> T reinterpret_borrow(handle h) {\n+  return {h, object::borrowed_t{}};\n+}\n+\n+/** \\rst\n+    Like `reinterpret_borrow`, but steals the reference.\n+\n+     .. code-block:: cpp\n+\n+        PyObject *p = PyObject_Str(obj);\n+        py::str s = reinterpret_steal<py::str>(p); // <-- `p` must be already be\n+a `str` \\endrst */\n+template <typename T> T reinterpret_steal(handle h) {\n+  return {h, object::stolen_t{}};\n+}\n+\n+NAMESPACE_BEGIN(detail)\n+inline std::string error_string();\n+NAMESPACE_END(detail)\n+\n+/// Fetch and hold an error which was already set in Python.  An instance of\n+/// this is typically thrown to propagate python-side errors back through C++\n+/// which can either be caught manually or else falls back to the function\n+/// dispatcher (which then raises the captured error back to python).\n+class error_already_set : public std::runtime_error {\n+public:\n+  /// Constructs a new exception from the current Python error indicator, if\n+  /// any.  The current Python error indicator will be cleared.\n+  error_already_set() : std::runtime_error(detail::error_string()) {\n+    PyErr_Fetch(&m_type.ptr(), &m_value.ptr(), &m_trace.ptr());\n+  }\n+\n+  error_already_set(const error_already_set &) = default;\n+  error_already_set(error_already_set &&) = default;\n+\n+  inline ~error_already_set();\n+\n+  /// Give the currently-held error back to Python, if any.  If there is\n+  /// currently a Python error already set it is cleared first.  After this\n+  /// call, the current object no longer stores the error variables (but the\n+  /// `.what()` string is still available).\n+  void restore() {\n+    PyErr_Restore(m_type.release().ptr(), m_value.release().ptr(),\n+                  m_trace.release().ptr());\n+  }\n+\n+  // Does nothing; provided for backwards compatibility.\n+  PYBIND11_DEPRECATED(\"Use of error_already_set.clear() is deprecated\")\n+  void clear() {}\n+\n+  /// Check if the currently trapped error type matches the given Python\n+  /// exception class (or a subclass thereof).  May also be passed a tuple to\n+  /// search for any exception class matches in the given tuple.\n+  bool matches(handle exc) const {\n+    return PyErr_GivenExceptionMatches(m_type.ptr(), exc.ptr());\n+  }\n+\n+  const object &type() const { return m_type; }\n+  const object &value() const { return m_value; }\n+  const object &trace() const { return m_trace; }\n+\n+private:\n+  object m_type, m_value, m_trace;\n+};\n+\n+/** \\defgroup python_builtins _\n+    Unless stated otherwise, the following C++ functions behave the same\n+    as their Python counterparts.\n+ */\n+\n+/** \\ingroup python_builtins\n+    \\rst\n+    Return true if ``obj`` is an instance of ``T``. Type ``T`` must be a\n+subclass of `object` or a class which was exposed to Python as\n+``py::class_<T>``. \\endrst */\n+template <typename T,\n+          detail::enable_if_t<std::is_base_of<object, T>::value, int> = 0>\n+bool isinstance(handle obj) {\n+  return T::check_(obj);\n+}\n+\n+template <typename T,\n+          detail::enable_if_t<!std::is_base_of<object, T>::value, int> = 0>\n+bool isinstance(handle obj) {\n+  return detail::isinstance_generic(obj, typeid(T));\n+}\n+\n+template <> inline bool isinstance<handle>(handle obj) = delete;\n+template <> inline bool isinstance<object>(handle obj) {\n+  return obj.ptr() != nullptr;\n+}\n+\n+/// \\ingroup python_builtins\n+/// Return true if ``obj`` is an instance of the ``type``.\n+inline bool isinstance(handle obj, handle type) {\n+  const auto result = PyObject_IsInstance(obj.ptr(), type.ptr());\n+  if (result == -1)\n+    throw error_already_set();\n+  return result != 0;\n+}\n+\n+/// \\addtogroup python_builtins\n+/// @{\n+inline bool hasattr(handle obj, handle name) {\n+  return PyObject_HasAttr(obj.ptr(), name.ptr()) == 1;\n+}\n+\n+inline bool hasattr(handle obj, const char *name) {\n+  return PyObject_HasAttrString(obj.ptr(), name) == 1;\n+}\n+\n+inline void delattr(handle obj, handle name) {\n+  if (PyObject_DelAttr(obj.ptr(), name.ptr()) != 0) {\n+    throw error_already_set();\n+  }\n+}\n+\n+inline void delattr(handle obj, const char *name) {\n+  if (PyObject_DelAttrString(obj.ptr(), name) != 0) {\n+    throw error_already_set();\n+  }\n+}\n+\n+inline object getattr(handle obj, handle name) {\n+  PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr());\n+  if (!result) {\n+    throw error_already_set();\n+  }\n+  return reinterpret_steal<object>(result);\n+}\n+\n+inline object getattr(handle obj, const char *name) {\n+  PyObject *result = PyObject_GetAttrString(obj.ptr(), name);\n+  if (!result) {\n+    throw error_already_set();\n+  }\n+  return reinterpret_steal<object>(result);\n+}\n+\n+inline object getattr(handle obj, handle name, handle default_) {\n+  if (PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr())) {\n+    return reinterpret_steal<object>(result);\n+  } else {\n+    PyErr_Clear();\n+    return reinterpret_borrow<object>(default_);\n+  }\n+}\n+\n+inline object getattr(handle obj, const char *name, handle default_) {\n+  if (PyObject *result = PyObject_GetAttrString(obj.ptr(), name)) {\n+    return reinterpret_steal<object>(result);\n+  } else {\n+    PyErr_Clear();\n+    return reinterpret_borrow<object>(default_);\n+  }\n+}\n+\n+inline void setattr(handle obj, handle name, handle value) {\n+  if (PyObject_SetAttr(obj.ptr(), name.ptr(), value.ptr()) != 0) {\n+    throw error_already_set();\n+  }\n+}\n+\n+inline void setattr(handle obj, const char *name, handle value) {\n+  if (PyObject_SetAttrString(obj.ptr(), name, value.ptr()) != 0) {\n+    throw error_already_set();\n+  }\n+}\n+\n+inline ssize_t hash(handle obj) {\n+  auto h = PyObject_Hash(obj.ptr());\n+  if (h == -1) {\n+    throw error_already_set();\n+  }\n+  return h;\n+}\n+\n+/// @} python_builtins\n+\n+NAMESPACE_BEGIN(detail)\n+inline handle get_function(handle value) {\n+  if (value) {\n+#if PY_MAJOR_VERSION >= 3\n+    if (PyInstanceMethod_Check(value.ptr()))\n+      value = PyInstanceMethod_GET_FUNCTION(value.ptr());\n+    else\n+#endif\n+        if (PyMethod_Check(value.ptr()))\n+      value = PyMethod_GET_FUNCTION(value.ptr());\n+  }\n+  return value;\n+}\n+\n+// Helper aliases/functions to support implicit casting of values given to\n+// python accessors/methods. When given a pyobject, this simply returns the\n+// pyobject as-is; for other C++ type, the value goes through\n+// pybind11::cast(obj) to convert it to an `object`.\n+template <typename T, enable_if_t<is_pyobject<T>::value, int> = 0>\n+auto object_or_cast(T &&o) -> decltype(std::forward<T>(o)) {\n+  return std::forward<T>(o);\n+}\n+// The following casting version is implemented in cast.h:\n+template <typename T, enable_if_t<!is_pyobject<T>::value, int> = 0>\n+object object_or_cast(T &&o);\n+// Match a PyObject*, which we want to convert directly to handle via its\n+// converting constructor\n+inline handle object_or_cast(PyObject *ptr) { return ptr; }\n+\n+template <typename Policy>\n+class accessor : public object_api<accessor<Policy>> {\n+  using key_type = typename Policy::key_type;\n+\n+public:\n+  accessor(handle obj, key_type key) : obj(obj), key(std::move(key)) {}\n+  accessor(const accessor &) = default;\n+  accessor(accessor &&) = default;\n+\n+  // accessor overload required to override default assignment operator\n+  // (templates are not allowed to replace default compiler-generated\n+  // assignments).\n+  void operator=(const accessor &a) && {\n+    std::move(*this).operator=(handle(a));\n+  }\n+  void operator=(const accessor &a) & { operator=(handle(a)); }\n+\n+  template <typename T> void operator=(T &&value) && {\n+    Policy::set(obj, key, object_or_cast(std::forward<T>(value)));\n+  }\n+  template <typename T> void operator=(T &&value) & {\n+    get_cache() =\n+        reinterpret_borrow<object>(object_or_cast(std::forward<T>(value)));\n+  }\n+\n+  template <typename T = Policy>\n+  PYBIND11_DEPRECATED(\"Use of obj.attr(...) as bool is deprecated in favor of \"\n+                      \"pybind11::hasattr(obj, ...)\")\n+  explicit\n+  operator enable_if_t<std::is_same<T, accessor_policies::str_attr>::value ||\n+                           std::is_same<T, accessor_policies::obj_attr>::value,\n+                       bool>() const {\n+    return hasattr(obj, key);\n+  }\n+  template <typename T = Policy>\n+  PYBIND11_DEPRECATED(\n+      \"Use of obj[key] as bool is deprecated in favor of obj.contains(key)\")\n+  explicit\n+  operator enable_if_t<std::is_same<T, accessor_policies::generic_item>::value,\n+                       bool>() const {\n+    return obj.contains(key);\n+  }\n+\n+  operator object() const { return get_cache(); }\n+  PyObject *ptr() const { return get_cache().ptr(); }\n+  template <typename T> T cast() const {\n+    return get_cache().template cast<T>();\n+  }\n+\n+private:\n+  object &get_cache() const {\n+    if (!cache) {\n+      cache = Policy::get(obj, key);\n+    }\n+    return cache;\n+  }\n+\n+private:\n+  handle obj;\n+  key_type key;\n+  mutable object cache;\n+};\n+\n+NAMESPACE_BEGIN(accessor_policies)\n+struct obj_attr {\n+  using key_type = object;\n+  static object get(handle obj, handle key) { return getattr(obj, key); }\n+  static void set(handle obj, handle key, handle val) {\n+    setattr(obj, key, val);\n+  }\n+};\n+\n+struct str_attr {\n+  using key_type = const char *;\n+  static object get(handle obj, const char *key) { return getattr(obj, key); }\n+  static void set(handle obj, const char *key, handle val) {\n+    setattr(obj, key, val);\n+  }\n+};\n+\n+struct generic_item {\n+  using key_type = object;\n+\n+  static object get(handle obj, handle key) {\n+    PyObject *result = PyObject_GetItem(obj.ptr(), key.ptr());\n+    if (!result) {\n+      throw error_already_set();\n+    }\n+    return reinterpret_steal<object>(result);\n+  }\n+\n+  static void set(handle obj, handle key, handle val) {\n+    if (PyObject_SetItem(obj.ptr(), key.ptr(), val.ptr()) != 0) {\n+      throw error_already_set();\n+    }\n+  }\n+};\n+\n+struct sequence_item {\n+  using key_type = size_t;\n+\n+  static object get(handle obj, size_t index) {\n+    PyObject *result =\n+        PySequence_GetItem(obj.ptr(), static_cast<ssize_t>(index));\n+    if (!result) {\n+      throw error_already_set();\n+    }\n+    return reinterpret_steal<object>(result);\n+  }\n+\n+  static void set(handle obj, size_t index, handle val) {\n+    // PySequence_SetItem does not steal a reference to 'val'\n+    if (PySequence_SetItem(obj.ptr(), static_cast<ssize_t>(index), val.ptr()) !=\n+        0) {\n+      throw error_already_set();\n+    }\n+  }\n+};\n+\n+struct list_item {\n+  using key_type = size_t;\n+\n+  static object get(handle obj, size_t index) {\n+    PyObject *result = PyList_GetItem(obj.ptr(), static_cast<ssize_t>(index));\n+    if (!result) {\n+      throw error_already_set();\n+    }\n+    return reinterpret_borrow<object>(result);\n+  }\n+\n+  static void set(handle obj, size_t index, handle val) {\n+    // PyList_SetItem steals a reference to 'val'\n+    if (PyList_SetItem(obj.ptr(), static_cast<ssize_t>(index),\n+                       val.inc_ref().ptr()) != 0) {\n+      throw error_already_set();\n+    }\n+  }\n+};\n+\n+struct tuple_item {\n+  using key_type = size_t;\n+\n+  static object get(handle obj, size_t index) {\n+    PyObject *result = PyTuple_GetItem(obj.ptr(), static_cast<ssize_t>(index));\n+    if (!result) {\n+      throw error_already_set();\n+    }\n+    return reinterpret_borrow<object>(result);\n+  }\n+\n+  static void set(handle obj, size_t index, handle val) {\n+    // PyTuple_SetItem steals a reference to 'val'\n+    if (PyTuple_SetItem(obj.ptr(), static_cast<ssize_t>(index),\n+                        val.inc_ref().ptr()) != 0) {\n+      throw error_already_set();\n+    }\n+  }\n+};\n+NAMESPACE_END(accessor_policies)\n+\n+/// STL iterator template used for tuple, list, sequence and dict\n+template <typename Policy> class generic_iterator : public Policy {\n+  using It = generic_iterator;\n+\n+public:\n+  using difference_type = ssize_t;\n+  using iterator_category = typename Policy::iterator_category;\n+  using value_type = typename Policy::value_type;\n+  using reference = typename Policy::reference;\n+  using pointer = typename Policy::pointer;\n+\n+  generic_iterator() = default;\n+  generic_iterator(handle seq, ssize_t index) : Policy(seq, index) {}\n+\n+  reference operator*() const { return Policy::dereference(); }\n+  reference operator[](difference_type n) const { return *(*this + n); }\n+  pointer operator->() const { return **this; }\n+\n+  It &operator++() {\n+    Policy::increment();\n+    return *this;\n+  }\n+  It operator++(int) {\n+    auto copy = *this;\n+    Policy::increment();\n+    return copy;\n+  }\n+  It &operator--() {\n+    Policy::decrement();\n+    return *this;\n+  }\n+  It operator--(int) {\n+    auto copy = *this;\n+    Policy::decrement();\n+    return copy;\n+  }\n+  It &operator+=(difference_type n) {\n+    Policy::advance(n);\n+    return *this;\n+  }\n+  It &operator-=(difference_type n) {\n+    Policy::advance(-n);\n+    return *this;\n+  }\n+\n+  friend It operator+(const It &a, difference_type n) {\n+    auto copy = a;\n+    return copy += n;\n+  }\n+  friend It operator+(difference_type n, const It &b) { return b + n; }\n+  friend It operator-(const It &a, difference_type n) {\n+    auto copy = a;\n+    return copy -= n;\n+  }\n+  friend difference_type operator-(const It &a, const It &b) {\n+    return a.distance_to(b);\n+  }\n+\n+  friend bool operator==(const It &a, const It &b) { return a.equal(b); }\n+  friend bool operator!=(const It &a, const It &b) { return !(a == b); }\n+  friend bool operator<(const It &a, const It &b) { return b - a > 0; }\n+  friend bool operator>(const It &a, const It &b) { return b < a; }\n+  friend bool operator>=(const It &a, const It &b) { return !(a < b); }\n+  friend bool operator<=(const It &a, const It &b) { return !(a > b); }\n+};\n+\n+NAMESPACE_BEGIN(iterator_policies)\n+/// Quick proxy class needed to implement ``operator->`` for iterators which\n+/// can't return pointers\n+template <typename T> struct arrow_proxy {\n+  T value;\n+\n+  arrow_proxy(T &&value) : value(std::move(value)) {}\n+  T *operator->() const { return &value; }\n+};\n+\n+/// Lightweight iterator policy using just a simple pointer: see\n+/// ``PySequence_Fast_ITEMS``\n+class sequence_fast_readonly {\n+protected:\n+  using iterator_category = std::random_access_iterator_tag;\n+  using value_type = handle;\n+  using reference = const handle;\n+  using pointer = arrow_proxy<const handle>;\n+\n+  sequence_fast_readonly(handle obj, ssize_t n)\n+      : ptr(PySequence_Fast_ITEMS(obj.ptr()) + n) {}\n+\n+  reference dereference() const { return *ptr; }\n+  void increment() { ++ptr; }\n+  void decrement() { --ptr; }\n+  void advance(ssize_t n) { ptr += n; }\n+  bool equal(const sequence_fast_readonly &b) const { return ptr == b.ptr; }\n+  ssize_t distance_to(const sequence_fast_readonly &b) const {\n+    return ptr - b.ptr;\n+  }\n+\n+private:\n+  PyObject **ptr;\n+};\n+\n+/// Full read and write access using the sequence protocol: see\n+/// ``detail::sequence_accessor``\n+class sequence_slow_readwrite {\n+protected:\n+  using iterator_category = std::random_access_iterator_tag;\n+  using value_type = object;\n+  using reference = sequence_accessor;\n+  using pointer = arrow_proxy<const sequence_accessor>;\n+\n+  sequence_slow_readwrite(handle obj, ssize_t index) : obj(obj), index(index) {}\n+\n+  reference dereference() const { return {obj, static_cast<size_t>(index)}; }\n+  void increment() { ++index; }\n+  void decrement() { --index; }\n+  void advance(ssize_t n) { index += n; }\n+  bool equal(const sequence_slow_readwrite &b) const {\n+    return index == b.index;\n+  }\n+  ssize_t distance_to(const sequence_slow_readwrite &b) const {\n+    return index - b.index;\n+  }\n+\n+private:\n+  handle obj;\n+  ssize_t index;\n+};\n+\n+/// Python's dictionary protocol permits this to be a forward iterator\n+class dict_readonly {\n+protected:\n+  using iterator_category = std::forward_iterator_tag;\n+  using value_type = std::pair<handle, handle>;\n+  using reference = const value_type;\n+  using pointer = arrow_proxy<const value_type>;\n+\n+  dict_readonly() = default;\n+  dict_readonly(handle obj, ssize_t pos) : obj(obj), pos(pos) { increment(); }\n+\n+  reference dereference() const { return {key, value}; }\n+  void increment() {\n+    if (!PyDict_Next(obj.ptr(), &pos, &key, &value)) {\n+      pos = -1;\n+    }\n+  }\n+  bool equal(const dict_readonly &b) const { return pos == b.pos; }\n+\n+private:\n+  handle obj;\n+  PyObject *key = nullptr, *value = nullptr;\n+  ssize_t pos = -1;\n+};\n+NAMESPACE_END(iterator_policies)\n+\n+#if !defined(PYPY_VERSION)\n+using tuple_iterator =\n+    generic_iterator<iterator_policies::sequence_fast_readonly>;\n+using list_iterator =\n+    generic_iterator<iterator_policies::sequence_fast_readonly>;\n+#else\n+using tuple_iterator =\n+    generic_iterator<iterator_policies::sequence_slow_readwrite>;\n+using list_iterator =\n+    generic_iterator<iterator_policies::sequence_slow_readwrite>;\n+#endif\n+\n+using sequence_iterator =\n+    generic_iterator<iterator_policies::sequence_slow_readwrite>;\n+using dict_iterator = generic_iterator<iterator_policies::dict_readonly>;\n+\n+inline bool PyIterable_Check(PyObject *obj) {\n+  PyObject *iter = PyObject_GetIter(obj);\n+  if (iter) {\n+    Py_DECREF(iter);\n+    return true;\n+  } else {\n+    PyErr_Clear();\n+    return false;\n+  }\n+}\n+\n+inline bool PyNone_Check(PyObject *o) { return o == Py_None; }\n+#if PY_MAJOR_VERSION >= 3\n+inline bool PyEllipsis_Check(PyObject *o) { return o == Py_Ellipsis; }\n+#endif\n+\n+inline bool PyUnicode_Check_Permissive(PyObject *o) {\n+  return PyUnicode_Check(o) || PYBIND11_BYTES_CHECK(o);\n+}\n+\n+inline bool PyStaticMethod_Check(PyObject *o) {\n+  return o->ob_type == &PyStaticMethod_Type;\n+}\n+\n+class kwargs_proxy : public handle {\n+public:\n+  explicit kwargs_proxy(handle h) : handle(h) {}\n+};\n+\n+class args_proxy : public handle {\n+public:\n+  explicit args_proxy(handle h) : handle(h) {}\n+  kwargs_proxy operator*() const { return kwargs_proxy(*this); }\n+};\n+\n+/// Python argument categories (using PEP 448 terms)\n+template <typename T> using is_keyword = std::is_base_of<arg, T>;\n+template <typename T>\n+using is_s_unpacking = std::is_same<args_proxy, T>; // * unpacking\n+template <typename T>\n+using is_ds_unpacking = std::is_same<kwargs_proxy, T>; // ** unpacking\n+template <typename T>\n+using is_positional =\n+    satisfies_none_of<T, is_keyword, is_s_unpacking, is_ds_unpacking>;\n+template <typename T>\n+using is_keyword_or_ds = satisfies_any_of<T, is_keyword, is_ds_unpacking>;\n+\n+// Call argument collector forward declarations\n+template <return_value_policy policy = return_value_policy::automatic_reference>\n+class simple_collector;\n+template <return_value_policy policy = return_value_policy::automatic_reference>\n+class unpacking_collector;\n+\n+NAMESPACE_END(detail)\n+\n+// TODO: After the deprecated constructors are removed, this macro can be\n+// simplified by\n+//       inheriting ctors: `using Parent::Parent`. It's not an option right now\n+//       because the `using` statement triggers the parent deprecation warning\n+//       even if the ctor isn't even used.\n+#define PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                         \\\n+public:                                                                        \\\n+  PYBIND11_DEPRECATED(\"Use reinterpret_borrow<\" #Name                          \\\n+                      \">() or reinterpret_steal<\" #Name \">()\")                 \\\n+  Name(handle h, bool is_borrowed)                                             \\\n+      : Parent(is_borrowed ? Parent(h, borrowed_t{})                           \\\n+                           : Parent(h, stolen_t{})) {}                         \\\n+  Name(handle h, borrowed_t) : Parent(h, borrowed_t{}) {}                      \\\n+  Name(handle h, stolen_t) : Parent(h, stolen_t{}) {}                          \\\n+  PYBIND11_DEPRECATED(\"Use py::isinstance<py::python_type>(obj) instead\")      \\\n+  bool check() const { return m_ptr != nullptr && (bool)CheckFun(m_ptr); }     \\\n+  static bool check_(handle h) {                                               \\\n+    return h.ptr() != nullptr && CheckFun(h.ptr());                            \\\n+  }\n+\n+#define PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun)                \\\n+  PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                               \\\n+  /* This is deliberately not 'explicit' to allow implicit conversion from     \\\n+   * object: */                                                                \\\n+  Name(const object &o)                                                        \\\n+      : Parent(check_(o) ? o.inc_ref().ptr() : ConvertFun(o.ptr()),            \\\n+               stolen_t{}) {                                                   \\\n+    if (!m_ptr)                                                                \\\n+      throw error_already_set();                                               \\\n+  }                                                                            \\\n+  Name(object &&o)                                                             \\\n+      : Parent(check_(o) ? o.release().ptr() : ConvertFun(o.ptr()),            \\\n+               stolen_t{}) {                                                   \\\n+    if (!m_ptr)                                                                \\\n+      throw error_already_set();                                               \\\n+  }                                                                            \\\n+  template <typename Policy_>                                                  \\\n+  Name(const ::pybind11::detail::accessor<Policy_> &a) : Name(object(a)) {}\n+\n+#define PYBIND11_OBJECT(Name, Parent, CheckFun)                                \\\n+  PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                               \\\n+  /* This is deliberately not 'explicit' to allow implicit conversion from     \\\n+   * object: */                                                                \\\n+  Name(const object &o) : Parent(o) {}                                         \\\n+  Name(object &&o) : Parent(std::move(o)) {}\n+\n+#define PYBIND11_OBJECT_DEFAULT(Name, Parent, CheckFun)                        \\\n+  PYBIND11_OBJECT(Name, Parent, CheckFun)                                      \\\n+  Name() : Parent() {}\n+\n+/// \\addtogroup pytypes\n+/// @{\n+\n+/** \\rst\n+    Wraps a Python iterator so that it can also be used as a C++ input iterator\n+\n+    Caveat: copying an iterator does not (and cannot) clone the internal\n+    state of the Python iterable. This also applies to the post-increment\n+    operator. This iterator should only be used to retrieve the current\n+    value using ``operator*()``.\n+\\endrst */\n+class iterator : public object {\n+public:\n+  using iterator_category = std::input_iterator_tag;\n+  using difference_type = ssize_t;\n+  using value_type = handle;\n+  using reference = const handle;\n+  using pointer = const handle *;\n+\n+  PYBIND11_OBJECT_DEFAULT(iterator, object, PyIter_Check)\n+\n+  iterator &operator++() {\n+    advance();\n+    return *this;\n+  }\n+\n+  iterator operator++(int) {\n+    auto rv = *this;\n+    advance();\n+    return rv;\n+  }\n+\n+  reference operator*() const {\n+    if (m_ptr && !value.ptr()) {\n+      auto &self = const_cast<iterator &>(*this);\n+      self.advance();\n+    }\n+    return value;\n+  }\n+\n+  pointer operator->() const {\n+    operator*();\n+    return &value;\n+  }\n+\n+  /** \\rst\n+       The value which marks the end of the iteration. ``it ==\n+  iterator::sentinel()`` is equivalent to catching ``StopIteration`` in Python.\n+\n+       .. code-block:: cpp\n+\n+           void foo(py::iterator it) {\n+               while (it != py::iterator::sentinel()) {\n+                  // use `*it`\n+                  ++it;\n+               }\n+           }\n+  \\endrst */\n+  static iterator sentinel() { return {}; }\n+\n+  friend bool operator==(const iterator &a, const iterator &b) {\n+    return a->ptr() == b->ptr();\n+  }\n+  friend bool operator!=(const iterator &a, const iterator &b) {\n+    return a->ptr() != b->ptr();\n+  }\n+\n+private:\n+  void advance() {\n+    value = reinterpret_steal<object>(PyIter_Next(m_ptr));\n+    if (PyErr_Occurred()) {\n+      throw error_already_set();\n+    }\n+  }\n+\n+private:\n+  object value = {};\n+};\n+\n+class iterable : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(iterable, object, detail::PyIterable_Check)\n+};\n+\n+class bytes;\n+\n+class str : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(str, object, detail::PyUnicode_Check_Permissive, raw_str)\n+\n+  str(const char *c, size_t n)\n+      : object(PyUnicode_FromStringAndSize(c, (ssize_t)n), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate string object!\");\n+  }\n+\n+  // 'explicit' is explicitly omitted from the following constructors to allow\n+  // implicit conversion to py::str from C++ string-like objects\n+  str(const char *c = \"\") : object(PyUnicode_FromString(c), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate string object!\");\n+  }\n+\n+  str(const std::string &s) : str(s.data(), s.size()) {}\n+\n+  explicit str(const bytes &b);\n+\n+  /** \\rst\n+      Return a string representation of the object. This is analogous to\n+      the ``str()`` function in Python.\n+  \\endrst */\n+  explicit str(handle h) : object(raw_str(h.ptr()), stolen_t{}) {}\n+\n+  operator std::string() const {\n+    object temp = *this;\n+    if (PyUnicode_Check(m_ptr)) {\n+      temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(m_ptr));\n+      if (!temp)\n+        pybind11_fail(\"Unable to extract string contents! (encoding issue)\");\n+    }\n+    char *buffer;\n+    ssize_t length;\n+    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length))\n+      pybind11_fail(\"Unable to extract string contents! (invalid type)\");\n+    return std::string(buffer, (size_t)length);\n+  }\n+\n+  template <typename... Args> str format(Args &&...args) const {\n+    return attr(\"format\")(std::forward<Args>(args)...);\n+  }\n+\n+private:\n+  /// Return string representation -- always returns a new reference, even if\n+  /// already a str\n+  static PyObject *raw_str(PyObject *op) {\n+    PyObject *str_value = PyObject_Str(op);\n+#if PY_MAJOR_VERSION < 3\n+    if (!str_value)\n+      throw error_already_set();\n+    PyObject *unicode =\n+        PyUnicode_FromEncodedObject(str_value, \"utf-8\", nullptr);\n+    Py_XDECREF(str_value);\n+    str_value = unicode;\n+#endif\n+    return str_value;\n+  }\n+};\n+/// @} pytypes\n+\n+inline namespace literals {\n+/** \\rst\n+    String literal version of `str`\n+ \\endrst */\n+inline str operator\"\" _s(const char *s, size_t size) { return {s, size}; }\n+} // namespace literals\n+\n+/// \\addtogroup pytypes\n+/// @{\n+class bytes : public object {\n+public:\n+  PYBIND11_OBJECT(bytes, object, PYBIND11_BYTES_CHECK)\n+\n+  // Allow implicit conversion:\n+  bytes(const char *c = \"\")\n+      : object(PYBIND11_BYTES_FROM_STRING(c), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate bytes object!\");\n+  }\n+\n+  bytes(const char *c, size_t n)\n+      : object(PYBIND11_BYTES_FROM_STRING_AND_SIZE(c, (ssize_t)n), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate bytes object!\");\n+  }\n+\n+  // Allow implicit conversion:\n+  bytes(const std::string &s) : bytes(s.data(), s.size()) {}\n+\n+  explicit bytes(const pybind11::str &s);\n+\n+  operator std::string() const {\n+    char *buffer;\n+    ssize_t length;\n+    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(m_ptr, &buffer, &length))\n+      pybind11_fail(\"Unable to extract bytes contents!\");\n+    return std::string(buffer, (size_t)length);\n+  }\n+};\n+\n+inline bytes::bytes(const pybind11::str &s) {\n+  object temp = s;\n+  if (PyUnicode_Check(s.ptr())) {\n+    temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(s.ptr()));\n+    if (!temp)\n+      pybind11_fail(\"Unable to extract string contents! (encoding issue)\");\n+  }\n+  char *buffer;\n+  ssize_t length;\n+  if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length))\n+    pybind11_fail(\"Unable to extract string contents! (invalid type)\");\n+  auto obj = reinterpret_steal<object>(\n+      PYBIND11_BYTES_FROM_STRING_AND_SIZE(buffer, length));\n+  if (!obj)\n+    pybind11_fail(\"Could not allocate bytes object!\");\n+  m_ptr = obj.release().ptr();\n+}\n+\n+inline str::str(const bytes &b) {\n+  char *buffer;\n+  ssize_t length;\n+  if (PYBIND11_BYTES_AS_STRING_AND_SIZE(b.ptr(), &buffer, &length))\n+    pybind11_fail(\"Unable to extract bytes contents!\");\n+  auto obj = reinterpret_steal<object>(\n+      PyUnicode_FromStringAndSize(buffer, (ssize_t)length));\n+  if (!obj)\n+    pybind11_fail(\"Could not allocate string object!\");\n+  m_ptr = obj.release().ptr();\n+}\n+\n+class none : public object {\n+public:\n+  PYBIND11_OBJECT(none, object, detail::PyNone_Check)\n+  none() : object(Py_None, borrowed_t{}) {}\n+};\n+\n+#if PY_MAJOR_VERSION >= 3\n+class ellipsis : public object {\n+public:\n+  PYBIND11_OBJECT(ellipsis, object, detail::PyEllipsis_Check)\n+  ellipsis() : object(Py_Ellipsis, borrowed_t{}) {}\n+};\n+#endif\n+\n+class bool_ : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(bool_, object, PyBool_Check, raw_bool)\n+  bool_() : object(Py_False, borrowed_t{}) {}\n+  // Allow implicit conversion from and to `bool`:\n+  bool_(bool value) : object(value ? Py_True : Py_False, borrowed_t{}) {}\n+  operator bool() const { return m_ptr && PyLong_AsLong(m_ptr) != 0; }\n+\n+private:\n+  /// Return the truth value of an object -- always returns a new reference\n+  static PyObject *raw_bool(PyObject *op) {\n+    const auto value = PyObject_IsTrue(op);\n+    if (value == -1)\n+      return nullptr;\n+    return handle(value ? Py_True : Py_False).inc_ref().ptr();\n+  }\n+};\n+\n+NAMESPACE_BEGIN(detail)\n+// Converts a value to the given unsigned type.  If an error occurs, you get\n+// back (Unsigned) -1; otherwise you get back the unsigned long or unsigned long\n+// long value cast to (Unsigned). (The distinction is critically important when\n+// casting a returned -1 error value to some other unsigned type: (A)-1 != (B)-1\n+// when A and B are unsigned types of different sizes).\n+template <typename Unsigned> Unsigned as_unsigned(PyObject *o) {\n+  if (sizeof(Unsigned) <= sizeof(unsigned long)\n+#if PY_VERSION_HEX < 0x03000000\n+      || PyInt_Check(o)\n+#endif\n+  ) {\n+    unsigned long v = PyLong_AsUnsignedLong(o);\n+    return v == (unsigned long)-1 && PyErr_Occurred() ? (Unsigned)-1\n+                                                      : (Unsigned)v;\n+  } else {\n+    unsigned long long v = PyLong_AsUnsignedLongLong(o);\n+    return v == (unsigned long long)-1 && PyErr_Occurred() ? (Unsigned)-1\n+                                                           : (Unsigned)v;\n+  }\n+}\n+NAMESPACE_END(detail)\n+\n+class int_ : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(int_, object, PYBIND11_LONG_CHECK, PyNumber_Long)\n+  int_() : object(PyLong_FromLong(0), stolen_t{}) {}\n+  // Allow implicit conversion from C++ integral types:\n+  template <typename T,\n+            detail::enable_if_t<std::is_integral<T>::value, int> = 0>\n+  int_(T value) {\n+    if (sizeof(T) <= sizeof(long)) {\n+      if (std::is_signed<T>::value)\n+        m_ptr = PyLong_FromLong((long)value);\n+      else\n+        m_ptr = PyLong_FromUnsignedLong((unsigned long)value);\n+    } else {\n+      if (std::is_signed<T>::value)\n+        m_ptr = PyLong_FromLongLong((long long)value);\n+      else\n+        m_ptr = PyLong_FromUnsignedLongLong((unsigned long long)value);\n+    }\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate int object!\");\n+  }\n+\n+  template <typename T,\n+            detail::enable_if_t<std::is_integral<T>::value, int> = 0>\n+  operator T() const {\n+    return std::is_unsigned<T>::value  ? detail::as_unsigned<T>(m_ptr)\n+           : sizeof(T) <= sizeof(long) ? (T)PyLong_AsLong(m_ptr)\n+                                       : (T)PYBIND11_LONG_AS_LONGLONG(m_ptr);\n+  }\n+};\n+\n+class float_ : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(float_, object, PyFloat_Check, PyNumber_Float)\n+  // Allow implicit conversion from float/double:\n+  float_(float value) : object(PyFloat_FromDouble((double)value), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate float object!\");\n+  }\n+  float_(double value = .0)\n+      : object(PyFloat_FromDouble((double)value), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate float object!\");\n+  }\n+  operator float() const { return (float)PyFloat_AsDouble(m_ptr); }\n+  operator double() const { return (double)PyFloat_AsDouble(m_ptr); }\n+};\n+\n+class weakref : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(weakref, object, PyWeakref_Check)\n+  explicit weakref(handle obj, handle callback = {})\n+      : object(PyWeakref_NewRef(obj.ptr(), callback.ptr()), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate weak reference!\");\n+  }\n+};\n+\n+class slice : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(slice, object, PySlice_Check)\n+  slice(ssize_t start_, ssize_t stop_, ssize_t step_) {\n+    int_ start(start_), stop(stop_), step(step_);\n+    m_ptr = PySlice_New(start.ptr(), stop.ptr(), step.ptr());\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate slice object!\");\n+  }\n+  bool compute(size_t length, size_t *start, size_t *stop, size_t *step,\n+               size_t *slicelength) const {\n+    return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *)m_ptr, (ssize_t)length,\n+                                (ssize_t *)start, (ssize_t *)stop,\n+                                (ssize_t *)step, (ssize_t *)slicelength) == 0;\n+  }\n+  bool compute(ssize_t length, ssize_t *start, ssize_t *stop, ssize_t *step,\n+               ssize_t *slicelength) const {\n+    return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *)m_ptr, length, start,\n+                                stop, step, slicelength) == 0;\n+  }\n+};\n+\n+class capsule : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(capsule, object, PyCapsule_CheckExact)\n+  PYBIND11_DEPRECATED(\n+      \"Use reinterpret_borrow<capsule>() or reinterpret_steal<capsule>()\")\n+  capsule(PyObject *ptr, bool is_borrowed)\n+      : object(is_borrowed ? object(ptr, borrowed_t{})\n+                           : object(ptr, stolen_t{})) {}\n+\n+  explicit capsule(const void *value, const char *name = nullptr,\n+                   void (*destructor)(PyObject *) = nullptr)\n+      : object(PyCapsule_New(const_cast<void *>(value), name, destructor),\n+               stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate capsule object!\");\n+  }\n+\n+  PYBIND11_DEPRECATED(\n+      \"Please pass a destructor that takes a void pointer as input\")\n+  capsule(const void *value, void (*destruct)(PyObject *))\n+      : object(PyCapsule_New(const_cast<void *>(value), nullptr, destruct),\n+               stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate capsule object!\");\n+  }\n+\n+  capsule(const void *value, void (*destructor)(void *)) {\n+    m_ptr = PyCapsule_New(const_cast<void *>(value), nullptr, [](PyObject *o) {\n+      auto destructor =\n+          reinterpret_cast<void (*)(void *)>(PyCapsule_GetContext(o));\n+      void *ptr = PyCapsule_GetPointer(o, nullptr);\n+      destructor(ptr);\n+    });\n+\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate capsule object!\");\n+\n+    if (PyCapsule_SetContext(m_ptr, (void *)destructor) != 0)\n+      pybind11_fail(\"Could not set capsule context!\");\n+  }\n+\n+  capsule(void (*destructor)()) {\n+    m_ptr = PyCapsule_New(\n+        reinterpret_cast<void *>(destructor), nullptr, [](PyObject *o) {\n+          auto destructor =\n+              reinterpret_cast<void (*)()>(PyCapsule_GetPointer(o, nullptr));\n+          destructor();\n+        });\n+\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate capsule object!\");\n+  }\n+\n+  template <typename T> operator T *() const {\n+    auto name = this->name();\n+    T *result = static_cast<T *>(PyCapsule_GetPointer(m_ptr, name));\n+    if (!result)\n+      pybind11_fail(\"Unable to extract capsule contents!\");\n+    return result;\n+  }\n+\n+  const char *name() const { return PyCapsule_GetName(m_ptr); }\n+};\n+\n+class tuple : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(tuple, object, PyTuple_Check, PySequence_Tuple)\n+  explicit tuple(size_t size = 0)\n+      : object(PyTuple_New((ssize_t)size), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate tuple object!\");\n+  }\n+  size_t size() const { return (size_t)PyTuple_Size(m_ptr); }\n+  detail::tuple_accessor operator[](size_t index) const {\n+    return {*this, index};\n+  }\n+  detail::item_accessor operator[](handle h) const {\n+    return object::operator[](h);\n+  }\n+  detail::tuple_iterator begin() const { return {*this, 0}; }\n+  detail::tuple_iterator end() const {\n+    return {*this, PyTuple_GET_SIZE(m_ptr)};\n+  }\n+};\n+\n+class dict : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(dict, object, PyDict_Check, raw_dict)\n+  dict() : object(PyDict_New(), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate dict object!\");\n+  }\n+  template <typename... Args,\n+            typename = detail::enable_if_t<\n+                detail::all_of<detail::is_keyword_or_ds<Args>...>::value>,\n+            // MSVC workaround: it can't compile an out-of-line definition, so\n+            // defer the collector\n+            typename collector =\n+                detail::deferred_t<detail::unpacking_collector<>, Args...>>\n+  explicit dict(Args &&...args)\n+      : dict(collector(std::forward<Args>(args)...).kwargs()) {}\n+\n+  size_t size() const { return (size_t)PyDict_Size(m_ptr); }\n+  detail::dict_iterator begin() const { return {*this, 0}; }\n+  detail::dict_iterator end() const { return {}; }\n+  void clear() const { PyDict_Clear(ptr()); }\n+  bool contains(handle key) const {\n+    return PyDict_Contains(ptr(), key.ptr()) == 1;\n+  }\n+  bool contains(const char *key) const {\n+    return PyDict_Contains(ptr(), pybind11::str(key).ptr()) == 1;\n+  }\n+\n+private:\n+  /// Call the `dict` Python type -- always returns a new reference\n+  static PyObject *raw_dict(PyObject *op) {\n+    if (PyDict_Check(op))\n+      return handle(op).inc_ref().ptr();\n+    return PyObject_CallFunctionObjArgs((PyObject *)&PyDict_Type, op, nullptr);\n+  }\n+};\n+\n+class sequence : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(sequence, object, PySequence_Check)\n+  size_t size() const { return (size_t)PySequence_Size(m_ptr); }\n+  detail::sequence_accessor operator[](size_t index) const {\n+    return {*this, index};\n+  }\n+  detail::item_accessor operator[](handle h) const {\n+    return object::operator[](h);\n+  }\n+  detail::sequence_iterator begin() const { return {*this, 0}; }\n+  detail::sequence_iterator end() const {\n+    return {*this, PySequence_Size(m_ptr)};\n+  }\n+};\n+\n+class list : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(list, object, PyList_Check, PySequence_List)\n+  explicit list(size_t size = 0)\n+      : object(PyList_New((ssize_t)size), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate list object!\");\n+  }\n+  size_t size() const { return (size_t)PyList_Size(m_ptr); }\n+  detail::list_accessor operator[](size_t index) const {\n+    return {*this, index};\n+  }\n+  detail::item_accessor operator[](handle h) const {\n+    return object::operator[](h);\n+  }\n+  detail::list_iterator begin() const { return {*this, 0}; }\n+  detail::list_iterator end() const { return {*this, PyList_GET_SIZE(m_ptr)}; }\n+  template <typename T> void append(T &&val) const {\n+    PyList_Append(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr());\n+  }\n+};\n+\n+class args : public tuple {\n+  PYBIND11_OBJECT_DEFAULT(args, tuple, PyTuple_Check)\n+};\n+class kwargs : public dict {\n+  PYBIND11_OBJECT_DEFAULT(kwargs, dict, PyDict_Check)\n+};\n+\n+class set : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(set, object, PySet_Check, PySet_New)\n+  set() : object(PySet_New(nullptr), stolen_t{}) {\n+    if (!m_ptr)\n+      pybind11_fail(\"Could not allocate set object!\");\n+  }\n+  size_t size() const { return (size_t)PySet_Size(m_ptr); }\n+  template <typename T> bool add(T &&val) const {\n+    return PySet_Add(m_ptr,\n+                     detail::object_or_cast(std::forward<T>(val)).ptr()) == 0;\n+  }\n+  void clear() const { PySet_Clear(m_ptr); }\n+};\n+\n+class function : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(function, object, PyCallable_Check)\n+  handle cpp_function() const {\n+    handle fun = detail::get_function(m_ptr);\n+    if (fun && PyCFunction_Check(fun.ptr()))\n+      return fun;\n+    return handle();\n+  }\n+  bool is_cpp_function() const { return (bool)cpp_function(); }\n+};\n+\n+class staticmethod : public object {\n+public:\n+  PYBIND11_OBJECT_CVT(staticmethod, object, detail::PyStaticMethod_Check,\n+                      PyStaticMethod_New)\n+};\n+\n+class buffer : public object {\n+public:\n+  PYBIND11_OBJECT_DEFAULT(buffer, object, PyObject_CheckBuffer)\n+\n+  buffer_info request(bool writable = false) {\n+    int flags = PyBUF_STRIDES | PyBUF_FORMAT;\n+    if (writable)\n+      flags |= PyBUF_WRITABLE;\n+    Py_buffer *view = new Py_buffer();\n+    if (PyObject_GetBuffer(m_ptr, view, flags) != 0) {\n+      delete view;\n+      throw error_already_set();\n+    }\n+    return buffer_info(view);\n+  }\n+};\n+\n+class memoryview : public object {\n+public:\n+  explicit memoryview(const buffer_info &info) {\n+    static Py_buffer buf{};\n+    // Py_buffer uses signed sizes, strides and shape!..\n+    static std::vector<Py_ssize_t> py_strides{};\n+    static std::vector<Py_ssize_t> py_shape{};\n+    buf.buf = info.ptr;\n+    buf.itemsize = info.itemsize;\n+    buf.format = const_cast<char *>(info.format.c_str());\n+    buf.ndim = (int)info.ndim;\n+    buf.len = info.size;\n+    py_strides.clear();\n+    py_shape.clear();\n+    for (size_t i = 0; i < (size_t)info.ndim; ++i) {\n+      py_strides.push_back(info.strides[i]);\n+      py_shape.push_back(info.shape[i]);\n+    }\n+    buf.strides = py_strides.data();\n+    buf.shape = py_shape.data();\n+    buf.suboffsets = nullptr;\n+    buf.readonly = false;\n+    buf.internal = nullptr;\n+\n+    m_ptr = PyMemoryView_FromBuffer(&buf);\n+    if (!m_ptr)\n+      pybind11_fail(\"Unable to create memoryview from buffer descriptor\");\n+  }\n+\n+  PYBIND11_OBJECT_CVT(memoryview, object, PyMemoryView_Check,\n+                      PyMemoryView_FromObject)\n+};\n+/// @} pytypes\n+\n+/// \\addtogroup python_builtins\n+/// @{\n+inline size_t len(handle h) {\n+  ssize_t result = PyObject_Length(h.ptr());\n+  if (result < 0)\n+    pybind11_fail(\"Unable to compute length of object\");\n+  return (size_t)result;\n+}\n+\n+inline size_t len_hint(handle h) {\n+#if PY_VERSION_HEX >= 0x03040000\n+  ssize_t result = PyObject_LengthHint(h.ptr(), 0);\n+#else\n+  ssize_t result = PyObject_Length(h.ptr());\n+#endif\n+  if (result < 0) {\n+    // Sometimes a length can't be determined at all (eg generators)\n+    // In which case simply return 0\n+    PyErr_Clear();\n+    return 0;\n+  }\n+  return (size_t)result;\n+}\n+\n+inline str repr(handle h) {\n+  PyObject *str_value = PyObject_Repr(h.ptr());\n+  if (!str_value)\n+    throw error_already_set();\n+#if PY_MAJOR_VERSION < 3\n+  PyObject *unicode = PyUnicode_FromEncodedObject(str_value, \"utf-8\", nullptr);\n+  Py_XDECREF(str_value);\n+  str_value = unicode;\n+  if (!str_value)\n+    throw error_already_set();\n+#endif\n+  return reinterpret_steal<str>(str_value);\n+}\n+\n+inline iterator iter(handle obj) {\n+  PyObject *result = PyObject_GetIter(obj.ptr());\n+  if (!result) {\n+    throw error_already_set();\n+  }\n+  return reinterpret_steal<iterator>(result);\n+}\n+/// @} python_builtins\n+\n+NAMESPACE_BEGIN(detail)\n+template <typename D> iterator object_api<D>::begin() const {\n+  return iter(derived());\n+}\n+template <typename D> iterator object_api<D>::end() const {\n+  return iterator::sentinel();\n+}\n+template <typename D>\n+item_accessor object_api<D>::operator[](handle key) const {\n+  return {derived(), reinterpret_borrow<object>(key)};\n+}\n+template <typename D>\n+item_accessor object_api<D>::operator[](const char *key) const {\n+  return {derived(), pybind11::str(key)};\n+}\n+template <typename D> obj_attr_accessor object_api<D>::attr(handle key) const {\n+  return {derived(), reinterpret_borrow<object>(key)};\n+}\n+template <typename D>\n+str_attr_accessor object_api<D>::attr(const char *key) const {\n+  return {derived(), key};\n+}\n+template <typename D> args_proxy object_api<D>::operator*() const {\n+  return args_proxy(derived().ptr());\n+}\n+template <typename D>\n+template <typename T>\n+bool object_api<D>::contains(T &&item) const {\n+  return attr(\"__contains__\")(std::forward<T>(item)).template cast<bool>();\n+}\n+\n+template <typename D> pybind11::str object_api<D>::str() const {\n+  return pybind11::str(derived());\n+}\n+\n+template <typename D> str_attr_accessor object_api<D>::doc() const {\n+  return attr(\"__doc__\");\n+}\n+\n+template <typename D> handle object_api<D>::get_type() const {\n+  return (PyObject *)Py_TYPE(derived().ptr());\n+}\n+\n+template <typename D>\n+bool object_api<D>::rich_compare(object_api const &other, int value) const {\n+  int rv =\n+      PyObject_RichCompareBool(derived().ptr(), other.derived().ptr(), value);\n+  if (rv == -1)\n+    throw error_already_set();\n+  return rv == 1;\n+}\n+\n+#define PYBIND11_MATH_OPERATOR_UNARY(op, fn)                                   \\\n+  template <typename D> object object_api<D>::op() const {                     \\\n+    object result = reinterpret_steal<object>(fn(derived().ptr()));            \\\n+    if (!result.ptr())                                                         \\\n+      throw error_already_set();                                               \\\n+    return result;                                                             \\\n+  }\n+\n+#define PYBIND11_MATH_OPERATOR_BINARY(op, fn)                                  \\\n+  template <typename D>                                                        \\\n+  object object_api<D>::op(object_api const &other) const {                    \\\n+    object result =                                                            \\\n+        reinterpret_steal<object>(fn(derived().ptr(), other.derived().ptr())); \\\n+    if (!result.ptr())                                                         \\\n+      throw error_already_set();                                               \\\n+    return result;                                                             \\\n+  }\n+\n+PYBIND11_MATH_OPERATOR_UNARY(operator~, PyNumber_Invert)\n+PYBIND11_MATH_OPERATOR_UNARY(operator-, PyNumber_Negative)\n+PYBIND11_MATH_OPERATOR_BINARY(operator+, PyNumber_Add)\n+PYBIND11_MATH_OPERATOR_BINARY(operator+=, PyNumber_InPlaceAdd)\n+PYBIND11_MATH_OPERATOR_BINARY(operator-, PyNumber_Subtract)\n+PYBIND11_MATH_OPERATOR_BINARY(operator-=, PyNumber_InPlaceSubtract)\n+PYBIND11_MATH_OPERATOR_BINARY(operator*, PyNumber_Multiply)\n+PYBIND11_MATH_OPERATOR_BINARY(operator*=, PyNumber_InPlaceMultiply)\n+PYBIND11_MATH_OPERATOR_BINARY(operator/, PyNumber_TrueDivide)\n+PYBIND11_MATH_OPERATOR_BINARY(operator/=, PyNumber_InPlaceTrueDivide)\n+PYBIND11_MATH_OPERATOR_BINARY(operator|, PyNumber_Or)\n+PYBIND11_MATH_OPERATOR_BINARY(operator|=, PyNumber_InPlaceOr)\n+PYBIND11_MATH_OPERATOR_BINARY(operator&, PyNumber_And)\n+PYBIND11_MATH_OPERATOR_BINARY(operator&=, PyNumber_InPlaceAnd)\n+PYBIND11_MATH_OPERATOR_BINARY(operator^, PyNumber_Xor)\n+PYBIND11_MATH_OPERATOR_BINARY(operator^=, PyNumber_InPlaceXor)\n+PYBIND11_MATH_OPERATOR_BINARY(operator<<, PyNumber_Lshift)\n+PYBIND11_MATH_OPERATOR_BINARY(operator<<=, PyNumber_InPlaceLshift)\n+PYBIND11_MATH_OPERATOR_BINARY(operator>>, PyNumber_Rshift)\n+PYBIND11_MATH_OPERATOR_BINARY(operator>>=, PyNumber_InPlaceRshift)\n+\n+#undef PYBIND11_MATH_OPERATOR_UNARY\n+#undef PYBIND11_MATH_OPERATOR_BINARY\n+\n+NAMESPACE_END(detail)\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "python/src/pybind11/stl.h", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "file_content_changes": "@@ -0,0 +1,424 @@\n+/*\n+    pybind11/stl.h: Transparent conversion for STL data types\n+\n+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"pybind11.h\"\n+#include <deque>\n+#include <iostream>\n+#include <list>\n+#include <map>\n+#include <set>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <valarray>\n+\n+#if defined(_MSC_VER)\n+#pragma warning(push)\n+#pragma warning(                                                               \\\n+    disable : 4127) // warning C4127: Conditional expression is constant\n+#endif\n+\n+#ifdef __has_include\n+// std::optional (but including it in c++14 mode isn't allowed)\n+#if defined(PYBIND11_CPP17) && __has_include(<optional>)\n+#include <optional>\n+#define PYBIND11_HAS_OPTIONAL 1\n+#endif\n+// std::experimental::optional (but not allowed in c++11 mode)\n+#if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \\\n+                                 !__has_include(<optional>))\n+#include <experimental/optional>\n+#define PYBIND11_HAS_EXP_OPTIONAL 1\n+#endif\n+// std::variant\n+#if defined(PYBIND11_CPP17) && __has_include(<variant>)\n+#include <variant>\n+#define PYBIND11_HAS_VARIANT 1\n+#endif\n+#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)\n+#include <optional>\n+#include <variant>\n+#define PYBIND11_HAS_OPTIONAL 1\n+#define PYBIND11_HAS_VARIANT 1\n+#endif\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+/// Extracts an const lvalue reference or rvalue reference for U based on the\n+/// type of T (e.g. for forwarding a container element).  Typically used\n+/// indirect via forwarded_type(), below.\n+template <typename T, typename U>\n+using forwarded_type =\n+    conditional_t<std::is_lvalue_reference<T>::value, remove_reference_t<U> &,\n+                  remove_reference_t<U> &&>;\n+\n+/// Forwards a value U as rvalue or lvalue according to whether T is rvalue or\n+/// lvalue; typically used for forwarding a container's elements.\n+template <typename T, typename U> forwarded_type<T, U> forward_like(U &&u) {\n+  return std::forward<detail::forwarded_type<T, U>>(std::forward<U>(u));\n+}\n+\n+template <typename Type, typename Key> struct set_caster {\n+  using type = Type;\n+  using key_conv = make_caster<Key>;\n+\n+  bool load(handle src, bool convert) {\n+    if (!isinstance<pybind11::set>(src))\n+      return false;\n+    auto s = reinterpret_borrow<pybind11::set>(src);\n+    value.clear();\n+    for (auto entry : s) {\n+      key_conv conv;\n+      if (!conv.load(entry, convert))\n+        return false;\n+      value.insert(cast_op<Key &&>(std::move(conv)));\n+    }\n+    return true;\n+  }\n+\n+  template <typename T>\n+  static handle cast(T &&src, return_value_policy policy, handle parent) {\n+    if (!std::is_lvalue_reference<T>::value)\n+      policy = return_value_policy_override<Key>::policy(policy);\n+    pybind11::set s;\n+    for (auto &&value : src) {\n+      auto value_ = reinterpret_steal<object>(\n+          key_conv::cast(forward_like<T>(value), policy, parent));\n+      if (!value_ || !s.add(value_))\n+        return handle();\n+    }\n+    return s.release();\n+  }\n+\n+  PYBIND11_TYPE_CASTER(type, _(\"Set[\") + key_conv::name + _(\"]\"));\n+};\n+\n+template <typename Type, typename Key, typename Value> struct map_caster {\n+  using key_conv = make_caster<Key>;\n+  using value_conv = make_caster<Value>;\n+\n+  bool load(handle src, bool convert) {\n+    if (!isinstance<dict>(src))\n+      return false;\n+    auto d = reinterpret_borrow<dict>(src);\n+    value.clear();\n+    for (auto it : d) {\n+      key_conv kconv;\n+      value_conv vconv;\n+      if (!kconv.load(it.first.ptr(), convert) ||\n+          !vconv.load(it.second.ptr(), convert))\n+        return false;\n+      value.emplace(cast_op<Key &&>(std::move(kconv)),\n+                    cast_op<Value &&>(std::move(vconv)));\n+    }\n+    return true;\n+  }\n+\n+  template <typename T>\n+  static handle cast(T &&src, return_value_policy policy, handle parent) {\n+    dict d;\n+    return_value_policy policy_key = policy;\n+    return_value_policy policy_value = policy;\n+    if (!std::is_lvalue_reference<T>::value) {\n+      policy_key = return_value_policy_override<Key>::policy(policy_key);\n+      policy_value = return_value_policy_override<Value>::policy(policy_value);\n+    }\n+    for (auto &&kv : src) {\n+      auto key = reinterpret_steal<object>(\n+          key_conv::cast(forward_like<T>(kv.first), policy_key, parent));\n+      auto value = reinterpret_steal<object>(\n+          value_conv::cast(forward_like<T>(kv.second), policy_value, parent));\n+      if (!key || !value)\n+        return handle();\n+      d[key] = value;\n+    }\n+    return d.release();\n+  }\n+\n+  PYBIND11_TYPE_CASTER(Type, _(\"Dict[\") + key_conv::name + _(\", \") +\n+                                 value_conv::name + _(\"]\"));\n+};\n+\n+template <typename Type, typename Value> struct list_caster {\n+  using value_conv = make_caster<Value>;\n+\n+  bool load(handle src, bool convert) {\n+    if (!isinstance<sequence>(src) || isinstance<str>(src))\n+      return false;\n+    auto s = reinterpret_borrow<sequence>(src);\n+    value.clear();\n+    reserve_maybe(s, &value);\n+    for (auto it : s) {\n+      value_conv conv;\n+      if (!conv.load(it, convert))\n+        return false;\n+      value.push_back(cast_op<Value &&>(std::move(conv)));\n+    }\n+    return true;\n+  }\n+\n+private:\n+  template <typename T = Type,\n+            enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)),\n+                                     void>::value,\n+                        int> = 0>\n+  void reserve_maybe(sequence s, Type *) {\n+    value.reserve(s.size());\n+  }\n+  void reserve_maybe(sequence, void *) {}\n+\n+public:\n+  template <typename T>\n+  static handle cast(T &&src, return_value_policy policy, handle parent) {\n+    if (!std::is_lvalue_reference<T>::value)\n+      policy = return_value_policy_override<Value>::policy(policy);\n+    list l(src.size());\n+    size_t index = 0;\n+    for (auto &&value : src) {\n+      auto value_ = reinterpret_steal<object>(\n+          value_conv::cast(forward_like<T>(value), policy, parent));\n+      if (!value_)\n+        return handle();\n+      PyList_SET_ITEM(l.ptr(), (ssize_t)index++,\n+                      value_.release().ptr()); // steals a reference\n+    }\n+    return l.release();\n+  }\n+\n+  PYBIND11_TYPE_CASTER(Type, _(\"List[\") + value_conv::name + _(\"]\"));\n+};\n+\n+template <typename Type, typename Alloc>\n+struct type_caster<std::vector<Type, Alloc>>\n+    : list_caster<std::vector<Type, Alloc>, Type> {};\n+\n+template <typename Type, typename Alloc>\n+struct type_caster<std::deque<Type, Alloc>>\n+    : list_caster<std::deque<Type, Alloc>, Type> {};\n+\n+template <typename Type, typename Alloc>\n+struct type_caster<std::list<Type, Alloc>>\n+    : list_caster<std::list<Type, Alloc>, Type> {};\n+\n+template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0>\n+struct array_caster {\n+  using value_conv = make_caster<Value>;\n+\n+private:\n+  template <bool R = Resizable> bool require_size(enable_if_t<R, size_t> size) {\n+    if (value.size() != size)\n+      value.resize(size);\n+    return true;\n+  }\n+  template <bool R = Resizable>\n+  bool require_size(enable_if_t<!R, size_t> size) {\n+    return size == Size;\n+  }\n+\n+public:\n+  bool load(handle src, bool convert) {\n+    if (!isinstance<sequence>(src))\n+      return false;\n+    auto l = reinterpret_borrow<sequence>(src);\n+    if (!require_size(l.size()))\n+      return false;\n+    size_t ctr = 0;\n+    for (auto it : l) {\n+      value_conv conv;\n+      if (!conv.load(it, convert))\n+        return false;\n+      value[ctr++] = cast_op<Value &&>(std::move(conv));\n+    }\n+    return true;\n+  }\n+\n+  template <typename T>\n+  static handle cast(T &&src, return_value_policy policy, handle parent) {\n+    list l(src.size());\n+    size_t index = 0;\n+    for (auto &&value : src) {\n+      auto value_ = reinterpret_steal<object>(\n+          value_conv::cast(forward_like<T>(value), policy, parent));\n+      if (!value_)\n+        return handle();\n+      PyList_SET_ITEM(l.ptr(), (ssize_t)index++,\n+                      value_.release().ptr()); // steals a reference\n+    }\n+    return l.release();\n+  }\n+\n+  PYBIND11_TYPE_CASTER(ArrayType,\n+                       _(\"List[\") + value_conv::name +\n+                           _<Resizable>(_(\"\"), _(\"[\") + _<Size>() + _(\"]\")) +\n+                           _(\"]\"));\n+};\n+\n+template <typename Type, size_t Size>\n+struct type_caster<std::array<Type, Size>>\n+    : array_caster<std::array<Type, Size>, Type, false, Size> {};\n+\n+template <typename Type>\n+struct type_caster<std::valarray<Type>>\n+    : array_caster<std::valarray<Type>, Type, true> {};\n+\n+template <typename Key, typename Compare, typename Alloc>\n+struct type_caster<std::set<Key, Compare, Alloc>>\n+    : set_caster<std::set<Key, Compare, Alloc>, Key> {};\n+\n+template <typename Key, typename Hash, typename Equal, typename Alloc>\n+struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>\n+    : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> {};\n+\n+template <typename Key, typename Value, typename Compare, typename Alloc>\n+struct type_caster<std::map<Key, Value, Compare, Alloc>>\n+    : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> {};\n+\n+template <typename Key, typename Value, typename Hash, typename Equal,\n+          typename Alloc>\n+struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>\n+    : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key,\n+                 Value> {};\n+\n+// This type caster is intended to be used for std::optional and\n+// std::experimental::optional\n+template <typename T> struct optional_caster {\n+  using value_conv = make_caster<typename T::value_type>;\n+\n+  template <typename T_>\n+  static handle cast(T_ &&src, return_value_policy policy, handle parent) {\n+    if (!src)\n+      return none().inc_ref();\n+    policy =\n+        return_value_policy_override<typename T::value_type>::policy(policy);\n+    return value_conv::cast(*std::forward<T_>(src), policy, parent);\n+  }\n+\n+  bool load(handle src, bool convert) {\n+    if (!src) {\n+      return false;\n+    } else if (src.is_none()) {\n+      return true; // default-constructed value is already empty\n+    }\n+    value_conv inner_caster;\n+    if (!inner_caster.load(src, convert))\n+      return false;\n+\n+    value.emplace(cast_op<typename T::value_type &&>(std::move(inner_caster)));\n+    return true;\n+  }\n+\n+  PYBIND11_TYPE_CASTER(T, _(\"Optional[\") + value_conv::name + _(\"]\"));\n+};\n+\n+#if PYBIND11_HAS_OPTIONAL\n+template <typename T>\n+struct type_caster<std::optional<T>>\n+    : public optional_caster<std::optional<T>> {};\n+\n+template <>\n+struct type_caster<std::nullopt_t> : public void_caster<std::nullopt_t> {};\n+#endif\n+\n+#if PYBIND11_HAS_EXP_OPTIONAL\n+template <typename T>\n+struct type_caster<std::experimental::optional<T>>\n+    : public optional_caster<std::experimental::optional<T>> {};\n+\n+template <>\n+struct type_caster<std::experimental::nullopt_t>\n+    : public void_caster<std::experimental::nullopt_t> {};\n+#endif\n+\n+/// Visit a variant and cast any found type to Python\n+struct variant_caster_visitor {\n+  return_value_policy policy;\n+  handle parent;\n+\n+  using result_type = handle; // required by boost::variant in C++11\n+\n+  template <typename T> result_type operator()(T &&src) const {\n+    return make_caster<T>::cast(std::forward<T>(src), policy, parent);\n+  }\n+};\n+\n+/// Helper class which abstracts away variant's `visit` function. `std::variant`\n+/// and similar `namespace::variant` types which provide a `namespace::visit()`\n+/// function are handled here automatically using argument-dependent lookup.\n+/// Users can provide specializations for other variant-like classes, e.g.\n+/// `boost::variant` and `boost::apply_visitor`.\n+template <template <typename...> class Variant> struct visit_helper {\n+  template <typename... Args>\n+  static auto call(Args &&...args)\n+      -> decltype(visit(std::forward<Args>(args)...)) {\n+    return visit(std::forward<Args>(args)...);\n+  }\n+};\n+\n+/// Generic variant caster\n+template <typename Variant> struct variant_caster;\n+\n+template <template <typename...> class V, typename... Ts>\n+struct variant_caster<V<Ts...>> {\n+  static_assert(sizeof...(Ts) > 0,\n+                \"Variant must consist of at least one alternative.\");\n+\n+  template <typename U, typename... Us>\n+  bool load_alternative(handle src, bool convert, type_list<U, Us...>) {\n+    auto caster = make_caster<U>();\n+    if (caster.load(src, convert)) {\n+      value = cast_op<U>(caster);\n+      return true;\n+    }\n+    return load_alternative(src, convert, type_list<Us...>{});\n+  }\n+\n+  bool load_alternative(handle, bool, type_list<>) { return false; }\n+\n+  bool load(handle src, bool convert) {\n+    // Do a first pass without conversions to improve constructor resolution.\n+    // E.g. `py::int_(1).cast<variant<double, int>>()` needs to fill the `int`\n+    // slot of the variant. Without two-pass loading `double` would be filled\n+    // because it appears first and a conversion is possible.\n+    if (convert && load_alternative(src, false, type_list<Ts...>{}))\n+      return true;\n+    return load_alternative(src, convert, type_list<Ts...>{});\n+  }\n+\n+  template <typename Variant>\n+  static handle cast(Variant &&src, return_value_policy policy, handle parent) {\n+    return visit_helper<V>::call(variant_caster_visitor{policy, parent},\n+                                 std::forward<Variant>(src));\n+  }\n+\n+  using Type = V<Ts...>;\n+  PYBIND11_TYPE_CASTER(Type, _(\"Union[\") +\n+                                 detail::concat(make_caster<Ts>::name...) +\n+                                 _(\"]\"));\n+};\n+\n+#if PYBIND11_HAS_VARIANT\n+template <typename... Ts>\n+struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> {\n+};\n+#endif\n+\n+NAMESPACE_END(detail)\n+\n+inline std::ostream &operator<<(std::ostream &os, const handle &obj) {\n+  os << (std::string)str(obj);\n+  return os;\n+}\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)\n+\n+#if defined(_MSC_VER)\n+#pragma warning(pop)\n+#endif"}, {"filename": "python/src/pybind11/stl_bind.h", "status": "added", "additions": 669, "deletions": 0, "changes": 669, "file_content_changes": "@@ -0,0 +1,669 @@\n+/*\n+    pybind11/std_bind.h: Binding generators for STL data types\n+\n+    Copyright (c) 2016 Sergey Lyskov and Wenzel Jakob\n+\n+    All rights reserved. Use of this source code is governed by a\n+    BSD-style license that can be found in the LICENSE file.\n+*/\n+\n+#pragma once\n+\n+#include \"detail/common.h\"\n+#include \"operators.h\"\n+\n+#include <algorithm>\n+#include <sstream>\n+\n+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)\n+NAMESPACE_BEGIN(detail)\n+\n+/* SFINAE helper class used by 'is_comparable */\n+template <typename T> struct container_traits {\n+  template <typename T2>\n+  static std::true_type test_comparable(decltype(std::declval<const T2 &>() ==\n+                                                 std::declval<const T2 &>()) *);\n+  template <typename T2> static std::false_type test_comparable(...);\n+  template <typename T2>\n+  static std::true_type test_value(typename T2::value_type *);\n+  template <typename T2> static std::false_type test_value(...);\n+  template <typename T2>\n+  static std::true_type test_pair(typename T2::first_type *,\n+                                  typename T2::second_type *);\n+  template <typename T2> static std::false_type test_pair(...);\n+\n+  static constexpr const bool is_comparable =\n+      std::is_same<std::true_type,\n+                   decltype(test_comparable<T>(nullptr))>::value;\n+  static constexpr const bool is_pair =\n+      std::is_same<std::true_type,\n+                   decltype(test_pair<T>(nullptr, nullptr))>::value;\n+  static constexpr const bool is_vector =\n+      std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;\n+  static constexpr const bool is_element = !is_pair && !is_vector;\n+};\n+\n+/* Default: is_comparable -> std::false_type */\n+template <typename T, typename SFINAE = void>\n+struct is_comparable : std::false_type {};\n+\n+/* For non-map data structures, check whether operator== can be instantiated */\n+template <typename T>\n+struct is_comparable<T, enable_if_t<container_traits<T>::is_element &&\n+                                    container_traits<T>::is_comparable>>\n+    : std::true_type {};\n+\n+/* For a vector/map data structure, recursively check the value type (which is\n+ * std::pair for maps) */\n+template <typename T>\n+struct is_comparable<T, enable_if_t<container_traits<T>::is_vector>> {\n+  static constexpr const bool value =\n+      is_comparable<typename T::value_type>::value;\n+};\n+\n+/* For pairs, recursively check the two data types */\n+template <typename T>\n+struct is_comparable<T, enable_if_t<container_traits<T>::is_pair>> {\n+  static constexpr const bool value =\n+      is_comparable<typename T::first_type>::value &&\n+      is_comparable<typename T::second_type>::value;\n+};\n+\n+/* Fallback functions */\n+template <typename, typename, typename... Args>\n+void vector_if_copy_constructible(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_if_equal_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_if_insertion_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void vector_modifiers(const Args &...) {}\n+\n+template <typename Vector, typename Class_>\n+void vector_if_copy_constructible(\n+    enable_if_t<is_copy_constructible<Vector>::value, Class_> &cl) {\n+  cl.def(init<const Vector &>(), \"Copy constructor\");\n+}\n+\n+template <typename Vector, typename Class_>\n+void vector_if_equal_operator(\n+    enable_if_t<is_comparable<Vector>::value, Class_> &cl) {\n+  using T = typename Vector::value_type;\n+\n+  cl.def(self == self);\n+  cl.def(self != self);\n+\n+  cl.def(\n+      \"count\",\n+      [](const Vector &v, const T &x) {\n+        return std::count(v.begin(), v.end(), x);\n+      },\n+      arg(\"x\"), \"Return the number of times ``x`` appears in the list\");\n+\n+  cl.def(\n+      \"remove\",\n+      [](Vector &v, const T &x) {\n+        auto p = std::find(v.begin(), v.end(), x);\n+        if (p != v.end())\n+          v.erase(p);\n+        else\n+          throw value_error();\n+      },\n+      arg(\"x\"),\n+      \"Remove the first item from the list whose value is x. \"\n+      \"It is an error if there is no such item.\");\n+\n+  cl.def(\n+      \"__contains__\",\n+      [](const Vector &v, const T &x) {\n+        return std::find(v.begin(), v.end(), x) != v.end();\n+      },\n+      arg(\"x\"), \"Return true the container contains ``x``\");\n+}\n+\n+// Vector modifiers -- requires a copyable vector_type:\n+// (Technically, some of these (pop and __delitem__) don't actually require\n+// copyability, but it seems silly to allow deletion but not insertion, so\n+// include them here too.)\n+template <typename Vector, typename Class_>\n+void vector_modifiers(\n+    enable_if_t<is_copy_constructible<typename Vector::value_type>::value,\n+                Class_> &cl) {\n+  using T = typename Vector::value_type;\n+  using SizeType = typename Vector::size_type;\n+  using DiffType = typename Vector::difference_type;\n+\n+  cl.def(\n+      \"append\", [](Vector &v, const T &value) { v.push_back(value); }, arg(\"x\"),\n+      \"Add an item to the end of the list\");\n+\n+  cl.def(init([](iterable it) {\n+    auto v = std::unique_ptr<Vector>(new Vector());\n+    v->reserve(len_hint(it));\n+    for (handle h : it)\n+      v->push_back(h.cast<T>());\n+    return v.release();\n+  }));\n+\n+  cl.def(\n+      \"extend\",\n+      [](Vector &v, const Vector &src) {\n+        v.insert(v.end(), src.begin(), src.end());\n+      },\n+      arg(\"L\"), \"Extend the list by appending all the items in the given list\");\n+\n+  cl.def(\n+      \"extend\",\n+      [](Vector &v, iterable it) {\n+        const size_t old_size = v.size();\n+        v.reserve(old_size + len_hint(it));\n+        try {\n+          for (handle h : it) {\n+            v.push_back(h.cast<T>());\n+          }\n+        } catch (const cast_error &) {\n+          v.erase(v.begin() +\n+                      static_cast<typename Vector::difference_type>(old_size),\n+                  v.end());\n+          try {\n+            v.shrink_to_fit();\n+          } catch (const std::exception &) {\n+            // Do nothing\n+          }\n+          throw;\n+        }\n+      },\n+      arg(\"L\"), \"Extend the list by appending all the items in the given list\");\n+\n+  cl.def(\n+      \"insert\",\n+      [](Vector &v, SizeType i, const T &x) {\n+        if (i > v.size())\n+          throw index_error();\n+        v.insert(v.begin() + (DiffType)i, x);\n+      },\n+      arg(\"i\"), arg(\"x\"), \"Insert an item at a given position.\");\n+\n+  cl.def(\n+      \"pop\",\n+      [](Vector &v) {\n+        if (v.empty())\n+          throw index_error();\n+        T t = v.back();\n+        v.pop_back();\n+        return t;\n+      },\n+      \"Remove and return the last item\");\n+\n+  cl.def(\n+      \"pop\",\n+      [](Vector &v, SizeType i) {\n+        if (i >= v.size())\n+          throw index_error();\n+        T t = v[i];\n+        v.erase(v.begin() + (DiffType)i);\n+        return t;\n+      },\n+      arg(\"i\"), \"Remove and return the item at index ``i``\");\n+\n+  cl.def(\"__setitem__\", [](Vector &v, SizeType i, const T &t) {\n+    if (i >= v.size())\n+      throw index_error();\n+    v[i] = t;\n+  });\n+\n+  /// Slicing protocol\n+  cl.def(\n+      \"__getitem__\",\n+      [](const Vector &v, slice slice) -> Vector * {\n+        size_t start, stop, step, slicelength;\n+\n+        if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))\n+          throw error_already_set();\n+\n+        Vector *seq = new Vector();\n+        seq->reserve((size_t)slicelength);\n+\n+        for (size_t i = 0; i < slicelength; ++i) {\n+          seq->push_back(v[start]);\n+          start += step;\n+        }\n+        return seq;\n+      },\n+      arg(\"s\"), \"Retrieve list elements using a slice object\");\n+\n+  cl.def(\n+      \"__setitem__\",\n+      [](Vector &v, slice slice, const Vector &value) {\n+        size_t start, stop, step, slicelength;\n+        if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))\n+          throw error_already_set();\n+\n+        if (slicelength != value.size())\n+          throw std::runtime_error(\"Left and right hand size of slice \"\n+                                   \"assignment have different sizes!\");\n+\n+        for (size_t i = 0; i < slicelength; ++i) {\n+          v[start] = value[i];\n+          start += step;\n+        }\n+      },\n+      \"Assign list elements using a slice object\");\n+\n+  cl.def(\n+      \"__delitem__\",\n+      [](Vector &v, SizeType i) {\n+        if (i >= v.size())\n+          throw index_error();\n+        v.erase(v.begin() + DiffType(i));\n+      },\n+      \"Delete the list elements at index ``i``\");\n+\n+  cl.def(\n+      \"__delitem__\",\n+      [](Vector &v, slice slice) {\n+        size_t start, stop, step, slicelength;\n+\n+        if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))\n+          throw error_already_set();\n+\n+        if (step == 1 && false) {\n+          v.erase(v.begin() + (DiffType)start,\n+                  v.begin() + DiffType(start + slicelength));\n+        } else {\n+          for (size_t i = 0; i < slicelength; ++i) {\n+            v.erase(v.begin() + DiffType(start));\n+            start += step - 1;\n+          }\n+        }\n+      },\n+      \"Delete list elements using a slice object\");\n+}\n+\n+// If the type has an operator[] that doesn't return a reference (most notably\n+// std::vector<bool>), we have to access by copying; otherwise we return by\n+// reference.\n+template <typename Vector>\n+using vector_needs_copy = negation<\n+    std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]),\n+                 typename Vector::value_type &>>;\n+\n+// The usual case: access and iterate by reference\n+template <typename Vector, typename Class_>\n+void vector_accessor(\n+    enable_if_t<!vector_needs_copy<Vector>::value, Class_> &cl) {\n+  using T = typename Vector::value_type;\n+  using SizeType = typename Vector::size_type;\n+  using ItType = typename Vector::iterator;\n+\n+  cl.def(\n+      \"__getitem__\",\n+      [](Vector &v, SizeType i) -> T & {\n+        if (i >= v.size())\n+          throw index_error();\n+        return v[i];\n+      },\n+      return_value_policy::reference_internal // ref + keepalive\n+  );\n+\n+  cl.def(\n+      \"__iter__\",\n+      [](Vector &v) {\n+        return make_iterator<return_value_policy::reference_internal, ItType,\n+                             ItType, T &>(v.begin(), v.end());\n+      },\n+      keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+  );\n+}\n+\n+// The case for special objects, like std::vector<bool>, that have to be\n+// returned-by-copy:\n+template <typename Vector, typename Class_>\n+void vector_accessor(\n+    enable_if_t<vector_needs_copy<Vector>::value, Class_> &cl) {\n+  using T = typename Vector::value_type;\n+  using SizeType = typename Vector::size_type;\n+  using ItType = typename Vector::iterator;\n+  cl.def(\"__getitem__\", [](const Vector &v, SizeType i) -> T {\n+    if (i >= v.size())\n+      throw index_error();\n+    return v[i];\n+  });\n+\n+  cl.def(\n+      \"__iter__\",\n+      [](Vector &v) {\n+        return make_iterator<return_value_policy::copy, ItType, ItType, T>(\n+            v.begin(), v.end());\n+      },\n+      keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+  );\n+}\n+\n+template <typename Vector, typename Class_>\n+auto vector_if_insertion_operator(Class_ &cl, std::string const &name)\n+    -> decltype(std::declval<std::ostream &>()\n+                    << std::declval<typename Vector::value_type>(),\n+                void()) {\n+  using size_type = typename Vector::size_type;\n+\n+  cl.def(\n+      \"__repr__\",\n+      [name](Vector &v) {\n+        std::ostringstream s;\n+        s << name << '[';\n+        for (size_type i = 0; i < v.size(); ++i) {\n+          s << v[i];\n+          if (i != v.size() - 1)\n+            s << \", \";\n+        }\n+        s << ']';\n+        return s.str();\n+      },\n+      \"Return the canonical string representation of this list.\");\n+}\n+\n+// Provide the buffer interface for vectors if we have data() and we have a\n+// format for it GCC seems to have \"void std::vector<bool>::data()\" - doing\n+// SFINAE on the existence of data() is insufficient, we need to check it\n+// returns an appropriate pointer\n+template <typename Vector, typename = void>\n+struct vector_has_data_and_format : std::false_type {};\n+template <typename Vector>\n+struct vector_has_data_and_format<\n+    Vector,\n+    enable_if_t<std::is_same<\n+        decltype(format_descriptor<typename Vector::value_type>::format(),\n+                 std::declval<Vector>().data()),\n+        typename Vector::value_type *>::value>> : std::true_type {};\n+\n+// Add the buffer interface to a vector\n+template <typename Vector, typename Class_, typename... Args>\n+enable_if_t<detail::any_of<std::is_same<Args, buffer_protocol>...>::value>\n+vector_buffer(Class_ &cl) {\n+  using T = typename Vector::value_type;\n+\n+  static_assert(\n+      vector_has_data_and_format<Vector>::value,\n+      \"There is not an appropriate format descriptor for this vector\");\n+\n+  // numpy.h declares this for arbitrary types, but it may raise an exception\n+  // and crash hard at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so\n+  // check here\n+  format_descriptor<T>::format();\n+\n+  cl.def_buffer([](Vector &v) -> buffer_info {\n+    return buffer_info(v.data(), static_cast<ssize_t>(sizeof(T)),\n+                       format_descriptor<T>::format(), 1, {v.size()},\n+                       {sizeof(T)});\n+  });\n+\n+  cl.def(init([](buffer buf) {\n+    auto info = buf.request();\n+    if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T)))\n+      throw type_error(\"Only valid 1D buffers can be copied to a vector\");\n+    if (!detail::compare_buffer_info<T>::compare(info) ||\n+        (ssize_t)sizeof(T) != info.itemsize)\n+      throw type_error(\"Format mismatch (Python: \" + info.format +\n+                       \" C++: \" + format_descriptor<T>::format() + \")\");\n+\n+    auto vec = std::unique_ptr<Vector>(new Vector());\n+    vec->reserve((size_t)info.shape[0]);\n+    T *p = static_cast<T *>(info.ptr);\n+    ssize_t step = info.strides[0] / static_cast<ssize_t>(sizeof(T));\n+    T *end = p + info.shape[0] * step;\n+    for (; p != end; p += step)\n+      vec->push_back(*p);\n+    return vec.release();\n+  }));\n+\n+  return;\n+}\n+\n+template <typename Vector, typename Class_, typename... Args>\n+enable_if_t<!detail::any_of<std::is_same<Args, buffer_protocol>...>::value>\n+vector_buffer(Class_ &) {}\n+\n+NAMESPACE_END(detail)\n+\n+//\n+// std::vector\n+//\n+template <typename Vector, typename holder_type = std::unique_ptr<Vector>,\n+          typename... Args>\n+class_<Vector, holder_type> bind_vector(handle scope, std::string const &name,\n+                                        Args &&...args) {\n+  using Class_ = class_<Vector, holder_type>;\n+\n+  // If the value_type is unregistered (e.g. a converting type) or is itself\n+  // registered module-local then make the vector binding module-local as well:\n+  using vtype = typename Vector::value_type;\n+  auto vtype_info = detail::get_type_info(typeid(vtype));\n+  bool local = !vtype_info || vtype_info->module_local;\n+\n+  Class_ cl(scope, name.c_str(), pybind11::module_local(local),\n+            std::forward<Args>(args)...);\n+\n+  // Declare the buffer interface if a buffer_protocol() is passed in\n+  detail::vector_buffer<Vector, Class_, Args...>(cl);\n+\n+  cl.def(init<>());\n+\n+  // Register copy constructor (if possible)\n+  detail::vector_if_copy_constructible<Vector, Class_>(cl);\n+\n+  // Register comparison-related operators and functions (if possible)\n+  detail::vector_if_equal_operator<Vector, Class_>(cl);\n+\n+  // Register stream insertion operator (if possible)\n+  detail::vector_if_insertion_operator<Vector, Class_>(cl, name);\n+\n+  // Modifiers require copyable vector value type\n+  detail::vector_modifiers<Vector, Class_>(cl);\n+\n+  // Accessor and iterator; return by value if copyable, otherwise we return by\n+  // ref + keep-alive\n+  detail::vector_accessor<Vector, Class_>(cl);\n+\n+  cl.def(\n+      \"__bool__\", [](const Vector &v) -> bool { return !v.empty(); },\n+      \"Check whether the list is nonempty\");\n+\n+  cl.def(\"__len__\", &Vector::size);\n+\n+#if 0\n+    // C++ style functions deprecated, leaving it here as an example\n+    cl.def(init<size_type>());\n+\n+    cl.def(\"resize\",\n+         (void (Vector::*) (size_type count)) & Vector::resize,\n+         \"changes the number of elements stored\");\n+\n+    cl.def(\"erase\",\n+        [](Vector &v, SizeType i) {\n+        if (i >= v.size())\n+            throw index_error();\n+        v.erase(v.begin() + i);\n+    }, \"erases element at index ``i``\");\n+\n+    cl.def(\"empty\",         &Vector::empty,         \"checks whether the container is empty\");\n+    cl.def(\"size\",          &Vector::size,          \"returns the number of elements\");\n+    cl.def(\"push_back\", (void (Vector::*)(const T&)) &Vector::push_back, \"adds an element to the end\");\n+    cl.def(\"pop_back\",                               &Vector::pop_back, \"removes the last element\");\n+\n+    cl.def(\"max_size\",      &Vector::max_size,      \"returns the maximum possible number of elements\");\n+    cl.def(\"reserve\",       &Vector::reserve,       \"reserves storage\");\n+    cl.def(\"capacity\",      &Vector::capacity,      \"returns the number of elements that can be held in currently allocated storage\");\n+    cl.def(\"shrink_to_fit\", &Vector::shrink_to_fit, \"reduces memory usage by freeing unused memory\");\n+\n+    cl.def(\"clear\", &Vector::clear, \"clears the contents\");\n+    cl.def(\"swap\",   &Vector::swap, \"swaps the contents\");\n+\n+    cl.def(\"front\", [](Vector &v) {\n+        if (v.size()) return v.front();\n+        else throw index_error();\n+    }, \"access the first element\");\n+\n+    cl.def(\"back\", [](Vector &v) {\n+        if (v.size()) return v.back();\n+        else throw index_error();\n+    }, \"access the last element \");\n+\n+#endif\n+\n+  return cl;\n+}\n+\n+//\n+// std::map, std::unordered_map\n+//\n+\n+NAMESPACE_BEGIN(detail)\n+\n+/* Fallback functions */\n+template <typename, typename, typename... Args>\n+void map_if_insertion_operator(const Args &...) {}\n+template <typename, typename, typename... Args>\n+void map_assignment(const Args &...) {}\n+\n+// Map assignment when copy-assignable: just copy the value\n+template <typename Map, typename Class_>\n+void map_assignment(\n+    enable_if_t<std::is_copy_assignable<typename Map::mapped_type>::value,\n+                Class_> &cl) {\n+  using KeyType = typename Map::key_type;\n+  using MappedType = typename Map::mapped_type;\n+\n+  cl.def(\"__setitem__\", [](Map &m, const KeyType &k, const MappedType &v) {\n+    auto it = m.find(k);\n+    if (it != m.end())\n+      it->second = v;\n+    else\n+      m.emplace(k, v);\n+  });\n+}\n+\n+// Not copy-assignable, but still copy-constructible: we can update the value by\n+// erasing and reinserting\n+template <typename Map, typename Class_>\n+void map_assignment(\n+    enable_if_t<!std::is_copy_assignable<typename Map::mapped_type>::value &&\n+                    is_copy_constructible<typename Map::mapped_type>::value,\n+                Class_> &cl) {\n+  using KeyType = typename Map::key_type;\n+  using MappedType = typename Map::mapped_type;\n+\n+  cl.def(\"__setitem__\", [](Map &m, const KeyType &k, const MappedType &v) {\n+    // We can't use m[k] = v; because value type might not be default\n+    // constructable\n+    auto r = m.emplace(k, v);\n+    if (!r.second) {\n+      // value type is not copy assignable so the only way to insert it is to\n+      // erase it first...\n+      m.erase(r.first);\n+      m.emplace(k, v);\n+    }\n+  });\n+}\n+\n+template <typename Map, typename Class_>\n+auto map_if_insertion_operator(Class_ &cl, std::string const &name)\n+    -> decltype(std::declval<std::ostream &>()\n+                    << std::declval<typename Map::key_type>()\n+                    << std::declval<typename Map::mapped_type>(),\n+                void()) {\n+\n+  cl.def(\n+      \"__repr__\",\n+      [name](Map &m) {\n+        std::ostringstream s;\n+        s << name << '{';\n+        bool f = false;\n+        for (auto const &kv : m) {\n+          if (f)\n+            s << \", \";\n+          s << kv.first << \": \" << kv.second;\n+          f = true;\n+        }\n+        s << '}';\n+        return s.str();\n+      },\n+      \"Return the canonical string representation of this map.\");\n+}\n+\n+NAMESPACE_END(detail)\n+\n+template <typename Map, typename holder_type = std::unique_ptr<Map>,\n+          typename... Args>\n+class_<Map, holder_type> bind_map(handle scope, const std::string &name,\n+                                  Args &&...args) {\n+  using KeyType = typename Map::key_type;\n+  using MappedType = typename Map::mapped_type;\n+  using Class_ = class_<Map, holder_type>;\n+\n+  // If either type is a non-module-local bound type then make the map binding\n+  // non-local as well; otherwise (e.g. both types are either module-local or\n+  // converting) the map will be module-local.\n+  auto tinfo = detail::get_type_info(typeid(MappedType));\n+  bool local = !tinfo || tinfo->module_local;\n+  if (local) {\n+    tinfo = detail::get_type_info(typeid(KeyType));\n+    local = !tinfo || tinfo->module_local;\n+  }\n+\n+  Class_ cl(scope, name.c_str(), pybind11::module_local(local),\n+            std::forward<Args>(args)...);\n+\n+  cl.def(init<>());\n+\n+  // Register stream insertion operator (if possible)\n+  detail::map_if_insertion_operator<Map, Class_>(cl, name);\n+\n+  cl.def(\n+      \"__bool__\", [](const Map &m) -> bool { return !m.empty(); },\n+      \"Check whether the map is nonempty\");\n+\n+  cl.def(\n+      \"__iter__\", [](Map &m) { return make_key_iterator(m.begin(), m.end()); },\n+      keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+  );\n+\n+  cl.def(\n+      \"items\", [](Map &m) { return make_iterator(m.begin(), m.end()); },\n+      keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */\n+  );\n+\n+  cl.def(\n+      \"__getitem__\",\n+      [](Map &m, const KeyType &k) -> MappedType & {\n+        auto it = m.find(k);\n+        if (it == m.end())\n+          throw key_error();\n+        return it->second;\n+      },\n+      return_value_policy::reference_internal // ref + keepalive\n+  );\n+\n+  cl.def(\"__contains__\", [](Map &m, const KeyType &k) -> bool {\n+    auto it = m.find(k);\n+    if (it == m.end())\n+      return false;\n+    return true;\n+  });\n+\n+  // Assignment provided only if the type is copyable\n+  detail::map_assignment<Map, Class_>(cl);\n+\n+  cl.def(\"__delitem__\", [](Map &m, const KeyType &k) {\n+    auto it = m.find(k);\n+    if (it == m.end())\n+      throw key_error();\n+    m.erase(it);\n+  });\n+\n+  cl.def(\"__len__\", &Map::size);\n+\n+  return cl;\n+}\n+\n+NAMESPACE_END(PYBIND11_NAMESPACE)"}, {"filename": "third-party/pybind11", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1 +0,0 @@\n-Subproject commit aa304c9c7d725ffb9d10af08a3b34cb372307020"}]