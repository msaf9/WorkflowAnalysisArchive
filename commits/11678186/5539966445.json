[{"filename": "python/triton/tools/compile.py", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "file_content_changes": "@@ -1,11 +1,12 @@\n import binascii\n+import hashlib\n import importlib.util\n import sys\n from argparse import ArgumentParser\n from pathlib import Path\n+from typing import List\n \n import triton\n-from triton.compiler.code_generator import kernel_suffix\n from triton.compiler.make_launcher import ty_to_cpp\n \n desc = \"\"\"\n@@ -39,12 +40,16 @@\n     # command-line arguments\n     parser = ArgumentParser(description=desc)\n     parser.add_argument(\"path\", help=\"Path to Python source containing desired kernel in its scope. File will be executed.\")\n-    parser.add_argument(\"--kernel-name\", \"-n\", type=str, default=\"\")\n-    parser.add_argument(\"--out-path\", \"-o\", type=Path, help=\"Out filename\")\n+    parser.add_argument(\"--kernel-name\", \"-n\", type=str, default=\"\", help=\"Name of the kernel to compile\", required=True)\n+    parser.add_argument(\"--num-warps\", \"-w\", type=int, help=\"Number of warps to launch the kernel\", default=1)\n     parser.add_argument(\"--out-name\", \"-on\", type=str, default=None, help=\"Out name for the compiled kernel\")\n-    parser.add_argument(\"--signature\", \"-s\", type=str, help=\"Signature of the kernel\")\n+    parser.add_argument(\"--out-path\", \"-o\", type=Path, default=None, help=\"Out filename\")\n+    parser.add_argument(\"--signature\", \"-s\", type=str, help=\"Signature of the kernel\", required=True)\n     args = parser.parse_args()\n \n+    out_name = args.out_name if args.out_name else args.kernel_name\n+    out_path = args.out_path if args.out_path else out_name\n+\n     # execute python sources and extract functions wrapped in JITFunction\n     arg_path = Path(args.path)\n     sys.path.insert(0, str(arg_path.parent))\n@@ -68,6 +73,12 @@ def constexpr(s):\n         except ValueError:\n             pass\n         return None\n+\n+    def hash_signature(signature: List[str]):\n+        m = hashlib.sha256()\n+        m.update(\"\".join(signature).encode())\n+        return m.hexdigest()[:8]\n+\n     hints = {i: constexpr(s.split(\":\")[1]) for i, s in enumerate(signature) if \":\" in s}\n     hints = {k: v for k, v in hints.items() if v is not None}\n     constexprs = {i: constexpr(s) for i, s in enumerate(signature)}\n@@ -80,12 +91,12 @@ def constexpr(s):\n     divisible_by_16 = [i for i, h in hints.items() if h == 16]\n     equal_to_1 = [i for i, h in hints.items() if h == 1]\n     config = triton.compiler.instance_descriptor(divisible_by_16=divisible_by_16, equal_to_1=equal_to_1)\n-    ccinfo = triton.compile(kernel, signature=signature, constants=constexprs, configs=[config], num_warps=1)\n+    ccinfo = triton.compile(kernel, signature=signature, constants=constexprs, configs=[config], num_warps=args.num_warps)\n     arg_names = [kernel.arg_names[i] for i in signature.keys()]\n \n     # dump C stub code\n-    suffix = kernel_suffix(signature.values(), config)\n-    func_name = '_'.join([kernel.__name__, suffix])\n+    suffix = hash_signature(signature.values())\n+    func_name = '_'.join([out_name, suffix])\n     hex_ = str(binascii.hexlify(ccinfo.asm[\"cubin\"]))[2:-1]\n     params = {\n         \"kernel_name\": func_name,\n@@ -99,5 +110,5 @@ def constexpr(s):\n     }\n     for ext in ['h', 'c']:\n         template_path = Path(__file__).parent / f\"compile.{ext}\"\n-        with args.out_path.with_suffix(f\".{suffix}.{ext}\").open(\"w\") as fp:\n+        with out_path.with_suffix(f\".{suffix}.{ext}\").open(\"w\") as fp:\n             fp.write(Path(template_path).read_text().format(**params))"}]