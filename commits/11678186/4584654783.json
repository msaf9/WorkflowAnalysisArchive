[{"filename": "python/triton/__init__.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -9,7 +9,6 @@\n import torch  # noqa: F401\n \n # submodules\n-from . import impl\n from .runtime import (\n     autotune,\n     Config,"}, {"filename": "python/triton/common/__init__.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "file_content_changes": "@@ -1 +1,3 @@\n-from .build import _build\n\\ No newline at end of file\n+from .build import _build\n+\n+__all__ = [\"_build\"]"}, {"filename": "python/triton/common/build.py", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "file_content_changes": "@@ -1,18 +1,21 @@\n import contextlib\n import functools\n import io\n+import os\n import shutil\n import subprocess\n import sys\n import sysconfig\n+\n import setuptools\n-import os\n+\n \n # TODO: is_hip shouldn't be here\n def is_hip():\n     import torch\n     return torch.version.hip is not None\n \n+\n @functools.lru_cache()\n def libcuda_dirs():\n     locs = subprocess.check_output([\"whereis\", \"libcuda.so\"]).decode().strip().split()[1:]\n@@ -23,6 +26,7 @@ def libcuda_dirs():\n def rocm_path_dir():\n     return os.getenv(\"ROCM_PATH\", default=\"/opt/rocm\")\n \n+\n @contextlib.contextmanager\n def quiet():\n     old_stdout, old_stderr = sys.stdout, sys.stderr\n@@ -31,7 +35,8 @@ def quiet():\n         yield\n     finally:\n         sys.stdout, sys.stderr = old_stdout, old_stderr\n-    \n+\n+\n def _build(name, src, srcdir):\n     if is_hip():\n         hip_lib_dir = os.path.join(rocm_path_dir(), \"lib\")\n@@ -108,4 +113,4 @@ def _build(name, src, srcdir):\n     )\n     with quiet():\n         setuptools.setup(**args)\n-    return so\n\\ No newline at end of file\n+    return so"}, {"filename": "python/triton/compiler/code_generator.py", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "file_content_changes": "@@ -4,19 +4,19 @@\n import warnings\n from typing import Any, Callable, Dict, Optional, Tuple, Type, Union\n \n-import triton\n-import triton._C.libtriton.triton as _triton\n-from .. import impl\n-from .. import language as tl\n-from . import errors\n-from .errors import UnsupportedLanguageConstruct\n+from .. import language\n+# ideally we wouldn't need this\n+from ..runtime import JITFunction\n+from .errors import (CompilationError, CompileTimeAssertionFailure,\n+                     UnsupportedLanguageConstruct)\n+from triton._C.libtriton.triton import ir\n \n \n def mangle_ty(ty):\n     if ty.is_ptr():\n         return 'P' + mangle_ty(ty.element_ty)\n     if ty.is_int():\n-        SIGNED = triton.language.dtype.SIGNEDNESS.SIGNED\n+        SIGNED = language.dtype.SIGNEDNESS.SIGNED\n         prefix = 'i' if ty.int_signedness == SIGNED else 'u'\n         return prefix + str(ty.int_bitwidth)\n     if ty.is_fp8():\n@@ -49,15 +49,15 @@ def mangle_fn(name, arg_tys, constants):\n \n \n def _is_triton_tensor(o: Any) -> bool:\n-    return isinstance(o, triton.language.tensor)\n+    return isinstance(o, language.tensor)\n \n \n def _is_constexpr(o: Any) -> bool:\n-    return isinstance(o, triton.language.constexpr)  # TODO: fetch triton.language.constexpr to a global after circular imports untangled, saving getattr\n+    return isinstance(o, language.constexpr)  # TODO: fetch language.constexpr to a global after circular imports untangled, saving getattr\n \n \n def _unwrap_if_constexpr(o: Any):\n-    return o.value if isinstance(o, triton.language.constexpr) else o\n+    return o.value if isinstance(o, language.constexpr) else o\n \n \n _condition_types = {bool, int, type(None)}  # Python types accepted for conditionals inside kernels\n@@ -85,7 +85,7 @@ def __exit__(self, *args, **kwargs):\n class CodeGenerator(ast.NodeVisitor):\n     def __init__(self, context, prototype, gscope, attributes, constants, function_name,\n                  module=None, is_kernel=False, function_types: Optional[Dict] = None, debug=False):\n-        self.builder = _triton.ir.builder(context)\n+        self.builder = ir.builder(context)\n         self.module = self.builder.create_module() if module is None else module\n         self.function_ret_types = {} if function_types is None else function_types\n         self.prototype = prototype\n@@ -99,23 +99,23 @@ def __init__(self, context, prototype, gscope, attributes, constants, function_n\n         self.debug = debug\n         self.scf_stack = []\n         # SSA-construction\n-        # name => triton.language.tensor\n-        self.local_defs: Dict[str, triton.language.tensor] = {}\n-        self.global_uses: Dict[str, triton.language.tensor] = {}\n+        # name => language.tensor\n+        self.local_defs: Dict[str, language.tensor] = {}\n+        self.global_uses: Dict[str, language.tensor] = {}\n         self.dereference_name: Callable[[str], Any] = self._define_name_lookup()\n \n     builtin_namespace: Dict[str, Any] = {_.__name__: _ for _ in (range, float, int, isinstance, getattr)}\n \n     def _define_name_lookup(self):\n-        # TODO: this needs to be moved to class scope when cyclic imports untangled and `triton.language` can be imported at module level\n+        # TODO: this needs to be moved to class scope when cyclic imports untangled and `language` can be imported at module level\n         self.builtin_namespace.update((\n-            ('print', triton.language.core.device_print),\n-            ('min', triton.language.minimum),  # TODO: why `min`? if `min`, why not `max`? `sum`? `all`?\n+            ('print', language.core.device_print),\n+            ('min', language.minimum),  # TODO: why `min`? if `min`, why not `max`? `sum`? `all`?\n         ))\n-        # TODO: this needs to be moved to class scope when cyclic imports untangled and `triton.language` can be imported at module level\n+        # TODO: this needs to be moved to class scope when cyclic imports untangled and `language` can be imported at module level\n         self.statically_implemented_functions.update((\n-            (triton.language.core.static_assert, CodeGenerator.execute_static_assert),\n-            (triton.language.core.static_print, CodeGenerator.execute_static_print),\n+            (language.core.static_assert, CodeGenerator.execute_static_assert),\n+            (language.core.static_print, CodeGenerator.execute_static_print),\n         ))\n \n         def local_lookup(name: str, absent):\n@@ -138,7 +138,7 @@ def name_lookup(name: str) -> Any:\n         return name_lookup\n \n     def set_value(self, name: str,\n-                  value: Union[triton.language.tensor, triton.language.constexpr]) -> None:\n+                  value: Union[language.tensor, language.constexpr]) -> None:\n         ''' This function:\n           called by visit_Assign() & visit_FuncDef() to store left value (lvalue)\n         1. record local defined name (FIXME: should consider control flow)\n@@ -171,7 +171,7 @@ def contains_return_op(self, node):\n             return any(pred(s) for s in node.body)\n         elif isinstance(node, ast.Call):\n             fn = self.visit(node.func)\n-            if isinstance(fn, triton.JITFunction):\n+            if isinstance(fn, JITFunction):\n                 old_gscope = self.gscope\n                 self.gscope = sys.modules[fn.fn.__module__].__dict__\n                 ret = self.contains_return_op(fn.parse())\n@@ -207,12 +207,12 @@ def visit_Return(self, node):\n             self.builder.ret([])\n             ret_ty = None\n         elif isinstance(ret_value, tuple):\n-            ret_values = [triton.language.core._to_tensor(v, self.builder) for v in ret_value]\n+            ret_values = [language.core._to_tensor(v, self.builder) for v in ret_value]\n             ret_types = [v.type for v in ret_values]\n             self.builder.ret([v.handle for v in ret_values])\n             ret_ty = tuple(ret_types)\n         else:\n-            ret = triton.language.core._to_tensor(ret_value, self.builder)\n+            ret = language.core._to_tensor(ret_value, self.builder)\n             self.builder.ret([ret.handle])\n             ret_ty = ret.type\n         # self.builder.create_branch(post_ret_block)\n@@ -243,13 +243,13 @@ def visit_FunctionDef(self, node):\n             if i in self.constants:\n                 cst = self.constants[i]\n                 if not _is_constexpr(cst):\n-                    cst = triton.language.constexpr(self.constants[i])\n+                    cst = language.constexpr(self.constants[i])\n                 arg_values.append(cst)\n                 continue\n             else:\n                 if i in self.attributes:\n                     fn.set_arg_attr(idx, \"tt.divisibility\", self.attributes[i][1])\n-                arg_values.append(triton.language.tensor(fn.args(idx), self.prototype.param_types[idx]))\n+                arg_values.append(language.tensor(fn.args(idx), self.prototype.param_types[idx]))\n                 idx += 1\n \n         insert_pt = self.builder.get_insertion_block()\n@@ -289,12 +289,12 @@ def visit_AnnAssign(self, node):\n         target = self.visit(node.target)\n         value = self.visit(node.value)\n         # constexpr\n-        if annotation == triton.language.constexpr:\n+        if annotation == language.constexpr:\n             if target in self.lscope:\n                 raise ValueError(f'{target} is already defined.'\n                                  f' constexpr cannot be reassigned.')\n             if not _is_constexpr(value):\n-                value = triton.language.constexpr(value)\n+                value = language.constexpr(value)\n             self.lscope[target] = value\n             return self.lscope[target]\n         # default: call visit_Assign\n@@ -312,13 +312,13 @@ def visit_Assign(self, node):\n             names = [names]\n         if not isinstance(values, tuple):\n             values = [values]\n-        native_nontensor_types = (triton.language.dtype, )\n+        native_nontensor_types = (language.dtype, )\n         for name, value in zip(names, values):\n             # by default, constexpr are assigned into python variable\n             value = _unwrap_if_constexpr(value)\n             if not _is_triton_tensor(value) and \\\n                not isinstance(value, native_nontensor_types):\n-                value = triton.language.core._to_tensor(value, self.builder)\n+                value = language.core._to_tensor(value, self.builder)\n             self.set_value(name, value)\n \n     def visit_AugAssign(self, node):\n@@ -447,7 +447,7 @@ def visit_if_top_level(self, cond, node):\n         self.builder.set_insertion_point_to_start(endif_block)\n         # update value\n         for i, name in enumerate(names):\n-            new_tensor = triton.language.core.tensor(endif_block.arg(i), ret_types[i])\n+            new_tensor = language.core.tensor(endif_block.arg(i), ret_types[i])\n             self.set_value(name, new_tensor)\n \n     # TODO: refactor\n@@ -475,13 +475,13 @@ def visit_if_scf(self, cond, node):\n                 self.builder.create_yield_op([else_defs[n].handle for n in names])\n         # update values\n         for i, name in enumerate(names):\n-            new_tensor = triton.language.core.tensor(if_op.get_result(i), ret_types[i])\n+            new_tensor = language.core.tensor(if_op.get_result(i), ret_types[i])\n             self.set_value(name, new_tensor)\n \n     def visit_If(self, node):\n         cond = self.visit(node.test)\n         if _is_triton_tensor(cond):\n-            cond = cond.to(triton.language.int1, _builder=self.builder)\n+            cond = cond.to(language.int1, _builder=self.builder)\n             if self.scf_stack or not self.contains_return_op(node):\n                 self.visit_if_scf(cond, node)\n             else:\n@@ -515,9 +515,9 @@ def visit_Compare(self, node):\n         lhs = _unwrap_if_constexpr(self.visit(node.left))\n         rhs = _unwrap_if_constexpr(self.visit(node.comparators[0]))\n         if type(node.ops[0]) == ast.Is:\n-            return triton.language.constexpr(lhs is rhs)\n+            return language.constexpr(lhs is rhs)\n         if type(node.ops[0]) == ast.IsNot:\n-            return triton.language.constexpr(lhs is not rhs)\n+            return language.constexpr(lhs is not rhs)\n         method_name = self._method_name_for_comp_op.get(type(node.ops[0]))\n         if method_name is None:\n             raise UnsupportedLanguageConstruct(None, node, \"AST comparison operator '{}' is not (currently) implemented.\".format(node.ops[0].__name__))\n@@ -572,7 +572,7 @@ def visit_While(self, node):\n                                                                  [ty.to_ir(self.builder) for ty in ret_types])\n             self.builder.set_insertion_point_to_start(before_block)\n             for i, name in enumerate(names):\n-                self.lscope[name] = triton.language.core.tensor(before_block.arg(i), ret_types[i])\n+                self.lscope[name] = language.core.tensor(before_block.arg(i), ret_types[i])\n                 self.local_defs[name] = self.lscope[name]\n             cond = self.visit(node.test)\n             self.builder.set_insertion_point_to_end(before_block)\n@@ -585,7 +585,7 @@ def visit_While(self, node):\n             # generate loop body\n             self.builder.set_insertion_point_to_start(after_block)\n             for i, name in enumerate(names):\n-                self.lscope[name] = triton.language.core.tensor(after_block.arg(i), ret_types[i])\n+                self.lscope[name] = language.core.tensor(after_block.arg(i), ret_types[i])\n                 self.local_defs[name] = self.lscope[name]\n             self.scf_stack.append(node)\n             self.visit_compound_statement(node.body)\n@@ -603,7 +603,7 @@ def visit_While(self, node):\n \n         # WhileOp defines new values, update the symbol table (lscope, local_defs)\n         for i, name in enumerate(names):\n-            new_def = triton.language.core.tensor(while_op.get_result(i), ret_types[i])\n+            new_def = language.core.tensor(while_op.get_result(i), ret_types[i])\n             self.lscope[name] = new_def\n             self.local_defs[name] = new_def\n \n@@ -625,13 +625,13 @@ def visit_ExtSlice(self, node):\n     def visit_For(self, node):\n         IteratorClass = self.visit(node.iter.func)\n         iter_args = [self.visit(arg) for arg in node.iter.args]\n-        if IteratorClass == triton.language.static_range:\n+        if IteratorClass == language.static_range:\n             iterator = IteratorClass(*iter_args)\n             static_range = range(iterator.start.value,\n                                  iterator.end.value,\n                                  iterator.step.value)\n             for i in static_range:\n-                self.lscope[node.target.id] = triton.language.constexpr(i)\n+                self.lscope[node.target.id] = language.constexpr(i)\n                 self.visit_compound_statement(node.body)\n                 for stmt in node.orelse:\n                     ast.NodeVisitor.generic_visit(self, stmt)\n@@ -649,17 +649,17 @@ def visit_For(self, node):\n         # handle negative constant step (not supported by scf.for in MLIR)\n         negative_step = False\n         if _is_constexpr(step) and step.value < 0:\n-            step = triton.language.constexpr(-step.value)\n+            step = language.constexpr(-step.value)\n             negative_step = True\n             lb, ub = ub, lb\n-        lb = triton.language.core._to_tensor(lb, self.builder)\n-        ub = triton.language.core._to_tensor(ub, self.builder)\n-        step = triton.language.core._to_tensor(step, self.builder)\n+        lb = language.core._to_tensor(lb, self.builder)\n+        ub = language.core._to_tensor(ub, self.builder)\n+        step = language.core._to_tensor(step, self.builder)\n         # induction variable type\n-        iv_type = triton.language.semantic.integer_promote_impl(lb.dtype, ub.dtype)\n-        iv_type = triton.language.semantic.integer_promote_impl(iv_type, step.dtype)\n+        iv_type = language.semantic.integer_promote_impl(lb.dtype, ub.dtype)\n+        iv_type = language.semantic.integer_promote_impl(iv_type, step.dtype)\n         iv_ir_type = iv_type.to_ir(self.builder)\n-        iv_is_signed = iv_type.int_signedness == triton.language.core.dtype.SIGNEDNESS.SIGNED\n+        iv_is_signed = iv_type.int_signedness == language.core.dtype.SIGNEDNESS.SIGNED\n         # lb/ub/step might be constexpr, we need to cast them to tensor\n         lb = lb.handle\n         ub = ub.handle\n@@ -670,7 +670,7 @@ def visit_For(self, node):\n         step = self.builder.create_int_cast(step, iv_ir_type, iv_is_signed)\n         # Create placeholder for the loop induction variable\n         iv = self.builder.create_undef(iv_ir_type)\n-        self.set_value(node.target.id, triton.language.core.tensor(iv, iv_type))\n+        self.set_value(node.target.id, language.core.tensor(iv, iv_type))\n \n         with enter_sub_region(self) as sr:\n             liveins, insert_block = sr\n@@ -700,8 +700,8 @@ def visit_For(self, node):\n                         f'Please make sure that the type stays consistent.'\n \n                     names.append(name)\n-                    init_args.append(triton.language.core._to_tensor(liveins[name], self.builder))\n-                    yields.append(triton.language.core._to_tensor(self.local_defs[name], self.builder))\n+                    init_args.append(language.core._to_tensor(liveins[name], self.builder))\n+                    yields.append(language.core._to_tensor(self.local_defs[name], self.builder))\n \n             # create ForOp\n             self.builder.restore_insertion_point(ip)\n@@ -710,13 +710,13 @@ def visit_For(self, node):\n             self.scf_stack.append(node)\n             self.builder.set_insertion_point_to_start(for_op.get_body(0))\n             for i, name in enumerate(names):\n-                self.set_value(name, triton.language.core.tensor(for_op.get_body(0).arg(i + 1), yields[i].type))\n+                self.set_value(name, language.core.tensor(for_op.get_body(0).arg(i + 1), yields[i].type))\n             self.visit_compound_statement(node.body)\n             self.scf_stack.pop()\n             yields = []\n             for name in self.local_defs:\n                 if name in liveins:\n-                    yields.append(triton.language.core._to_tensor(self.local_defs[name], self.builder))\n+                    yields.append(language.core._to_tensor(self.local_defs[name], self.builder))\n \n             # create YieldOp\n             if len(yields) > 0:\n@@ -731,11 +731,11 @@ def visit_For(self, node):\n                 iv = self.builder.create_sub(ub, iv)\n                 iv = self.builder.create_add(iv, lb)\n             self.lscope[node.target.id].handle.replace_all_uses_with(iv)\n-            self.set_value(node.target.id, triton.language.core.tensor(iv, iv_type))\n+            self.set_value(node.target.id, language.core.tensor(iv, iv_type))\n \n         # update lscope & local_defs (ForOp defines new values)\n         for i, name in enumerate(names):\n-            self.set_value(name, triton.language.core.tensor(for_op.get_result(i), yields[i].type))\n+            self.set_value(name, language.core.tensor(for_op.get_result(i), yields[i].type))\n \n         for stmt in node.orelse:\n             assert False, \"Don't know what to do with else after for\"\n@@ -759,7 +759,7 @@ def visit_Assert(self, node) -> Any:\n         test = self.visit(node.test)\n         msg = self.visit(node.msg)\n         # Convert assert to triton's device_assert which happens on the device\n-        return triton.language.core.device_assert(test, msg, _builder=self.builder)\n+        return language.core.device_assert(test, msg, _builder=self.builder)\n \n     def visit_Call(self, node):\n         fn = _unwrap_if_constexpr(self.visit(node.func))\n@@ -770,15 +770,15 @@ def visit_Call(self, node):\n \n         kws = dict(self.visit(keyword) for keyword in node.keywords)\n         args = [self.visit(arg) for arg in node.args]\n-        if fn is triton.language.core.device_assert:   # TODO: this should not be so hardcoded\n+        if fn is language.core.device_assert:   # TODO: this should not be so hardcoded\n             if not self.debug:\n                 return\n-        if isinstance(fn, triton.runtime.JITFunction):\n+        if isinstance(fn, JITFunction):\n             from inspect import getcallargs\n             args = getcallargs(fn.fn, *args, **kws)\n             args = [args[name] for name in fn.arg_names]\n             args = [arg if _is_triton_tensor(arg)\n-                    else triton.language.constexpr(arg) for arg in args]\n+                    else language.constexpr(arg) for arg in args]\n             # generate function def\n             attributes = dict()\n             constexprs = [i for i, arg in enumerate(args) if _is_constexpr(arg)]\n@@ -790,7 +790,7 @@ def visit_Call(self, node):\n             fn_name = mangle_fn(fn.__name__, arg_types, constants)\n             # generate function def if necessary\n             if not self.module.has_function(fn_name):\n-                prototype = triton.language.function_type([], arg_types)\n+                prototype = language.function_type([], arg_types)\n                 gscope = sys.modules[fn.fn.__module__].__dict__\n                 generator = CodeGenerator(self.builder.context, prototype, gscope, attributes, constants, module=self.module, function_name=fn_name, function_types=self.function_ret_types, debug=self.debug)\n                 generator.visit(fn.parse())\n@@ -803,21 +803,21 @@ def visit_Call(self, node):\n             if call_op.get_num_results() == 0 or callee_ret_type is None:\n                 return None\n             elif call_op.get_num_results() == 1:\n-                return triton.language.tensor(call_op.get_result(0), callee_ret_type)\n+                return language.tensor(call_op.get_result(0), callee_ret_type)\n             else:\n                 # should return a tuple of tl.tensor\n                 results = []\n                 for i in range(call_op.get_num_results()):\n-                    results.append(triton.language.tensor(call_op.get_result(i), callee_ret_type[i]))\n+                    results.append(language.tensor(call_op.get_result(i), callee_ret_type[i]))\n                 return tuple(results)\n-        if (hasattr(fn, '__self__') and _is_triton_tensor(fn.__self__)) or impl.is_builtin(fn):\n+        if (hasattr(fn, '__self__') and _is_triton_tensor(fn.__self__)) or language.core.is_builtin(fn):\n             return fn(*args, _builder=self.builder, **kws)\n         if fn in self.builtin_namespace.values():\n             args = map(_unwrap_if_constexpr, args)\n         return fn(*args, **kws)\n \n     def visit_Constant(self, node):\n-        return triton.language.constexpr(node.value)\n+        return language.constexpr(node.value)\n \n     def visit_BoolOp(self, node: ast.BoolOp):\n         if len(node.values) != 2:\n@@ -832,19 +832,19 @@ def visit_BoolOp(self, node: ast.BoolOp):\n \n     if sys.version_info < (3, 8):\n         def visit_NameConstant(self, node):\n-            return triton.language.constexpr(node.value)\n+            return language.constexpr(node.value)\n \n         def visit_Num(self, node):\n-            return triton.language.constexpr(node.n)\n+            return language.constexpr(node.n)\n \n         def visit_Str(self, node):\n-            return triton.language.constexpr(ast.literal_eval(node))\n+            return language.constexpr(ast.literal_eval(node))\n \n     def visit_Attribute(self, node):\n         lhs = self.visit(node.value)\n         if _is_triton_tensor(lhs):\n             if node.attr == \"T\":\n-                return triton.language.semantic.trans(lhs, builder=self.builder)\n+                return language.semantic.trans(lhs, builder=self.builder)\n         return getattr(lhs, node.attr)\n \n     def visit_Expr(self, node):\n@@ -909,31 +909,31 @@ def execute_static_assert(self, node: ast.Call) -> None:\n                 except Exception as e:\n                     message = \"<failed to evaluate assertion message: \" + repr(e) + \">\"\n \n-            raise errors.CompileTimeAssertionFailure(None, node, _unwrap_if_constexpr(message))\n+            raise CompileTimeAssertionFailure(None, node, _unwrap_if_constexpr(message))\n         return None\n \n \n def str_to_ty(name):\n     if name[0] == \"*\":\n         ty = str_to_ty(name[1:])\n-        return triton.language.pointer_type(ty)\n+        return language.pointer_type(ty)\n     tys = {\n-        \"fp8e5\": triton.language.float8e5,\n-        \"fp8e4\": triton.language.float8e4,\n-        \"fp16\": triton.language.float16,\n-        \"bf16\": triton.language.bfloat16,\n-        \"fp32\": triton.language.float32,\n-        \"fp64\": triton.language.float64,\n-        \"i1\": triton.language.int1,\n-        \"i8\": triton.language.int8,\n-        \"i16\": triton.language.int16,\n-        \"i32\": triton.language.int32,\n-        \"i64\": triton.language.int64,\n-        \"u8\": triton.language.uint8,\n-        \"u16\": triton.language.uint16,\n-        \"u32\": triton.language.uint32,\n-        \"u64\": triton.language.uint64,\n-        \"B\": triton.language.int1,\n+        \"fp8e5\": language.float8e5,\n+        \"fp8e4\": language.float8e4,\n+        \"fp16\": language.float16,\n+        \"bf16\": language.bfloat16,\n+        \"fp32\": language.float32,\n+        \"fp64\": language.float64,\n+        \"i1\": language.int1,\n+        \"i8\": language.int8,\n+        \"i16\": language.int16,\n+        \"i32\": language.int32,\n+        \"i64\": language.int64,\n+        \"u8\": language.uint8,\n+        \"u16\": language.uint16,\n+        \"u32\": language.uint32,\n+        \"u64\": language.uint64,\n+        \"B\": language.int1,\n     }\n     return tys[name]\n \n@@ -955,7 +955,7 @@ def ast_to_ttir(fn, signature, specialization, constants, debug=False):\n     # canonicalize signature\n     if isinstance(signature, str):\n         signature = {k: v.strip() for k, v in enumerate(signature.split(\",\"))}\n-    context = _triton.ir.context()\n+    context = ir.context()\n     context.load_triton()\n     # create kernel prototype\n     cst_key = lambda i: fn.arg_names.index(i) if isinstance(i, str) else i\n@@ -970,21 +970,21 @@ def ast_to_ttir(fn, signature, specialization, constants, debug=False):\n     all_constants.update(new_constants)\n     arg_types = [str_to_ty(v) for k, v in signature.items() if k not in constants]\n \n-    prototype = triton.language.function_type([], arg_types)\n+    prototype = language.function_type([], arg_types)\n     generator = CodeGenerator(context, prototype, gscope=gscope, constants=all_constants,\n                               function_name=function_name, attributes=new_attrs,\n                               is_kernel=True, debug=debug)\n     try:\n         generator.visit(fn.parse())\n-    except errors.CompilationError as e:\n+    except CompilationError as e:\n         if e.src is None:\n             e.set_source_code(fn.src)\n         raise\n     except Exception as e:\n         node = generator.last_node\n         if node is None:\n             raise\n-        raise errors.CompilationError(fn.src, node, repr(e)) from e\n+        raise CompilationError(fn.src, node, repr(e)) from e\n     ret = generator.module\n     # module takes ownership of the context\n     ret.context = context"}, {"filename": "python/triton/impl/__init__.py", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "file_content_changes": "@@ -1,18 +0,0 @@\n-\"\"\"Triton internal implementation details.\n-\n-Client libraries should not import interfaces from the `triton.impl` module;\n-as the details are subject to change.\n-\n-APIs defined in the `triton.impl` module which are public will be re-exported\n-in other relevant `triton` module namespaces.\n-\"\"\"\n-\n-from .base import builtin, extern, is_builtin\n-from triton._C.libtriton.triton import ir\n-\n-__all__ = [\n-    \"builtin\",\n-    \"extern\",\n-    \"ir\",\n-    \"is_builtin\",\n-]"}, {"filename": "python/triton/impl/base.py", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "file_content_changes": "@@ -1,36 +0,0 @@\n-from __future__ import annotations\n-\n-from functools import wraps\n-from typing import TypeVar\n-\n-T = TypeVar(\"T\")\n-\n-TRITON_BUILTIN = \"__triton_builtin__\"\n-\n-\n-def builtin(fn: T) -> T:\n-    \"\"\"Mark a function as a builtin.\"\"\"\n-    assert callable(fn)\n-\n-    @wraps(fn)\n-    def wrapper(*args, **kwargs):\n-        if \"_builder\" not in kwargs or kwargs[\"_builder\"] is None:\n-            raise ValueError(\n-                \"Did you forget to add @triton.jit ? \"\n-                \"(`_builder` argument must be provided outside of JIT functions.)\"\n-            )\n-        return fn(*args, **kwargs)\n-\n-    setattr(wrapper, TRITON_BUILTIN, True)\n-\n-    return wrapper\n-\n-\n-def is_builtin(fn) -> bool:\n-    \"\"\"Is this a registered triton builtin function?\"\"\"\n-    return getattr(fn, TRITON_BUILTIN, False)\n-\n-\n-def extern(fn: T) -> T:\n-    \"\"\"A decorator for external functions.\"\"\"\n-    return builtin(fn)"}, {"filename": "python/triton/language/__init__.py", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "file_content_changes": "@@ -1,10 +1,6 @@\n \"\"\"isort:skip_file\"\"\"\n # Import order is significant here.\n \n-from ..impl import (\n-    ir,\n-    builtin,\n-)\n from . import math\n from .core import (\n     abs,"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "file_content_changes": "@@ -1,17 +1,46 @@\n from __future__ import annotations\n \n from enum import Enum\n+from functools import wraps\n from typing import Callable, List, TypeVar\n \n import triton\n-from . import builtin, semantic\n+from . import semantic\n from triton._C.libtriton.triton import ir\n \n T = TypeVar('T')\n \n TRITON_MAX_TENSOR_NUMEL = 131072\n \n \n+T = TypeVar(\"T\")\n+\n+TRITON_BUILTIN = \"__triton_builtin__\"\n+\n+\n+def builtin(fn: T) -> T:\n+    \"\"\"Mark a function as a builtin.\"\"\"\n+    assert callable(fn)\n+\n+    @wraps(fn)\n+    def wrapper(*args, **kwargs):\n+        if \"_builder\" not in kwargs or kwargs[\"_builder\"] is None:\n+            raise ValueError(\n+                \"Did you forget to add @triton.jit ? \"\n+                \"(`_builder` argument must be provided outside of JIT functions.)\"\n+            )\n+        return fn(*args, **kwargs)\n+\n+    setattr(wrapper, TRITON_BUILTIN, True)\n+\n+    return wrapper\n+\n+\n+def is_builtin(fn) -> bool:\n+    \"\"\"Is this a registered triton builtin function?\"\"\"\n+    return getattr(fn, TRITON_BUILTIN, False)\n+\n+\n def _to_tensor(x, builder):\n     if isinstance(x, bool):\n         return tensor(builder.get_int1(x), int1)"}, {"filename": "python/triton/language/extern.py", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "file_content_changes": "@@ -45,6 +45,11 @@ def dispatch(func, lib_name: str, lib_path: str, args: list, arg_type_symbol_dic\n         return core.tensor(func(lib_name, lib_path, symbol, arg_list, ret_type.to_ir(_builder)), ret_type)\n \n \n+def extern(fn):\n+    \"\"\"A decorator for external functions.\"\"\"\n+    return core.builtin(fn)\n+\n+\n def elementwise(lib_name: str, lib_path: str, args: list, arg_type_symbol_dict: dict, _builder=None):\n     '''\n         Dispatch an elementwise function to a library"}, {"filename": "python/triton/language/math.py", "status": "modified", "additions": 199, "deletions": 200, "changes": 399, "file_content_changes": "@@ -2,7 +2,6 @@\n \n import torch\n \n-from .. import impl\n from . import core, extern\n \n if torch.version.hip is not None:\n@@ -12,30 +11,30 @@\n LIBDEVICE_PATH = os.getenv(\"TRITON_LIBDEVICE_PATH\", LOCAL_PATH)\n \n \n-@impl.extern\n+@extern.extern\n def clz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_clz\", core.dtype(\"int32\")),\n                                (core.dtype(\"int64\"),): (\"__nv_clzll\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def popc(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_popc\", core.dtype(\"int32\")),\n                                (core.dtype(\"int64\"),): (\"__nv_popcll\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def byte_perm(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_byte_perm\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def min(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_min\", core.dtype(\"int32\")),\n@@ -47,7 +46,7 @@ def min(arg0, arg1, _builder=None):\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def max(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_max\", core.dtype(\"int32\")),\n@@ -59,7 +58,7 @@ def max(arg0, arg1, _builder=None):\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def mulhi(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_mulhi\", core.dtype(\"int32\")),\n@@ -69,31 +68,31 @@ def mulhi(arg0, arg1, _builder=None):\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def mul24(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_mul24\", core.dtype(\"int32\")),\n                                (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_umul24\", core.dtype(\"uint32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def brev(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_brev\", core.dtype(\"int32\")),\n                                (core.dtype(\"int64\"),): (\"__nv_brevll\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sad(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"), core.dtype(\"uint32\"),): (\"__nv_sad\", core.dtype(\"int32\")),\n                                (core.dtype(\"uint32\"), core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_usad\", core.dtype(\"uint32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def abs(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_abs\", core.dtype(\"int32\")),\n@@ -103,1370 +102,1370 @@ def abs(arg0, _builder=None):\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def floor(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_floorf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_floor\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rcp64h(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_rcp64h\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rsqrt(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_rsqrtf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_rsqrt\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ceil(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_ceil\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"),): (\"__nv_ceilf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def trunc(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_trunc\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"),): (\"__nv_truncf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def exp2(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_exp2f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_exp2\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def saturatef(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_saturatef\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fma_rn(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fma_rz(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fma_rd(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fma_ru(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_dividef(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fast_fdividef\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def div_rn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def div_rz(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def div_rd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def div_ru(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rcp_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frcp_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_drcp_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rcp_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frcp_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_drcp_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rcp_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frcp_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_drcp_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rcp_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frcp_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_drcp_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sqrt_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_dsqrt_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sqrt_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_dsqrt_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sqrt_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_dsqrt_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sqrt_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_dsqrt_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sqrt(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_sqrtf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_sqrt\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def add_rn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rn\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def add_rz(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rz\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def add_rd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rd\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def add_ru(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_ru\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def mul_rn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rn\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def mul_rz(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rz\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def mul_rd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rd\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def mul_ru(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_ru\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2int_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2int_rn\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2int_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2int_rz\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2int_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2int_rd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2int_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2int_ru\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2uint_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rn\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2uint_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rz\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2uint_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2uint_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2uint_ru\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def int2double_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2double_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def uint2double_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2double_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2int_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2int_rn\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2int_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2int_rz\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2int_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2int_rd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2int_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2int_ru\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2uint_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rn\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2uint_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rz\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2uint_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2uint_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2uint_ru\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def int2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def int2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def int2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def int2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def uint2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def uint2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def uint2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def uint2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def hiloint2double(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_hiloint2double\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2loint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2loint\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2hiint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2hiint\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2ll_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rn\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2ll_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rz\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2ll_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rd\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2ll_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ll_ru\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2ull_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rn\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2ull_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rz\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2ull_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rd\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float2ull_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ull_ru\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2ll_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rn\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2ll_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rz\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2ll_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rd\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2ll_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ll_ru\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2ull_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rn\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2ull_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rz\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2ull_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rd\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double2ull_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ull_ru\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ll2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ll2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ll2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ll2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ull2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ull2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ull2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ull2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ll2double_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2double_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ll2double_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2double_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ll2double_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2double_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ll2double_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2double_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ull2double_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2double_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ull2double_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2double_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ull2double_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2double_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ull2double_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2double_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def int_as_float(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int_as_float\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float_as_int(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float_as_int\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def uint_as_float(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint_as_float\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def float_as_uint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float_as_uint\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def longlong_as_double(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_longlong_as_double\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def double_as_longlong(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double_as_longlong\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_sinf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_sinf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_cosf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_cosf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_log2f(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_log2f\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_logf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_logf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_expf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_expf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_tanf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_tanf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_exp10f(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_exp10f\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_log10f(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_log10f\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fast_powf(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fast_powf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def hadd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_hadd\", core.dtype(\"int32\")),\n                                (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_uhadd\", core.dtype(\"uint32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rhadd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_rhadd\", core.dtype(\"int32\")),\n                                (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_urhadd\", core.dtype(\"uint32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sub_rn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sub_rz(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sub_rd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sub_ru(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rsqrt_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frsqrt_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ffs(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_ffs\", core.dtype(\"int32\")),\n                                (core.dtype(\"int64\"),): (\"__nv_ffsll\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_rintf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_rint\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def llrint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_llrintf\", core.dtype(\"int64\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_llrint\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def nearbyint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_nearbyintf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_nearbyint\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def isnan(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_isnanf\", core.dtype(\"int32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_isnand\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def signbit(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_signbitf\", core.dtype(\"int32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_signbitd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def copysign(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_copysignf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_copysign\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def finitef(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_finitef\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def isinf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_isinff\", core.dtype(\"int32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_isinfd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def nextafter(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_nextafterf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_nextafter\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sin(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_sinf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_sin\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def cos(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cosf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cos\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sinpi(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_sinpif\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_sinpi\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def cospi(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cospif\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cospi\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def tan(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_tanf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_tan\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def log2(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_log2f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_log2\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def exp(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_expf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_exp\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def exp10(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_exp10f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_exp10\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def cosh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_coshf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cosh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def sinh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_sinhf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_sinh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def tanh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_tanhf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_tanh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def atan2(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_atan2f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_atan2\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def atan(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_atanf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_atan\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def asin(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_asinf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_asin\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def acos(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_acosf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_acos\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def log(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_logf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_log\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def log10(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_log10f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_log10\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def log1p(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_log1pf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_log1p\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def acosh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_acoshf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_acosh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def asinh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_asinhf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_asinh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def atanh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_atanhf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_atanh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def expm1(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_expm1f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_expm1\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def hypot(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_hypotf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_hypot\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rhypot(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rhypotf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rhypot\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def norm3d(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_norm3df\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_norm3d\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rnorm3d(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rnorm3df\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rnorm3d\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def norm4d(arg0, arg1, arg2, arg3, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, arg3, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_norm4df\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_norm4d\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rnorm4d(arg0, arg1, arg2, arg3, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, arg3, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rnorm4df\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rnorm4d\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def cbrt(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cbrtf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cbrt\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def rcbrt(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_rcbrtf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_rcbrt\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def j0(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_j0f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_j0\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def j1(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_j1f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_j1\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def y0(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_y0f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_y0\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def y1(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_y1f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_y1\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def yn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"fp32\"),): (\"__nv_ynf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"int32\"), core.dtype(\"fp64\"),): (\"__nv_yn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def jn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"fp32\"),): (\"__nv_jnf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"int32\"), core.dtype(\"fp64\"),): (\"__nv_jn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def cyl_bessel_i0(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cyl_bessel_i0f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cyl_bessel_i0\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def cyl_bessel_i1(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cyl_bessel_i1f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cyl_bessel_i1\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def erf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erff\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erf\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def erfinv(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erfinvf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erfinv\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def erfc(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erfcf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erfc\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def erfcx(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erfcxf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erfcx\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def erfcinv(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erfcinvf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erfcinv\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def normcdfinv(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_normcdfinvf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_normcdfinv\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def normcdf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_normcdff\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_normcdf\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def lgamma(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_lgammaf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_lgamma\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ldexp(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_ldexpf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"int32\"),): (\"__nv_ldexp\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def scalbn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_scalbnf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"int32\"),): (\"__nv_scalbn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fmod(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmodf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fmod\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def remainder(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_remainderf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_remainder\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fma(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def pow(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_powif\", core.dtype(\"fp32\")),\n@@ -1476,55 +1475,55 @@ def pow(arg0, arg1, _builder=None):\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def tgamma(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_tgammaf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_tgamma\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def round(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_roundf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_round\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def llround(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_llroundf\", core.dtype(\"int64\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_llround\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def fdim(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdimf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fdim\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def ilogb(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_ilogbf\", core.dtype(\"int32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_ilogb\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def logb(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_logbf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_logb\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@impl.extern\n+@extern.extern\n def isfinited(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_isfinited\", core.dtype(\"int32\")),"}, {"filename": "python/triton/tools/build_extern.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -293,7 +293,7 @@ def _output_stubs(self) -> str:\n         header_str += \"LIBDEVICE_PATH = os.getenv(\\\"TRITON_LIBDEVICE_PATH\\\", LOCAL_PATH)\\n\"\n         func_str = \"\"\n         for symbols in self._symbol_groups.values():\n-            func_str += \"@extern.extern\\n\"\n+            func_str += \"@language.extern\\n\"\n             func_name_str = f\"def {symbols[0].op_name}(\"\n             for arg_name in symbols[0].arg_names:\n                 func_name_str += f\"{arg_name}, \""}]