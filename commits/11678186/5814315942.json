[{"filename": "lib/Conversion/NVGPUToLLVM/NVGPUToLLVMPass.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "file_content_changes": "@@ -401,14 +401,14 @@ class MBarrierArriveOpPattern : public mlir::RewritePattern {\n \n       ptxInstr(barOpr).predicate(pred, \"b\");\n     } else if (arriveType == mlir::triton::nvgpu::MBarriveType::cp_async) {\n-      assert(txCount > 0 && \"txCount should be valid\");\n       auto &ptxInstr = *ptxBuilder.create<PTXInstr>(\n           \"cp.async.mbarrier.arrive.noinc.shared.b64\");\n       auto *barOpr =\n           ptxBuilder.newAddrOperand(ptrtoint(i32_ty, mbarrier), \"r\", 0);\n \n       ptxInstr(barOpr).predicate(pred, \"b\");\n     } else if (arriveType == mlir::triton::nvgpu::MBarriveType::expect_tx) {\n+      assert(txCount > 0 && \"txCount should be valid\");\n       auto &ptxInstr = *ptxBuilder.create<PTXInstr>(\n           \"mbarrier.arrive.expect_tx.shared.b64 _,\");\n       auto *barOpr =\n@@ -417,6 +417,7 @@ class MBarrierArriveOpPattern : public mlir::RewritePattern {\n \n       ptxInstr(barOpr, expectedOpr).predicate(pred, \"b\");\n     } else if (arriveType == mlir::triton::nvgpu::MBarriveType::remote) {\n+      assert(ctaId && \"ctaId should have a valid value\");\n       auto ptxAsm =\n           \" { .reg .b32 remAddr32;                                       \\n\"\n           \"  @$2 mapa.shared::cluster.u32  remAddr32, $0, $1;            \\n\"\n@@ -1401,7 +1402,7 @@ class ConvertNVGPUToLLVM : public ConvertNVGPUToLLVMBase<ConvertNVGPUToLLVM> {\n     // patterns.add<CGABarrierWaitOpPattern>(context);\n     // patterns.add<CGABarrierArriveOpPattern>(context);\n     patterns.add<NamedBarrierWaitOpPattern>(context);\n-    // patterns.add<NamedBarrierArriveOpPattern>(context);\n+    patterns.add<NamedBarrierArriveOpPattern>(context);\n     // patterns.add<FenceMBarrierInitOpPattern>(context);\n \n     if (applyPatternsAndFoldGreedily(mod, std::move(patterns)).failed())"}]