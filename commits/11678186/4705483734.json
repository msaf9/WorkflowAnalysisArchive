[{"filename": "python/tutorials/08-experimental-block-pointer.py", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "file_content_changes": "@@ -32,14 +32,20 @@\n # --------------------\n # A block pointer pointers to a block in a parent tensor and is constructed by :code:`make_block_ptr` function,\n # which takes the following information as arguments:\n-# - :code:`base`: the base pointer to the parent tensor;\n-# - :code:`shape`: the shape of the parent tensor;\n-# - :code:`strides`: the strides of the parent tensor, which means how much to increase the pointer by when moving by 1 element in a specific axis;\n-# - :code:`offsets`: the offsets of the block;\n-# - :code:`block_shape`: the shape of the block;\n-# - :code:`order`: the order of the block, which means how the block is laid out in memory.\n-#\n-# For example, to a block pointer to a :code:`BLOCK_SIZE_M`x:code:`BLOCK_SIZE_K` block in a row-major 2D matrix A by\n+#\n+# * :code:`base`: the base pointer to the parent tensor;\n+#\n+# * :code:`shape`: the shape of the parent tensor;\n+#\n+# * :code:`strides`: the strides of the parent tensor, which means how much to increase the pointer by when moving by 1 element in a specific axis;\n+#\n+# * :code:`offsets`: the offsets of the block;\n+#\n+# * :code:`block_shape`: the shape of the block;\n+#\n+# * :code:`order`: the order of the block, which means how the block is laid out in memory.\n+#\n+# For example, to a block pointer to a :code:`BLOCK_SIZE_M * BLOCK_SIZE_K` block in a row-major 2D matrix A by\n # offsets :code:`(pid_m * BLOCK_SIZE_M, 0)` and strides :code:`(stride_am, stride_ak)`, we can use the following code\n # (exactly the same as the previous matrix multiplication tutorial):\n #\n@@ -58,15 +64,17 @@\n # --------------------------\n # To load/store a block pointer, we can use :code:`load/store` function, which takes a block pointer as an argument,\n # de-references it, and loads/stores a block. You may mask some values in the block, here we have an extra argument\n-# :code:`boundary_check` to specify whether to check the boundary of each axis for the block pointer. With check on and\n+# :code:`boundary_check` to specify whether to check the boundary of each axis for the block pointer. With check on,\n # out-of-bound values will be masked according to the :code:`padding_option` argument (load only), which can be\n # :code:`zero` or :code:`nan`. Temporarily, we do not support other values due to some hardware limitations. In this\n # mode of block pointer load/store does not support :code:`mask` or :code:`other` arguments in the legacy mode.\n #\n-# So to load a block in A, we can simply write :code:`a = tl.load(a_block_ptr, boundary_check=(0, 1))`. Boundary check\n-# may cost extra performance, so if you can guarantee that the block pointer is always in-bound in some axis, you can\n-# turn off the check by not passing the index into the :code:`boundary_check` argument. For example, if we know that\n-# :code:`M` is a multiple of :code:`BLOCK_SIZE_M`, we can write :code:`a = tl.load(a_block_ptr, boundary_check=(1, ))`.\n+# So to load the block pointer of A in the previous section, we can simply write\n+# :code:`a = tl.load(a_block_ptr, boundary_check=(0, 1))`. Boundary check may cost extra performance, so if you can\n+# guarantee that the block pointer is always in-bound in some axis, you can turn off the check by not passing the index\n+# into the :code:`boundary_check` argument. For example, if we know that :code:`M` is a multiple of\n+# :code:`BLOCK_SIZE_M`, we can replace with :code:`a = tl.load(a_block_ptr, boundary_check=(1, ))`, since axis 0 is\n+# always in bound.\n \n # %%\n # Advance a Block Pointer\n@@ -76,7 +84,7 @@\n # but with the offsets advanced by the specified amount.\n #\n # For example, to advance the block pointer by :code:`BLOCK_SIZE_K` in the second axis\n-# (no need to multiply with stride), we can write :code:`a_block_ptr = tl.advance(a_block_ptr, (0, BLOCK_SIZE_K))`.\n+# (no need to multiply with strides), we can write :code:`a_block_ptr = tl.advance(a_block_ptr, (0, BLOCK_SIZE_K))`.\n \n # %%\n # Final Result"}]