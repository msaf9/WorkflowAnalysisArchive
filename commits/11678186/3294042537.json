[{"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPU.cpp", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "file_content_changes": "@@ -1,7 +1,7 @@\n #include \"triton/Conversion/TritonToTritonGPU/TritonToTritonGPU.h\"\n #include \"../PassDetail.h\"\n-#include \"mlir/Dialect/StandardOps/IR/Ops.h\"\n #include \"mlir/Dialect/Arithmetic/IR/Arithmetic.h\"\n+#include \"mlir/Dialect/StandardOps/IR/Ops.h\"\n #include \"mlir/Transforms/DialectConversion.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n@@ -115,8 +115,7 @@ void populateArithmeticPatternsAndLegality(\n       ArithCmpPattern<arith::CmpFOp, triton::gpu::CmpFOp>,\n       // Cast Ops\n       GenericOpPattern<arith::TruncIOp>, GenericOpPattern<arith::TruncFOp>,\n-      GenericOpPattern<arith::SIToFPOp>>(\n-      typeConverter, context);\n+      GenericOpPattern<arith::SIToFPOp>>(typeConverter, context);\n }\n \n // this shouldn't exist if mlir's SelectOp checked encodings properly\n@@ -129,20 +128,21 @@ class StdSelectPattern : public OpConversionPattern<SelectOp> {\n                   ConversionPatternRewriter &rewriter) const override {\n     Type retType = this->getTypeConverter()->convertType(op.getType());\n     triton::gpu::SelectOp res =\n-        rewriter.replaceOpWithNewOp<triton::gpu::SelectOp>(op, retType, adaptor.getCondition(),\n-                                           adaptor.getTrueValue(), adaptor.getFalseValue());\n+        rewriter.replaceOpWithNewOp<triton::gpu::SelectOp>(\n+            op, retType, adaptor.getCondition(), adaptor.getTrueValue(),\n+            adaptor.getFalseValue());\n     return success();\n   }\n };\n \n-\n void populateStdPatternsAndLegality(TritonGPUTypeConverter &typeConverter,\n-                                     RewritePatternSet &patterns,\n-                                     TritonGPUConversionTarget &target) {\n+                                    RewritePatternSet &patterns,\n+                                    TritonGPUConversionTarget &target) {\n   MLIRContext *context = patterns.getContext();\n   // Rewrite rule\n   patterns.add<StdSelectPattern>(typeConverter, context);\n-  target.addLegalOp<ReturnOp>(); // this is ok because all functions are inlined by the frontend\n+  target.addLegalOp<ReturnOp>(); // this is ok because all functions are inlined\n+                                 // by the frontend\n }\n \n void populateMathPatternsAndLegality(TritonGPUTypeConverter &typeConverter,\n@@ -251,7 +251,8 @@ struct TritonDotPattern : public OpConversionPattern<triton::DotOp> {\n       b = rewriter.create<triton::gpu::ConvertLayoutOp>(b.getLoc(), dstType, b);\n     }\n     auto newDot = rewriter.replaceOpWithNewOp<triton::DotOp>(\n-        op, retType, a, b, adaptor.c(), adaptor.allowTF32(), adaptor.transA(), adaptor.transB());\n+        op, retType, a, b, adaptor.c(), adaptor.allowTF32(), adaptor.transA(),\n+        adaptor.transB());\n     return success();\n   }\n };"}]