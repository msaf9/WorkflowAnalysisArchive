[{"filename": "CMakeLists.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -173,6 +173,9 @@ include(AddLLVM)\n include(AddMLIR)\n include(HandleLLVMOptions) # human-friendly error message\n \n+# Disable warnings that show up in external code (gtest;pybind11)\n+set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-covered-switch-default\")\n+\n include_directories(${MLIR_INCLUDE_DIRS})\n include_directories(${LLVM_INCLUDE_DIRS})\n include_directories(${PROJECT_SOURCE_DIR}/include)"}, {"filename": "include/triton/Conversion/TritonGPUToLLVM/PtxAsmFormat.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -15,9 +15,9 @@ class Location;\n namespace triton {\n using llvm::StringRef;\n \n-class PTXInstr;\n-class PTXInstrCommon;\n-class PTXInstrExecution;\n+struct PTXInstr;\n+struct PTXInstrCommon;\n+struct PTXInstrExecution;\n \n // PTXBuilder helps to manage a PTX asm program consists of one or multiple\n // instructions.\n@@ -172,8 +172,8 @@ struct PTXBuilder {\n     return argArchive.back().get();\n   }\n \n-  friend class PTXInstr;\n-  friend class PTXInstrCommon;\n+  friend struct PTXInstr;\n+  friend struct PTXInstrCommon;\n \n protected:\n   llvm::SmallVector<std::unique_ptr<Operand>, 6> argArchive;\n@@ -209,7 +209,7 @@ struct PTXInstrCommon {\n   PTXBuilder *builder{};\n   llvm::SmallVector<std::string, 4> instrParts;\n \n-  friend class PTXInstrExecution;\n+  friend struct PTXInstrExecution;\n };\n \n template <class ConcreteT> struct PTXInstrBase : public PTXInstrCommon {"}, {"filename": "include/triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "file_content_changes": "@@ -11,16 +11,12 @@ class ModuleOp;\n template <typename T> class OperationPass;\n \n class TritonLLVMConversionTarget : public ConversionTarget {\n-  mlir::LLVMTypeConverter &typeConverter;\n-\n public:\n   explicit TritonLLVMConversionTarget(MLIRContext &ctx,\n                                       mlir::LLVMTypeConverter &typeConverter);\n };\n \n class TritonLLVMFunctionConversionTarget : public ConversionTarget {\n-  mlir::LLVMTypeConverter &typeConverter;\n-\n public:\n   explicit TritonLLVMFunctionConversionTarget(\n       MLIRContext &ctx, mlir::LLVMTypeConverter &typeConverter);"}, {"filename": "include/triton/Dialect/TritonGPU/Transforms/TritonGPUConversion.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -21,7 +21,6 @@ class TritonGPUTypeConverter : public TypeConverter {\n };\n \n class TritonGPUConversionTarget : public ConversionTarget {\n-  TritonGPUTypeConverter &typeConverter;\n \n public:\n   explicit TritonGPUConversionTarget(MLIRContext &ctx,"}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -31,7 +31,7 @@ std::string getValueOperandName(Value value, AsmState &state) {\n   std::string opName;\n   llvm::raw_string_ostream ss(opName);\n   value.printAsOperand(ss, state);\n-  return std::move(opName);\n+  return opName;\n }\n \n } // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "file_content_changes": "@@ -237,7 +237,6 @@ struct FuncOpConversionBase : public ConvertOpToLLVMPattern<FuncOp> {\n /// FuncOp legalization pattern that converts MemRef arguments to pointers to\n /// MemRef descriptors (LLVM struct data types) containing all the MemRef type\n /// information.\n-static constexpr StringRef kEmitIfaceAttrName = \"llvm.emit_c_interface\";\n struct FuncOpConversion : public FuncOpConversionBase {\n   FuncOpConversion(LLVMTypeConverter &converter, int numWarps,\n                    PatternBenefit benefit)\n@@ -1914,12 +1913,12 @@ class MMA16816SmemLoader {\n                      ArrayRef<int> matShape, int perPhase, int maxPhase,\n                      int elemBytes, ConversionPatternRewriter &rewriter,\n                      TypeConverter *typeConverter, const Location &loc)\n-      : wpt(wpt), order(order.begin(), order.end()), kOrder(kOrder),\n+      : order(order.begin(), order.end()), kOrder(kOrder),\n         tileShape(tileShape.begin(), tileShape.end()),\n         instrShape(instrShape.begin(), instrShape.end()),\n         matShape(matShape.begin(), matShape.end()), perPhase(perPhase),\n         maxPhase(maxPhase), elemBytes(elemBytes), rewriter(rewriter),\n-        typeConverter(typeConverter), loc(loc), ctx(rewriter.getContext()) {\n+        loc(loc), ctx(rewriter.getContext()) {\n     cMatShape = matShape[order[0]];\n     sMatShape = matShape[order[1]];\n \n@@ -2136,7 +2135,6 @@ class MMA16816SmemLoader {\n \n     Value ptr = getPtr(ptrIdx);\n \n-    Value resV4;\n     if (canUseLdmatrix) {\n       int sOffset =\n           matIdx[order[1]] * sMatStride * sMatShape * sTileStride * elemBytes;\n@@ -2266,7 +2264,6 @@ class MMA16816SmemLoader {\n   }\n \n private:\n-  int wpt;\n   SmallVector<uint32_t> order;\n   int kOrder;\n   SmallVector<int64_t> tileShape;\n@@ -2276,7 +2273,6 @@ class MMA16816SmemLoader {\n   int maxPhase;\n   int elemBytes;\n   ConversionPatternRewriter &rewriter;\n-  TypeConverter *typeConverter{};\n   const Location &loc;\n   MLIRContext *ctx{};\n \n@@ -3364,7 +3360,7 @@ namespace mlir {\n \n TritonLLVMConversionTarget::TritonLLVMConversionTarget(\n     MLIRContext &ctx, mlir::LLVMTypeConverter &typeConverter)\n-    : ConversionTarget(ctx), typeConverter(typeConverter) {\n+    : ConversionTarget(ctx) {\n   addLegalDialect<LLVM::LLVMDialect>();\n   addLegalDialect<NVVM::NVVMDialect>();\n   // addIllegalDialect<triton::TritonDialect>();\n@@ -3376,7 +3372,7 @@ TritonLLVMConversionTarget::TritonLLVMConversionTarget(\n \n TritonLLVMFunctionConversionTarget::TritonLLVMFunctionConversionTarget(\n     MLIRContext &ctx, mlir::LLVMTypeConverter &typeConverter)\n-    : ConversionTarget(ctx), typeConverter(typeConverter) {\n+    : ConversionTarget(ctx) {\n   addLegalDialect<LLVM::LLVMDialect>();\n   // addLegalDialect<NVVM::NVVMDialect>();\n   addIllegalOp<mlir::FuncOp>();"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -78,7 +78,7 @@ class LoopPipeliner {\n   /// create the new ForOp (add new args & insert prefetched ops)\n   scf::ForOp createNewForOp();\n \n-  friend class PipelinePass;\n+  friend struct PipelinePass;\n };\n \n // helpers"}, {"filename": "lib/Dialect/TritonGPU/Transforms/TritonGPUConversion.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -73,7 +73,7 @@ TritonGPUTypeConverter::TritonGPUTypeConverter(MLIRContext *context,\n //\n TritonGPUConversionTarget::TritonGPUConversionTarget(\n     MLIRContext &context, TritonGPUTypeConverter &typeConverter)\n-    : ConversionTarget(context), typeConverter(typeConverter) {\n+    : ConversionTarget(context) {\n   // TODO: we should also verify ops of TritonGPUDialect\n   addLegalDialect<triton::gpu::TritonGPUDialect>();\n \n@@ -90,7 +90,7 @@ TritonGPUConversionTarget::TritonGPUConversionTarget(\n   });\n \n   // We have requirements for the data layouts\n-  addDynamicallyLegalOp<triton::DotOp>([this](triton::DotOp dotOp) -> bool {\n+  addDynamicallyLegalOp<triton::DotOp>([](triton::DotOp dotOp) -> bool {\n     Attribute aEncoding =\n         dotOp.a().getType().cast<RankedTensorType>().getEncoding();\n     Attribute bEncoding ="}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -1286,14 +1286,14 @@ void init_triton_translation(py::module &m) {\n           std::string cubin(std::istreambuf_iterator<char>(_cubin), {});\n           _cubin.close();\n           py::bytes bytes(cubin);\n-          return bytes;\n+          return std::move(bytes);\n         });\n }\n \n void init_triton(py::module &m) {\n   py::module subm = m.def_submodule(\"triton\");\n-  // init_triton_codegen(std::move(subm.def_submodule(\"code_gen\")));\n-  init_triton_runtime(std::move(subm.def_submodule(\"runtime\")));\n-  init_triton_ir(std::move(subm.def_submodule(\"ir\")));\n+  // init_triton_codegen(subm.def_submodule(\"code_gen\"));\n+  init_triton_runtime(subm.def_submodule(\"runtime\"));\n+  init_triton_ir(subm.def_submodule(\"ir\"));\n   init_triton_translation(subm);\n }"}]