[{"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -995,8 +995,8 @@ struct ExpOpConversionApprox\n   Value createDestOp(mlir::math::ExpOp op, OpAdaptor adaptor,\n                      ConversionPatternRewriter &rewriter, Type elemTy,\n                      ValueRange operands, Location loc) const {\n-    // For FP64 input, call __nv_expf for higher-precision calculation\n-    if (elemTy.getIntOrFloatBitWidth() == 64)\n+    // For non-FP32 input, call __nv_expf for higher-precision calculation\n+    if (elemTy.getIntOrFloatBitWidth() != 32)\n       return {};\n \n     const double log2e = 1.4426950408889634;\n@@ -1117,7 +1117,7 @@ void populateElementwiseOpToLLVMPatterns(\n \n   patterns.add<ExtElemwiseOpConversion>(typeConverter, benefit);\n   // ExpOpConversionApprox will try using ex2.approx if the input type is\n-  // FP32. For FP64 input type, ExpOpConversionApprox will return failure and\n+  // FP32. For other input types, ExpOpConversionApprox will return failure and\n   // ElementwiseOpConversion<math::ExpOp, math::ExpOp> defined below will call\n   // __nv_expf for higher-precision calculation\n   patterns.add<ExpOpConversionApprox>(typeConverter, benefit);"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "file_content_changes": "@@ -514,11 +514,9 @@ def test_unary_op(dtype_x, expr, device='cuda'):\n # ----------------\n \n \n-@pytest.mark.parametrize(\"expr\", [\n-    'exp', 'log', 'cos', 'sin'\n-])\n-def test_math_op(expr, device='cuda'):\n-    _test_unary('float32', f'tl.{expr}(x)', f'np.{expr}(x) ', device=device)\n+@pytest.mark.parametrize(\"dtype_x, expr\", [(dtype_x, expr) for dtype_x in float_dtypes for expr in ['exp', 'log', 'cos', 'sin']])\n+def test_math_op(dtype_x, expr, device='cuda'):\n+    _test_unary(dtype_x, f'tl.{expr}(x)', f'np.{expr}(x) ', device=device)\n \n # ----------------\n # test abs"}]