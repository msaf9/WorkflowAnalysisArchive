[{"filename": "include/triton/Dialect/Triton/IR/TritonOps.td", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "file_content_changes": "@@ -186,7 +186,14 @@ def TT_StoreOp : TT_Op<\"store\",\n // Atomic Op\n //\n def TT_AtomicRMWOp : TT_Op<\"atomic_rmw\", [SameOperandsAndResultShape,\n-                                          SameOperandsAndResultEncoding]> {\n+                                          SameOperandsAndResultEncoding,\n+                                          MemoryEffects<[MemWrite]>,\n+                                          TypesMatchWith<\"infer ptr type from value type\",\n+                                                         \"val\", \"ptr\",\n+                                                         \"getPointerTypeSameShape($_self)\">,\n+                                          TypesMatchWith<\"infer mask type from value type\",\n+                                                         \"val\", \"mask\", \"getI1SameShape($_self)\",\n+                                                       \"($_op.getOperands().size() <= 2) || std::equal_to<>()\">]> {\n     let summary = \"atomic rmw\";\n \n     let description = [{\n@@ -195,8 +202,8 @@ def TT_AtomicRMWOp : TT_Op<\"atomic_rmw\", [SameOperandsAndResultShape,\n         return old value at $ptr\n     }];\n \n-    let arguments = (ins TT_AtomicRMWAttr:$atomic_rmw_op, TT_PtrTensor:$ptr,\n-                         TT_Type:$val, I1Tensor:$mask);\n+    let arguments = (ins TT_AtomicRMWAttr:$atomic_rmw_op, TT_PtrLike:$ptr,\n+                         TT_Type:$val, Optional<TT_BoolLike>:$mask);\n \n     let results = (outs TT_Type:$result);\n }"}, {"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPU.cpp", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "file_content_changes": "@@ -278,6 +278,20 @@ struct TritonStorePattern : public OpConversionPattern<triton::StoreOp> {\n   }\n };\n \n+struct TritonAtomicRMWPattern\n+    : public OpConversionPattern<triton::AtomicRMWOp> {\n+  using OpConversionPattern<triton::AtomicRMWOp>::OpConversionPattern;\n+\n+  LogicalResult\n+  matchAndRewrite(triton::AtomicRMWOp op, OpAdaptor adaptor,\n+                  ConversionPatternRewriter &rewriter) const override {\n+    rewriter.replaceOpWithNewOp<triton::AtomicRMWOp>(\n+        op, typeConverter->convertType(op.getType()), adaptor.atomic_rmw_op(),\n+        adaptor.ptr(), adaptor.val(), adaptor.mask());\n+    return success();\n+  }\n+};\n+\n struct TritonExtElemwisePattern\n     : public OpConversionPattern<triton::ExtElemwiseOp> {\n   using OpConversionPattern<triton::ExtElemwiseOp>::OpConversionPattern;"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Coalesce.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -118,6 +118,10 @@ struct CoalescePass : public TritonGPUCoalesceBase<CoalescePass> {\n       builder.setInsertionPoint(curr);\n       if (auto load = dyn_cast<triton::LoadOp>(curr))\n         coalesceOp<triton::LoadOp>(axisInfo, curr, load.ptr(), builder);\n+      if (auto op = dyn_cast<triton::AtomicRMWOp>(curr))\n+        coalesceOp<triton::AtomicRMWOp>(axisInfo, curr, op.ptr(), builder);\n+      if (auto op = dyn_cast<triton::AtomicCASOp>(curr))\n+        coalesceOp<triton::AtomicCASOp>(axisInfo, curr, op.ptr(), builder);\n       if (auto load = dyn_cast<triton::gpu::InsertSliceAsyncOp>(curr))\n         coalesceOp<triton::gpu::InsertSliceAsyncOp>(axisInfo, curr, load.src(),\n                                                     builder);"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "file_content_changes": "@@ -204,7 +204,7 @@ inline bool expensive_to_remat(Operation *op) {\n     return true;\n   if (isa<tensor::ExtractSliceOp, triton::gpu::AllocTensorOp,\n           triton::gpu::InsertSliceAsyncOp, triton::LoadOp, triton::StoreOp,\n-          triton::DotOp>(op))\n+          triton::AtomicRMWOp, triton::AtomicCASOp, triton::DotOp>(op))\n     return true;\n   if (isa<scf::YieldOp, scf::ForOp>(op))\n     return true;\n@@ -482,7 +482,9 @@ class RematerializeForward : public mlir::RewritePattern {\n \n     SetVector<Operation *> cvtSlices;\n     auto filter = [&](Operation *op) {\n-      return isInLoop(op) && !isa<triton::LoadOp>(op) &&\n+      return isInLoop(op) &&\n+             !isa<triton::LoadOp, triton::StoreOp, triton::AtomicRMWOp,\n+                  triton::AtomicCASOp>(op) &&\n              !isa<triton::DotOp>(op) && !isa<scf::YieldOp>(op) &&\n              !isa<triton::gpu::ConvertLayoutOp>(op);\n     };"}]