[{"filename": "python/test/tools/compare_files.py", "status": "modified", "additions": 71, "deletions": 35, "changes": 106, "file_content_changes": "@@ -7,11 +7,18 @@\n \n \n def listFilesWithExtension(path: str, extension: str) -> List[str]:\n+    \"\"\"\n+        Returns a list of files in the given path with the given extension\n+        The files are returned with their full path\n+    \"\"\"\n     files = glob.glob(os.path.join(path, f'*.{extension}'))\n     return files\n \n \n def getFileWithExtension(path: str, ext: str) -> Optional[str]:\n+    \"\"\"\n+        Returns a single file in the given path with the given extension\n+    \"\"\"\n     # get all files in directory with extension\n     files = listFilesWithExtension(path, ext)\n     if len(files) == 0:\n@@ -22,38 +29,32 @@ def getFileWithExtension(path: str, ext: str) -> Optional[str]:\n     return files[0]\n \n \n-def loadYamlFile(file_path: str) -> List[Dict[str, str]]:\n-    with open(file_path, 'r') as file:\n+def loadYamlFile(filePath: str) -> List[Dict[str, str]]:\n+    \"\"\"\n+        Loads a yaml file and returns its content as a list of dictionaries\n+    \"\"\"\n+    with open(filePath, 'r') as file:\n         content = yaml.safe_load(file)\n     return content\n \n \n def compareFiles(file1: str, file2: str) -> bool:\n+    \"\"\"\n+        Compares two files and returns True if they are the same, False otherwise\n+    \"\"\"\n     with open(file1, 'rb') as f1, open(file2, 'rb') as f2:\n         content1 = f1.read()\n         content2 = f2.read()\n \n     return content1 == content2\n \n \n-def getNameToHashesDict(path: str) -> Dict[str, List[str]]:\n-    name_to_hashes = {}\n-    for hash in os.listdir(path):\n-        full_path = os.path.join(path, hash)\n-        assert os.path.isdir(full_path), f\"Path {full_path} is not a directory!\"\n-        json_file = getFileWithExtension(full_path, \"json\")\n-        if json_file is None:\n-            continue\n-        # load json file\n-        with open(json_file, 'r') as file:\n-            content = yaml.safe_load(file)\n-            # get name\n-            name = content[\"name\"]\n-            name_to_hashes.setdefault(name, []).append(hash)\n-    return name_to_hashes\n-\n-\n def getFileVec(path: str) -> List[Tuple[str, str]]:\n+    \"\"\"\n+        Returns a list of tuples (extension, file) for the given path (note: the path includes the hash)\n+        The returned list must have extensions (json, ttir, ttgir)\n+        in this particular order, unless a file with a certain extension does not exist\n+    \"\"\"\n     vec = []\n     for ext in [\"json\", \"ttir\", \"ttgir\"]:\n         file = getFileWithExtension(path, ext)\n@@ -62,15 +63,41 @@ def getFileVec(path: str) -> List[Tuple[str, str]]:\n     return vec\n \n \n-def do_files_match(path1: str, path2: str) -> bool:\n+def getNameToHashesDict(path: str) -> Dict[str, List[str]]:\n+    \"\"\"\n+        Returns a dictionary that maps kernel names to a list of hashes that have the same kernel name\n+        in the given path\n+        Note: the hashes must have a json file and either a ttir or ttgir file, otherwise they are ignored\n+    \"\"\"\n+    nameToHashes = {}\n+    for hash in os.listdir(path):\n+        fullPath = os.path.join(path, hash)\n+        assert os.path.isdir(fullPath), f\"Path {fullPath} is not a directory!\"\n+        fileVec = getFileVec(fullPath)\n+        if len(fileVec) < 2 or fileVec[0][0] != \"json\":\n+            continue\n+        jsonFile = fileVec[0][1]\n+        # load json file\n+        with open(jsonFile, 'r') as file:\n+            content = yaml.safe_load(file)\n+            # get name\n+            name = content[\"name\"]\n+            nameToHashes.setdefault(name, []).append(hash)\n+    return nameToHashes\n+\n+\n+def doFilesMatch(path1: str, path2: str) -> bool:\n+    \"\"\"\n+        Returns True if the files in the given paths match, False otherwise\n+        The files are considered to match if:\n+        1. The number of files in both paths match\n+        2. The json files match\n+        3. Both paths have a ttir that match, if a ttir does not exist, the ttgir file must exist and match\n+    \"\"\"\n     filesVec1 = getFileVec(path1)\n     filesVec2 = getFileVec(path2)\n-    # both hashes must at least have 1 json file and 1 ttir or ttgir file\n-    # and the number of files must match\n-    if len(filesVec1) <= 1 or len(filesVec2) <= 1 or len(filesVec1) != len(filesVec2):\n-        return False\n-    # if either path does not have a json file, return false\n-    if filesVec1[0][0] != \"json\" or filesVec2[0][0] != \"json\":\n+    # The number of files must match\n+    if len(filesVec1) != len(filesVec2):\n         return False\n \n     for (ext1, file1), (ext2, file2) in zip(filesVec1, filesVec2):\n@@ -85,9 +112,14 @@ def do_files_match(path1: str, path2: str) -> bool:\n     return True\n \n \n-def compare_matching_files(name: str, extension: str, name_to_hashes1: Dict[str, List[str]], name_to_hashes2: Dict[str, List[str]], args) -> Tuple[str, str]:\n-    hashes1 = name_to_hashes1.get(name, [])\n-    hashes2 = name_to_hashes2.get(name, [])\n+def compareMatchingFiles(name: str, extension: str, nameToHashes1: Dict[str, List[str]], nameToHashes2: Dict[str, List[str]], args) -> Tuple[str, str]:\n+    \"\"\"\n+        Compare files with the given name/extension in all hashes in both paths\n+        Return the first mismatching files as a tuple (file1, file2), otherwise, return an empty tuple\n+        Note: asserts that at least one comparison was made\n+    \"\"\"\n+    hashes1 = nameToHashes1.get(name, [])\n+    hashes2 = nameToHashes2.get(name, [])\n     numComparisons = 0\n     for hash1 in hashes1:\n         path1 = os.path.join(args.path1, hash1)\n@@ -97,19 +129,23 @@ def compare_matching_files(name: str, extension: str, name_to_hashes1: Dict[str,\n             # 1. json files that match\n             # 2. ttir files that match (if they exist), otherwise ttgir files that match (if they exist)\n             # if any of these contraints is not met, then we can skip this pair of hashes since they are not a match\n-            if not do_files_match(path1, path2):\n+            if not doFilesMatch(path1, path2):\n                 continue\n             numComparisons += 1\n-            ext_file1 = listFilesWithExtension(path1, extension)[0]\n-            ext_file2 = listFilesWithExtension(path2, extension)[0]\n-            if not compareFiles(ext_file1, ext_file2):\n-                return (ext_file1, ext_file2)\n+            extFile1 = listFilesWithExtension(path1, extension)[0]\n+            extFile2 = listFilesWithExtension(path2, extension)[0]\n+            if not compareFiles(extFile1, extFile2):\n+                return (extFile1, extFile2)\n     assert numComparisons > 0, f\"Did not find any matching files for {name}\"\n     print(f\"Compared {numComparisons} matching files for {name}\")\n     return ()\n \n \n def main(args) -> None:\n+    \"\"\"\n+        Iterates over all kernels in the given yaml file and compares them\n+        in the given paths\n+    \"\"\"\n     assert args.path1 != args.path2, \"Cannot compare files in the same directory!\"\n     # Get kernel name to hashes dict, these hashes would have the same kernel name\n     nameToHashes1 = getNameToHashesDict(args.path1)\n@@ -126,7 +162,7 @@ def main(args) -> None:\n         extension = d[\"extension\"]  # extension of the file to be compared (e.g. ptx)\n         # Compare all hashes on path 1 with all hashes on path 2\n         # result is either the mismatching (file1, file2) with \"extension\" or empty tuple if no mismatch\n-        result = compare_matching_files(name, extension, nameToHashes1, nameToHashes2, args)\n+        result = compareMatchingFiles(name, extension, nameToHashes1, nameToHashes2, args)\n         # If mismatch exists, add it to mismatches dict\n         if len(result) > 0:\n             mismatches[name] = result"}]