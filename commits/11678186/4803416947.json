[{"filename": "include/triton/Dialect/TritonGPU/IR/Dialect.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -33,6 +33,8 @@ SmallVector<unsigned> getSizePerThread(Attribute layout);\n \n SmallVector<unsigned> getContigPerThread(Attribute layout);\n \n+SmallVector<unsigned> getUniqueContigPerThread(Type type);\n+\n SmallVector<unsigned> getThreadsPerCTA(Attribute layout);\n \n SmallVector<unsigned>"}, {"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "file_content_changes": "@@ -919,11 +919,13 @@ unsigned AxisInfoAnalysis::getPtrContiguity(Value ptr) {\n   auto order = triton::gpu::getOrder(layout);\n   unsigned align = getPtrAlignment(ptr);\n \n-  unsigned contigPerThread = triton::gpu::getSizePerThread(layout)[order[0]];\n-  contigPerThread = std::min(align, contigPerThread);\n-  contigPerThread = std::min<unsigned>(shape[order[0]], contigPerThread);\n+  unsigned uniqueContigPerThread =\n+      triton::gpu::getUniqueContigPerThread(tensorTy)[order[0]];\n+  uniqueContigPerThread = std::min(align, uniqueContigPerThread);\n+  uniqueContigPerThread =\n+      std::min<unsigned>(shape[order[0]], uniqueContigPerThread);\n \n-  return contigPerThread;\n+  return uniqueContigPerThread;\n }\n \n unsigned AxisInfoAnalysis::getPtrAlignment(Value ptr) {"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "file_content_changes": "@@ -146,11 +146,31 @@ SmallVector<unsigned> getContigPerThread(Attribute layout) {\n   if (auto mmaLayout = layout.dyn_cast<MmaEncodingAttr>()) {\n     assert(mmaLayout.isVolta() || mmaLayout.isAmpere());\n     return {1, 2};\n+  } else if (auto sliceLayout = layout.dyn_cast<SliceEncodingAttr>()) {\n+    auto parentLayout = sliceLayout.getParent();\n+    return getContigPerThread(parentLayout);\n   } else {\n     return getSizePerThread(layout);\n   }\n }\n \n+SmallVector<unsigned> getUniqueContigPerThread(Type type) {\n+  if (type.isIntOrIndexOrFloat() || type.isa<triton::PointerType>())\n+    return SmallVector<unsigned>(1, 1);\n+  auto tensorType = type.cast<RankedTensorType>();\n+  auto shape = tensorType.getShape();\n+  auto rank = shape.size();\n+  SmallVector<unsigned> ret(rank);\n+  auto contigPerThread = getContigPerThread(tensorType.getEncoding());\n+  for (int d = 0; d < rank; ++d) {\n+    if (shape[d] < contigPerThread[d])\n+      ret[d] = 1;\n+    else\n+      ret[d] = contigPerThread[d];\n+  }\n+  return ret;\n+}\n+\n SmallVector<unsigned> getThreadsPerCTA(Attribute layout) {\n   SmallVector<unsigned> threads;\n   if (auto blockedLayout = layout.dyn_cast<BlockedEncodingAttr>()) {"}]