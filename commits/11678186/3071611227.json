[{"filename": "cmake/FindLLVM.cmake", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -25,7 +25,7 @@\n #  LLVM_VERSION_STRING - Full LLVM version string (e.g. 6.0.0svn).\n #  LLVM_VERSION_BASE_STRING - Base LLVM version string without git/svn suffix (e.g. 6.0.0).\n #\n-# Note: The variable names were chosen in conformance with the offical CMake\n+# Note: The variable names were chosen in conformance with the official CMake\n # guidelines, see ${CMAKE_ROOT}/Modules/readme.txt.\n \n # Try suffixed versions to pick up the newest LLVM install available on Debian\n@@ -196,4 +196,4 @@ include(FindPackageHandleStandardArgs)\n \n find_package_handle_standard_args(LLVM\n     REQUIRED_VARS LLVM_ROOT_DIR\n-    VERSION_VAR LLVM_VERSION_STRING)\n\\ No newline at end of file\n+    VERSION_VAR LLVM_VERSION_STRING)"}, {"filename": "docs/programming-guide/chapter-2/related-work.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -14,7 +14,7 @@ Traditional compilers typically rely on intermediate representations, such as LL\n Program Representation\n +++++++++++++++++++++++\n \n-Polyhedral compilation is a vast area of research. In this section we only outline the most basic aspects of this topic, but readers interested in the solid mathematical foundations underneath may refer to the ample litterature on linear and integer programming.\n+Polyhedral compilation is a vast area of research. In this section we only outline the most basic aspects of this topic, but readers interested in the solid mathematical foundations underneath may refer to the ample literature on linear and integer programming.\n \n .. table::\n     :widths: 50 50"}, {"filename": "include/triton/codegen/analysis/layout.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -246,7 +246,7 @@ struct N_buffer_info_t {\n   std::map<ir::value*, int> firsts_idx;\n };\n \n-// abstract for dot and coresponding smem values\n+// abstract for dot and corresponding smem values\n class shared_layout: public data_layout {\n private:\n   static bool is_loop_latch(ir::phi_node *phi, ir::instruction *terminator);"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -569,7 +569,7 @@ std::tuple<Value*, Value*, Value*, Value*> generator::fp8x4_to_fp16x4(Value *in0\n   \"prmt.b32 a1, 0, $2, 0x7060;            \\n\\t\" // If input is 0xdcba set a1 to 0xd0c0\n   \"lop3.b32 b0, a0, 0x7fff7fff, 0, 0xc0;  \\n\\t\" // b0 = a0 & 0x7fff7fff (strip sign)\n   \"lop3.b32 b1, a1, 0x7fff7fff, 0, 0xc0;  \\n\\t\" // b1 = a1 & 0x7fff7fff (strip sign)\n-  \"shr.b32  b0, b0, 1;                    \\n\\t\" // b0 >>= 1 (shift into fp16 poistion)\n+  \"shr.b32  b0, b0, 1;                    \\n\\t\" // b0 >>= 1 (shift into fp16 position)\n   \"shr.b32  b1, b1, 1;                    \\n\\t\" // b1 >>= 1 (shift into fp16 position)\n   \"lop3.b32 $0, b0, 0x80008000, a0, 0xf8; \\n\\t\" // out0 = b0 | (0x80008000 & a0) (restore sign)\n   \"lop3.b32 $1, b1, 0x80008000, a1, 0xf8; \\n\\t\" // out1 = b1 | (0x80008000 & a1) (restore sign)"}, {"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -96,7 +96,7 @@ static bool find_and_replace(std::string& str, const std::string& begin, const s\n std::string path_to_ptxas(int& version) {\n   std::vector<std::string> rets;\n   std::string ret;\n-  // search pathes for ptxas\n+  // search paths for ptxas\n   std::vector<std::string> ptxas_prefixes = {\"\", \"/usr/local/cuda/bin/\"};\n   std::string triton_ptxas = tools::getenv(\"TRITON_PTXAS_PATH\");\n   if(!triton_ptxas.empty())"}, {"filename": "lib/ir/print.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -92,7 +92,7 @@ class AssemblyWriter {\n //-------------------------\n void SlotTracker::process_module() {\n   // Nothing to do at the moment.\n-  // Create slots for global variable & unamed functions & ...\n+  // Create slots for global variable & unnamed functions & ...\n   module_processed = true;\n }\n "}, {"filename": "python/src/functions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -253,7 +253,7 @@ ir::value *dot(ir::value *lhs, ir::value *rhs, ir::builder *builder) {\n std::string where_docstr = R\"pbdoc(\n     Returns a block of elements from either `x` or `y`, depending on `condition`.\n     Note that `x` and `y` are always evaluated regardless of the value of `condition`.\n-    If you want to avoid unintented memory operations, use the `mask` arguments in `triton.load` and `triton.store` instead.\n+    If you want to avoid unintended memory operations, use the `mask` arguments in `triton.load` and `triton.store` instead.\n \n     :param condition: When True (nonzero), yield x, otherwise yield y.\n     :type condition: Block of triton.bool"}, {"filename": "python/test/regression/test_performance.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -152,7 +152,7 @@ def test_elementwise(N):\n     cur_mem_clock = nvsmi(['clocks.current.memory'])[0]\n     ref_mem_clock = mem_clocks[DEVICE_NAME]\n     max_gpu_perf = get_dram_gbps()\n-    assert abs(cur_mem_clock - ref_mem_clock) < 10, f'GPU memmory must run at {ref_mem_clock} MHz'\n+    assert abs(cur_mem_clock - ref_mem_clock) < 10, f'GPU memory must run at {ref_mem_clock} MHz'\n     z = torch.empty((N, ), dtype=torch.float16, device='cuda')\n     x = torch.randn_like(z)\n     y = torch.randn_like(z)"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -55,7 +55,7 @@ def numpy_random(shape, dtype_str, rs: Optional[RandomState] = None, low=None, h\n \n def to_triton(x: np.ndarray, device='cuda', dst_type=None) -> Union[TensorWrapper, torch.Tensor]:\n     '''\n-    Note: We need dst_type becasue the type of x can be different from dst_type.\n+    Note: We need dst_type because the type of x can be different from dst_type.\n           For example: x is of type `float32`, dst_type is `bfloat16`.\n           If dst_type is None, we infer dst_type from x.\n     '''\n@@ -424,7 +424,7 @@ def test_unary_op(dtype_x, expr, device='cuda'):\n # ----------------\n # test math ops\n # ----------------\n-# @pytest.mark.paramterize(\"expr\", [\n+# @pytest.mark.parametrize(\"expr\", [\n #     'exp', 'log', 'cos', 'sin'\n # ])\n "}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -66,7 +66,7 @@ def mangle_ty(ty):\n         elt = mangle_ty(ty.scalar)\n         shape = '_'.join(map(str, ty.shape))\n         return f'{elt}S{shape}S'\n-    assert False, \"Unsupport type\"\n+    assert False, \"Unsupported type\"\n \n \n def mangle_fn(name, arg_tys, constants):"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -192,7 +192,7 @@ def to_ir(self, builder: ir.builder) -> ir.type:\n             return builder.get_float_ty()\n         elif self.name == 'fp64':\n             return builder.get_double_ty()\n-        raise ValueError(f'fail to covert {self} to ir type')\n+        raise ValueError(f'fail to convert {self} to ir type')\n \n     def __str__(self):\n         return self.name\n@@ -925,7 +925,7 @@ def where(condition, x, y, _builder=None):\n \n     Note that :code:`x` and :code:`y` are always evaluated regardless of the value of :code:`condition`.\n \n-    If you want to avoid unintented memory operations, use the :code:`mask` arguments in `triton.load` and `triton.store` instead.\n+    If you want to avoid unintended memory operations, use the :code:`mask` arguments in `triton.load` and `triton.store` instead.\n \n     The shape of :code:`x` and :code:`y` are both broadcast to the shape of :code:`condition`.\n     :code:`x` and :code:`y` must have the data type."}, {"filename": "python/triton/ops/blocksparse/matmul.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -328,7 +328,7 @@ def dsd_lut(layout, block, step, trans, device):\n     # create increments\n     incs = torch.stack((B_incs, A_incs), dim=1).view(-1).contiguous()\n     # pad by a factor 2*MAX_NUM_STAGES\n-    # to accomodate pre-fetching inside the kernel\n+    # to accommodate pre-fetching inside the kernel\n     pad = torch.zeros(20, device=incs.device, dtype=incs.dtype)\n     incs = torch.cat((incs, pad))\n     # create lut"}, {"filename": "python/triton/testing.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -379,7 +379,7 @@ def wrapper(*args, **kwargs):\n                 test_id = kwargs['request'].node.callspec.id\n                 cmd = f\"{path}::{test_fn.__name__}[{test_id}]\"\n                 out = subprocess.run([\"cuda-memcheck\", \"pytest\", \"-vs\", cmd], capture_output=True, env=env)\n-                assert out.returncode == 0, \"cuda-memcheck returned an error: bounds checkng failed\"\n+                assert out.returncode == 0, \"cuda-memcheck returned an error: bounds checking failed\"\n                 assert \"ERROR SUMMARY: 0 errors\" in str(out.stdout)\n             else:\n                 test_fn(*args, **kwargs)"}, {"filename": "python/triton/tools/disasm.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -104,7 +104,7 @@ def extract(file_path, fun):\n             # peek the next line\n             line = sass_lines[line_idx].decode()\n         # Print sass\n-        # label naming convension: LBB#i\n+        # label naming convention: LBB#i\n         for idx, (ctrl, asm) in enumerate(asm_buffer):\n             # Print label if this is BRA target\n             offset = idx * 16"}, {"filename": "python/tutorials/02-fused-softmax.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -78,7 +78,7 @@ def softmax_kernel(\n     input_ptrs = row_start_ptr + col_offsets\n     # Load the row into SRAM, using a mask since BLOCK_SIZE may be > than n_cols\n     row = tl.load(input_ptrs, mask=col_offsets < n_cols, other=-float('inf'))\n-    # Substract maximum for numerical stability\n+    # Subtract maximum for numerical stability\n     row_minus_max = row - tl.max(row, axis=0)\n     # Note that exponentials in Triton are fast but approximate (i.e., think __expf in CUDA)\n     numerator = tl.exp(row_minus_max)"}, {"filename": "python/tutorials/03-matrix-multiplication.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -18,7 +18,7 @@\n # They are notoriously hard to optimize, hence their implementation is generally done by\n # hardware vendors themselves as part of so-called \"kernel libraries\" (e.g., cuBLAS).\n # Unfortunately, these libraries are often proprietary and cannot be easily customized\n-# to accomodate the needs of modern deep learning workloads (e.g., fused activation functions).\n+# to accommodate the needs of modern deep learning workloads (e.g., fused activation functions).\n # In this tutorial, you will learn how to implement efficient matrix multiplications by\n # yourself with Triton, in a way that is easy to customize and extend.\n #"}]