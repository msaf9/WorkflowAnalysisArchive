[{"filename": "lib/Conversion/NVGPUToLLVM/NVGPUToLLVMPass.cpp", "status": "modified", "additions": 91, "deletions": 46, "changes": 137, "file_content_changes": "@@ -54,6 +54,16 @@ class NVGPUOpPatternBase : public mlir::RewritePattern {\n     }\n     return val;\n   }\n+  SmallVector<PTXBuilder::Operand *>\n+  getPtxOutputs(std::vector<std::string> &outputConstraints,\n+                PTXBuilder &ptxBuilder) const {\n+    SmallVector<PTXBuilder::Operand *> ptxOutputs;\n+    for (unsigned i = 0; i < outputConstraints.size(); i++) {\n+      auto *ptxOutput = ptxBuilder.newOperand(outputConstraints[i]);\n+      ptxOutputs.push_back(ptxOutput);\n+    }\n+    return ptxOutputs;\n+  }\n \n   SmallVector<PTXBuilder::Operand *> getPtxOperands(\n       std::vector<std::pair<mlir::Value, std::string>> &operandsAndTypes,\n@@ -70,11 +80,58 @@ class NVGPUOpPatternBase : public mlir::RewritePattern {\n     return ptxOperands;\n   }\n \n+  virtual std::vector<std::string> getOutputConstraints(SourceOp op) const {\n+    return {};\n+  }\n+\n   virtual std::vector<std::pair<mlir::Value, std::string>>\n   getOperandsAndTypes(SourceOp op) const {\n     return {};\n   }\n \n+  Type getReturnType(std::vector<std::string> outputConstraints,\n+                     mlir::PatternRewriter &rewriter) const {\n+    auto ctx = rewriter.getContext();\n+    Type resTy;\n+    if (outputConstraints.empty()) {\n+      resTy = void_ty(ctx);\n+    } else {\n+      SmallVector<Type> retTys;\n+      for (auto &outputConstraint : outputConstraints) {\n+        assert(outputConstraint[0] == '=' &&\n+               \"Constraint must be for an output\");\n+        Type retTy;\n+        switch (outputConstraint[1]) {\n+        case 'h':\n+          retTy = IntegerType::get(ctx, 16);\n+          break;\n+        case 'r':\n+          retTy = IntegerType::get(ctx, 32);\n+          break;\n+        case 'l':\n+          retTy = IntegerType::get(ctx, 64);\n+          break;\n+        case 'f':\n+          retTy = FloatType::getF32(ctx);\n+          break;\n+        case 'd':\n+          retTy = FloatType::getF64(ctx);\n+          break;\n+        default:\n+          assert(false && \"Unsupported output constraint\");\n+          break;\n+        }\n+        retTys.push_back(retTy);\n+      }\n+      if (retTys.size() == 1) {\n+        resTy = retTys[1];\n+      } else {\n+        resTy = struct_ty(retTys);\n+      }\n+    }\n+    return resTy;\n+  }\n+\n   LogicalResult\n   matchAndRewrite(mlir::Operation *op,\n                   mlir::PatternRewriter &rewriter) const override {\n@@ -87,16 +144,18 @@ class NVGPUOpPatternBase : public mlir::RewritePattern {\n     auto ptxAsm = concrete->getPtxAsm(sourceOp);\n     auto hasSideEffects = !isMemoryEffectFree(sourceOp);\n     auto operandsAndTypes = concrete->getOperandsAndTypes(sourceOp);\n+    auto outputConstraints = concrete->getOutputConstraints(sourceOp);\n+\n     PTXBuilder ptxBuilder;\n+    auto ptxOutputs = getPtxOutputs(outputConstraints, ptxBuilder);\n     auto ptxOperands =\n         getPtxOperands(operandsAndTypes, ptxBuilder, loc, rewriter);\n+    SmallVector<PTXBuilder::Operand *> outputsAndOperands = ptxOutputs;\n+    outputsAndOperands.append(ptxOperands.begin(), ptxOperands.end());\n     auto &ptxInstr = *ptxBuilder.create<PTXInstr>(ptxAsm);\n-    ptxInstr(ptxOperands, /*onlyAttachMLIRArgs=*/true);\n-    mlir::Type resTy;\n-    if (op->getResultTypes().empty()) {\n-      resTy = void_ty(ctx);\n-    }\n-    auto res = ptxBuilder.launch(rewriter, loc, resTy,\n+    ptxInstr(outputsAndOperands, /*onlyAttachMLIRArgs=*/true);\n+    auto retTy = getReturnType(outputConstraints, rewriter);\n+    auto res = ptxBuilder.launch(rewriter, loc, retTy,\n                                  /*hasSideEffects*/ hasSideEffects);\n     rewriter.replaceOp(op, res);\n     return mlir::success();\n@@ -676,30 +735,39 @@ class Sts64OpPattern : public NVGPUOpPatternBase<ttn::Sts64Op, Sts64OpPattern> {\n   }\n };\n \n-class LoadDSmemOpPattern : public mlir::RewritePattern {\n+class LoadDSmemOpPattern\n+    : public NVGPUOpPatternBase<ttn::LoadDSmemOp, LoadDSmemOpPattern> {\n public:\n-  LoadDSmemOpPattern(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(ttn::LoadDSmemOp::getOperationName(), 1, context) {\n+  using Base = NVGPUOpPatternBase<ttn::LoadDSmemOp, LoadDSmemOpPattern>;\n+  using Base::Base;\n+\n+  std::vector<std::string> getOutputConstraints(ttn::LoadDSmemOp op) const {\n+    auto bitwidth = op.getBitwidth();\n+    std::string c = bitwidth == 16 ? \"=h\" : (bitwidth == 32 ? \"=r\" : \"=l\");\n+    auto vec = op.getVec();\n+    return std::vector<std::string>(vec, c);\n   }\n+  std::vector<std::pair<mlir::Value, std::string>>\n+  getOperandsAndTypes(ttn::LoadDSmemOp op) const {\n+    std::vector<std::pair<mlir::Value, std::string>> operandsAndTypes;\n+    auto addr = op.getAddr();\n+    auto ctaId = op.getCtaId();\n \n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto ctx = rewriter.getContext();\n-    auto loadDSmemOp = llvm::dyn_cast<ttn::LoadDSmemOp>(op);\n-    if (!loadDSmemOp)\n-      return mlir::failure();\n-    auto loc = op->getLoc();\n-    auto addr = loadDSmemOp.getAddr();\n-    auto ctaId = loadDSmemOp.getCtaId();\n-    auto bitwidth = loadDSmemOp.getBitwidth();\n-    auto vec = loadDSmemOp.getVec();\n+    operandsAndTypes.push_back({addr, \"i32\"});\n+    operandsAndTypes.push_back({ctaId, \"i32\"});\n+    return operandsAndTypes;\n+  }\n+\n+  std::string getPtxAsm(ttn::LoadDSmemOp op) const {\n+    auto addr = op.getAddr();\n+    auto ctaId = op.getCtaId();\n+    auto bitwidth = op.getBitwidth();\n+    auto vec = op.getVec();\n \n     assert(\n         (bitwidth == 8 || bitwidth == 16 || bitwidth == 32 || bitwidth == 64) &&\n         \"invalid bitwidth\");\n     assert((vec == 1 || vec == 2 || vec == 4) && \"invalid vec size\");\n-    PTXBuilder ptxBuilder;\n \n     std::string o1 = vec > 1 ? \".v.u\" : \".u\";\n     std::string vecStr = vec == 1   ? \"$0\"\n@@ -715,30 +783,7 @@ class LoadDSmemOpPattern : public mlir::RewritePattern {\n                   o1 + std::to_string(bitwidth) + \" \" + vecStr +\n                   \", [remoteAddr];\\n\"\n                   \"}\\n\";\n-\n-    auto &ptxInstr = *ptxBuilder.create<PTXInstr>(ptxAsm);\n-    std::string c = bitwidth == 16 ? \"=h\" : (bitwidth == 32 ? \"=r\" : \"=l\");\n-    SmallVector<PTXBuilder::Operand *> oprs;\n-    for (unsigned i = 0; i < vec; ++i) {\n-      auto *ret = ptxBuilder.newOperand(c);\n-      oprs.push_back(ret);\n-    }\n-    auto *addrOpr = ptxBuilder.newOperand(addr, \"r\");\n-    auto *ctaIdOpr = ptxBuilder.newOperand(ctaId, \"r\");\n-    oprs.push_back(addrOpr);\n-    oprs.push_back(ctaIdOpr);\n-\n-    Type retTy = IntegerType::get(rewriter.getContext(), bitwidth);\n-    SmallVector<Type> retTys(vec, retTy);\n-    if (vec > 1)\n-      retTy = struct_ty(retTys);\n-\n-    ptxInstr(oprs,\n-             /*onlyAttachMLIRArgs=*/true);\n-\n-    auto res = ptxBuilder.launch(rewriter, loc, retTy);\n-    rewriter.replaceOp(op, {res});\n-    return mlir::success();\n+    return ptxAsm;\n   }\n };\n "}]