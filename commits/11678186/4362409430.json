[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "file_content_changes": "@@ -70,14 +70,11 @@ class LoopPipeliner {\n   /// Block arguments that loads depend on\n   SetVector<BlockArgument> depArgs;\n \n-  /// Block arguments that are immediately used by loads\n-  SetVector<BlockArgument> immedidateDepArgs;\n-\n   /// Operations (inside the loop body) that loads depend on\n   SetVector<Operation *> depOps;\n \n   /// collect values that v depends on and are defined inside the loop\n-  void collectDeps(Value v, int stages, SetVector<std::pair<Value, int>> &deps);\n+  void collectDeps(Value v, int stages, SetVector<Value> &deps);\n \n   void setValueMapping(Value origin, Value newValue, int stage);\n \n@@ -124,8 +121,7 @@ Value LoopPipeliner::lookupOrDefault(Value origin, int stage) {\n   return valueMapping[origin][stage];\n }\n \n-void LoopPipeliner::collectDeps(Value v, int stages,\n-                                SetVector<std::pair<Value, int>> &deps) {\n+void LoopPipeliner::collectDeps(Value v, int stages, SetVector<Value> &deps) {\n   // Loop-invariant value, skip\n   if (v.getParentRegion() != &forOp.getLoopBody())\n     return;\n@@ -139,14 +135,14 @@ void LoopPipeliner::collectDeps(Value v, int stages,\n     if (arg.getArgNumber() > 0) {\n       // Skip the first arg (loop induction variable)\n       // Otherwise the op idx is arg.getArgNumber()-1\n-      deps.insert({v, stages});\n+      deps.insert(v);\n       collectDeps(yieldOp->getOperand(arg.getArgNumber() - 1), stages - 1,\n                   deps);\n     }\n   } else { // value\n     // v might be in deps, but we still need to visit v.\n     // This is because v might depend on value in previous iterations\n-    deps.insert({v, stages});\n+    deps.insert(v);\n     for (Value op : v.getDefiningOp()->getOperands())\n       collectDeps(op, stages, deps);\n   }\n@@ -202,15 +198,12 @@ LogicalResult LoopPipeliner::initialize() {\n     return failure();\n \n   // load => values that it depends on\n-  DenseMap<Value, SetVector<std::pair<Value, int>>> loadDeps;\n-  DenseMap<Value, SetVector<Value>> denseLoadDeps;\n+  DenseMap<Value, SetVector<Value>> loadDeps;\n   for (triton::LoadOp loadOp : validLoads) {\n-    SetVector<std::pair<Value, int>> deps;\n+    SetVector<Value> deps;\n     for (Value op : loadOp->getOperands())\n       collectDeps(op, numStages - 1, deps);\n     loadDeps[loadOp] = deps;\n-    for (auto dep : deps)\n-      denseLoadDeps[loadOp].insert(dep.first);\n   }\n \n   // Don't pipeline valid loads that depend on other valid loads\n@@ -220,7 +213,7 @@ LogicalResult LoopPipeliner::initialize() {\n   for (triton::LoadOp loadOp : validLoads) {\n     bool isCandidate = true;\n     for (triton::LoadOp other : validLoads) {\n-      if (denseLoadDeps[loadOp].contains(other)) {\n+      if (loadDeps[loadOp].contains(other)) {\n         isCandidate = false;\n         break;\n       }\n@@ -276,15 +269,11 @@ LogicalResult LoopPipeliner::initialize() {\n   if (!loads.empty()) {\n     // Update depArgs & depOps\n     for (Value loadOp : loads) {\n-      for (auto &entry : loadDeps[loadOp]) {\n-        auto dep = entry.first;\n-        auto stage = entry.second;\n+      for (Value dep : loadDeps[loadOp]) {\n         // TODO: we should record the stage that the value is depended on\n-        if (auto arg = dep.dyn_cast<BlockArgument>()) {\n+        if (auto arg = dep.dyn_cast<BlockArgument>())\n           depArgs.insert(arg);\n-          if (stage == 0)\n-            immedidateDepArgs.insert(arg);\n-        } else\n+        else\n           depOps.insert(dep.getDefiningOp());\n       }\n     }\n@@ -494,10 +483,19 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n   size_t depArgsBeginIdx = newLoopArgs.size();\n   for (BlockArgument depArg : depArgs) {\n     depArgsIdx[depArg] = newLoopArgs.size();\n-    if (immedidateDepArgs.contains(depArg))\n-      newLoopArgs.push_back(valueMapping[depArg][numStages - 1]);\n-    else\n+    auto users = depArg.getUsers();\n+    bool immediate = false;\n+    for (auto user : users) {\n+      if (loads.contains(user->getResult(0))) {\n+        // Immediate dep arg\n+        immediate = true;\n+        break;\n+      }\n+    }\n+    if (immediate)\n       newLoopArgs.push_back(valueMapping[depArg][numStages - 2]);\n+    else\n+      newLoopArgs.push_back(valueMapping[depArg][numStages - 1]);\n   }\n \n   size_t nextIVIdx = newLoopArgs.size();"}]