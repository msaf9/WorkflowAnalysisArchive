[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "file_content_changes": "@@ -77,6 +77,8 @@ class LoopPipeliner {\n   /// Block arguments that loads depend on\n   SetVector<BlockArgument> depArgs;\n \n+  SetVector<BlockArgument> immedidateDepArgs;\n+\n   SetVector<BlockArgument> nonImmedidateDepArgs;\n \n   /// Operations (inside the loop body) that loads depend on\n@@ -213,12 +215,6 @@ LogicalResult LoopPipeliner::initialize() {\n     for (Value op : loadOp->getOperands())\n       collectDeps(op, numStages - 1, deps);\n     loadDeps[loadOp] = deps;\n-    if (deps.size() > 0 && !isa<BlockArgument>(deps.front())) {\n-      for (auto dep : deps) {\n-        if (auto arg = dyn_cast<BlockArgument>(dep))\n-          nonImmedidateDepArgs.insert(arg);\n-      }\n-    }\n   }\n \n   // Don't pipeline valid loads that depend on other valid loads\n@@ -284,17 +280,28 @@ LogicalResult LoopPipeliner::initialize() {\n   if (!loads.empty()) {\n     // Update depArgs & depOps\n     for (Value loadOp : loads) {\n-      for (Value dep : loadDeps[loadOp]) {\n+      auto &deps = loadDeps[loadOp];\n+      for (Value dep : deps) {\n         // TODO: we should record the stage that the value is depended on\n-        if (auto arg = dep.dyn_cast<BlockArgument>())\n+        if (auto arg = dep.dyn_cast<BlockArgument>()) {\n           depArgs.insert(arg);\n-        else\n+          if (deps.front().isa<BlockArgument>())\n+            immedidateDepArgs.insert(arg);\n+          else\n+            nonImmedidateDepArgs.insert(arg);\n+        } else\n           depOps.insert(dep.getDefiningOp());\n       }\n     }\n     return success();\n   }\n \n+  // Check if immedidateDepArgs and nonImmedidateDepArgs are disjoint\n+  // If yes, we can pipeline the loop for now\n+  for (BlockArgument arg : immedidateDepArgs)\n+    if (nonImmedidateDepArgs.contains(arg))\n+      return failure();\n+\n   return failure();\n }\n "}]