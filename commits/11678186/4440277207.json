[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 126, "deletions": 70, "changes": 196, "file_content_changes": "@@ -16,7 +16,7 @@\n import warnings\n from collections import namedtuple\n from pathlib import Path\n-from typing import Any, Callable, Dict, Tuple, Union\n+from typing import Any, Callable, Dict, Tuple, Union, Optional\n \n import setuptools\n import torch\n@@ -109,10 +109,11 @@ def __exit__(self, *args, **kwargs):\n \n \n class CodeGenerator(ast.NodeVisitor):\n-    def __init__(self, context, prototype, gscope, attributes, constants, function_name, module=None, is_kernel=False, function_types=dict(), debug=False):\n+    def __init__(self, context, prototype, gscope, attributes, constants, function_name,\n+                 module=None, is_kernel=False, function_types: Optional[Dict] = None, debug=False):\n         self.builder = _triton.ir.builder(context)\n         self.module = self.builder.create_module() if module is None else module\n-        self.function_ret_types = function_types\n+        self.function_ret_types = {} if function_types is None else function_types\n         self.prototype = prototype\n         self.gscope = gscope\n         self.lscope = dict()\n@@ -122,45 +123,45 @@ def __init__(self, context, prototype, gscope, attributes, constants, function_n\n         self.is_kernel = is_kernel\n         self.last_node = None\n         self.debug = debug\n-        self.builtins = {\n-            'range': range,\n-            'min': triton.language.minimum,\n-            'float': float,\n-            'int': int,\n-            'print': triton.language.core.device_print,\n-            'isinstance': isinstance,\n-            'getattr': getattr,\n-        }\n-        self.static_functions = [\n-            'static_print', 'static_assert'\n-        ]\n         self.scf_stack = []\n         # SSA-construction\n         # name => triton.language.tensor\n         self.local_defs: Dict[str, triton.language.tensor] = {}\n         self.global_uses: Dict[str, triton.language.tensor] = {}\n-\n-    def get_value(self, name):\n-        ''' This function:\n-        1. make sure `name` is defined\n-        2. if `name` is triton.language.tensor, get stored tensor by calling\n-           `self._get_tensor()`\n-        '''\n-        # search node.id in local scope\n-        ret = None\n-        if name in self.lscope:\n-            ret = self.lscope[name]\n-            if name not in self.local_defs:\n-                self.global_uses[name] = ret\n-        # search node.id in global scope\n-        elif name in self.gscope:\n-            ret = self.gscope[name]\n-        # search node.id in builtins\n-        elif name in self.builtins:\n-            ret = self.builtins[name]\n-        else:\n-            raise ValueError(f'{name} is not defined')\n-        return ret\n+        self.dereference_name: Callable[[str], Any] = self._define_name_lookup()\n+\n+    builtin_namespace: Dict[str, Any] = {_.__name__: _ for _ in (range, float, int, isinstance, getattr)}\n+\n+    def _define_name_lookup(self):\n+        # TODO: this needs to be moved to class scope when cyclic imports untangled and `triton.language` can be imported at module level\n+        self.builtin_namespace.update((\n+            ('print', triton.language.core.device_print),\n+            ('min', triton.language.minimum),  # TODO: why `min`? if `min`, why not `max`? `sum`? `all`?\n+        ))\n+        # TODO: this needs to be moved to class scope when cyclic imports untangled and `triton.language` can be imported at module level\n+        self.statically_implemented_functions.update((\n+            (triton.language.core.static_assert, self.execute_static_assert),\n+            (triton.language.core.static_print, self.execute_static_print),\n+        ))\n+\n+        def local_lookup(name: str, absent):\n+            value = self.lscope.get(name, absent)  # this needs to be re-fetched from `self` every time, because it gets switched occasionally\n+            if value is not absent and name not in self.local_defs:\n+                self.global_uses[name] = value\n+            return value\n+\n+        lookup_order = local_lookup, self.gscope.get, self.builtin_namespace.get\n+        absent_marker = object()\n+\n+        def name_lookup(name: str) -> Any:\n+            absent = absent_marker\n+            for lookup_function in lookup_order:\n+                value = lookup_function(name, absent)\n+                if value is not absent:\n+                    return value\n+            raise NameError(f'{name} is not defined')\n+\n+        return name_lookup\n \n     def set_value(self, name: str,\n                   value: Union[triton.language.tensor, triton.language.constexpr]) -> None:\n@@ -328,7 +329,8 @@ def visit_Assign(self, node):\n         _names = []\n         for target in node.targets:\n             _names += [self.visit(target)]\n-        assert len(_names) == 1\n+        if len(_names) > 1:\n+            raise NotImplementedError(\"Multiple assignment is not supported.\")\n         names = _names[0]\n         values = self.visit(node.value)\n         if not isinstance(names, tuple):\n@@ -349,12 +351,12 @@ def visit_AugAssign(self, node):\n         rhs = ast.BinOp(lhs, node.op, node.value)\n         assign = ast.Assign(targets=[node.target], value=rhs)\n         self.visit(assign)\n-        return self.get_value(name)\n+        return self.dereference_name(name)\n \n     def visit_Name(self, node):\n         if type(node.ctx) == ast.Store:\n             return node.id\n-        return self.get_value(node.id)\n+        return self.dereference_name(node.id)\n \n     def visit_Store(self, node):\n         ast.NodeVisitor.generic_visit(self, node)\n@@ -671,7 +673,7 @@ def visit_For(self, node):\n                     ast.NodeVisitor.generic_visit(self, stmt)\n             return\n \n-        if IteratorClass != self.builtins['range']:\n+        if IteratorClass is not range:\n             raise RuntimeError('Only `range` and `static_range` iterators are currently supported')\n \n         # visit iterator arguments\n@@ -785,8 +787,8 @@ def visit_Slice(self, node):\n     def visit_Index(self, node):\n         return self.visit(node.value)\n \n-    def visit_keyword(self, node):\n-        return {node.arg: self.visit(node.value)}\n+    def visit_keyword(self, node) -> Tuple[str, Any]:\n+        return node.arg, self.visit(node.value)\n \n     def visit_Assert(self, node) -> Any:\n         if not self.debug:\n@@ -800,22 +802,16 @@ def visit_Call(self, node):\n         fn = self.visit(node.func)\n         if isinstance(fn, triton.language.constexpr):\n             fn = fn.value\n-        kws = dict()\n-        for keyword in node.keywords:\n-            kws.update(self.visit(keyword))\n+\n+        static_implementation = self.statically_implemented_functions.get(fn)\n+        if static_implementation is not None:\n+            return static_implementation(node)\n+\n+        kws = dict(self.visit(keyword) for keyword in node.keywords)\n         args = [self.visit(arg) for arg in node.args]\n-        if fn.__name__ == \"print\":\n-            fn = self.builtins[\"print\"]\n-        elif fn.__name__ == \"device_assert\":\n+        if fn is triton.language.core.device_assert:   # TODO: this should not be so hardcoded\n             if not self.debug:\n                 return\n-        elif fn.__name__ in self.static_functions:\n-            if fn.__name__ == \"static_print\":\n-                print(*args, **kws)\n-                return\n-            elif fn.__name__ == \"static_assert\":\n-                assert args[0], args[1]\n-                return\n         if isinstance(fn, triton.runtime.JITFunction):\n             from inspect import getcallargs\n             args = getcallargs(fn.fn, *args, **kws)\n@@ -853,12 +849,10 @@ def visit_Call(self, node):\n                 for i in range(call_op.get_num_results()):\n                     results.append(triton.language.tensor(call_op.get_result(i), callee_ret_type[i]))\n                 return tuple(results)\n-        if (hasattr(fn, '__self__') and self.is_triton_tensor(fn.__self__)) \\\n-                or impl.is_builtin(fn):\n+        if (hasattr(fn, '__self__') and self.is_triton_tensor(fn.__self__)) or impl.is_builtin(fn):\n             return fn(*args, _builder=self.builder, **kws)\n-        if fn in self.builtins.values():\n-            args = [arg.value if isinstance(arg, triton.language.constexpr) else arg\n-                    for arg in args]\n+        if fn in self.builtin_namespace.values():\n+            args = [arg.value if isinstance(arg, triton.language.constexpr) else arg for arg in args]\n         return fn(*args, **kws)\n \n     def visit_Constant(self, node):\n@@ -935,19 +929,76 @@ def generic_visit(self, node):\n         typename = type(node).__name__\n         raise NotImplementedError(\"Unsupported node: {}\".format(typename))\n \n+    # TODO: populate this here (rather than inside `_define_name_lookup`) once cyclic imports resolved\n+    statically_implemented_functions: Dict[object, Callable[[ast.Call], Any]] = {}\n+\n+    def execute_static_print(self, node: ast.Call) -> None:\n+        # TODO: too simplistic? Perhaps do something else with non-constexpr\n+        def unwrap(_):\n+            return _.value if isinstance(_, triton.language.constexpr) else _\n+\n+        kws = {name: unwrap(value) for name, value in (self.visit(keyword) for keyword in node.keywords)}\n+        args = [unwrap(self.visit(arg)) for arg in node.args]\n+        print(*args, **kws)\n+\n+    def execute_static_assert(self, node: ast.Call) -> None:\n+        arg_count = len(node.args)\n+        if not (0 < arg_count <= 2) or len(node.keywords):\n+            raise TypeError(\"`static_assert` requires one or two positional arguments only\")\n+\n+        passed = self.visit(node.args[0])\n+        if not isinstance(passed, bool):\n+            raise NotImplementedError(\"Assertion condition could not be determined at compile-time. Make sure that it depends only on `constexpr` values\")\n+        if not passed:\n+            if arg_count == 1:\n+                message = \"\"\n+            else:\n+                try:\n+                    message = self.visit(node.args[1])\n+                except Exception as e:\n+                    message = \"<failed to evaluate assertion message: \" + repr(e) + \">\"\n+\n+            raise CompileTimeAssertionFailure(None, node, message)\n+        return None\n+\n \n class CompilationError(Exception):\n-    def __init__(self, src, node):\n-        self.message = f'at {node.lineno}:{node.col_offset}:\\n'\n-        self.message += '\\n'.join(src.split('\\n')[:node.lineno])\n-        self.message += '\\n' + ' ' * node.col_offset + '^'\n+    source_line_count_max_in_message = 12\n+\n+    def _format_message(self) -> str:\n+        node = self.node\n+        message = f'at {node.lineno}:{node.col_offset}:'\n+        if self.src is None:\n+            message += \" <source unavailable>\"\n+        else:\n+            message += '\\n'.join(self.src.split('\\n')[:node.lineno][-self.source_line_count_max_in_message:])\n+            message += '\\n' + ' ' * node.col_offset + '^'\n+        if self.error_message:\n+            message += '\\n' + self.error_message\n+        return message\n+\n+    def __init__(self, src: Optional[str], node: ast.AST, error_message: Optional[str]):\n         self.src = src\n         self.node = node\n-        super().__init__(self.message)\n+        self.error_message = error_message\n+        self.message = self._format_message()\n+\n+    def __str__(self):\n+        return self.message\n+\n+    def __repr__(self):\n+        return \"{}({!r})\".format(type(self).__name__, self.message)\n \n     def __reduce__(self):\n         # this is necessary to make CompilationError picklable\n-        return (type(self), (self.src, self.node))\n+        return type(self), (self.src, self.node, self.error_message)\n+\n+\n+class CompileTimeAssertionFailure(CompilationError):\n+    \"\"\"Specific exception for failed tests in `static_assert` invocations\"\"\"\n+    def set_source_code(self, src: Optional[str]):\n+        self.src = src\n+        self.message = self._format_message()\n \n \n class OutOfResources(Exception):\n@@ -1012,11 +1063,16 @@ def build_triton_ir(fn, signature, specialization, constants, debug=False):\n     generator = CodeGenerator(context, prototype, gscope=gscope, constants=all_constants, function_name=function_name, attributes=new_attrs, is_kernel=True, debug=debug)\n     try:\n         generator.visit(fn.parse())\n+    except CompileTimeAssertionFailure as e:\n+        e.set_source_code(fn.src)\n+        raise\n+    except CompilationError:  # (can this ever happen? nobody has access to fn.src except here)\n+        raise  # unchanged\n     except Exception as e:\n         node = generator.last_node\n-        if node is None or isinstance(e, CompilationError):\n-            raise e\n-        raise CompilationError(fn.src, node) from e\n+        if node is None:\n+            raise\n+        raise CompilationError(fn.src, node, repr(e)) from e\n     ret = generator.module\n     # module takes ownership of the context\n     ret.context = context"}]