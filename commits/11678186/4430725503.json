[{"filename": ".github/workflows/integration-tests.yml", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "file_content_changes": "@@ -22,7 +22,7 @@ jobs:\n         id: set-matrix\n         run: |\n           if [ x\"${{ github.repository }}\" == x\"openai/triton\" ]; then\n-            echo '::set-output name=matrix::[[\"self-hosted\", \"A100\"], [\"self-hosted\", \"V100\"], \"macos-10.15\"]'\n+            echo '::set-output name=matrix::[[\"self-hosted\", \"A100\", \"cuda\"], [\"self-hosted\", \"V100\", \"cuda\"], [\"self-hosted\", \"gfx908\", \"rocm\"], \"macos-10.15\"]'\n           else\n             echo '::set-output name=matrix::[\"ubuntu-latest\", \"macos-10.15\"]'\n           fi\n@@ -74,11 +74,21 @@ jobs:\n           flake8 --config ./python/setup.cfg ./python || ( echo '::error::Flake8 failed; see logs for errors.' ; exit 1 )\n \n       - name: Install Triton\n+        if: ${{matrix.runner[2] != 'rocm'}}\n         run: |\n           cd python\n           TRITON_USE_ASSERT_ENABLED_LLVM=TRUE pip3 install -e '.[tests]'\n \n+      - name: Install Triton on ROCM\n+        if: ${{matrix.runner[2] == 'rocm'}}\n+        run: |\n+          cd python\n+          pip3 uninstall --yes torch torchvision torchaudio\n+          pip3 install --no-cache-dir --force-reinstall torch==1.13.1 --extra-index-url https://download.pytorch.org/whl/rocm5.2\n+          TRITON_USE_ASSERT_ENABLED_LLVM=TRUE pip3 install -e '.[tests]'\n+\n       - name: Run lit tests\n+        if: ${{matrix.runner[2] != 'rocm'}}\n         run: |\n           cd python\n           LIT_TEST_DIR=\"build/$(ls build)/test\"\n@@ -87,13 +97,20 @@ jobs:\n           fi\n           lit -v \"$LIT_TEST_DIR\"\n \n-      - name: Run python tests\n-        if: ${{matrix.runner[0] == 'self-hosted'}}\n+      - name: Run python tests on CUDA\n+        if: ${{matrix.runner[2] == 'cuda'}}\n         run: |\n           cd python/test/unit/\n           pytest\n+      \n+      - name: Run python tests on ROCM\n+        if: ${{matrix.runner[2] == 'rocm'}}\n+        run: |\n+          cd python/test/unit/language/\n+          pytest --capture=tee-sys -rfs --verbose\n \n       - name: Run CXX unittests\n+        if: ${{matrix.runner[2] == 'cuda'}}\n         run: |\n           cd python/\n           cd \"build/$(ls build)\""}, {"filename": "bin/triton-translate.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -14,9 +14,9 @@\n #include \"triton/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n+#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n #include \"triton/Target/PTX/PTXTranslation.h\"\n-#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"llvm/IR/LLVMContext.h\"\n #include \"llvm/Support/CommandLine.h\"\n #include \"llvm/Support/InitLLVM.h\"\n@@ -79,7 +79,8 @@ LogicalResult tritonTranslateMain(int argc, char **argv,\n       llvm::cl::init(\"-\"));\n \n   static llvm::cl::opt<std::string> targetKind(\n-      \"target\", llvm::cl::desc(\"<translation target, options: llvmir/ptx/hsaco>\"),\n+      \"target\",\n+      llvm::cl::desc(\"<translation target, options: llvmir/ptx/hsaco>\"),\n       llvm::cl::value_desc(\"target\"), llvm::cl::init(\"llvmir\"));\n \n   static llvm::cl::opt<int> SMArch(\"sm\", llvm::cl::desc(\"sm arch\"),\n@@ -132,10 +133,9 @@ LogicalResult tritonTranslateMain(int argc, char **argv,\n     llvm::outs() << ::triton::translateLLVMIRToPTX(*llvmir, SMArch.getValue(),\n                                                    ptxVersion.getValue());\n   else if (targetKind == \"hsaco\") {\n-    auto [module, hsaco] =\n-        ::triton::translateLLVMIRToHSACO(*llvmir, GCNArch.getValue(),\n-                                                  GCNTriple.getValue(),\n-                                                  GCNFeatures.getValue());\n+    auto [module, hsaco] = ::triton::translateLLVMIRToHSACO(\n+        *llvmir, GCNArch.getValue(), GCNTriple.getValue(),\n+        GCNFeatures.getValue());\n     llvm::outs() << hsaco;\n   } else {\n     llvm::errs() << \"Error: Unknown target specified: \" << targetKind << \"\\n\";"}, {"filename": "include/triton/Conversion/TritonGPUToLLVM/AsmFormat.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -16,7 +16,7 @@ namespace triton {\n using llvm::StringRef;\n \n inline std::string strJoin(llvm::ArrayRef<std::string> strs,\n-                    llvm::StringRef delimiter) {\n+                           llvm::StringRef delimiter) {\n   std::string osStr;\n   llvm::raw_string_ostream os(osStr);\n   for (size_t i = 0; !strs.empty() && i < strs.size() - 1; ++i)"}, {"filename": "include/triton/Conversion/TritonGPUToLLVM/GCNAsmFormat.h", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "file_content_changes": "@@ -48,7 +48,7 @@ struct GCNBuilder {\n     std::string dump() const;\n   };\n \n-struct Modifier {\n+  struct Modifier {\n     Value value;\n     std::string modifier;\n     std::string arg;\n@@ -191,10 +191,12 @@ struct GCNInstrCommon {\n   // clang-format on\n \n   // Set operands of this instruction.\n-  GCNInstrExecution &operator()(llvm::ArrayRef<Operand *> oprs, llvm::ArrayRef<Modifier*> mods);\n+  GCNInstrExecution &operator()(llvm::ArrayRef<Operand *> oprs,\n+                                llvm::ArrayRef<Modifier *> mods);\n \n protected:\n-  GCNInstrExecution &call(llvm::ArrayRef<Operand *> oprs, ArrayRef<Modifier *> mods);\n+  GCNInstrExecution &call(llvm::ArrayRef<Operand *> oprs,\n+                          ArrayRef<Modifier *> mods);\n \n   GCNBuilder *builder{};\n   llvm::SmallVector<std::string, 4> instrParts;\n@@ -218,17 +220,12 @@ template <class ConcreteT> struct GCNInstrBase : public GCNInstrCommon {\n   }\n };\n \n-enum VectorWidth {\n-  Byte = 8,\n-  Short = 16,\n-  Dword = 32,\n-  Qword = 64\n-};\n+enum VectorWidth { Byte = 8, Short = 16, Dword = 32, Qword = 64 };\n \n struct GCNInstr : public GCNInstrBase<GCNInstr> {\n   using GCNInstrBase<GCNInstr>::GCNInstrBase;\n \n-   GCNInstr &float_op_type(int width) {\n+  GCNInstr &float_op_type(int width) {\n     switch (width) {\n     case Byte:\n       assert(Byte != width);\n@@ -258,8 +255,10 @@ struct GCNInstrExecution {\n \n   GCNInstrExecution() = default;\n   explicit GCNInstrExecution(GCNInstrCommon *instr,\n-                             llvm::ArrayRef<Operand *> oprs, llvm::ArrayRef<Modifier *> modifiers)\n-      : instr(instr), argsInOrder(oprs.begin(), oprs.end()), mods(modifiers.begin(), modifiers.end()) {}\n+                             llvm::ArrayRef<Operand *> oprs,\n+                             llvm::ArrayRef<Modifier *> modifiers)\n+      : instr(instr), argsInOrder(oprs.begin(), oprs.end()),\n+        mods(modifiers.begin(), modifiers.end()) {}\n \n   std::string dump() const;\n \n@@ -268,8 +267,6 @@ struct GCNInstrExecution {\n   GCNInstrCommon *instr{};\n };\n \n-\n-\n struct GCNMemInstr : public GCNInstrBase<GCNMemInstr> {\n   using GCNInstrBase<GCNMemInstr>::GCNInstrBase;\n   // Add specific type suffix to instruction"}, {"filename": "include/triton/Target/HSACO/HSACOTranslation.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "file_content_changes": "@@ -12,10 +12,9 @@ class Module;\n namespace triton {\n \n // Translate TritonGPU IR to HSACO code.\n-std::tuple<std::string, std::string> translateLLVMIRToHSACO(llvm::Module& module,\n-                                                            std::string gfx_arch,\n-                                                            std::string gfx_triple,\n-                                                            std::string gfx_features);\n+std::tuple<std::string, std::string>\n+translateLLVMIRToHSACO(llvm::Module &module, std::string gfx_arch,\n+                       std::string gfx_triple, std::string gfx_features);\n \n } // namespace triton\n "}, {"filename": "include/triton/Tools/Sys/GetPlatform.hpp", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "file_content_changes": "@@ -20,27 +20,26 @@\n  */\n \n #ifndef TDL_TOOLS_SYS_GETPLATFORM_HPP\n-#define TDL_TOOLS_SYS__GETPLATFORM_HPP\n+#define TDL_TOOLS_SYS_GETPLATFORM_HPP\n \n #include <algorithm>\n #include <cstdlib>\n-#include <string>\n #include <iostream>\n #include <map>\n #include <memory>\n-\n-\n+#include <string>\n \n inline std::map<std::string, bool> cache{};\n inline bool isROCM() {\n   // only need to run function once after that return cached value\n   if (cache.find(\"isROCM\") != cache.end()) {\n-      return cache[\"isROCM\"];\n+    return cache[\"isROCM\"];\n   }\n \n   // run command\n   std::string cmd = \"apt-cache show rocm-libs | grep 'Package:'\";\n-  std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), \"r\"), pclose);\n+  std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), \"r\"),\n+                                                pclose);\n   if (!pipe) {\n     std::cout << (\"cmd failed!\") << std::endl;\n   }\n@@ -54,7 +53,7 @@ inline bool isROCM() {\n \n   // check ROCM that is found\n   cache[\"isROCM\"] = result.find(\"rocm\") != std::string::npos;\n-  return cache[\"isROCM\"] ;\n+  return cache[\"isROCM\"];\n }\n \n #endif"}, {"filename": "lib/Conversion/TritonGPUToLLVM/GCNAsmFormat.cpp", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "file_content_changes": "@@ -27,7 +27,8 @@ GCNBuilder::Operand *GCNBuilder::newOperand(StringRef constraint) {\n   return opr;\n }\n \n-GCNBuilder::Modifier *GCNBuilder::newModifier(StringRef modifier, StringRef arg) {\n+GCNBuilder::Modifier *GCNBuilder::newModifier(StringRef modifier,\n+                                              StringRef arg) {\n   assert(!modifier.empty());\n   auto *mod = newModifier();\n   mod->modifier = modifier;\n@@ -134,13 +135,15 @@ std::string GCNBuilder::dump() const {\n   return strJoin(lines, \"\\n\\t\");\n }\n \n-GCNInstrExecution &GCNInstrCommon::call(ArrayRef<Operand *> oprs, ArrayRef<Modifier *> mods) {\n+GCNInstrExecution &GCNInstrCommon::call(ArrayRef<Operand *> oprs,\n+                                        ArrayRef<Modifier *> mods) {\n   builder->executions.emplace_back(\n       std::make_unique<GCNInstrExecution>(this, oprs, mods));\n   return *builder->executions.back();\n }\n \n-GCNInstrExecution &GCNInstrCommon::operator()(ArrayRef<Operand *> oprs, ArrayRef<Modifier *> mods) {\n+GCNInstrExecution &GCNInstrCommon::operator()(ArrayRef<Operand *> oprs,\n+                                              ArrayRef<Modifier *> mods) {\n   return call(oprs, mods);\n }\n \n@@ -158,7 +161,7 @@ std::string GCNInstrExecution::dump() const {\n   std::string argsRepr = strJoin(argReprs, \", \");\n \n   llvm::SmallVector<std::string, 4> modReprs;\n-  for(auto *mod : mods) {\n+  for (auto *mod : mods) {\n     modReprs.push_back(mod->dump());\n   }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/PTXAsmFormat.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,7 +1,7 @@\n #include \"triton/Conversion/TritonGPUToLLVM/PTXAsmFormat.h\"\n-#include \"triton/Conversion/TritonGPUToLLVM/AsmFormat.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/Transforms/DialectConversion.h\"\n+#include \"triton/Conversion/TritonGPUToLLVM/AsmFormat.h\"\n #include \"llvm/Support/raw_ostream.h\"\n // TODO(Superjomn): unify to llvm::raw_string_ostream\n #include <sstream>"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "file_content_changes": "@@ -120,11 +120,11 @@ struct FuncOpConversion : public FuncOpConversionBase {\n     // Set an attribute to indicate this function is a kernel entry.\n     newFuncOp->setAttr(\"nvvm.kernel\",\n                        rewriter.getIntegerAttr(type::u1Ty(ctx), 1));\n-    if(!isROCM()){\n+    if (!isROCM()) {\n       // Set an attribute for maxntidx, it could be used in latter LLVM codegen\n       // for `nvvm.annotation` metadata.\n       newFuncOp->setAttr(\"nvvm.maxntid\",\n-                        rewriter.getIntegerAttr(i32_ty, 32 * numWarps));\n+                         rewriter.getIntegerAttr(i32_ty, 32 * numWarps));\n     }\n \n     rewriter.eraseOp(funcOp);\n@@ -226,11 +226,12 @@ class ConvertTritonGPUToLLVM\n     populatePatterns1(populateLoadStoreOpToLLVMPatterns);\n     populatePatterns1(populateReduceOpToLLVMPatterns);\n     populatePatterns2(populateViewOpToLLVMPatterns);\n-   \n-     // Native lowering patterns\n+\n+    // Native lowering patterns\n     if (isROCM()) {\n-      mlir::populateGpuToROCDLConversionPatterns(typeConverter, patterns, mlir::gpu::amd::HIP);\n-    }else{\n+      mlir::populateGpuToROCDLConversionPatterns(typeConverter, patterns,\n+                                                 mlir::gpu::amd::HIP);\n+    } else {\n       mlir::populateGpuToNVVMConversionPatterns(typeConverter, patterns);\n     }\n \n@@ -244,7 +245,8 @@ class ConvertTritonGPUToLLVM\n       RewritePatternSet gcnPatterns(context);\n       populateElementwiseOpToPTXPatterns(typeConverter, gcnPatterns,\n                                          /*benefits=*/10);\n-      if (failed(applyPartialConversion(mod, gcnTarget, std::move(gcnPatterns))))\n+      if (failed(\n+              applyPartialConversion(mod, gcnTarget, std::move(gcnPatterns))))\n         return signalPassFailure();\n     } else {\n       // Use our custom converters to convert some operations to PTX to avoid\n@@ -256,10 +258,10 @@ class ConvertTritonGPUToLLVM\n       // Add patterns to convert LLVM to PTX\n       populateElementwiseOpToPTXPatterns(typeConverter, ptxPatterns,\n                                          /*benefits=*/10);\n-      if (failed(applyPartialConversion(mod, ptxTarget, std::move(ptxPatterns))))\n+      if (failed(\n+              applyPartialConversion(mod, ptxTarget, std::move(ptxPatterns))))\n         return signalPassFailure();\n     }\n-\n   }\n \n private:"}, {"filename": "lib/Target/HSACO/HSACOTranslation.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -133,12 +133,12 @@ std::string generate_hsaco(llvm::Module *module, const std::string &triple,\n   std::string hsaco_path = kernel_name + std::string(\".hsaco\");\n \n   std::string error_message;\n-  std::string lld_path = ::triton::tools::getenv(\"ROCM_PATH\") + \"/llvm/bin/ld.lld\";\n-  int lld_result =\n-      llvm::sys::ExecuteAndWait(lld_path,\n-                                {lld_path, \"-flavor\", \"gnu\",\n-                                 \"-shared\", \"-o\", hsaco_path, isabin_path},\n-                                std::nullopt, {}, 0, 0, &error_message);\n+  std::string lld_path =\n+      ::triton::tools::getenv(\"ROCM_PATH\") + \"/llvm/bin/ld.lld\";\n+  int lld_result = llvm::sys::ExecuteAndWait(\n+      lld_path,\n+      {lld_path, \"-flavor\", \"gnu\", \"-shared\", \"-o\", hsaco_path, isabin_path},\n+      std::nullopt, {}, 0, 0, &error_message);\n   if (lld_result) {\n     std::cout << \"ld.lld execute fail: \" << std::endl;\n     std::cout << error_message << std::endl;"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "file_content_changes": "@@ -16,10 +16,10 @@\n #include \"triton/Conversion/TritonGPUToLLVM/ArithToIndexPass.h\"\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h\"\n #include \"triton/Tools/Sys/GetEnv.hpp\"\n+#include \"triton/Tools/Sys/GetPlatform.hpp\"\n #include \"llvm/ADT/APInt.h\"\n #include \"llvm/ADT/STLExtras.h\"\n #include \"llvm/ADT/SmallVector.h\"\n-#include \"triton/Tools/Sys/GetPlatform.hpp\"\n #include \"llvm/IR/CallingConv.h\"\n #include \"llvm/IR/Constants.h\"\n #include \"llvm/IRReader/IRReader.h\"\n@@ -230,7 +230,7 @@ static bool linkExternLib(llvm::Module &module, llvm::StringRef name,\n   }\n \n   // check if ROCM\n-  if (!isROCM()){\n+  if (!isROCM()) {\n     if (name == \"libdevice\") {\n       linkLibdevice(module);\n     } else {\n@@ -332,9 +332,10 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n   if (::triton::tools::getBoolEnv(\"LLVM_IR_ENABLE_DUMP\")) {\n     std::string mod_string;\n     std::unique_ptr<llvm::raw_string_ostream> ir_ss(\n-           new llvm::raw_string_ostream(mod_string));\n+        new llvm::raw_string_ostream(mod_string));\n     llvmIR->print(*ir_ss, nullptr);\n-    std::cout << \"// -----// LLVM IR Dump //----- //\\n\" << mod_string << std::endl;\n+    std::cout << \"// -----// LLVM IR Dump //----- //\\n\"\n+              << mod_string << std::endl;\n   }\n \n   return llvmIR;"}, {"filename": "python/setup.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -222,7 +222,6 @@ def build_extension(self, ext):\n     install_requires=[\n         \"cmake>=3.20\",\n         \"filelock\",\n-        \"torch\",\n         \"lit\",\n     ],\n     package_data={\"triton\": [\"third_party/**/*\"]},"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "file_content_changes": "@@ -23,9 +23,9 @@\n #include \"triton/Dialect/Triton/IR/Types.h\"\n #include \"triton/Dialect/Triton/Transforms/Passes.h\"\n #include \"triton/Dialect/TritonGPU/Transforms/Passes.h\"\n+#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"triton/Target/LLVMIR/LLVMIRTranslation.h\"\n #include \"triton/Target/PTX/PTXTranslation.h\"\n-#include \"triton/Target/HSACO/HSACOTranslation.h\"\n #include \"triton/Tools/Sys/GetEnv.hpp\"\n #include \"triton/Tools/Sys/GetPlatform.hpp\"\n \n@@ -902,22 +902,22 @@ void init_triton_ir(py::module &&m) {\n            [](mlir::OpBuilder &self, mlir::Value &lhs,\n               mlir::Value &rhs) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-               return mlir::Value(\n-                   self.create<mlir::arith::ShLIOp>(loc, lhs, rhs));\n+             return mlir::Value(\n+                 self.create<mlir::arith::ShLIOp>(loc, lhs, rhs));\n            })\n       .def(\"create_lshr\",\n            [](mlir::OpBuilder &self, mlir::Value &lhs,\n               mlir::Value &rhs) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-               return mlir::Value(\n-                   self.create<mlir::arith::ShRUIOp>(loc, lhs, rhs));\n+             return mlir::Value(\n+                 self.create<mlir::arith::ShRUIOp>(loc, lhs, rhs));\n            })\n       .def(\"create_ashr\",\n            [](mlir::OpBuilder &self, mlir::Value &lhs,\n               mlir::Value &rhs) -> mlir::Value {\n              auto loc = self.getUnknownLoc();\n-               return mlir::Value(\n-                   self.create<mlir::arith::ShRSIOp>(loc, lhs, rhs));\n+             return mlir::Value(\n+                 self.create<mlir::arith::ShRSIOp>(loc, lhs, rhs));\n            })\n       // AddPtr (similar to GEP)\n       .def(\"create_addptr\",\n@@ -1592,8 +1592,8 @@ void init_triton_translation(py::module &m) {\n \n   m.def(\n       \"translate_llvmir_to_hsaco\",\n-      [](const std::string llvmIR, std::string gfx_arch, std::string gfx_triple, \n-          std::string gfx_features) -> std::tuple<std::string, std::string> {\n+      [](const std::string llvmIR, std::string gfx_arch, std::string gfx_triple,\n+         std::string gfx_features) -> std::tuple<std::string, std::string> {\n         // create LLVM module from C++\n         llvm::LLVMContext context;\n         std::unique_ptr<llvm::MemoryBuffer> buffer =\n@@ -1602,7 +1602,8 @@ void init_triton_translation(py::module &m) {\n         std::unique_ptr<llvm::Module> module =\n             llvm::parseIR(buffer->getMemBufferRef(), error, context);\n         // translate module to HSACO\n-        auto hsacoCode = triton::translateLLVMIRToHSACO(*module, gfx_arch, gfx_triple, gfx_features);\n+        auto hsacoCode = triton::translateLLVMIRToHSACO(\n+            *module, gfx_arch, gfx_triple, gfx_features);\n         return hsacoCode;\n       },\n       ret::take_ownership);"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "file_content_changes": "@@ -27,13 +27,15 @@\n from . import impl\n from .tools.disasm import extract\n \n+\n def static_vars(**kwargs):\n     def decorate(func):\n         for k in kwargs:\n             setattr(func, k, kwargs[k])\n         return func\n     return decorate\n \n+\n def str_to_ty(name):\n     if name[0] == \"*\":\n         ty = str_to_ty(name[1:])\n@@ -1094,6 +1096,7 @@ def ptx_get_kernel_name(ptx: str) -> str:\n         if line.startswith('// .globl'):\n             return line.split()[-1]\n \n+\n def amdgcn_get_kernel_name(amdgcn: str) -> str:\n     '''\n     Get kernel name from AMDGCN code.\n@@ -1545,10 +1548,12 @@ def quiet():\n     finally:\n         sys.stdout, sys.stderr = old_stdout, old_stderr\n \n+\n @functools.lru_cache()\n def rocm_path_dir():\n     return os.getenv(\"ROCM_PATH\", default=\"/opt/rocm\")\n \n+\n def _build(name, src, srcdir):\n     if torch.version.hip is not None:\n         hip_lib_dir = os.path.join(rocm_path_dir(), \"lib\")\n@@ -1661,6 +1666,7 @@ def read_or_execute(cache_manager, force_compile, file_name, metadata,\n     cache_manager.put(data, file_name, True if isinstance(data, bytes) else data)\n     return module, md5, True, False\n \n+\n def get_amdgpu_arch_fulldetails():\n     \"\"\"\n     get the amdgpu fulll ISA details for compiling:\n@@ -1678,9 +1684,10 @@ def get_amdgpu_arch_fulldetails():\n             arch_features = \"+\" + re.search('\\\\w+', arch_name_features[1]).group(0) + \",\"\\\n                             \"-\" + re.search('\\\\w+', arch_name_features[2]).group(0)\n         return [arch_triple, arch_name, arch_features]\n-    except:\n+    except BaseException:\n         return None\n \n+\n def make_stub(name, signature, constants):\n     # name of files that are cached\n     so_cache_key = make_so_cache_key(triton.runtime.jit.version_key(), signature, constants)\n@@ -1762,7 +1769,7 @@ def _is_jsonable(x):\n # def compile(fn, signature: str, device: int = -1, constants=dict(), num_warps: int = 4, num_stages: int = 3, extern_libs=None, configs=None):\n \n \n-@static_vars(discovered_gfx_arch_fulldetails = get_amdgpu_arch_fulldetails())\n+@static_vars(discovered_gfx_arch_fulldetails=get_amdgpu_arch_fulldetails())\n def compile(fn, **kwargs):\n     capability = kwargs.get(\"cc\", None)\n     if capability is None:\n@@ -1788,7 +1795,7 @@ def compile(fn, **kwargs):\n \n         for key in list(extern_libs):\n             if extern_libs[key] == '' or extern_libs[key] is None:\n-               extern_libs.pop(key)\n+                extern_libs.pop(key)\n \n         gfx_arch_full_details = compile.discovered_gfx_arch_fulldetails\n         gfx_arch = os.environ.get('MI_GPU_ARCH', gfx_arch_full_details[1])\n@@ -1804,8 +1811,8 @@ def compile(fn, **kwargs):\n                      lambda src: ttgir_to_llir(src, extern_libs, capability)),\n             \"amdgcn\": (lambda path: Path(path).read_text(),\n                        lambda src: llir_to_amdgcn_and_hsaco(src, gfx_arch,\n-                                                        gfx_arch_full_details[0],\n-                                                        gfx_arch_full_details[2])),\n+                                                            gfx_arch_full_details[0],\n+                                                            gfx_arch_full_details[2])),\n         }\n     else:\n         stages = {\n@@ -1914,42 +1921,45 @@ def compile(fn, **kwargs):\n     # return handle to compiled kernel\n     return CompiledKernel(fn, so_path, metadata, asm)\n \n-@static_vars(discovered_gfx_arch_fulldetails = get_amdgpu_arch_fulldetails())\n+\n+@static_vars(discovered_gfx_arch_fulldetails=get_amdgpu_arch_fulldetails())\n def _get_amdgcn_bitcode_paths():\n-  if torch.version.hip is not None:\n-      gpu_arch_agnostic_bitcode_libraries = [\"opencl.bc\",\n-                                             \"ocml.bc\",\n-                                             \"ockl.bc\",\n-                                             \"oclc_finite_only_off.bc\",\n-                                             \"oclc_daz_opt_off.bc\",\n-                                             \"oclc_correctly_rounded_sqrt_on.bc\",\n-                                             \"oclc_unsafe_math_off.bc\",\n-                                             \"oclc_wavefrontsize64_on.bc\"]\n-    \n-      gfx_arch = _get_amdgcn_bitcode_paths.discovered_gfx_arch_fulldetails[1]\n-      gfx_arch_id = re.search('gfx(\\\\w+)', gfx_arch).group(1).strip()\n-\n-      gpu_arch_specific_bitcode_library = 'oclc_isa_version_' + gfx_arch_id + \".bc\"\n-      bitcode_path_dir = os.path.join(Path(__file__).parent.resolve(), \"third_party/rocm/lib/bitcode/\")\n-\n-      amdgcn_bitcode_paths = {}\n-      i = 1\n-      for bc_lib in gpu_arch_agnostic_bitcode_libraries:\n-        bc_path = bitcode_path_dir + bc_lib\n-        if os.path.exists(bc_path):\n-            amdgcn_bitcode_paths['library_' + str(i)] = bc_path\n-            i += 1\n-      bc_gfx_path = bitcode_path_dir + gpu_arch_specific_bitcode_library\n-      if os.path.exists(bc_gfx_path):\n-        amdgcn_bitcode_paths['library_' + str(i)] = bc_gfx_path\n-    \n-      return amdgcn_bitcode_paths\n-  else:\n-      return {}\n-\n-@static_vars(amdgcn_bitcode_paths = _get_amdgcn_bitcode_paths())\n+    if torch.version.hip is not None:\n+        gpu_arch_agnostic_bitcode_libraries = [\"opencl.bc\",\n+                                               \"ocml.bc\",\n+                                               \"ockl.bc\",\n+                                               \"oclc_finite_only_off.bc\",\n+                                               \"oclc_daz_opt_off.bc\",\n+                                               \"oclc_correctly_rounded_sqrt_on.bc\",\n+                                               \"oclc_unsafe_math_off.bc\",\n+                                               \"oclc_wavefrontsize64_on.bc\"]\n+\n+        gfx_arch = _get_amdgcn_bitcode_paths.discovered_gfx_arch_fulldetails[1]\n+        gfx_arch_id = re.search('gfx(\\\\w+)', gfx_arch).group(1).strip()\n+\n+        gpu_arch_specific_bitcode_library = 'oclc_isa_version_' + gfx_arch_id + \".bc\"\n+        bitcode_path_dir = os.path.join(Path(__file__).parent.resolve(), \"third_party/rocm/lib/bitcode/\")\n+\n+        amdgcn_bitcode_paths = {}\n+        i = 1\n+        for bc_lib in gpu_arch_agnostic_bitcode_libraries:\n+            bc_path = bitcode_path_dir + bc_lib\n+            if os.path.exists(bc_path):\n+                amdgcn_bitcode_paths['library_' + str(i)] = bc_path\n+                i += 1\n+        bc_gfx_path = bitcode_path_dir + gpu_arch_specific_bitcode_library\n+        if os.path.exists(bc_gfx_path):\n+            amdgcn_bitcode_paths['library_' + str(i)] = bc_gfx_path\n+\n+        return amdgcn_bitcode_paths\n+    else:\n+        return {}\n+\n+\n+@static_vars(amdgcn_bitcode_paths=_get_amdgcn_bitcode_paths())\n def get_amdgcn_bitcode_paths():\n-  return get_amdgcn_bitcode_paths.amdgcn_bitcode_paths\n+    return get_amdgcn_bitcode_paths.amdgcn_bitcode_paths\n+\n \n class CompiledKernel:\n \n@@ -2179,15 +2189,19 @@ def init_cuda_utils():\n     if cuda_utils is None:\n         cuda_utils = CudaUtils()\n \n+\n cuda_utils = None\n \n+\n def init_hip_utils():\n     global hip_utils\n     if hip_utils is None:\n         hip_utils = HIPUtils()\n \n+\n hip_utils = None\n \n+\n class HIPUtils(object):\n     def __new__(cls):\n         if not hasattr(cls, 'instance'):"}, {"filename": "python/triton/language/libdevice.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -1,4 +1,5 @@\n import os\n+\n import torch\n \n from .. import impl\n@@ -10,6 +11,7 @@\n     LOCAL_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"third_party\", \"cuda\", \"lib\", \"libdevice.10.bc\")\n LIBDEVICE_PATH = os.getenv(\"TRITON_LIBDEVICE_PATH\", LOCAL_PATH)\n \n+\n @impl.extern\n def clz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],"}, {"filename": "python/triton/tools/aot.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -72,7 +72,7 @@\n \n         # triton-ir -> triton-gpu-ir\n         # use compute_capability == 80\n-        module = triton.compiler.ttir_to_ttgir(module, num_warps=args.num_warps) # num_stages=3, compute_capability=80)\n+        module = triton.compiler.ttir_to_ttgir(module, num_warps=args.num_warps)  # num_stages=3, compute_capability=80)\n         module = triton.compiler.optimize_ttgir(module, num_stages=3, compute_capability=80)\n         # triton-gpu-ir -> llvm-ir\n         # use compute_capability == 80"}]