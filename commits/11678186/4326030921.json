[{"filename": "bin/CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "file_content_changes": "@@ -1,7 +1,3 @@\n-add_subdirectory(FileCheck)\n-# add_llvm_executable(FileCheck FileCheck/FileCheck.cpp)\n-# target_link_libraries(FileCheck PRIVATE LLVMFileCheck LLVMSupport)\n-\n get_property(dialect_libs GLOBAL PROPERTY MLIR_DIALECT_LIBS)\n get_property(conversion_libs GLOBAL PROPERTY MLIR_CONVERSION_LIBS)\n "}, {"filename": "bin/FileCheck/CMakeLists.txt", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -1,2 +0,0 @@\n-add_llvm_executable(FileCheck FileCheck.cpp)\n-target_link_libraries(FileCheck PRIVATE LLVMFileCheck LLVMSupport)\n\\ No newline at end of file"}, {"filename": "bin/FileCheck/FileCheck.cpp", "status": "removed", "additions": 0, "deletions": 885, "changes": 885, "file_content_changes": "@@ -1,885 +0,0 @@\n-//===- FileCheck.cpp - Check that File's Contents match what is expected --===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// FileCheck does a line-by line check of a file that validates whether it\n-// contains the expected content.  This is useful for regression tests etc.\n-//\n-// This program exits with an exit status of 2 on error, exit status of 0 if\n-// the file matched the expected contents, and exit status of 1 if it did not\n-// contain the expected contents.\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#include \"llvm/FileCheck/FileCheck.h\"\n-#include \"llvm/Support/CommandLine.h\"\n-#include \"llvm/Support/InitLLVM.h\"\n-#include \"llvm/Support/Process.h\"\n-#include \"llvm/Support/SourceMgr.h\"\n-#include \"llvm/Support/WithColor.h\"\n-#include \"llvm/Support/raw_ostream.h\"\n-#include <cmath>\n-#include <map>\n-using namespace llvm;\n-\n-static cl::extrahelp FileCheckOptsEnv(\n-    \"\\nOptions are parsed from the environment variable FILECHECK_OPTS and\\n\"\n-    \"from the command line.\\n\");\n-\n-static cl::opt<std::string>\n-    CheckFilename(cl::Positional, cl::desc(\"<check-file>\"), cl::Optional);\n-\n-static cl::opt<std::string>\n-    InputFilename(\"input-file\", cl::desc(\"File to check (defaults to stdin)\"),\n-                  cl::init(\"-\"), cl::value_desc(\"filename\"));\n-\n-static cl::list<std::string> CheckPrefixes(\n-    \"check-prefix\",\n-    cl::desc(\"Prefix to use from check file (defaults to 'CHECK')\"));\n-static cl::alias CheckPrefixesAlias(\n-    \"check-prefixes\", cl::aliasopt(CheckPrefixes), cl::CommaSeparated,\n-    cl::NotHidden,\n-    cl::desc(\n-        \"Alias for -check-prefix permitting multiple comma separated values\"));\n-\n-static cl::list<std::string> CommentPrefixes(\n-    \"comment-prefixes\", cl::CommaSeparated, cl::Hidden,\n-    cl::desc(\"Comma-separated list of comment prefixes to use from check file\\n\"\n-             \"(defaults to 'COM,RUN'). Please avoid using this feature in\\n\"\n-             \"LLVM's LIT-based test suites, which should be easier to\\n\"\n-             \"maintain if they all follow a consistent comment style. This\\n\"\n-             \"feature is meant for non-LIT test suites using FileCheck.\"));\n-\n-static cl::opt<bool> NoCanonicalizeWhiteSpace(\n-    \"strict-whitespace\",\n-    cl::desc(\"Do not treat all horizontal whitespace as equivalent\"));\n-\n-static cl::opt<bool> IgnoreCase(\"ignore-case\",\n-                                cl::desc(\"Use case-insensitive matching\"));\n-\n-static cl::list<std::string> ImplicitCheckNot(\n-    \"implicit-check-not\",\n-    cl::desc(\"Add an implicit negative check with this pattern to every\\n\"\n-             \"positive check. This can be used to ensure that no instances of\\n\"\n-             \"this pattern occur which are not matched by a positive pattern\"),\n-    cl::value_desc(\"pattern\"));\n-\n-static cl::list<std::string>\n-    GlobalDefines(\"D\", cl::AlwaysPrefix,\n-                  cl::desc(\"Define a variable to be used in capture patterns.\"),\n-                  cl::value_desc(\"VAR=VALUE\"));\n-\n-static cl::opt<bool> AllowEmptyInput(\n-    \"allow-empty\", cl::init(false),\n-    cl::desc(\"Allow the input file to be empty. This is useful when making\\n\"\n-             \"checks that some error message does not occur, for example.\"));\n-\n-static cl::opt<bool> AllowUnusedPrefixes(\n-    \"allow-unused-prefixes\", cl::init(false), cl::ZeroOrMore,\n-    cl::desc(\"Allow prefixes to be specified but not appear in the test.\"));\n-\n-static cl::opt<bool> MatchFullLines(\n-    \"match-full-lines\", cl::init(false),\n-    cl::desc(\"Require all positive matches to cover an entire input line.\\n\"\n-             \"Allows leading and trailing whitespace if --strict-whitespace\\n\"\n-             \"is not also passed.\"));\n-\n-static cl::opt<bool> EnableVarScope(\n-    \"enable-var-scope\", cl::init(false),\n-    cl::desc(\"Enables scope for regex variables. Variables with names that\\n\"\n-             \"do not start with '$' will be reset at the beginning of\\n\"\n-             \"each CHECK-LABEL block.\"));\n-\n-static cl::opt<bool> AllowDeprecatedDagOverlap(\n-    \"allow-deprecated-dag-overlap\", cl::init(false),\n-    cl::desc(\"Enable overlapping among matches in a group of consecutive\\n\"\n-             \"CHECK-DAG directives.  This option is deprecated and is only\\n\"\n-             \"provided for convenience as old tests are migrated to the new\\n\"\n-             \"non-overlapping CHECK-DAG implementation.\\n\"));\n-\n-static cl::opt<bool> Verbose(\n-    \"v\", cl::init(false), cl::ZeroOrMore,\n-    cl::desc(\"Print directive pattern matches, or add them to the input dump\\n\"\n-             \"if enabled.\\n\"));\n-\n-static cl::opt<bool> VerboseVerbose(\n-    \"vv\", cl::init(false), cl::ZeroOrMore,\n-    cl::desc(\"Print information helpful in diagnosing internal FileCheck\\n\"\n-             \"issues, or add it to the input dump if enabled.  Implies\\n\"\n-             \"-v.\\n\"));\n-\n-// The order of DumpInputValue members affects their precedence, as documented\n-// for -dump-input below.\n-enum DumpInputValue {\n-  DumpInputNever,\n-  DumpInputFail,\n-  DumpInputAlways,\n-  DumpInputHelp\n-};\n-\n-static cl::list<DumpInputValue> DumpInputs(\n-    \"dump-input\",\n-    cl::desc(\"Dump input to stderr, adding annotations representing\\n\"\n-             \"currently enabled diagnostics.  When there are multiple\\n\"\n-             \"occurrences of this option, the <value> that appears earliest\\n\"\n-             \"in the list below has precedence.  The default is 'fail'.\\n\"),\n-    cl::value_desc(\"mode\"),\n-    cl::values(clEnumValN(DumpInputHelp, \"help\", \"Explain input dump and quit\"),\n-               clEnumValN(DumpInputAlways, \"always\", \"Always dump input\"),\n-               clEnumValN(DumpInputFail, \"fail\", \"Dump input on failure\"),\n-               clEnumValN(DumpInputNever, \"never\", \"Never dump input\")));\n-\n-// The order of DumpInputFilterValue members affects their precedence, as\n-// documented for -dump-input-filter below.\n-enum DumpInputFilterValue {\n-  DumpInputFilterError,\n-  DumpInputFilterAnnotation,\n-  DumpInputFilterAnnotationFull,\n-  DumpInputFilterAll\n-};\n-\n-static cl::list<DumpInputFilterValue> DumpInputFilters(\n-    \"dump-input-filter\",\n-    cl::desc(\"In the dump requested by -dump-input, print only input lines of\\n\"\n-             \"kind <value> plus any context specified by -dump-input-context.\\n\"\n-             \"When there are multiple occurrences of this option, the <value>\\n\"\n-             \"that appears earliest in the list below has precedence.  The\\n\"\n-             \"default is 'error' when -dump-input=fail, and it's 'all' when\\n\"\n-             \"-dump-input=always.\\n\"),\n-    cl::values(clEnumValN(DumpInputFilterAll, \"all\", \"All input lines\"),\n-               clEnumValN(DumpInputFilterAnnotationFull, \"annotation-full\",\n-                          \"Input lines with annotations\"),\n-               clEnumValN(DumpInputFilterAnnotation, \"annotation\",\n-                          \"Input lines with starting points of annotations\"),\n-               clEnumValN(DumpInputFilterError, \"error\",\n-                          \"Input lines with starting points of error \"\n-                          \"annotations\")));\n-\n-static cl::list<unsigned> DumpInputContexts(\n-    \"dump-input-context\", cl::value_desc(\"N\"),\n-    cl::desc(\"In the dump requested by -dump-input, print <N> input lines\\n\"\n-             \"before and <N> input lines after any lines specified by\\n\"\n-             \"-dump-input-filter.  When there are multiple occurrences of\\n\"\n-             \"this option, the largest specified <N> has precedence.  The\\n\"\n-             \"default is 5.\\n\"));\n-\n-typedef cl::list<std::string>::const_iterator prefix_iterator;\n-\n-static void DumpCommandLine(int argc, char **argv) {\n-  errs() << \"FileCheck command line: \";\n-  for (int I = 0; I < argc; I++)\n-    errs() << \" \" << argv[I];\n-  errs() << \"\\n\";\n-}\n-\n-struct MarkerStyle {\n-  /// The starting char (before tildes) for marking the line.\n-  char Lead;\n-  /// What color to use for this annotation.\n-  raw_ostream::Colors Color;\n-  /// A note to follow the marker, or empty string if none.\n-  std::string Note;\n-  /// Does this marker indicate inclusion by -dump-input-filter=error?\n-  bool FiltersAsError;\n-  MarkerStyle() {}\n-  MarkerStyle(char Lead, raw_ostream::Colors Color,\n-              const std::string &Note = \"\", bool FiltersAsError = false)\n-      : Lead(Lead), Color(Color), Note(Note), FiltersAsError(FiltersAsError) {\n-    assert((!FiltersAsError || !Note.empty()) &&\n-           \"expected error diagnostic to have note\");\n-  }\n-};\n-\n-static MarkerStyle GetMarker(FileCheckDiag::MatchType MatchTy) {\n-  switch (MatchTy) {\n-  case FileCheckDiag::MatchFoundAndExpected:\n-    return MarkerStyle('^', raw_ostream::GREEN);\n-  case FileCheckDiag::MatchFoundButExcluded:\n-    return MarkerStyle('!', raw_ostream::RED, \"error: no match expected\",\n-                       /*FiltersAsError=*/true);\n-  case FileCheckDiag::MatchFoundButWrongLine:\n-    return MarkerStyle('!', raw_ostream::RED, \"error: match on wrong line\",\n-                       /*FiltersAsError=*/true);\n-  case FileCheckDiag::MatchFoundButDiscarded:\n-    return MarkerStyle('!', raw_ostream::CYAN,\n-                       \"discard: overlaps earlier match\");\n-  case FileCheckDiag::MatchFoundErrorNote:\n-    // Note should always be overridden within the FileCheckDiag.\n-    return MarkerStyle('!', raw_ostream::RED,\n-                       \"error: unknown error after match\",\n-                       /*FiltersAsError=*/true);\n-  case FileCheckDiag::MatchNoneAndExcluded:\n-    return MarkerStyle('X', raw_ostream::GREEN);\n-  case FileCheckDiag::MatchNoneButExpected:\n-    return MarkerStyle('X', raw_ostream::RED, \"error: no match found\",\n-                       /*FiltersAsError=*/true);\n-  case FileCheckDiag::MatchNoneForInvalidPattern:\n-    return MarkerStyle('X', raw_ostream::RED,\n-                       \"error: match failed for invalid pattern\",\n-                       /*FiltersAsError=*/true);\n-  case FileCheckDiag::MatchFuzzy:\n-    return MarkerStyle('?', raw_ostream::MAGENTA, \"possible intended match\",\n-                       /*FiltersAsError=*/true);\n-  }\n-  llvm_unreachable_internal(\"unexpected match type\");\n-}\n-\n-static void DumpInputAnnotationHelp(raw_ostream &OS) {\n-  OS << \"The following description was requested by -dump-input=help to\\n\"\n-     << \"explain the input dump printed by FileCheck.\\n\"\n-     << \"\\n\"\n-     << \"Related command-line options:\\n\"\n-     << \"\\n\"\n-     << \"  - -dump-input=<value> enables or disables the input dump\\n\"\n-     << \"  - -dump-input-filter=<value> filters the input lines\\n\"\n-     << \"  - -dump-input-context=<N> adjusts the context of filtered lines\\n\"\n-     << \"  - -v and -vv add more annotations\\n\"\n-     << \"  - -color forces colors to be enabled both in the dump and below\\n\"\n-     << \"  - -help documents the above options in more detail\\n\"\n-     << \"\\n\"\n-     << \"These options can also be set via FILECHECK_OPTS.  For example, for\\n\"\n-     << \"maximum debugging output on failures:\\n\"\n-     << \"\\n\"\n-     << \"  $ FILECHECK_OPTS='-dump-input-filter=all -vv -color' ninja check\\n\"\n-     << \"\\n\"\n-     << \"Input dump annotation format:\\n\"\n-     << \"\\n\";\n-\n-  // Labels for input lines.\n-  OS << \"  - \";\n-  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"L:\";\n-  OS << \"     labels line number L of the input file\\n\"\n-     << \"           An extra space is added after each input line to represent\"\n-     << \" the\\n\"\n-     << \"           newline character\\n\";\n-\n-  // Labels for annotation lines.\n-  OS << \"  - \";\n-  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"T:L\";\n-  OS << \"    labels the only match result for either (1) a pattern of type T\"\n-     << \" from\\n\"\n-     << \"           line L of the check file if L is an integer or (2) the\"\n-     << \" I-th implicit\\n\"\n-     << \"           pattern if L is \\\"imp\\\" followed by an integer \"\n-     << \"I (index origin one)\\n\";\n-  OS << \"  - \";\n-  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"T:L'N\";\n-  OS << \"  labels the Nth match result for such a pattern\\n\";\n-\n-  // Markers on annotation lines.\n-  OS << \"  - \";\n-  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"^~~\";\n-  OS << \"    marks good match (reported if -v)\\n\"\n-     << \"  - \";\n-  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"!~~\";\n-  OS << \"    marks bad match, such as:\\n\"\n-     << \"           - CHECK-NEXT on same line as previous match (error)\\n\"\n-     << \"           - CHECK-NOT found (error)\\n\"\n-     << \"           - CHECK-DAG overlapping match (discarded, reported if \"\n-     << \"-vv)\\n\"\n-     << \"  - \";\n-  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"X~~\";\n-  OS << \"    marks search range when no match is found, such as:\\n\"\n-     << \"           - CHECK-NEXT not found (error)\\n\"\n-     << \"           - CHECK-NOT not found (success, reported if -vv)\\n\"\n-     << \"           - CHECK-DAG not found after discarded matches (error)\\n\"\n-     << \"  - \";\n-  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"?\";\n-  OS << \"      marks fuzzy match when no match is found\\n\";\n-\n-  // Elided lines.\n-  OS << \"  - \";\n-  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"...\";\n-  OS << \"    indicates elided input lines and annotations, as specified by\\n\"\n-     << \"           -dump-input-filter and -dump-input-context\\n\";\n-\n-  // Colors.\n-  OS << \"  - colors \";\n-  WithColor(OS, raw_ostream::GREEN, true) << \"success\";\n-  OS << \", \";\n-  WithColor(OS, raw_ostream::RED, true) << \"error\";\n-  OS << \", \";\n-  WithColor(OS, raw_ostream::MAGENTA, true) << \"fuzzy match\";\n-  OS << \", \";\n-  WithColor(OS, raw_ostream::CYAN, true, false) << \"discarded match\";\n-  OS << \", \";\n-  WithColor(OS, raw_ostream::CYAN, true, true) << \"unmatched input\";\n-  OS << \"\\n\";\n-}\n-\n-/// An annotation for a single input line.\n-struct InputAnnotation {\n-  /// The index of the match result across all checks\n-  unsigned DiagIndex;\n-  /// The label for this annotation.\n-  std::string Label;\n-  /// Is this the initial fragment of a diagnostic that has been broken across\n-  /// multiple lines?\n-  bool IsFirstLine;\n-  /// What input line (one-origin indexing) this annotation marks.  This might\n-  /// be different from the starting line of the original diagnostic if\n-  /// !IsFirstLine.\n-  unsigned InputLine;\n-  /// The column range (one-origin indexing, open end) in which to mark the\n-  /// input line.  If InputEndCol is UINT_MAX, treat it as the last column\n-  /// before the newline.\n-  unsigned InputStartCol, InputEndCol;\n-  /// The marker to use.\n-  MarkerStyle Marker;\n-  /// Whether this annotation represents a good match for an expected pattern.\n-  bool FoundAndExpectedMatch;\n-};\n-\n-/// Get an abbreviation for the check type.\n-static std::string GetCheckTypeAbbreviation(Check::FileCheckType Ty) {\n-  switch (Ty) {\n-  case Check::CheckPlain:\n-    if (Ty.getCount() > 1)\n-      return \"count\";\n-    return \"check\";\n-  case Check::CheckNext:\n-    return \"next\";\n-  case Check::CheckSame:\n-    return \"same\";\n-  case Check::CheckNot:\n-    return \"not\";\n-  case Check::CheckDAG:\n-    return \"dag\";\n-  case Check::CheckLabel:\n-    return \"label\";\n-  case Check::CheckEmpty:\n-    return \"empty\";\n-  case Check::CheckComment:\n-    return \"com\";\n-  case Check::CheckEOF:\n-    return \"eof\";\n-  case Check::CheckBadNot:\n-    return \"bad-not\";\n-  case Check::CheckBadCount:\n-    return \"bad-count\";\n-  case Check::CheckMisspelled:\n-    return \"misspelled\";\n-  case Check::CheckNone:\n-    llvm_unreachable(\"invalid FileCheckType\");\n-  }\n-  llvm_unreachable(\"unknown FileCheckType\");\n-}\n-\n-static void\n-BuildInputAnnotations(const SourceMgr &SM, unsigned CheckFileBufferID,\n-                      const std::pair<unsigned, unsigned> &ImpPatBufferIDRange,\n-                      const std::vector<FileCheckDiag> &Diags,\n-                      std::vector<InputAnnotation> &Annotations,\n-                      unsigned &LabelWidth) {\n-  struct CompareSMLoc {\n-    bool operator()(const SMLoc &LHS, const SMLoc &RHS) const {\n-      return LHS.getPointer() < RHS.getPointer();\n-    }\n-  };\n-  // How many diagnostics does each pattern have?\n-  std::map<SMLoc, unsigned, CompareSMLoc> DiagCountPerPattern;\n-  for (auto Diag : Diags)\n-    ++DiagCountPerPattern[Diag.CheckLoc];\n-  // How many diagnostics have we seen so far per pattern?\n-  std::map<SMLoc, unsigned, CompareSMLoc> DiagIndexPerPattern;\n-  // How many total diagnostics have we seen so far?\n-  unsigned DiagIndex = 0;\n-  // What's the widest label?\n-  LabelWidth = 0;\n-  for (auto DiagItr = Diags.begin(), DiagEnd = Diags.end(); DiagItr != DiagEnd;\n-       ++DiagItr) {\n-    InputAnnotation A;\n-    A.DiagIndex = DiagIndex++;\n-\n-    // Build label, which uniquely identifies this check result.\n-    unsigned CheckBufferID = SM.FindBufferContainingLoc(DiagItr->CheckLoc);\n-    auto CheckLineAndCol =\n-        SM.getLineAndColumn(DiagItr->CheckLoc, CheckBufferID);\n-    llvm::raw_string_ostream Label(A.Label);\n-    Label << GetCheckTypeAbbreviation(DiagItr->CheckTy) << \":\";\n-    if (CheckBufferID == CheckFileBufferID)\n-      Label << CheckLineAndCol.first;\n-    else if (ImpPatBufferIDRange.first <= CheckBufferID &&\n-             CheckBufferID < ImpPatBufferIDRange.second)\n-      Label << \"imp\" << (CheckBufferID - ImpPatBufferIDRange.first + 1);\n-    else\n-      llvm_unreachable(\"expected diagnostic's check location to be either in \"\n-                       \"the check file or for an implicit pattern\");\n-    if (DiagCountPerPattern[DiagItr->CheckLoc] > 1)\n-      Label << \"'\" << DiagIndexPerPattern[DiagItr->CheckLoc]++;\n-    LabelWidth = std::max((std::string::size_type)LabelWidth, A.Label.size());\n-\n-    A.Marker = GetMarker(DiagItr->MatchTy);\n-    if (!DiagItr->Note.empty()) {\n-      A.Marker.Note = DiagItr->Note;\n-      // It's less confusing if notes that don't actually have ranges don't have\n-      // markers.  For example, a marker for 'with \"VAR\" equal to \"5\"' would\n-      // seem to indicate where \"VAR\" matches, but the location we actually have\n-      // for the marker simply points to the start of the match/search range for\n-      // the full pattern of which the substitution is potentially just one\n-      // component.\n-      if (DiagItr->InputStartLine == DiagItr->InputEndLine &&\n-          DiagItr->InputStartCol == DiagItr->InputEndCol)\n-        A.Marker.Lead = ' ';\n-    }\n-    if (DiagItr->MatchTy == FileCheckDiag::MatchFoundErrorNote) {\n-      assert(!DiagItr->Note.empty() &&\n-             \"expected custom note for MatchFoundErrorNote\");\n-      A.Marker.Note = \"error: \" + A.Marker.Note;\n-    }\n-    A.FoundAndExpectedMatch =\n-        DiagItr->MatchTy == FileCheckDiag::MatchFoundAndExpected;\n-\n-    // Compute the mark location, and break annotation into multiple\n-    // annotations if it spans multiple lines.\n-    A.IsFirstLine = true;\n-    A.InputLine = DiagItr->InputStartLine;\n-    A.InputStartCol = DiagItr->InputStartCol;\n-    if (DiagItr->InputStartLine == DiagItr->InputEndLine) {\n-      // Sometimes ranges are empty in order to indicate a specific point, but\n-      // that would mean nothing would be marked, so adjust the range to\n-      // include the following character.\n-      A.InputEndCol =\n-          std::max(DiagItr->InputStartCol + 1, DiagItr->InputEndCol);\n-      Annotations.push_back(A);\n-    } else {\n-      assert(DiagItr->InputStartLine < DiagItr->InputEndLine &&\n-             \"expected input range not to be inverted\");\n-      A.InputEndCol = UINT_MAX;\n-      Annotations.push_back(A);\n-      for (unsigned L = DiagItr->InputStartLine + 1, E = DiagItr->InputEndLine;\n-           L <= E; ++L) {\n-        // If a range ends before the first column on a line, then it has no\n-        // characters on that line, so there's nothing to render.\n-        if (DiagItr->InputEndCol == 1 && L == E)\n-          break;\n-        InputAnnotation B;\n-        B.DiagIndex = A.DiagIndex;\n-        B.Label = A.Label;\n-        B.IsFirstLine = false;\n-        B.InputLine = L;\n-        B.Marker = A.Marker;\n-        B.Marker.Lead = '~';\n-        B.Marker.Note = \"\";\n-        B.InputStartCol = 1;\n-        if (L != E)\n-          B.InputEndCol = UINT_MAX;\n-        else\n-          B.InputEndCol = DiagItr->InputEndCol;\n-        B.FoundAndExpectedMatch = A.FoundAndExpectedMatch;\n-        Annotations.push_back(B);\n-      }\n-    }\n-  }\n-}\n-\n-static unsigned FindInputLineInFilter(\n-    DumpInputFilterValue DumpInputFilter, unsigned CurInputLine,\n-    const std::vector<InputAnnotation>::iterator &AnnotationBeg,\n-    const std::vector<InputAnnotation>::iterator &AnnotationEnd) {\n-  if (DumpInputFilter == DumpInputFilterAll)\n-    return CurInputLine;\n-  for (auto AnnotationItr = AnnotationBeg; AnnotationItr != AnnotationEnd;\n-       ++AnnotationItr) {\n-    switch (DumpInputFilter) {\n-    case DumpInputFilterAll:\n-      llvm_unreachable(\"unexpected DumpInputFilterAll\");\n-      break;\n-    case DumpInputFilterAnnotationFull:\n-      return AnnotationItr->InputLine;\n-    case DumpInputFilterAnnotation:\n-      if (AnnotationItr->IsFirstLine)\n-        return AnnotationItr->InputLine;\n-      break;\n-    case DumpInputFilterError:\n-      if (AnnotationItr->IsFirstLine && AnnotationItr->Marker.FiltersAsError)\n-        return AnnotationItr->InputLine;\n-      break;\n-    }\n-  }\n-  return UINT_MAX;\n-}\n-\n-/// To OS, print a vertical ellipsis (right-justified at LabelWidth) if it would\n-/// occupy less lines than ElidedLines, but print ElidedLines otherwise.  Either\n-/// way, clear ElidedLines.  Thus, if ElidedLines is empty, do nothing.\n-static void DumpEllipsisOrElidedLines(raw_ostream &OS, std::string &ElidedLines,\n-                                      unsigned LabelWidth) {\n-  if (ElidedLines.empty())\n-    return;\n-  unsigned EllipsisLines = 3;\n-  if (EllipsisLines < StringRef(ElidedLines).count('\\n')) {\n-    for (unsigned i = 0; i < EllipsisLines; ++i) {\n-      WithColor(OS, raw_ostream::BLACK, /*Bold=*/true)\n-          << right_justify(\".\", LabelWidth);\n-      OS << '\\n';\n-    }\n-  } else\n-    OS << ElidedLines;\n-  ElidedLines.clear();\n-}\n-\n-static void DumpAnnotatedInput(raw_ostream &OS, const FileCheckRequest &Req,\n-                               DumpInputFilterValue DumpInputFilter,\n-                               unsigned DumpInputContext,\n-                               StringRef InputFileText,\n-                               std::vector<InputAnnotation> &Annotations,\n-                               unsigned LabelWidth) {\n-  OS << \"Input was:\\n<<<<<<\\n\";\n-\n-  // Sort annotations.\n-  llvm::sort(Annotations,\n-             [](const InputAnnotation &A, const InputAnnotation &B) {\n-               // 1. Sort annotations in the order of the input lines.\n-               //\n-               // This makes it easier to find relevant annotations while\n-               // iterating input lines in the implementation below.  FileCheck\n-               // does not always produce diagnostics in the order of input\n-               // lines due to, for example, CHECK-DAG and CHECK-NOT.\n-               if (A.InputLine != B.InputLine)\n-                 return A.InputLine < B.InputLine;\n-               // 2. Sort annotations in the temporal order FileCheck produced\n-               // their associated diagnostics.\n-               //\n-               // This sort offers several benefits:\n-               //\n-               // A. On a single input line, the order of annotations reflects\n-               //    the FileCheck logic for processing directives/patterns.\n-               //    This can be helpful in understanding cases in which the\n-               //    order of the associated directives/patterns in the check\n-               //    file or on the command line either (i) does not match the\n-               //    temporal order in which FileCheck looks for matches for the\n-               //    directives/patterns (due to, for example, CHECK-LABEL,\n-               //    CHECK-NOT, or `--implicit-check-not`) or (ii) does match\n-               //    that order but does not match the order of those\n-               //    diagnostics along an input line (due to, for example,\n-               //    CHECK-DAG).\n-               //\n-               //    On the other hand, because our presentation format presents\n-               //    input lines in order, there's no clear way to offer the\n-               //    same benefit across input lines.  For consistency, it might\n-               //    then seem worthwhile to have annotations on a single line\n-               //    also sorted in input order (that is, by input column).\n-               //    However, in practice, this appears to be more confusing\n-               //    than helpful.  Perhaps it's intuitive to expect annotations\n-               //    to be listed in the temporal order in which they were\n-               //    produced except in cases the presentation format obviously\n-               //    and inherently cannot support it (that is, across input\n-               //    lines).\n-               //\n-               // B. When diagnostics' annotations are split among multiple\n-               //    input lines, the user must track them from one input line\n-               //    to the next.  One property of the sort chosen here is that\n-               //    it facilitates the user in this regard by ensuring the\n-               //    following: when comparing any two input lines, a\n-               //    diagnostic's annotations are sorted in the same position\n-               //    relative to all other diagnostics' annotations.\n-               return A.DiagIndex < B.DiagIndex;\n-             });\n-\n-  // Compute the width of the label column.\n-  const unsigned char *InputFilePtr = InputFileText.bytes_begin(),\n-                      *InputFileEnd = InputFileText.bytes_end();\n-  unsigned LineCount = InputFileText.count('\\n');\n-  if (InputFileEnd[-1] != '\\n')\n-    ++LineCount;\n-  unsigned LineNoWidth = std::log10(LineCount) + 1;\n-  // +3 below adds spaces (1) to the left of the (right-aligned) line numbers\n-  // on input lines and (2) to the right of the (left-aligned) labels on\n-  // annotation lines so that input lines and annotation lines are more\n-  // visually distinct.  For example, the spaces on the annotation lines ensure\n-  // that input line numbers and check directive line numbers never align\n-  // horizontally.  Those line numbers might not even be for the same file.\n-  // One space would be enough to achieve that, but more makes it even easier\n-  // to see.\n-  LabelWidth = std::max(LabelWidth, LineNoWidth) + 3;\n-\n-  // Print annotated input lines.\n-  unsigned PrevLineInFilter = 0; // 0 means none so far\n-  unsigned NextLineInFilter = 0; // 0 means uncomputed, UINT_MAX means none\n-  std::string ElidedLines;\n-  raw_string_ostream ElidedLinesOS(ElidedLines);\n-  ColorMode TheColorMode =\n-      WithColor(OS).colorsEnabled() ? ColorMode::Enable : ColorMode::Disable;\n-  if (TheColorMode == ColorMode::Enable)\n-    ElidedLinesOS.enable_colors(true);\n-  auto AnnotationItr = Annotations.begin(), AnnotationEnd = Annotations.end();\n-  for (unsigned Line = 1;\n-       InputFilePtr != InputFileEnd || AnnotationItr != AnnotationEnd; ++Line) {\n-    const unsigned char *InputFileLine = InputFilePtr;\n-\n-    // Compute the previous and next line included by the filter.\n-    if (NextLineInFilter < Line)\n-      NextLineInFilter = FindInputLineInFilter(DumpInputFilter, Line,\n-                                               AnnotationItr, AnnotationEnd);\n-    assert(NextLineInFilter && \"expected NextLineInFilter to be computed\");\n-    if (NextLineInFilter == Line)\n-      PrevLineInFilter = Line;\n-\n-    // Elide this input line and its annotations if it's not within the\n-    // context specified by -dump-input-context of an input line included by\n-    // -dump-input-filter.  However, in case the resulting ellipsis would occupy\n-    // more lines than the input lines and annotations it elides, buffer the\n-    // elided lines and annotations so we can print them instead.\n-    raw_ostream *LineOS = &OS;\n-    if ((!PrevLineInFilter || PrevLineInFilter + DumpInputContext < Line) &&\n-        (NextLineInFilter == UINT_MAX ||\n-         Line + DumpInputContext < NextLineInFilter))\n-      LineOS = &ElidedLinesOS;\n-    else {\n-      LineOS = &OS;\n-      DumpEllipsisOrElidedLines(OS, ElidedLinesOS.str(), LabelWidth);\n-    }\n-\n-    // Print right-aligned line number.\n-    WithColor(*LineOS, raw_ostream::BLACK, /*Bold=*/true, /*BF=*/false,\n-              TheColorMode)\n-        << format_decimal(Line, LabelWidth) << \": \";\n-\n-    // For the case where -v and colors are enabled, find the annotations for\n-    // good matches for expected patterns in order to highlight everything\n-    // else in the line.  There are no such annotations if -v is disabled.\n-    std::vector<InputAnnotation> FoundAndExpectedMatches;\n-    if (Req.Verbose && TheColorMode == ColorMode::Enable) {\n-      for (auto I = AnnotationItr; I != AnnotationEnd && I->InputLine == Line;\n-           ++I) {\n-        if (I->FoundAndExpectedMatch)\n-          FoundAndExpectedMatches.push_back(*I);\n-      }\n-    }\n-\n-    // Print numbered line with highlighting where there are no matches for\n-    // expected patterns.\n-    bool Newline = false;\n-    {\n-      WithColor COS(*LineOS, raw_ostream::SAVEDCOLOR, /*Bold=*/false,\n-                    /*BG=*/false, TheColorMode);\n-      bool InMatch = false;\n-      if (Req.Verbose)\n-        COS.changeColor(raw_ostream::CYAN, true, true);\n-      for (unsigned Col = 1; InputFilePtr != InputFileEnd && !Newline; ++Col) {\n-        bool WasInMatch = InMatch;\n-        InMatch = false;\n-        for (auto M : FoundAndExpectedMatches) {\n-          if (M.InputStartCol <= Col && Col < M.InputEndCol) {\n-            InMatch = true;\n-            break;\n-          }\n-        }\n-        if (!WasInMatch && InMatch)\n-          COS.resetColor();\n-        else if (WasInMatch && !InMatch)\n-          COS.changeColor(raw_ostream::CYAN, true, true);\n-        if (*InputFilePtr == '\\n') {\n-          Newline = true;\n-          COS << ' ';\n-        } else\n-          COS << *InputFilePtr;\n-        ++InputFilePtr;\n-      }\n-    }\n-    *LineOS << '\\n';\n-    unsigned InputLineWidth = InputFilePtr - InputFileLine;\n-\n-    // Print any annotations.\n-    while (AnnotationItr != AnnotationEnd && AnnotationItr->InputLine == Line) {\n-      WithColor COS(*LineOS, AnnotationItr->Marker.Color, /*Bold=*/true,\n-                    /*BG=*/false, TheColorMode);\n-      // The two spaces below are where the \": \" appears on input lines.\n-      COS << left_justify(AnnotationItr->Label, LabelWidth) << \"  \";\n-      unsigned Col;\n-      for (Col = 1; Col < AnnotationItr->InputStartCol; ++Col)\n-        COS << ' ';\n-      COS << AnnotationItr->Marker.Lead;\n-      // If InputEndCol=UINT_MAX, stop at InputLineWidth.\n-      for (++Col; Col < AnnotationItr->InputEndCol && Col <= InputLineWidth;\n-           ++Col)\n-        COS << '~';\n-      const std::string &Note = AnnotationItr->Marker.Note;\n-      if (!Note.empty()) {\n-        // Put the note at the end of the input line.  If we were to instead\n-        // put the note right after the marker, subsequent annotations for the\n-        // same input line might appear to mark this note instead of the input\n-        // line.\n-        for (; Col <= InputLineWidth; ++Col)\n-          COS << ' ';\n-        COS << ' ' << Note;\n-      }\n-      COS << '\\n';\n-      ++AnnotationItr;\n-    }\n-  }\n-  DumpEllipsisOrElidedLines(OS, ElidedLinesOS.str(), LabelWidth);\n-\n-  OS << \">>>>>>\\n\";\n-}\n-\n-int main(int argc, char **argv) {\n-  // Enable use of ANSI color codes because FileCheck is using them to\n-  // highlight text.\n-  llvm::sys::Process::UseANSIEscapeCodes(true);\n-\n-  InitLLVM X(argc, argv);\n-  cl::ParseCommandLineOptions(argc, argv, /*Overview*/ \"\", /*Errs*/ nullptr,\n-                              \"FILECHECK_OPTS\");\n-\n-  // Select -dump-input* values.  The -help documentation specifies the default\n-  // value and which value to choose if an option is specified multiple times.\n-  // In the latter case, the general rule of thumb is to choose the value that\n-  // provides the most information.\n-  DumpInputValue DumpInput =\n-      DumpInputs.empty()\n-          ? DumpInputFail\n-          : *std::max_element(DumpInputs.begin(), DumpInputs.end());\n-  DumpInputFilterValue DumpInputFilter;\n-  if (DumpInputFilters.empty())\n-    DumpInputFilter = DumpInput == DumpInputAlways ? DumpInputFilterAll\n-                                                   : DumpInputFilterError;\n-  else\n-    DumpInputFilter =\n-        *std::max_element(DumpInputFilters.begin(), DumpInputFilters.end());\n-  unsigned DumpInputContext = DumpInputContexts.empty()\n-                                  ? 5\n-                                  : *std::max_element(DumpInputContexts.begin(),\n-                                                      DumpInputContexts.end());\n-\n-  if (DumpInput == DumpInputHelp) {\n-    DumpInputAnnotationHelp(outs());\n-    return 0;\n-  }\n-  if (CheckFilename.empty()) {\n-    errs() << \"<check-file> not specified\\n\";\n-    return 2;\n-  }\n-\n-  FileCheckRequest Req;\n-  append_range(Req.CheckPrefixes, CheckPrefixes);\n-\n-  append_range(Req.CommentPrefixes, CommentPrefixes);\n-\n-  append_range(Req.ImplicitCheckNot, ImplicitCheckNot);\n-\n-  bool GlobalDefineError = false;\n-  for (StringRef G : GlobalDefines) {\n-    size_t EqIdx = G.find('=');\n-    if (EqIdx == std::string::npos) {\n-      errs() << \"Missing equal sign in command-line definition '-D\" << G\n-             << \"'\\n\";\n-      GlobalDefineError = true;\n-      continue;\n-    }\n-    if (EqIdx == 0) {\n-      errs() << \"Missing variable name in command-line definition '-D\" << G\n-             << \"'\\n\";\n-      GlobalDefineError = true;\n-      continue;\n-    }\n-    Req.GlobalDefines.push_back(G);\n-  }\n-  if (GlobalDefineError)\n-    return 2;\n-\n-  Req.AllowEmptyInput = AllowEmptyInput;\n-  Req.AllowUnusedPrefixes = AllowUnusedPrefixes;\n-  Req.EnableVarScope = EnableVarScope;\n-  Req.AllowDeprecatedDagOverlap = AllowDeprecatedDagOverlap;\n-  Req.Verbose = Verbose;\n-  Req.VerboseVerbose = VerboseVerbose;\n-  Req.NoCanonicalizeWhiteSpace = NoCanonicalizeWhiteSpace;\n-  Req.MatchFullLines = MatchFullLines;\n-  Req.IgnoreCase = IgnoreCase;\n-\n-  if (VerboseVerbose)\n-    Req.Verbose = true;\n-\n-  FileCheck FC(Req);\n-  if (!FC.ValidateCheckPrefixes())\n-    return 2;\n-\n-  Regex PrefixRE = FC.buildCheckPrefixRegex();\n-  std::string REError;\n-  if (!PrefixRE.isValid(REError)) {\n-    errs() << \"Unable to combine check-prefix strings into a prefix regular \"\n-              \"expression! This is likely a bug in FileCheck's verification of \"\n-              \"the check-prefix strings. Regular expression parsing failed \"\n-              \"with the following error: \"\n-           << REError << \"\\n\";\n-    return 2;\n-  }\n-\n-  SourceMgr SM;\n-\n-  // Read the expected strings from the check file.\n-  ErrorOr<std::unique_ptr<MemoryBuffer>> CheckFileOrErr =\n-      MemoryBuffer::getFileOrSTDIN(CheckFilename, /*IsText=*/true);\n-  if (std::error_code EC = CheckFileOrErr.getError()) {\n-    errs() << \"Could not open check file '\" << CheckFilename\n-           << \"': \" << EC.message() << '\\n';\n-    return 2;\n-  }\n-  MemoryBuffer &CheckFile = *CheckFileOrErr.get();\n-\n-  SmallString<4096> CheckFileBuffer;\n-  StringRef CheckFileText = FC.CanonicalizeFile(CheckFile, CheckFileBuffer);\n-\n-  unsigned CheckFileBufferID =\n-      SM.AddNewSourceBuffer(MemoryBuffer::getMemBuffer(\n-                                CheckFileText, CheckFile.getBufferIdentifier()),\n-                            SMLoc());\n-\n-  std::pair<unsigned, unsigned> ImpPatBufferIDRange;\n-  if (FC.readCheckFile(SM, CheckFileText, PrefixRE, &ImpPatBufferIDRange))\n-    return 2;\n-\n-  // Open the file to check and add it to SourceMgr.\n-  ErrorOr<std::unique_ptr<MemoryBuffer>> InputFileOrErr =\n-      MemoryBuffer::getFileOrSTDIN(InputFilename, /*IsText=*/true);\n-  if (InputFilename == \"-\")\n-    InputFilename = \"<stdin>\"; // Overwrite for improved diagnostic messages\n-  if (std::error_code EC = InputFileOrErr.getError()) {\n-    errs() << \"Could not open input file '\" << InputFilename\n-           << \"': \" << EC.message() << '\\n';\n-    return 2;\n-  }\n-  MemoryBuffer &InputFile = *InputFileOrErr.get();\n-\n-  if (InputFile.getBufferSize() == 0 && !AllowEmptyInput) {\n-    errs() << \"FileCheck error: '\" << InputFilename << \"' is empty.\\n\";\n-    DumpCommandLine(argc, argv);\n-    return 2;\n-  }\n-\n-  SmallString<4096> InputFileBuffer;\n-  StringRef InputFileText = FC.CanonicalizeFile(InputFile, InputFileBuffer);\n-\n-  SM.AddNewSourceBuffer(MemoryBuffer::getMemBuffer(\n-                            InputFileText, InputFile.getBufferIdentifier()),\n-                        SMLoc());\n-\n-  std::vector<FileCheckDiag> Diags;\n-  int ExitCode = FC.checkInput(SM, InputFileText,\n-                               DumpInput == DumpInputNever ? nullptr : &Diags)\n-                     ? EXIT_SUCCESS\n-                     : 1;\n-  if (DumpInput == DumpInputAlways ||\n-      (ExitCode == 1 && DumpInput == DumpInputFail)) {\n-    errs() << \"\\n\"\n-           << \"Input file: \" << InputFilename << \"\\n\"\n-           << \"Check file: \" << CheckFilename << \"\\n\"\n-           << \"\\n\"\n-           << \"-dump-input=help explains the following input dump.\\n\"\n-           << \"\\n\";\n-    std::vector<InputAnnotation> Annotations;\n-    unsigned LabelWidth;\n-    BuildInputAnnotations(SM, CheckFileBufferID, ImpPatBufferIDRange, Diags,\n-                          Annotations, LabelWidth);\n-    DumpAnnotatedInput(errs(), Req, DumpInputFilter, DumpInputContext,\n-                       InputFileText, Annotations, LabelWidth);\n-  }\n-\n-  return ExitCode;\n-}"}, {"filename": "python/setup.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -69,7 +69,7 @@ def get_llvm_package_info():\n     use_assert_enabled_llvm = check_env_flag(\"TRITON_USE_ASSERT_ENABLED_LLVM\", \"False\")\n     release_suffix = \"assert\" if use_assert_enabled_llvm else \"release\"\n     name = f'llvm+mlir-17.0.0-x86_64-{system_suffix}-{release_suffix}'\n-    url = f\"https://github.com/ptillet/triton-llvm-releases/releases/download/llvm-17.0.0-37b7a60cd74b/{name}.tar.xz\"\n+    url = f\"https://github.com/ptillet/triton-llvm-releases/releases/download/llvm-17.0.0-8e5a41e8271f/{name}.tar.xz\"\n     return Package(\"llvm\", name, url, \"lib\", \"LLVM_INCLUDE_DIRS\", \"LLVM_LIBRARY_DIR\", \"LLVM_SYSPATH\")\n \n "}]