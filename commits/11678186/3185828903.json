[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "file_content_changes": "@@ -1236,6 +1236,10 @@ def compile(fn, signature: str, device: int = -1, constants=dict(), num_warps: i\n \n class CompiledKernel:\n \n+    # Hooks for external tools to inspect triton kernels\n+    launch_enter_hook = None\n+    launch_exit_hook = None\n+\n     def __init__(self, fn_name, so_path, cache_dir, device):\n         # initialize launcher\n         import importlib.util\n@@ -1261,6 +1265,7 @@ def __init__(self, fn_name, so_path, cache_dir, device):\n             self.asm[\"ttir\"] = f.read()\n \n         mod, func, n_regs, n_spills = _triton.code_gen.load_binary(metadata[\"name\"], self.asm[\"cubin\"], self.shared, device)\n+        self.fn_name = fn_name\n         self.cu_module = mod\n         self.cu_function = func\n         self.n_regs = n_regs\n@@ -1270,7 +1275,14 @@ def __getitem__(self, grid):\n         def runner(*args, stream=None):\n             if stream is None:\n                 stream = torch.cuda.current_stream().cuda_stream\n+            if CompiledKernel.launch_enter_hook:\n+                hook_ret = CompiledKernel.launch_enter_hook(grid[0], grid[1], grid[2], stream, self)\n+            else:\n+                hook_ret = None\n             self.c_wrapper(grid[0], grid[1], grid[2], self.num_warps, self.shared, stream, self.cu_function, *args)\n+            if CompiledKernel.launch_exit_hook:\n+                CompiledKernel.launch_exit_hook(grid[0], grid[1], grid[2], stream, self, hook_ret)\n+\n         return runner\n \n     def get_sass(self, fun=None):"}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -250,15 +250,15 @@ def {self.fn.__name__}({', '.join(self.arg_names)}, grid, num_warps=4, num_stage\n     torch.cuda.set_device(device)\n     if stream is None and not warmup:\n       stream = get_cuda_stream(device)\n+    args = [{args}]\n     try:\n       bin = cache[key]\n       if not warmup:\n-          bin.c_wrapper(grid_0, grid_1, grid_2, bin.num_warps, bin.shared, stream, bin.cu_function, {args})\n+          bin[(grid_0, grid_1, grid_2)](*args, stream=stream)\n       return bin\n     # kernel not cached -- compile\n     except KeyError:\n       # build dict of constant values\n-      args = [{args}]\n       configs = self._get_config(*args),\n       constants = self._make_constants(constexpr_key)\n       constants.update({{i: None for i, arg in enumerate(args) if arg is None}})\n@@ -274,7 +274,7 @@ def {self.fn.__name__}({', '.join(self.arg_names)}, grid, num_warps=4, num_stage\n       if not self._call_hook(key, signature, device, constants, num_warps, num_stages, extern_libs, configs):\n         bin = triton.compile(self, signature, device, constants, num_warps, num_stages, extern_libs=extern_libs, configs=configs)\n         if not warmup:\n-            bin.c_wrapper(grid_0, grid_1, grid_2, bin.num_warps, bin.shared, stream, bin.cu_function, *args)\n+            bin[(grid_0, grid_1, grid_2)](*args, stream=stream)\n         self.cache[key] = bin\n         return bin\n       return None"}]