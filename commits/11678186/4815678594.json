[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "file_content_changes": "@@ -2087,6 +2087,7 @@ def _kernel(dst):\n @pytest.mark.parametrize(\"dtype_str, expr, lib_path\",\n                          [('int32', 'math.ffs', ''),\n                           ('float32', 'math.log2', ''),\n+                          ('float32', 'math.scalbn', ''),\n                           ('float32', 'math.pow', tl.math.libdevice_path()),\n                           ('float64', 'math.pow_dtype', tl.math.libdevice_path()),\n                           ('float64', 'math.norm4d', '')])\n@@ -2104,24 +2105,31 @@ def kernel(X, Y, BLOCK: tl.constexpr):\n     x = numpy_random(shape, dtype_str=dtype_str, rs=rs)\n \n     if expr == 'math.log2':\n-        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.broadcast_to(tl.math.log2(5.0), x.shape)'})\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': f'tl.broadcast_to(tl.{expr}(5.0), x.shape)'})\n         y_ref = np.log2(5.0)\n     elif expr == 'math.ffs':\n-        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.math.ffs(x)'})\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': f'tl.{expr}(x)'})\n         y_ref = np.zeros(shape, dtype=x.dtype)\n         for i in range(shape[0]):\n             y_ref[i] = (int(x[i]) & int(-x[i])).bit_length()\n+    elif expr == 'math.scalbn':\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': f'tl.{expr}(x, 2)'})\n+        y_ref = x * pow(2, 2)\n+    elif expr == 'math.pow_dtype':\n+        x = np.abs(x)\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': f'tl.math.pow(x, 0.5)'})\n+        y_ref = np.power(x, 0.5)\n     elif expr == 'math.pow':\n         # numpy does not allow negative factors in power, so we use abs()\n         x = np.abs(x)\n-        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.math.pow(x, x)'})\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': f'tl.{expr}(x, x)'})\n         y_ref = np.power(x, x)\n     elif expr == 'math.pow_dtype':\n         x = np.abs(x)\n         kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.math.pow(x, 0.5)'})\n         y_ref = np.power(x, 0.5)\n     elif expr == 'math.norm4d':\n-        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.math.norm4d(x, x, x, x)'})\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': f'tl.{expr}(x, x, x, x)'})\n         y_ref = np.sqrt(4 * np.power(x, 2))\n \n     x_tri = to_triton(x)\n@@ -2137,6 +2145,7 @@ def kernel(X, Y, BLOCK: tl.constexpr):\n \n @pytest.mark.parametrize(\"dtype_str, expr, lib_path\",\n                          [('float32', 'math.pow', ''),\n+                          ('float64', 'math.pow_dtype', ''),\n                           ('float64', 'math.pow', tl.math.libdevice_path())])\n def test_math_scalar(dtype_str, expr, lib_path):\n \n@@ -2153,9 +2162,14 @@ def kernel(X, Y, BLOCK: tl.constexpr):\n     y_ref = np.zeros(shape, dtype=x.dtype)\n \n     # numpy does not allow negative factors in power, so we use abs()\n-    x = np.abs(x)\n-    kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.math.pow(x, x)'})\n-    y_ref[:] = np.power(x, x)\n+    if expr == 'math.pow':\n+        x = np.abs(x)\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.math.pow(x, x)'})\n+        y_ref[:] = np.power(x, x)\n+    elif expr == 'math.pow_dtype':\n+        x = np.abs(x)\n+        kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': 'tl.math.pow(x, 0.5)'})\n+        y_ref[:] = np.power(x, 0.5)\n \n     # triton result\n     x_tri = to_triton(x)[0].item()"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "file_content_changes": "@@ -1582,27 +1582,36 @@ def extern_elementwise(lib_name: str, lib_path: str, args: list, arg_type_symbol\n         :param lib_path: the path of the library\n         :param args: the arguments of the function\n         :param arg_type_symbol_dict: the type of the arguments\n+        :param is_pure: whether the function is pure\n         :param _builder: the builder\n         :return: the return value of the function\n     '''\n     dispatch_args = args.copy()\n     all_scalar = True\n     ret_shape = None\n+    arg_types = []\n     for i in range(len(dispatch_args)):\n         dispatch_args[i] = _to_tensor(dispatch_args[i], _builder)\n+        arg_types.append(dispatch_args[i].dtype)\n         if dispatch_args[i].type.is_block():\n             all_scalar = False\n-    if not all_scalar:\n+    if len(arg_types) > 0:\n+        arg_types = tuple(arg_types)\n+        arithmetic_check = True\n+        # If there's a type tuple that is not supported by the library, we will do arithmetic check\n+        if arg_types in arg_type_symbol_dict:\n+            arithmetic_check = False\n         broadcast_arg = dispatch_args[0]\n         # Get the broadcast shape over all the arguments\n         for i, item in enumerate(dispatch_args):\n             _, broadcast_arg = semantic.binary_op_type_checking_impl(\n-                item, broadcast_arg, _builder)\n+                item, broadcast_arg, _builder, arithmetic_check=arithmetic_check)\n         # Change the shape of each argument based on the broadcast shape\n         for i in range(len(dispatch_args)):\n             dispatch_args[i], _ = semantic.binary_op_type_checking_impl(\n-                dispatch_args[i], broadcast_arg, _builder)\n-        ret_shape = broadcast_arg.shape\n+                dispatch_args[i], broadcast_arg, _builder, arithmetic_check=arithmetic_check)\n+        if not all_scalar:\n+            ret_shape = broadcast_arg.shape\n     func = getattr(_builder, \"create_extern_elementwise\")\n     return dispatch(func, lib_name, lib_path, dispatch_args, arg_type_symbol_dict, ret_shape, is_pure, _builder)\n "}, {"filename": "python/triton/tools/build_extern.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -287,7 +287,7 @@ def _output_stubs(self) -> str:\n         # @extern.extern\n         # def <op_name>(<args>, _builder=None):\n         #   arg_type_symbol_dict = {[arg_type]: {(symbol, ret_type)}}\n-        #   return extern.dispatch(\"libdevice\", <path>, <args>, <arg_type_symbol_dict>, _builder)\n+        #   return core.extern_elementwise(\"libdevice\", <path>, <args>, <arg_type_symbol_dict>, _builder)\n         import_str = \"from . import core\\n\"\n         import_str += \"import os\\n\"\n         import_str += \"import functools\\n\""}]