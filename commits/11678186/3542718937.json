[{"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 67, "deletions": 31, "changes": 98, "file_content_changes": "@@ -561,6 +561,7 @@ class RematerializeForward : public mlir::RewritePattern {\n // -----------------------------------------------------------------------------\n //\n // -----------------------------------------------------------------------------\n+namespace {\n static int computeCapabilityToMMAVersion(int computeCapability) {\n   if (computeCapability < 80) {\n     return 1;\n@@ -575,16 +576,68 @@ static int computeCapabilityToMMAVersion(int computeCapability) {\n static SmallVector<int64_t, 2>\n mmaVersionToShapePerWarp(int version, const ArrayRef<int64_t> &shape,\n                          int numWarps) {\n-  if (version == 1) {\n+  if (version == 1)\n     return {16, 16};\n-  } else if (version == 2) {\n+  else if (version == 2)\n     return {16, 8};\n-  } else {\n+  else {\n     assert(false && \"version not supported\");\n     return {0, 0};\n   }\n }\n \n+template <int version>\n+SmallVector<unsigned, 2> warpsPerTile(const ArrayRef<int64_t> shape,\n+                                      int numWarps);\n+\n+template <>\n+SmallVector<unsigned, 2> warpsPerTile<1>(const ArrayRef<int64_t> shape,\n+                                         int numWarps) {\n+  SmallVector<unsigned, 2> ret = {1, 1};\n+  SmallVector<int64_t, 2> shapePerWarp =\n+      mmaVersionToShapePerWarp(1, shape, numWarps);\n+  bool changed = false;\n+  do {\n+    changed = false;\n+    if (ret[0] * ret[1] < numWarps) {\n+      ret[0] = std::clamp<unsigned>(ret[0] * 2, 1, shape[0] / shapePerWarp[0]);\n+      changed = true;\n+    }\n+    if (ret[0] * ret[1] < numWarps) {\n+      ret[1] = std::clamp<unsigned>(ret[1] * 2, 1, shape[1] / shapePerWarp[1]);\n+      changed = true;\n+    }\n+  } while (changed);\n+  return ret;\n+}\n+\n+template <>\n+SmallVector<unsigned, 2> warpsPerTile<2>(const ArrayRef<int64_t> shape,\n+                                         int numWarps) {\n+  SmallVector<unsigned, 2> ret = {1, 1};\n+  SmallVector<int64_t, 2> shapePerWarp =\n+      mmaVersionToShapePerWarp(2, shape, numWarps);\n+  // TODO (@daadaada): double-check.\n+  // original logic in\n+  // https://github.com/openai/triton/blob/master/lib/codegen/analysis/layout.cc#L252\n+  // seems buggy for shape = [32, 16] ?\n+  do {\n+    if (ret[0] * ret[1] >= numWarps)\n+      break;\n+    if (shape[0] / shapePerWarp[0] / ret[0] >=\n+        shape[1] / (shapePerWarp[1] * 2) / ret[1]) {\n+      if (ret[0] < shape[0] / shapePerWarp[0]) {\n+        ret[0] *= 2;\n+      } else\n+        ret[1] *= 2;\n+    } else {\n+      ret[1] *= 2;\n+    }\n+  } while (true);\n+  return ret;\n+}\n+\n+} // namespace\n class BlockedToMMA : public mlir::RewritePattern {\n   int computeCapability;\n \n@@ -593,34 +646,17 @@ class BlockedToMMA : public mlir::RewritePattern {\n       : mlir::RewritePattern(triton::DotOp::getOperationName(), 2, context),\n         computeCapability(computeCapability) {}\n \n-  static SmallVector<unsigned, 2>\n-  getWarpsPerTile(const ArrayRef<int64_t> &shape, int version, int numWarps) {\n-    assert(version == 2);\n-    // TODO: Handle one warp per row for fused matmuls\n-    // TODO: unsigned -> int64_t to keep things uniform\n-    SmallVector<unsigned, 2> ret = {1, 1};\n-    SmallVector<int64_t, 2> shapePerWarp =\n-        mmaVersionToShapePerWarp(version, shape, numWarps);\n-    bool changed = false;\n-    // TODO (@daadaada): double-check.\n-    // original logic in\n-    // https://github.com/openai/triton/blob/master/lib/codegen/analysis/layout.cc#L252\n-    // seems buggy for shape = [32, 16] ?\n-    do {\n-      changed = false;\n-      if (ret[0] * ret[1] >= numWarps)\n-        break;\n-      if (shape[0] / shapePerWarp[0] / ret[0] >=\n-          shape[1] / (shapePerWarp[1] * 2) / ret[1]) {\n-        if (ret[0] < shape[0] / shapePerWarp[0]) {\n-          ret[0] *= 2;\n-        } else\n-          ret[1] *= 2;\n-      } else {\n-        ret[1] *= 2;\n-      }\n-    } while (true);\n-    return ret;\n+  static SmallVector<unsigned, 2> getWarpsPerTile(const ArrayRef<int64_t> shape,\n+                                                  int version, int numWarps) {\n+    switch (version) {\n+    case 1:\n+      return warpsPerTile<1>(shape, numWarps);\n+    case 2:\n+      return warpsPerTile<2>(shape, numWarps);\n+    default:\n+      assert(false && \"not supported version\");\n+      return {0, 0};\n+    }\n   }\n \n   mlir::LogicalResult"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -1416,7 +1416,8 @@ def compile(fn, **kwargs):\n         path = fn_cache_manager._make_path(f\"{name}.{ir}\")\n         if ir == ext:\n             next_module = parse(fn)\n-        elif os.path.exists(path) and\\\n+        elif os.path.exists(path) and \\\n+                ir in metadata[\"ctime\"] and \\\n                 os.path.getctime(path) == metadata[\"ctime\"][ir]:\n             next_module = parse(path)\n         else:"}]