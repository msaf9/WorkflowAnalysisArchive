[{"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.cpp", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "file_content_changes": "@@ -1,5 +1,6 @@\n #include \"DotOpHelpers.h\"\n #include \"TypeConverter.h\"\n+#include \"Utility.h\"\n \n namespace mlir {\n namespace LLVM {\n@@ -68,6 +69,8 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   auto shape = tensorTy.getShape();\n   auto order = sharedLayout.getOrder();\n \n+  RewriteEnvGuard guard(rewriter, loc);\n+\n   Value cSwizzleOffset = smemObj.getCSwizzleOffset(order[0]);\n   Value smemBase = smemObj.getBaseBeforeSwizzle(order[0], loc, rewriter);\n \n@@ -100,15 +103,14 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   // pre-compute pointer lanes\n   Value offA0 = isARow ? offsetAK : offsetAM;\n   Value offA1 = isARow ? offsetAM : offsetAK;\n-  Value phaseA = urem(udiv(offA1, i32_val(perPhaseA)), i32_val(maxPhaseA));\n-  offA0 = add(offA0, cSwizzleOffset);\n+  Value phaseA = offA1 / perPhaseA % maxPhaseA;\n+\n+  offA0 = offA0 + cSwizzleOffset;\n   SmallVector<Value> offA(numPtrA);\n   for (int i = 0; i < numPtrA; i++) {\n-    Value offA0I = add(offA0, i32_val(i * (isARow ? 4 : strideRepM)));\n-    offA0I = udiv(offA0I, i32_val(vecA));\n-    offA0I = xor_(offA0I, phaseA);\n-    offA0I = mul(offA0I, i32_val(vecA));\n-    offA[i] = add(mul(offA0I, strideA0), mul(offA1, strideA1));\n+    Value offA0I = offA0 + i * (isARow ? 4 : strideRepM);\n+    offA0I = ((offA0I / vecA) ^ phaseA) * vecA;\n+    offA[i] = offA0I * strideA0 + offA1 * strideA1;\n   }\n \n   Type elemX2Ty = vec_ty(f16_ty, 2);\n@@ -175,6 +177,7 @@ Value DotOpMmaV1ConversionHelper::loadB(\n     Value tensor, const SharedMemoryObject &smemObj, Value thread, Location loc,\n     TritonGPUToLLVMTypeConverter *typeConverter,\n     ConversionPatternRewriter &rewriter, Type resultTy) const {\n+  RewriteEnvGuard guard(rewriter, loc);\n   // smem\n   auto strides = smemObj.strides;\n \n@@ -213,17 +216,15 @@ Value DotOpMmaV1ConversionHelper::loadB(\n \n   Value offB0 = isBRow ? offsetBN : offsetBK;\n   Value offB1 = isBRow ? offsetBK : offsetBN;\n-  Value phaseB = urem(udiv(offB1, i32_val(perPhaseB)), i32_val(maxPhaseB));\n+  Value phaseB = (offB1 / perPhaseB) % maxPhaseB;\n   Value cSwizzleOffset = smemObj.getCSwizzleOffset(order[0]);\n \n-  offB0 = add(offB0, cSwizzleOffset);\n+  offB0 = offB0 + cSwizzleOffset;\n   SmallVector<Value> offB(numPtrB);\n   for (int i = 0; i < numPtrB; ++i) {\n-    Value offB0I = add(offB0, i32_val(i * (isBRow ? strideRepN : 4)));\n-    offB0I = udiv(offB0I, i32_val(vecB));\n-    offB0I = xor_(offB0I, phaseB);\n-    offB0I = mul(offB0I, i32_val(vecB));\n-    offB[i] = add(mul(offB0I, strideB0), mul(offB1, strideB1));\n+    Value offB0I = offB0 + i * (isBRow ? strideRepN : 4);\n+    offB0I = (offB0I / vecB ^ phaseB) * vecB;\n+    offB[i] = offB0I * strideB0 + offB1 * strideB1;\n   }\n \n   Type elemPtrTy = ptr_ty(f16_ty, 3);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -146,5 +146,7 @@ Value addStringToModule(Location loc, ConversionPatternRewriter &rewriter,\n   return stringStart;\n }\n \n+OPERATOR_FOR_EACH(OPERATOR_WITH_VALUE_DEF)\n+\n } // namespace LLVM\n } // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "file_content_changes": "@@ -265,6 +265,63 @@ Value shflSync(Location loc, ConversionPatternRewriter &rewriter, Value val,\n Value addStringToModule(Location loc, ConversionPatternRewriter &rewriter,\n                         StringRef key, StringRef content);\n \n+// Operator overriding begin\n+// @{\n+struct RewriteEnvGuard {\n+  PatternRewriter *oldPatternRewriter{};\n+  Location *oldLoc{};\n+\n+  RewriteEnvGuard(PatternRewriter &rewriter, Location &loc) {\n+    oldPatternRewriter = kPatternRewriter;\n+    oldLoc = kLoc;\n+\n+    kPatternRewriter = &rewriter;\n+    kLoc = &loc;\n+  }\n+\n+  ~RewriteEnvGuard() {\n+    kPatternRewriter = oldPatternRewriter;\n+    kLoc = oldLoc;\n+  }\n+\n+  static PatternRewriter *kPatternRewriter;\n+  static Location *kLoc;\n+};\n+\n+#define OPERATOR_FOR_EACH(__fn)                                                \\\n+  __fn(+, add) __fn(-, sub) __fn(*, mul) __fn(/, udiv) __fn(^, xor_)           \\\n+      __fn(%, urem)\n+\n+#define OPERATOR_WITH_VALUE_DECL(opr__, macro__)                               \\\n+  Value operator opr__(const Value &a, const Value &b);\n+\n+#define OPERATOR_WITH_VALUE_DEF(opr__, macro__)                                \\\n+  Value operator opr__(const Value &a, const Value &b) {                       \\\n+    auto &loc = *RewriteEnvGuard::kLoc;                                        \\\n+    auto &rewriter = *RewriteEnvGuard::kPatternRewriter;                       \\\n+    return macro__(a, b);                                                      \\\n+  }\n+\n+#define OPERATOR_WITH_INT_DEF(opr__, macro__)                                  \\\n+  template <typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>  \\\n+  Value operator opr__(const Value &a, T b) {                                  \\\n+    constexpr int bits = sizeof(b) * 8;                                        \\\n+    assert(a.getType().isInteger(bits) ||                                      \\\n+           a.getType().template isa<LLVM::PointerType>());                     \\\n+    auto &loc = *RewriteEnvGuard::kLoc;                                        \\\n+    auto &rewriter = *RewriteEnvGuard::kPatternRewriter;                       \\\n+    Type intTy = rewriter.getIntegerType(bits);                                \\\n+    auto bV = rewriter.create<LLVM::ConstantOp>(loc, intTy,                    \\\n+                                                IntegerAttr::get(intTy, b));   \\\n+    return macro__(a, bV);                                                     \\\n+  }\n+\n+OPERATOR_FOR_EACH(OPERATOR_WITH_VALUE_DECL)\n+OPERATOR_FOR_EACH(OPERATOR_WITH_INT_DEF)\n+\n+// @}\n+// Operator overriding end\n+\n } // namespace LLVM\n } // namespace mlir\n "}]