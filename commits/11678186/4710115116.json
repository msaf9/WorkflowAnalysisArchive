[{"filename": "python/src/extra/cuda.ll", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "file_content_changes": "@@ -9,4 +9,9 @@ define i64 @globaltimer() #0 {\n   ret i64 %1\n }\n \n+define i32 @smid() #0 {\n+  %1 = call i32 asm \"mov.u32 $0, %smid;\", \"=r\"() nounwind\n+  ret i32 %1\n+}\n+\n attributes #0 = { alwaysinline nounwind }"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "file_content_changes": "@@ -2335,6 +2335,18 @@ def kernel(Out1, Out2):\n     # 2 inlined globaltimers + one extra in the wrapper extern function\n     assert h.asm[\"ptx\"].count(\"%globaltimer\") == 3\n \n+\n+def test_smid():\n+\n+    @triton.jit\n+    def kernel(Out):\n+        tl.store(Out + tl.program_id(0), tl.extra.cuda.smid())\n+\n+    out = to_triton(np.zeros((1024,), dtype=np.int32), device='cuda')\n+    h = kernel[(out.shape[0],)](out)\n+    assert out.sort()[0].unique().shape[0] > 0\n+    assert h.asm[\"ptx\"].count(\"%smid\") == 2\n+\n # -----------------------\n # test layout conversions\n # -----------------------"}, {"filename": "python/triton/language/extra/cuda.bc", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "file_content_changes": "N/A"}, {"filename": "python/triton/language/extra/cuda.py", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "file_content_changes": "@@ -10,3 +10,10 @@ def globaltimer(_builder=None):\n     return core.extern_elementwise(\"cuda\", os.path.join(__path__, \"cuda.bc\"), [],\n                                    {tuple(): (\"globaltimer\", core.dtype(\"int64\")),\n                                     }, is_pure=False, _builder=_builder)\n+\n+\n+@core.extern\n+def smid(_builder=None):\n+    return core.extern_elementwise(\"cuda\", os.path.join(__path__, \"cuda.bc\"), [],\n+                                   {tuple(): (\"smid\", core.dtype(\"int32\")),\n+                                    }, is_pure=True, _builder=_builder)"}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "file_content_changes": "@@ -10,8 +10,6 @@\n from collections import defaultdict, namedtuple\n from typing import Callable, Generic, Iterable, Optional, TypeVar, Union, cast, overload\n \n-import torch\n-\n import triton\n \n \n@@ -239,25 +237,25 @@ def __init__(self, module, name):\n         return JITFunction.cache_hook(key=key, repr=repr, fn=LegacyCompiler(module, name), compile={\"key\": key, **kwargs}, is_manual_warmup=False, already_compiled=False)\n \n     def _get_arg_specialization_key(self, arg) -> str:\n-        arg_annotation = self.__annotations__.get(arg, None)\n-        if not arg_annotation:\n+        arg_annotation = self.__annotations__.get(arg, '')\n+        if arg_annotation == '':\n             return f'({arg}.data_ptr() % {JITFunction.divisibility} == 0) if hasattr({arg}, \"data_ptr\") \\\n                         else ({arg} % {JITFunction.divisibility} == 0, {arg} == 1) if isinstance({arg}, int) \\\n                         else (False,)'\n-        elif arg_annotation is torch.Tensor:\n+        elif 'Tensor' in arg_annotation:\n             return f'({arg}.data_ptr() % {JITFunction.divisibility} == 0)'\n-        elif arg_annotation is int:\n+        elif arg_annotation == 'int':\n             return f'({arg} % {JITFunction.divisibility} == 0, {arg} == 1)'\n         else:\n             return '(False,)'\n \n     def _get_arg_sig_key(self, arg) -> str:\n-        arg_annotation = self.__annotations__.get(arg, None)\n-        if arg_annotation is torch.Tensor:\n+        arg_annotation = self.__annotations__.get(arg, '')\n+        if 'Tensor' in arg_annotation:\n             return f'{arg}.dtype'\n-        elif arg_annotation is bool:\n+        elif arg_annotation == 'bool':\n             return \"i1\"\n-        elif arg_annotation is float:\n+        elif arg_annotation == 'float':\n             return 'fp32'\n         else:\n             return f'_key_of({arg})'\n@@ -359,12 +357,10 @@ def __init__(self, fn, version=None, do_not_specialize=None, debug=None):\n         self.kernel = None\n         self.debug = os.environ.get(\"TRITON_DEBUG\", \"0\") == \"1\" if debug is None else debug\n         # annotations\n-        self.annotations = {self.arg_names.index(name): ty for name, ty in fn.__annotations__.items()}\n-        self.__annotations__ = fn.__annotations__\n+        normalize_ty = lambda ty: ty.__name__ if isinstance(ty, type) else ty\n+        self.__annotations__ = {name: normalize_ty(ty) for name, ty in fn.__annotations__.items()}\n         # index of constexprs\n-        from triton.language.core import \\\n-            constexpr  # import here rather than at module level due to circular import tangle\n-        self.constexprs = [index for index, ty in self.annotations.items() if isinstance(ty, type) and issubclass(ty, constexpr)]\n+        self.constexprs = [self.arg_names.index(name) for name, ty in self.__annotations__.items() if 'constexpr' in ty]\n         # launcher\n         self.run = self._make_launcher()\n         # re-use docs of wrapped function"}]