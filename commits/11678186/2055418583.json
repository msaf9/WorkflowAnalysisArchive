[{"filename": "include/triton/codegen/selection/generator.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -182,6 +182,8 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   void visit_async_wait_inst(ir::async_wait_inst*);\n //  void visit_make_range_dyn(ir::make_range_dyn*);\n   void visit_make_range(ir::make_range*);\n+  void visit_clock_inst(ir::clock_inst*);\n+  void visit_globaltimer_inst(ir::globaltimer_inst*);\n //  void visit_make_range_sta(ir::make_range_sta*);\n   void visit_undef_value(ir::undef_value*);\n   void visit_constant_int(ir::constant_int*);\n@@ -192,6 +194,7 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   void visit_argument(ir::argument*);\n   void visit(ir::module &, llvm::Module &);\n \n+\n   // layouts\n   void visit_layout_mma(analysis::mma_layout*);\n   void visit_layout_scanline(analysis::scanline_layout*);"}, {"filename": "include/triton/ir/builder.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "file_content_changes": "@@ -28,7 +28,9 @@ class builder{\n   // Constructor\n   builder(context &ctx);\n   // Getters\n-  const context& get_context() { return ctx_; }\n+  // const context& get_context() const { return ctx_; }\n+  context& get_context() { return ctx_; }\n+\n   // Setters\n   void set_insert_point(iterator instr);\n   void set_insert_point(instruction* i);"}, {"filename": "include/triton/ir/dispatch.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -101,6 +101,10 @@ struct dispatch{\n   static ir::value *sin(ir::value *x, ir::builder *builder);\n   static ir::value *sqrt(ir::value *x, ir::builder *builder);\n \n+  // utilities\n+  static ir::value *globaltimer(ir::builder *builder);\n+  static ir::value *clock(ir::builder *builder);\n+\n   // internal (debug/optimization)\n   static ir::value *multiple_of(ir::value *x, int value, ir::builder *builder);\n   static ir::value *max_contiguous(ir::value *x, int value, ir::builder *builder);"}, {"filename": "include/triton/ir/enums.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -165,6 +165,8 @@ enum value_id_t: unsigned {\n   INST_MAKE_RANGE_STA,\n   INST_MAKE_RANGE,\n   INST_PREFETCH_S,\n+  INST_GLOBALTIMER,\n+  INST_CLOCK,\n };\n \n "}, {"filename": "include/triton/ir/instructions.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "file_content_changes": "@@ -971,6 +971,27 @@ class make_range: public instruction{\n   constant_int* last_;\n };\n \n+/* timing utilities */\n+class clock_inst: public instruction{\n+  clock_inst(context &ctx, const std::string &name, instruction *next);\n+  std::string repr_impl() const { return \"clock\"; }\n+  _TRITON_DEFINE_CLONE(clock_inst)\n+  _TRITON_DEFINE_ACCEPT(clock_inst)\n+\n+public:\n+  static clock_inst* create(context &ctx, const std::string &name = \"\", instruction *next = nullptr);\n+};\n+\n+class globaltimer_inst: public instruction{\n+  globaltimer_inst(context &ctx, const std::string &name, instruction *next);\n+  std::string repr_impl() const { return \"globaltimer\"; }\n+  _TRITON_DEFINE_CLONE(globaltimer_inst)\n+  _TRITON_DEFINE_ACCEPT(globaltimer_inst)\n+\n+public:\n+  static globaltimer_inst* create(context &ctx, const std::string &name = \"\", instruction *next = nullptr);\n+};\n+\n \n }\n }"}, {"filename": "include/triton/ir/visitor.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -75,6 +75,8 @@ class async_wait_inst;\n class make_range_dyn;\n class make_range;\n class prefetch_s_inst;\n+class clock_inst;\n+class globaltimer_inst;\n \n class make_range_sta;\n class undef_value;\n@@ -157,6 +159,8 @@ class visitor {\n   virtual void visit_make_range(make_range*) = 0;\n   virtual void visit_prefetch_s_inst(prefetch_s_inst*) = 0;\n   virtual void visit_function(function*) = 0;\n+  virtual void visit_clock_inst(clock_inst*) = 0;\n+  virtual void visit_globaltimer_inst(globaltimer_inst*) = 0;\n \n   virtual void visit_undef_value(undef_value*) = 0;\n   virtual void visit_constant_int(constant_int*) = 0;"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "file_content_changes": "@@ -1093,10 +1093,10 @@ void generator::visit_atomic_rmw_inst(ir::atomic_rmw_inst *atom) {\n       case tt::Xchg: name = \"exch\", s_ty = \"b\"; break;\n     }\n     std::string s_vec = vec == 2 ? \"x2\" : \"\";\n-    std::string mod = nbits == 32 ? \"\" : \".noftz\";\n+    std::string mod = nbits == 16 ? \".noftz\" : \"\";\n \n     std::string asm_str = \"@$1 atom.global.gpu.\" + name + mod + \".\" + s_ty + s_nbits + s_vec + \" $0, [$2\" + offset + \"], $3;\";\n-    std::string ty_id = nbits*vec == 32 ? \"r\" : \"h\";\n+    std::string ty_id = nbits*vec == 64 ? \"l\" : (nbits*vec == 32 ? \"r\" : \"h\");\n     std::string constraint = \"=\" + ty_id + \",b,l,\" + ty_id;\n     // create inline asm\n     InlineAsm *iasm = InlineAsm::get(fn_ty, asm_str, constraint, true);\n@@ -2597,6 +2597,18 @@ void generator::visit_barrier_inst(ir::barrier_inst*) {\n   add_barrier();\n }\n \n+void generator::visit_clock_inst(ir::clock_inst* clock){\n+  InlineAsm *iasm = InlineAsm::get(FunctionType::get(builder_->getInt64Ty(), {}), \"mov.u64 $0, %clock64;\", \"=l\", true);\n+  vals_[clock][{}] = call(iasm);\n+}\n+\n+void generator::visit_globaltimer_inst(ir::globaltimer_inst* timer){\n+  InlineAsm *iasm = InlineAsm::get(FunctionType::get(builder_->getInt64Ty(), {}), \"mov.u64 $0, %globaltimer;\", \"=l\", true);\n+  vals_[timer][{}] = call(iasm);\n+}\n+\n+\n+\n void generator::visit_prefetch_s_inst(ir::prefetch_s_inst *i) {\n   ir::value *v = i->get_operand(0);\n   int inc = i->get_inc();"}, {"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -181,13 +181,14 @@ std::string llir_to_ptx(llvm::Module* module, int cc, int version){\n   // create machine\n   module->setTargetTriple(triple);\n   std::string error;\n+  llvm::TargetMachine* machine;\n   auto target = llvm::TargetRegistry::lookupTarget(module->getTargetTriple(), error);\n   llvm::TargetOptions opt;\n   opt.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n   opt.UnsafeFPMath = false;\n   opt.NoInfsFPMath = false;\n   opt.NoNaNsFPMath = true;\n-  llvm::TargetMachine *machine = target->createTargetMachine(module->getTargetTriple(), proc, features, opt,\n+  machine = target->createTargetMachine(module->getTargetTriple(), proc, features, opt,\n                                                              llvm::Reloc::PIC_, llvm::None, llvm::CodeGenOpt::Aggressive);\n   // set data layout\n   if(layout.empty())"}, {"filename": "lib/ir/dispatch.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "file_content_changes": "@@ -854,6 +854,16 @@ ir::value *dispatch::sqrt(ir::value *x, ir::builder *builder) {\n   return builder->create_sqrt(x);\n }\n \n+//\n+\n+ir::value *dispatch::globaltimer(ir::builder *builder) {\n+  return builder->insert(globaltimer_inst::create(builder->get_context()));\n+}\n+\n+ir::value *dispatch::clock(ir::builder *builder) {\n+  return builder->insert(clock_inst::create(builder->get_context()));\n+\n+}\n \n //\n "}, {"filename": "lib/ir/instructions.cc", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "file_content_changes": "@@ -861,8 +861,7 @@ copy_from_shared_inst* copy_from_shared_inst::create(value *arg, const std::stri\n }\n \n // barrier\n-barrier_inst::barrier_inst(context &ctx, const std::string &name,\n-                                                       instruction *next)\n+barrier_inst::barrier_inst(context &ctx, const std::string &name, instruction *next)\n   : instruction(type::get_void_ty(ctx), INST_BARRIER, 0, name, next) { }\n \n barrier_inst* barrier_inst::create(context &ctx, const std::string &name, instruction *next) {\n@@ -881,27 +880,21 @@ prefetch_s_inst *prefetch_s_inst::create(context &ctx, value *arg, int inc, cons\n   return new prefetch_s_inst(ctx, arg, inc, name, next);\n }\n \n-//// nv_dynamic_program_idx\n-//make_range_dyn::make_range_dyn(type *ty, const std::string &name, instruction *next)\n-//  : instruction(ty, INST_MAKE_RANGE_DYN, 0, name, next) { }\n+// global timer\n+globaltimer_inst::globaltimer_inst(context &ctx, const std::string &name, instruction *next)\n+  : instruction(type::get_int64_ty(ctx), INST_GLOBALTIMER, 0, name, next) { }\n \n-//make_range_dyn* make_range_dyn::create(type *ty, const std::string &name, instruction *next) {\n-//  return new make_range_dyn(ty, name, next);\n-//}\n-\n-//// nv_static_program_idx\n-//make_range_sta::make_range_sta(make_range *range)\n-//  : constant(range->get_type(), 0), range_(range) { }\n+globaltimer_inst* globaltimer_inst::create(context &ctx, const std::string &name, instruction *next) {\n+  return new globaltimer_inst(ctx, name, next);\n+}\n \n-//make_range* make_range_sta::get_range() const\n-//{ return range_; }\n+// clock\n+clock_inst::clock_inst(context &ctx, const std::string &name, instruction *next)\n+  : instruction(type::get_int64_ty(ctx), INST_CLOCK, 0, name, next) { }\n \n-//make_range_sta* make_range_sta::get(make_range* range) {\n-//  static std::map<make_range*, make_range_sta*> cache;\n-//  if(cache.find(range) == cache.end())\n-//    cache.insert({range, new make_range_sta(range)});\n-//  return cache.at(range);\n-//}\n+clock_inst* clock_inst::create(context &ctx, const std::string &name, instruction *next) {\n+  return new clock_inst(ctx, name, next);\n+}\n \n \n // make_range"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -614,6 +614,9 @@ void init_triton_frontend(py::module &&m) {\n   m.def(\"cos\", &ir::dispatch::cos, ret::reference);\n   m.def(\"sin\", &ir::dispatch::sin, ret::reference);\n   m.def(\"sqrt\", &ir::dispatch::sqrt, ret::reference);\n+  // utilities\n+  m.def(\"clock\", &ir::dispatch::clock, ret::reference);\n+  m.def(\"globaltimer\", &ir::dispatch::globaltimer, ret::reference);\n   // internal (debugging only)\n   m.def(\"multiple_of\", &ir::dispatch::multiple_of, ret::reference);\n   m.def(\"max_contiguous\", &ir::dispatch::max_contiguous, ret::reference);"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "file_content_changes": "@@ -792,6 +792,19 @@ def sum(input, axis, _builder=None):\n def xor_sum(input, axis, _builder=None):\n     return frontend.xor_sum(input, axis, _builder)\n \n+# -----------------------\n+# Utilities\n+# -----------------------\n+\n+\n+@builtin\n+def globaltimer(_builder=None):\n+    return frontend.globaltimer(_builder)\n+\n+\n+@builtin\n+def clock(_builder=None):\n+    return frontend.clock(_builder)\n \n # -----------------------\n # Internal for debugging"}, {"filename": "python/tutorials/01-vector-add.py", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "file_content_changes": "@@ -24,9 +24,11 @@ def add_kernel(\n     y_ptr,  # *Pointer* to second input vector\n     output_ptr,  # *Pointer* to output vector\n     n_elements,  # Size of the vector\n+    time_start_ptr, time_end_ptr,\n     BLOCK_SIZE: tl.constexpr,  # Number of elements each program should process\n                  # NOTE: `constexpr` so it can be used as a shape value\n ):\n+    tl.atomic_min(time_start_ptr, tl.clock())\n     # There are multiple 'program's processing different data. We identify which program\n     # we are here\n     pid = tl.program_id(axis=0)  # We use a 1D launch grid so axis is 0\n@@ -45,6 +47,7 @@ def add_kernel(\n     output = x + y\n     # Write x + y back to DRAM\n     tl.store(output_ptr + offsets, output, mask=mask)\n+    tl.atomic_max(time_end_ptr, tl.clock())\n \n \n # %%\n@@ -53,6 +56,8 @@ def add_kernel(\n \n \n def add(x: torch.Tensor, y: torch.Tensor):\n+    time_start = torch.zeros(1, dtype=torch.int64, device='cuda')\n+    time_end = torch.zeros(1, dtype=torch.int64, device='cuda')\n     # We need to preallocate the output\n     output = torch.empty_like(x)\n     assert x.is_cuda and y.is_cuda and output.is_cuda\n@@ -65,9 +70,10 @@ def add(x: torch.Tensor, y: torch.Tensor):\n     #  - each torch.tensor object is implicitly converted into a pointer to its first element.\n     #  - `triton.jit`'ed functions can be index with a launch grid to obtain a callable GPU kernel\n     #  - don't forget to pass meta-parameters as keywords arguments\n-    add_kernel[grid](x, y, output, n_elements, BLOCK_SIZE=1024)\n+    add_kernel[grid](x, y, output, n_elements, time_start, time_end, BLOCK_SIZE=1024)\n     # We return a handle to z but, since `torch.cuda.synchronize()` hasn't been called, the kernel is still\n     # running asynchronously at this point.\n+    print((time_end, time_start))\n     return output\n \n "}]