[{"filename": "lib/Conversion/TritonGPUToLLVM/LoadStoreOpToLLVM.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "file_content_changes": "@@ -582,6 +582,10 @@ struct AtomicRMWOpConversion\n         ptxBuilderMemfence.launch(rewriter, loc, ASMReturnTy);\n         atom(dstOpr, ptrOpr, valOpr).predicate(rmwMask);\n         auto old = ptxBuilderAtomicRMW.launch(rewriter, loc, valueElemTy);\n+        if (op->user_begin() == op->user_end()) {\n+          rewriter.replaceOp(op, {old});\n+          return success();\n+        }\n         Value atomPtr = getSharedMemoryBase(loc, rewriter, op.getOperation());\n         atomPtr = bitcast(atomPtr, ptr_ty(valueElemTy, 3));\n         // Only threads with rmwMask = True store the result"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "file_content_changes": "@@ -1372,10 +1372,12 @@ def _max_combine(a, b):\n @triton.jit\n def _argmax_combine(value1, index1, value2, index2):\n     gt = value1 > value2\n-    lt = value1 < value2\n-    index_min = minimum(index1, index2)\n-    index_ret = where(gt, index1, where(lt, index2, index_min))\n-    value_ret = maximum(value1, value2)\n+    value_ret = where(gt, value1, value2)\n+    index_ret = where(gt, index1, index2)\n+    # lt = value1 < value2\n+    # index_min = minimum(index1, index2)\n+    # index_ret = where(gt, index1, where(lt, index2, index_min))\n+    # value_ret = maximum(value1, value2)\n     return value_ret, index_ret\n \n "}]