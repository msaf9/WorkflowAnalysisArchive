[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "file_content_changes": "@@ -15,6 +15,14 @@ using namespace mlir;\n #define GEN_PASS_CLASSES\n #include \"triton/Dialect/TritonGPU/Transforms/Passes.h.inc\"\n \n+static Type getI1SameShape(Value v) {\n+  Type vType = v.getType();\n+  auto i1Type = IntegerType::get(vType.getContext(), 1);\n+  auto tensorType = vType.cast<RankedTensorType>();\n+  return RankedTensorType::get(tensorType.getShape(), i1Type,\n+                               tensorType.getEncoding());\n+}\n+\n namespace {\n class LoopPipeliner {\n   /// comments on numStages:\n@@ -301,25 +309,29 @@ void LoopPipeliner::emitPrologue() {\n       }\n \n       // If this is a load/async_copy, we need to update the mask\n-      if (Value mask = [&]() {\n-            if (auto loadOp = llvm::dyn_cast<triton::LoadOp>(newOp)) {\n-              return loadOp.mask();\n-            } else if (auto insertSliceAsyncOp =\n-                           llvm::dyn_cast<triton::gpu::InsertSliceAsyncOp>(\n-                               newOp)) {\n-              return insertSliceAsyncOp.mask();\n-            } else {\n-              return mlir::Value();\n-            }\n-          }()) {\n+      if (llvm::isa<triton::LoadOp, triton::gpu::InsertSliceAsyncOp>(newOp)) {\n+        Value mask;\n+        auto newLoad = llvm::dyn_cast<triton::LoadOp>(newOp);\n+        auto newInsertAsync =\n+            llvm::dyn_cast<triton::gpu::InsertSliceAsyncOp>(newOp);\n+        if (newLoad)\n+          mask = newLoad.mask();\n+        else\n+          mask = newInsertAsync.mask();\n         // assert(I1 or TensorOf<[I1]>);\n         OpBuilder::InsertionGuard g(builder);\n         // TODO: move this out of the loop\n         builder.setInsertionPoint(newOp);\n-        Value splatCond = builder.create<triton::SplatOp>(\n-            mask.getLoc(), mask.getType(), loopCond);\n-        Value newMask =\n-            builder.create<arith::AndIOp>(mask.getLoc(), mask, splatCond);\n+        Value newMask;\n+        if (mask) {\n+          Value splatCond = builder.create<triton::SplatOp>(\n+              mask.getLoc(), mask.getType(), loopCond);\n+          newMask =\n+              builder.create<arith::AndIOp>(mask.getLoc(), mask, splatCond);\n+        } else {\n+          newMask = builder.create<triton::SplatOp>(\n+              loopCond.getLoc(), getI1SameShape(newOp->getResult(0)), loopCond);\n+        }\n         // TODO: better way to do this?\n         if (llvm::isa<triton::LoadOp>(newOp))\n           newOp->setOperand(1, newMask);\n@@ -345,7 +357,7 @@ void LoopPipeliner::emitPrologue() {\n                 newOp->getResult(dstIdx), stage + 1);\n         }\n       }\n-    }\n+    } // for (Operation *op : orderedDeps)\n \n     pipelineIterIdx = builder.create<arith::AddIOp>(\n         iv.getLoc(), pipelineIterIdx,\n@@ -477,26 +489,29 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n \n   for (Operation *op : orderedDeps) {\n     Operation *nextOp = nullptr;\n-    // TODO(da): does this work if loadOp has no mask?\n     // update loading mask\n     if (loads.contains(op->getResult(0))) {\n       auto loadOp = llvm::cast<triton::LoadOp>(op);\n       Value mask = loadOp.mask();\n+      Value newMask;\n       if (mask) {\n         Value splatCond = builder.create<triton::SplatOp>(\n             mask.getLoc(), mask.getType(), nextLoopCond);\n-        Value newMask = builder.create<arith::AndIOp>(\n+        newMask = builder.create<arith::AndIOp>(\n             mask.getLoc(), splatCond, nextMapping.lookupOrDefault(mask));\n         // if mask is defined outside the loop, don't update the map more than\n         // once\n         if (!(forOp.isDefinedOutsideOfLoop(mask) && nextMapping.contains(mask)))\n           nextMapping.map(mask, newMask);\n-      }\n+        newMask = nextMapping.lookupOrDefault(loadOp.mask());\n+      } else\n+        newMask = builder.create<triton::SplatOp>(\n+            loadOp.getLoc(), getI1SameShape(loadOp), nextLoopCond);\n       Value insertAsyncOp = builder.create<triton::gpu::InsertSliceAsyncOp>(\n           op->getLoc(), loadsBuffer[loadOp].getType(),\n           nextMapping.lookupOrDefault(loadOp.ptr()),\n           newForOp.getRegionIterArgs()[bufferIdx + nextBuffers.size()],\n-          insertSliceIndex, nextMapping.lookupOrDefault(loadOp.mask()),\n+          insertSliceIndex, newMask,\n           nextMapping.lookupOrDefault(loadOp.other()), loadOp.cache(),\n           loadOp.evict(), loadOp.isVolatile(), /*axis*/ 0);\n       nextBuffers.push_back(insertAsyncOp);"}]