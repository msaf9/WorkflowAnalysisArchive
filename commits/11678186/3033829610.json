[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "file_content_changes": "@@ -1,21 +1,18 @@\n from __future__ import annotations\n import hashlib\n from filelock import FileLock\n-import pickle\n import torch\n import setuptools\n import sysconfig\n import shutil\n import io\n import contextlib\n-\n import ast\n import os\n import sys\n import tempfile\n import warnings\n-from collections import defaultdict\n-from typing import Any, Dict, Tuple, Union\n+from typing import Any, Dict, Tuple, Union, Set\n \n import triton\n import triton._C.libtriton.triton as _triton\n@@ -978,6 +975,35 @@ def generate_torch_glue(kernel_name, signature, num_warps, binaries, tmpdir):\n         with open(headers[name], \"w\") as f:\n             f.write(initializer)\n \n+    func_init = '\\n  '.join(f\"init_function(\\\"{name}\\\", {name}_bin, {name}_shmem, device);\" for _, _, name in binaries)\n+    arg_decls = ', '.join(f\"{ty_to_cpp(ty)} arg{i}\" for i, ty in enumerate(tys))\n+\n+    def _extracted_type(ty):\n+        if ty[0] == '*':\n+            return \"PyObject*\"\n+        if ty[0] == 'i':\n+            return \"long\"\n+        return {\n+            'u32': 'uint32_t',\n+            'u64': 'uint64_t',\n+            'fp32': 'float',\n+            'fp64': 'double',\n+        }[ty]\n+\n+    def format_of(ty):\n+        return {\n+            \"PyObject*\": \"O\",\n+            \"float\": \"f\",\n+            \"double\": \"d\",\n+            \"long\": \"l\",\n+            \"uint32_t\": \"I\",\n+            \"int32_t\": \"i\",\n+            \"uint64_t\": \"K\",\n+            \"int64_t\": \"L\",\n+        }[ty]\n+\n+    format = \"iiil\" + ''.join([format_of(_extracted_type(ty)) for ty in tys])\n+\n     # generate glue code\n     n_args = len(tys)\n     src = \"\"\n@@ -1023,38 +1049,7 @@ def generate_torch_glue(kernel_name, signature, num_warps, binaries, tmpdir):\n   module = mod;\n   function = fun;\n }}\n-\"\"\"\n \n-    func_init = '\\n  '.join(f\"init_function(\\\"{name}\\\", {name}_bin, {name}_shmem, device);\" for _, _, name in binaries)\n-    arg_decls = ', '.join(f\"{ty_to_cpp(ty)} arg{i}\" for i, ty in enumerate(tys))\n-\n-    def _extracted_type(ty):\n-        if ty[0] == '*':\n-            return \"PyObject*\"\n-        if ty[0] == 'i':\n-            return \"long\"\n-        return {\n-            'u32': 'uint32_t',\n-            'u64': 'uint64_t',\n-            'fp32': 'float',\n-            'fp64': 'double',\n-        }[ty]\n-\n-    def format_of(ty):\n-        return {\n-            \"PyObject*\": \"O\",\n-            \"float\": \"f\",\n-            \"double\": \"d\",\n-            \"long\": \"l\",\n-            \"uint32_t\": \"I\",\n-            \"int32_t\": \"i\",\n-            \"uint64_t\": \"K\",\n-            \"int64_t\": \"L\",\n-        }[ty]\n-\n-    format = \"iiil\" + ''.join([format_of(_extracted_type(ty)) for ty in tys])\n-\n-    src += f\"\"\"\n void init_module(CUdevice device) {{\n   {func_init}\n }}\n@@ -1140,10 +1135,10 @@ def format_of(ty):\n   Py_DECREF(py_{name}_ptx);\n \"\"\"\n \n-    src += f\"\"\"\n+    src += \"\"\"\n   PyModule_AddObject(m, \"ptx\", ptx);\n   return m;\n-}}\n+}\n \"\"\"\n \n     return src\n@@ -1234,7 +1229,7 @@ def __init__(self, fn_name, data_path):\n         spec.loader.exec_module(mod)\n         self.c_wrapper = getattr(mod, fn_name)\n         ptx = getattr(mod, \"ptx\")\n-        if(len(ptx) == 1):\n+        if len(ptx) == 1:\n             self.asm = {\"ptx\": list(ptx.values())[0]}\n \n     def __getitem__(self, grid):"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -420,7 +420,7 @@ def __init__(self, handle, type: dtype):\n         self.numel = 1\n         for s in self.shape:\n             self.numel *= s\n-        is_pow2 = (self.numel and (not(self.numel & (self.numel - 1))))\n+        is_pow2 = (self.numel and (not (self.numel & (self.numel - 1))))\n         if not is_pow2:\n             raise ValueError(\"Triton tensors must have a power-of-two number of elements\")\n         self.numel = constexpr(self.numel)"}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -254,7 +254,7 @@ def warmup(kwargs):\n         return JITFunction.cache_hook(key=key, repr=repr, fn=LegacyCompiler(), compile={\"key\": key, **kwargs}, is_manual_warmup=False, already_compiled=False)\n \n     def _make_launcher(self):\n-        regular_args = [f'{arg}' for i, arg in enumerate(self.arg_names) if not i in self.constexprs]\n+        regular_args = [f'{arg}' for i, arg in enumerate(self.arg_names) if i not in self.constexprs]\n         constexpr_args = [f'{arg}' for i, arg in enumerate(self.arg_names) if i in self.constexprs]\n         args = ', '.join(regular_args)\n         # cache key for regular argument type"}]