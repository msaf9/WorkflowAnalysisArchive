[{"filename": "include/triton/Analysis/Utility.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -36,8 +36,6 @@ class ReduceOpHelper {\n \n   triton::ReduceOp getOperation() { return op; }\n \n-  Type getLargestSrcElementType();\n-\n   bool isFastReduction();\n \n   bool isWarpSynchronous();"}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "file_content_changes": "@@ -153,16 +153,6 @@ SmallVector<unsigned> ReduceOpHelper::getScratchConfigsFast() {\n   return smemShape;\n }\n \n-Type ReduceOpHelper::getLargestSrcElementType() {\n-  Type elemTy = srcElementTypes[0];\n-  for (const auto &ty : srcElementTypes) {\n-    if (elemTy.getIntOrFloatBitWidth() < ty.getIntOrFloatBitWidth()) {\n-      elemTy = ty;\n-    }\n-  }\n-  return elemTy;\n-}\n-\n unsigned ReduceOpHelper::getScratchSizeInBytes() {\n   unsigned elems = 0;\n   if (isFastReduction()) {\n@@ -173,9 +163,11 @@ unsigned ReduceOpHelper::getScratchSizeInBytes() {\n     elems = product<unsigned>(smemShape);\n   }\n \n-  unsigned bytesPerElem =\n-      ceil<unsigned>(getLargestSrcElementType().getIntOrFloatBitWidth(), 8);\n-  return (bytesPerElem * srcElementTypes.size()) * elems;\n+  unsigned bytesPerElem = 0;\n+  for (const auto &ty : srcElementTypes) {\n+    bytesPerElem += ceil<unsigned>(ty.getIntOrFloatBitWidth(), 8);\n+  }\n+  return bytesPerElem * elems;\n }\n \n bool ReduceOpHelper::isSupportedLayout() {"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ReduceOpToLLVM.cpp", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "file_content_changes": "@@ -144,17 +144,29 @@ struct ReduceOpConversion\n                                   ConversionPatternRewriter &rewriter) const {\n     auto loc = op.getLoc();\n     unsigned elems = product<unsigned>(smemShape);\n-    Type elemTy = helper.getLargestSrcElementType();\n-    auto elemPtrTy = LLVM::LLVMPointerType::get(elemTy, 3);\n-\n-    SmallVector<Value> smemBases(op.getNumOperands());\n-    smemBases[0] =\n+    // indices will store the index of the op operands in descending order\n+    // of their bitwidths\n+    std::vector<unsigned> indices(op.getNumOperands());\n+    std::iota(indices.begin(), indices.end(), 0);\n+    std::sort(indices.begin(), indices.end(), [&](unsigned i, unsigned j) {\n+      return op.getElementTypes()[i].getIntOrFloatBitWidth() >\n+             op.getElementTypes()[j].getIntOrFloatBitWidth();\n+    });\n+    // Assign base index to each operand in their order in indices\n+    std::map<unsigned, Value> indexToBase;\n+    indexToBase[indices[0]] =\n         bitcast(getSharedMemoryBase(loc, rewriter, op.getOperation()),\n-                getElementPtrType(op, 0));\n+                getElementPtrType(op, indices[0]));\n     for (unsigned i = 1; i < op.getNumOperands(); ++i) {\n-      smemBases[i] = bitcast(\n-          gep(elemPtrTy, bitcast(smemBases[i - 1], elemPtrTy), i32_val(elems)),\n-          getElementPtrType(op, i));\n+      indexToBase[indices[i]] =\n+          bitcast(gep(getElementPtrType(op, indices[i - 1]),\n+                      indexToBase[indices[i - 1]], i32_val(elems)),\n+                  getElementPtrType(op, indices[i]));\n+    }\n+    // smemBases[k] is the base pointer for the k-th operand\n+    SmallVector<Value> smemBases(op.getNumOperands());\n+    for (unsigned i = 0; i < op.getNumOperands(); ++i) {\n+      smemBases[i] = indexToBase[i];\n     }\n     return smemBases;\n   }"}]