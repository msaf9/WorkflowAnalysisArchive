[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 63, "deletions": 71, "changes": 134, "file_content_changes": "@@ -60,7 +60,14 @@ Value createConstantI32(Location loc, PatternRewriter &rewriter, int32_t v) {\n #define bit_cast(...) rewriter.create<LLVM::BitcastOp>(loc, __VA_ARGS__)\n #define gep(...) rewriter.create<LLVM::GEPOp>(loc, __VA_ARGS__)\n #define ptr_ty(...) LLVM::LLVMPointerType::get(__VA_ARGS__)\n+#define insert_val(...) rewriter.create<LLVM::InsertValueOp>(loc, __VA_ARGS__)\n #define extract_val(...) rewriter.create<LLVM::ExtractValueOp>(loc, __VA_ARGS__)\n+#define insert_element(...)                                                    \\\n+  rewriter.create<LLVM::InsertElementOp>(loc, __VA_ARGS__)\n+#define extract_element(...)                                                   \\\n+  rewriter.create<LLVM::ExtractElementOp>(loc, __VA_ARGS__)\n+#define address_of(...) rewriter.create<LLVM::AddressOfOp>(loc, __VA_ARGS__)\n+\n #define i32_val(...) LLVM::createConstantI32(loc, rewriter, __VA_ARGS__)\n #define i32_ty() rewriter.getIntegerType(32)\n \n@@ -256,9 +263,8 @@ Value getStructFromElements(Location loc, ValueRange resultVals,\n                             Type structType) {\n   Value llvmStruct = rewriter.create<LLVM::UndefOp>(loc, structType);\n   for (auto v : llvm::enumerate(resultVals)) {\n-    llvmStruct = rewriter.create<LLVM::InsertValueOp>(\n-        loc, structType, llvmStruct, v.value(),\n-        rewriter.getI64ArrayAttr(v.index()));\n+    llvmStruct = insert_val(structType, llvmStruct, v.value(),\n+                            rewriter.getI64ArrayAttr(v.index()));\n   }\n   return llvmStruct;\n }\n@@ -310,8 +316,7 @@ struct ConvertTritonGPUOpToLLVMPatternBase {\n     for (unsigned i = 0; i < elems; ++i) {\n       Type type =\n           llvmStruct.getType().cast<LLVM::LLVMStructType>().getBody()[i];\n-      results[i] = rewriter.create<LLVM::ExtractValueOp>(\n-          loc, type, llvmStruct, rewriter.getI64ArrayAttr(i));\n+      results[i] = extract_val(type, llvmStruct, rewriter.getI64ArrayAttr(i));\n     }\n     return results;\n   }\n@@ -389,22 +394,20 @@ class ConvertTritonGPUOpToLLVMPattern\n         Value dimSize = createIndexAttrConstant(\n             rewriter, loc, this->getTypeConverter()->getIndexType(),\n             std::get<1>(z));\n-        linear = rewriter.create<LLVM::AddOp>(\n-            loc, rewriter.create<LLVM::MulOp>(loc, linear, dimSize),\n-            std::get<0>(z));\n+        linear = add(mul(linear, dimSize), std::get<0>(z));\n       }\n     }\n     return linear;\n   }\n \n   SmallVector<Value>\n-  emitBaseIndexForBlockedLayout(Location loc, ConversionPatternRewriter &b,\n+  emitBaseIndexForBlockedLayout(Location loc,\n+                                ConversionPatternRewriter &rewriter,\n                                 const BlockedEncodingAttr &blocked_layout,\n                                 ArrayRef<int64_t> shape) const {\n     auto llvmIndexTy = this->getTypeConverter()->getIndexType();\n-    Value threadId = getThreadId(b, loc);\n-    Value warpSize = createIndexAttrConstant(b, loc, llvmIndexTy, 32);\n-    auto &rewriter = b;\n+    Value threadId = getThreadId(rewriter, loc);\n+    Value warpSize = createIndexAttrConstant(rewriter, loc, llvmIndexTy, 32);\n     Value laneId = urem(threadId, warpSize);\n     Value warpId = udiv(threadId, warpSize);\n     auto sizePerThread = blocked_layout.getSizePerThread();\n@@ -415,34 +418,32 @@ class ConvertTritonGPUOpToLLVMPattern\n \n     // step 1, delinearize threadId to get the base index\n     SmallVector<Value> multiDimWarpId =\n-        delinearize(b, loc, warpId, warpsPerCTA, order);\n+        delinearize(rewriter, loc, warpId, warpsPerCTA, order);\n     SmallVector<Value> multiDimThreadId =\n-        delinearize(b, loc, laneId, threadsPerWarp, order);\n+        delinearize(rewriter, loc, laneId, threadsPerWarp, order);\n     SmallVector<Value> multiDimBase(rank);\n     for (unsigned k = 0; k < rank; ++k) {\n       // Wrap around multiDimWarpId/multiDimThreadId incase\n       // shape[k] > shapePerCTA[k]\n       unsigned maxWarps =\n           ceil<unsigned>(shape[k], sizePerThread[k] * threadsPerWarp[k]);\n       unsigned maxThreads = ceil<unsigned>(shape[k], sizePerThread[k]);\n-      multiDimWarpId[k] = b.create<LLVM::URemOp>(\n-          loc, multiDimWarpId[k],\n-          createIndexAttrConstant(b, loc, llvmIndexTy, maxWarps));\n-      multiDimThreadId[k] = b.create<LLVM::URemOp>(\n-          loc, multiDimThreadId[k],\n-          createIndexAttrConstant(b, loc, llvmIndexTy, maxThreads));\n+      multiDimWarpId[k] =\n+          urem(multiDimWarpId[k],\n+               createIndexAttrConstant(rewriter, loc, llvmIndexTy, maxWarps));\n+      multiDimThreadId[k] =\n+          urem(multiDimThreadId[k],\n+               createIndexAttrConstant(rewriter, loc, llvmIndexTy, maxThreads));\n       // multiDimBase[k] = (multiDimThreadId[k] +\n       //                    multiDimWarpId[k] * threadsPerWarp[k]) *\n       //                   sizePerThread[k];\n-      Value threadsPerWarpK =\n-          createIndexAttrConstant(b, loc, llvmIndexTy, threadsPerWarp[k]);\n+      Value threadsPerWarpK = createIndexAttrConstant(\n+          rewriter, loc, llvmIndexTy, threadsPerWarp[k]);\n       Value sizePerThreadK =\n-          createIndexAttrConstant(b, loc, llvmIndexTy, sizePerThread[k]);\n-      multiDimBase[k] = b.create<LLVM::MulOp>(\n-          loc, sizePerThreadK,\n-          b.create<LLVM::AddOp>(\n-              loc, multiDimThreadId[k],\n-              b.create<LLVM::MulOp>(loc, multiDimWarpId[k], threadsPerWarpK)));\n+          createIndexAttrConstant(rewriter, loc, llvmIndexTy, sizePerThread[k]);\n+      multiDimBase[k] =\n+          mul(sizePerThreadK, add(multiDimThreadId[k],\n+                                  mul(multiDimWarpId[k], threadsPerWarpK)));\n     }\n     return multiDimBase;\n   }\n@@ -463,7 +464,7 @@ class ConvertTritonGPUOpToLLVMPattern\n   }\n \n   SmallVector<SmallVector<Value>>\n-  emitIndicesForSliceLayout(Location loc, ConversionPatternRewriter &b,\n+  emitIndicesForSliceLayout(Location loc, ConversionPatternRewriter &rewriter,\n                             const SliceEncodingAttr &sliceLayout,\n                             ArrayRef<int64_t> shape) const {\n     auto parent = sliceLayout.getParent();\n@@ -480,8 +481,8 @@ class ConvertTritonGPUOpToLLVMPattern\n           paddedShape[d] = shape[d - 1];\n         }\n       }\n-      auto paddedIndices =\n-          emitIndicesForBlockedLayout(loc, b, blockedParent, paddedShape);\n+      auto paddedIndices = emitIndicesForBlockedLayout(\n+          loc, rewriter, blockedParent, paddedShape);\n       unsigned numIndices = paddedIndices.size();\n       SmallVector<SmallVector<Value>> resultIndices(numIndices);\n       for (unsigned i = 0; i < numIndices; ++i) {\n@@ -510,7 +511,7 @@ class ConvertTritonGPUOpToLLVMPattern\n   //       be eliminated in the consequent MLIR/LLVM optimization. We might\n   //       implement a indiceCache if necessary.\n   SmallVector<SmallVector<Value>>\n-  emitIndicesForBlockedLayout(Location loc, ConversionPatternRewriter &b,\n+  emitIndicesForBlockedLayout(Location loc, ConversionPatternRewriter &rewriter,\n                               const BlockedEncodingAttr &blockedLayout,\n                               ArrayRef<int64_t> shape) const {\n     auto llvmIndexTy = this->getTypeConverter()->getIndexType();\n@@ -525,7 +526,7 @@ class ConvertTritonGPUOpToLLVMPattern\n \n     // step 1, delinearize threadId to get the base index\n     auto multiDimBase =\n-        emitBaseIndexForBlockedLayout(loc, b, blockedLayout, shape);\n+        emitBaseIndexForBlockedLayout(loc, rewriter, blockedLayout, shape);\n \n     // step 2, get offset of each element\n     unsigned elemsPerThread = 1;\n@@ -574,10 +575,10 @@ class ConvertTritonGPUOpToLLVMPattern\n             multiDimNanoTileId[k] *\n                 (sizePerThread[k] * threadsPerWarp[k] * warpsPerCTA[k]) +\n             multiElemsInNanoTileId[k];\n-        multiDimIdx[n][k] = b.create<LLVM::AddOp>(\n-            loc, multiDimBase[k],\n-            createIndexAttrConstant(b, loc, llvmIndexTy,\n-                                    offset[k][reorderedMultiDimId]));\n+        multiDimIdx[n][k] =\n+            add(multiDimBase[k],\n+                createIndexAttrConstant(rewriter, loc, llvmIndexTy,\n+                                        offset[k][reorderedMultiDimId]));\n       }\n     }\n \n@@ -594,7 +595,7 @@ class ConvertTritonGPUOpToLLVMPattern\n     size_t offset = allocation->getOffset(bufferId);\n     auto llvmIndexTy = this->getTypeConverter()->getIndexType();\n     Value offVal = createIndexAttrConstant(rewriter, loc, llvmIndexTy, offset);\n-    Value base = rewriter.create<LLVM::GEPOp>(loc, ptrTy, smem, offVal);\n+    Value base = gep(ptrTy, smem, offVal);\n     return base;\n   }\n };\n@@ -612,7 +613,7 @@ Value convertSplatLikeOp(Type elemType, Type resType, Value constVal,\n   auto tensorTy = resType.cast<RankedTensorType>();\n   auto layout = tensorTy.getEncoding();\n   auto srcType = typeConverter->convertType(elemType);\n-  auto llSrc = rewriter.create<LLVM::BitcastOp>(loc, srcType, constVal);\n+  auto llSrc = bit_cast(srcType, constVal);\n   size_t numElemsPerThread = getElemsPerThread(layout, tensorTy.getShape());\n   llvm::SmallVector<Value, 4> elems(numElemsPerThread, llSrc);\n   llvm::SmallVector<Type, 4> elemTypes(elems.size(), srcType);\n@@ -849,15 +850,15 @@ struct StoreOpConversion\n           Value elem = valueElems[elemOffset];\n           if (elem.getType().isInteger(1))\n             elem = rewriter.create<LLVM::SExtOp>(loc, type::i8Ty(ctx), elem);\n-          elem = rewriter.create<LLVM::BitcastOp>(loc, valueElemTy, elem);\n+          elem = bit_cast(valueElemTy, elem);\n \n           Type u32Ty = typeConverter->convertType(type::u32Ty(ctx));\n-          llWord = rewriter.create<LLVM::InsertElementOp>(\n-              loc, wordTy, llWord, elem,\n-              rewriter.create<LLVM::ConstantOp>(\n-                  loc, u32Ty, IntegerAttr::get(u32Ty, elemIdx)));\n+          llWord =\n+              insert_element(wordTy, llWord, elem,\n+                             rewriter.create<LLVM::ConstantOp>(\n+                                 loc, u32Ty, IntegerAttr::get(u32Ty, elemIdx)));\n         }\n-        llWord = rewriter.create<LLVM::BitcastOp>(loc, valArgTy, llWord);\n+        llWord = bit_cast(valArgTy, llWord);\n         std::string constraint =\n             (width == 64) ? \"l\" : ((width == 32) ? \"r\" : \"c\");\n         asmArgList->listAppend(ptxBuilder.newOperand(llWord, constraint));\n@@ -1053,8 +1054,7 @@ struct MakeRangeOpConversion\n     SmallVector<Value> retVals(elems);\n     for (auto multiDim : llvm::enumerate(idxs)) {\n       assert(multiDim.value().size() == 1);\n-      retVals[multiDim.index()] =\n-          rewriter.create<LLVM::AddOp>(loc, multiDim.value()[0], start);\n+      retVals[multiDim.index()] = add(multiDim.value()[0], start);\n     }\n     SmallVector<Type> types(elems, elemTy);\n     Type structTy = LLVM::LLVMStructType::getLiteral(getContext(), types);\n@@ -1213,11 +1213,9 @@ struct LoadOpConversion\n             Value falseVal = otherElems[vecStart + ii * size + s];\n             Value sVal = createIndexAttrConstant(\n                 rewriter, loc, this->getTypeConverter()->getIndexType(), s);\n-            v = rewriter.create<LLVM::InsertElementOp>(loc, vecTy, v, falseVal,\n-                                                       sVal);\n+            v = insert_element(vecTy, v, falseVal, sVal);\n           }\n-          v = rewriter.create<LLVM::BitcastOp>(\n-              loc, IntegerType::get(getContext(), width), v);\n+          v = bit_cast(IntegerType::get(getContext(), width), v);\n \n           PTXInstr::Operand *opr{};\n           if (otherIsSplatConstInt) {\n@@ -1258,23 +1256,21 @@ struct LoadOpConversion\n       for (unsigned int ii = 0; ii < nWords; ii++) {\n         Value curr;\n         if (retTy.isa<LLVM::LLVMStructType>()) {\n-          curr = rewriter.create<LLVM::ExtractValueOp>(\n-              loc, IntegerType::get(getContext(), width), ret,\n-              rewriter.getI64ArrayAttr(ii));\n+          curr = extract_val(IntegerType::get(getContext(), width), ret,\n+                             rewriter.getI64ArrayAttr(ii));\n         } else {\n           curr = ret;\n         }\n-        curr = rewriter.create<LLVM::BitcastOp>(\n-            loc, LLVM::getFixedVectorType(valueElemTy, width / valueElemNbits),\n+        curr = bit_cast(\n+            LLVM::getFixedVectorType(valueElemTy, width / valueElemNbits),\n             curr);\n         rets.push_back(curr);\n       }\n       int tmp = (width / valueElemNbits);\n       for (size_t ii = 0; ii < vec; ii++) {\n         Value vecIdx = createIndexAttrConstant(\n             rewriter, loc, this->getTypeConverter()->getIndexType(), ii % tmp);\n-        Value loaded = rewriter.create<LLVM::ExtractElementOp>(\n-            loc, valueElemTy, rets[ii / tmp], vecIdx);\n+        Value loaded = extract_element(valueElemTy, rets[ii / tmp], vecIdx);\n         loadedVals.push_back(loaded);\n       }\n     } // end vec\n@@ -1328,8 +1324,7 @@ struct AddPtrOpConversion\n         getElementsFromStruct(loc, adaptor.offset(), elems, rewriter);\n     SmallVector<Value> resultVals(elems);\n     for (unsigned i = 0; i < elems; ++i) {\n-      resultVals[i] =\n-          rewriter.create<LLVM::GEPOp>(loc, elemTy, ptrs[i], offsets[i]);\n+      resultVals[i] = gep(elemTy, ptrs[i], offsets[i]);\n     }\n     Value view = getStructFromElements(loc, resultVals, rewriter, structTy);\n     rewriter.replaceOp(op, view);\n@@ -1412,7 +1407,7 @@ struct ConvertLayoutOpConversion\n     Value smemBase =\n         getSharedMemoryBase(loc, rewriter, smem, allocation, op.getOperation());\n     auto elemPtrTy = LLVM::LLVMPointerType::get(llvmElemTy, 3);\n-    smemBase = rewriter.create<LLVM::BitcastOp>(loc, elemPtrTy, smemBase);\n+    smemBase = bit_cast(elemPtrTy, smemBase);\n \n     auto shape = dstTy.getShape();\n     unsigned rank = dstTy.getRank();\n@@ -1557,8 +1552,8 @@ struct ConvertLayoutOpConversion\n             getMultiDimIndex<unsigned>(elemId, layout.getSizePerThread());\n         SmallVector<Value> multiDimOffset(rank);\n         for (unsigned d = 0; d < rank; ++d) {\n-          multiDimOffset[d] = rewriter.create<LLVM::AddOp>(\n-              loc, multiDimOffsetFirstElem[d],\n+          multiDimOffset[d] = add(\n+              multiDimOffsetFirstElem[d],\n               createIndexAttrConstant(rewriter, loc, llvmIndexTy,\n                                       multiDimCTAInRepId[d] * shapePerCTA[d] +\n                                           multiDimElemId[d]));\n@@ -1567,18 +1562,16 @@ struct ConvertLayoutOpConversion\n             linearize(rewriter, loc, reorder<Value>(multiDimOffset, outOrd),\n                       reorder<unsigned>(paddedRepShape, outOrd));\n         auto elemPtrTy = LLVM::LLVMPointerType::get(llvmElemTy, 3);\n-        Value ptr =\n-            rewriter.create<LLVM::GEPOp>(loc, elemPtrTy, smemBase, offset);\n+        Value ptr = gep(elemPtrTy, smemBase, offset);\n         auto vecTy = VectorType::get(vec, llvmElemTy);\n-        ptr = rewriter.create<LLVM::BitcastOp>(\n-            loc, LLVM::LLVMPointerType::get(vecTy, 3), ptr);\n+        ptr = bit_cast(LLVM::LLVMPointerType::get(vecTy, 3), ptr);\n         if (stNotRd) {\n           Value valVec = rewriter.create<LLVM::UndefOp>(loc, vecTy);\n           for (unsigned v = 0; v < vec; ++v) {\n             Value vVal = createIndexAttrConstant(\n                 rewriter, loc, getTypeConverter()->getIndexType(), v);\n-            valVec = rewriter.create<LLVM::InsertElementOp>(\n-                loc, vecTy, valVec,\n+            valVec = insert_element(\n+                vecTy, valVec,\n                 vals[elemId + linearCTAId * accumSizePerThread + v], vVal);\n           }\n           rewriter.create<LLVM::StoreOp>(loc, valVec, ptr);\n@@ -1588,8 +1581,7 @@ struct ConvertLayoutOpConversion\n             Value vVal = createIndexAttrConstant(\n                 rewriter, loc, getTypeConverter()->getIndexType(), v);\n             vals[elemId + linearCTAId * accumSizePerThread + v] =\n-                rewriter.create<LLVM::ExtractElementOp>(loc, llvmElemTy, valVec,\n-                                                        vVal);\n+                extract_element(llvmElemTy, valVec, vVal);\n           }\n         }\n       }"}]