[{"filename": "python/triton/tools/build_extern.py", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "file_content_changes": "@@ -0,0 +1,348 @@\n+import argparse\n+import subprocess\n+from abc import ABC, abstractmethod\n+\n+\n+class Symbol:\n+    def __init__(self, name: str, op_name: str, ret_type: str, arg_names: list, arg_types: list) -> None:\n+        '''\n+        A symbol is a function declaration.\n+        :param name: name of the symbol\n+        :param op_name: name of the operation\n+        :param ret_type: return type of the operation\n+        :param arg_names: names of the arguments\n+        :param arg_types: types of the arguments\n+        '''\n+        self._name = name\n+        self._op_name = op_name\n+        self._ret_type = ret_type\n+        self._arg_names = arg_names\n+        self._arg_types = arg_types\n+\n+    @property\n+    def name(self):\n+        return self._name\n+\n+    @property\n+    def op_name(self):\n+        return self._op_name\n+\n+    @property\n+    def ret_type(self):\n+        return self._ret_type\n+\n+    @property\n+    def arg_names(self):\n+        return self._arg_names\n+\n+    @property\n+    def arg_types(self):\n+        return self._arg_types\n+\n+\n+def convert_type(type_str):\n+    if type_str == \"i32\":\n+        return \"int32\"\n+    elif type_str == \"u32\":\n+        return \"uint32\"\n+    elif type_str == \"i64\":\n+        return \"int64\"\n+    elif type_str == \"u64\":\n+        return \"uint64\"\n+    elif type_str == \"float\":\n+        return \"fp32\"\n+    elif type_str == \"double\":\n+        return \"fp64\"\n+    else:\n+        # ignore other types, such as pointer types\n+        return None\n+\n+\n+def to_unsigned(type_str):\n+    if type_str == \"int32\":\n+        return \"uint32\"\n+    elif type_str == \"int64\":\n+        return \"uint64\"\n+    else:\n+        return type_str\n+\n+\n+class ExternLibrary(ABC):\n+    def __init__(self, name: str, path: str, format: bool = True, grouping: bool = True) -> None:\n+        '''\n+        Abstract class for extern library.\n+        :param name: name of the library\n+        :param path: path of the library\n+        :param format: whether to format the generated stub file\n+        '''\n+        self._name = name\n+        self._path = path\n+        self._symbols = {}\n+        self._format = True\n+        self._grouping = grouping\n+\n+    @property\n+    def name(self):\n+        return self._name\n+\n+    @property\n+    def path(self):\n+        return self._path\n+\n+    @property\n+    def symbols(self):\n+        return self._symbols\n+\n+    @property\n+    def grouping(self):\n+        return self._grouping\n+\n+    @abstractmethod\n+    def parse_symbols(self, input_file):\n+        pass\n+\n+    @abstractmethod\n+    def _output_stubs(self) -> str:\n+        pass\n+\n+    def generate_stub_file(self, output_dir):\n+        file_str = self._output_stubs()\n+        if file_str is None or len(file_str) == 0:\n+            raise Exception(\"file_str is empty\")\n+\n+        output_file = f\"{output_dir}/{self._name}.py\"\n+        with open(output_file, \"w\") as f:\n+            f.write(file_str)\n+            f.close()\n+            if self._format:\n+                subprocess.Popen([\"autopep8\", \"-a\", \"-r\", \"-i\", output_file],\n+                                 stdout=subprocess.PIPE).communicate()\n+                subprocess.Popen([\"isort\", output_file], stdout=subprocess.PIPE).communicate()\n+\n+\n+class Libdevice(ExternLibrary):\n+    def __init__(self, path) -> None:\n+        '''\n+        Constructor for Libdevice.\n+        :param path: path of the libdevice library\n+        '''\n+        super().__init__(\"libdevice\", path)\n+        self._symbol_groups = {}\n+\n+    def _extract_symbol(self, line):\n+        # Extract symbols from line in the following format:\n+        # \"define [internal] <ret_type> @<name>(<arg_types>,)\"\n+        entries = line.split(\"@\")\n+        ret_str = entries[0]\n+        func_str = entries[1]\n+        # Get ret_type, skip internal symbols\n+        ret_strs = ret_str.split()\n+        if ret_strs[1] == \"internal\":\n+            return None\n+        ret_type = convert_type(ret_strs[1])\n+        if ret_type is None:\n+            return None\n+        # Get function name\n+        func_strs = func_str.split(\"(\")\n+        func_name = func_strs[0].replace(\"@\", \"\")\n+        op_name = func_name.replace(\"__nv_\", \"\")\n+        if 'ieee' in op_name:\n+            return None\n+        # Get arg_types\n+        arg_strs = func_strs[1].split(\",\")\n+        arg_types = []\n+        arg_names = []\n+        for i, arg_str in enumerate(arg_strs):\n+            arg_type = convert_type(arg_str.split()[0])\n+            if arg_type is None:\n+                return None\n+            arg_name = 'arg' + str(i)\n+            arg_types.append(arg_type)\n+            arg_names.append(arg_name)\n+        if op_name == \"sad\":\n+            # Special case for sad, where the last argument is an unsigned int\n+            arg_types[-1] = to_unsigned(arg_types[-1])\n+        elif op_name.startswith(\"u\"):\n+            # LLVM does not differentiate between signed and unsigned integer type.\n+            # We have to convert the types to unsigned\n+            ret_type = to_unsigned(ret_type)\n+            for i, arg_type in enumerate(arg_types):\n+                arg_types[i] = to_unsigned(arg_type)\n+        return Symbol(func_name, op_name, ret_type, arg_names, arg_types)\n+\n+    def _group_symbols(self):\n+        symbol_set = {}\n+        for symbol in self._symbols.values():\n+            op_name = symbol.op_name\n+            symbol_set[op_name] = symbol\n+\n+        # Group functions together by renaming.\n+        renaming = {\n+            'llabs': 'abs', 'acosf': 'acos', 'acoshf': 'acosh',\n+            'dadd_rd': 'add_rd', 'fadd_rd': 'add_rd', 'dadd_rn': 'add_rn',\n+            'fadd_rn': 'add_rn', 'dadd_ru': 'add_ru', 'fadd_ru': 'add_ru',\n+            'dadd_rz': 'add_rz', 'fadd_rz': 'add_rz', 'asinf': 'asin',\n+            'asinhf': 'asinh', 'atanf': 'atan', 'atan2f': 'atan2',\n+            'atanhf': 'atanh', 'brevll': 'brev', 'cbrtf': 'cbrt',\n+            'ceilf': 'ceil', 'clzll': 'clz', 'copysignf': 'copysign',\n+            'cosf': 'cos', 'coshf': 'cosh', 'cospif': 'cospi',\n+            'cyl_bessel_i0f': 'cyl_bessel_i0', 'cyl_bessel_i1f': 'cyl_bessel_i1',\n+            'fdiv_rd': 'div_rd', 'ddiv_rd': 'div_rd', 'fdiv_rn': 'div_rn',\n+            'ddiv_rn': 'div_rn', 'fdiv_ru': 'div_ru', 'ddiv_ru': 'div_ru',\n+            'fdiv_rz': 'div_rz', 'ddiv_rz': 'div_rz', 'erff': 'erf',\n+            'erfcf': 'erfc', 'erfcinvf': 'erfcinv', 'erfcxf': 'erfcx',\n+            'erfinvf': 'erfinv', 'expf': 'exp', 'exp10f': 'exp10',\n+            'exp2f': 'exp2', 'expm1f': 'expm1', 'fabsf': 'abs',\n+            'fabs': 'abs', 'fast_fdividef': 'fast_dividef',\n+            'fdimf': 'fdim', 'ffsll': 'ffs', 'floorf': 'floor',\n+            'fmaf': 'fma', 'fmaf_rd': 'fma_rd', 'fmaf_rn': 'fma_rn',\n+            'fmaf_ru': 'fma_ru', 'fmaf_rz': 'fma_rz', 'fmodf': 'fmod',\n+            'uhadd': 'hadd', 'hypotf': 'hypot', 'ilogbf': 'ilogb',\n+            'isinff': 'isinf', 'isinfd': 'isinf', 'isnanf': 'isnan',\n+            'isnand': 'isnan', 'j0f': 'j0', 'j1f': 'j1', 'jnf': 'jn',\n+            'ldexpf': 'ldexp', 'lgammaf': 'lgamma', 'llrintf': 'llrint',\n+            'llroundf': 'llround', 'logf': 'log', 'log10f': 'log10',\n+            'log1pf': 'log1p', 'log2f': 'log2', 'logbf': 'logb',\n+            'umax': 'max', 'llmax': 'max', 'ullmax': 'max', 'fmaxf': 'max',\n+            'fmax': 'max', 'umin': 'min', 'llmin': 'min', 'ullmin': 'min',\n+            'fminf': 'min', 'fmin': 'min', 'dmul_rd': 'mul_rd', 'fmul_rd': 'mul_rd',\n+            'dmul_rn': 'mul_rn', 'fmul_rn': 'mul_rn', 'dmul_ru': 'mul_ru',\n+            'fmul_ru': 'mul_ru', 'dmul_rz': 'mul_rz', 'fmul_rz': 'mul_rz',\n+            'umul24': 'mul24', 'umulhi': 'mulhi', 'mul64hi': 'mulhi',\n+            'umul64hi': 'mulhi', 'nearbyintf': 'nearbyint', 'nextafterf': 'nextafter',\n+            'norm3df': 'norm3d', 'norm4df': 'norm4d', 'normcdff': 'normcdf',\n+            'normcdfinvf': 'normcdfinv', 'popcll': 'popc', 'powif': 'pow', 'powi': 'pow',\n+            'powf': 'pow', 'rcbrtf': 'rcbrt', 'frcp_rd': 'rcp_rd', 'drcp_rd': 'rcp_rd',\n+            'frcp_rn': 'rcp_rn', 'drcp_rn': 'rcp_rn', 'frcp_ru': 'rcp_ru',\n+            'drcp_ru': 'rcp_ru', 'frcp_rz': 'rcp_rz', 'drcp_rz': 'rcp_rz',\n+            'remainderf': 'remainder', 'urhadd': 'rhadd', 'rhypotf': 'rhypot',\n+            'rintf': 'rint', 'rnorm3df': 'rnorm3d', 'rnorm4df': 'rnorm4d',\n+            'roundf': 'round', 'rsqrtf': 'rsqrt', 'frsqrt_rn': 'rsqrt_rn',\n+            'usad': 'sad', 'scalbnf': 'scalbn', 'signbitf': 'signbit',\n+            'signbitd': 'signbit', 'sinf': 'sin', 'sinhf': 'sinh',\n+            'sinpif': 'sinpi', 'sqrtf': 'sqrt', 'fsqrt_rd': 'sqrt_rd',\n+            'dsqrt_rd': 'sqrt_rd', 'fsqrt_rn': 'sqrt_rn', 'dsqrt_rn': 'sqrt_rn',\n+            'fsqrt_ru': 'sqrt_ru', 'dsqrt_ru': 'sqrt_ru', 'fsqrt_rz': 'sqrt_rz',\n+            'dsqrt_rz': 'sqrt_rz', 'fsub_rd': 'sub_rd', 'dsub_rd': 'sub_rd',\n+            'fsub_rn': 'sub_rn', 'dsub_rn': 'sub_rn', 'fsub_ru': 'sub_ru',\n+            'dsub_ru': 'sub_ru', 'fsub_rz': 'sub_rz', 'dsub_rz': 'sub_rz',\n+            'tanf': 'tan', 'tanhf': 'tanh', 'tgammaf': 'tgamma', 'truncf': 'trunc',\n+            'y0f': 'y0', 'y1f': 'y1', 'ynf': 'yn'\n+        }\n+\n+        for symbol in self._symbols.values():\n+            op_name = symbol.op_name\n+            if op_name in renaming:\n+                op_name = renaming[op_name]\n+                symbol._op_name = op_name\n+            if op_name in self._symbol_groups:\n+                self._symbol_groups[op_name].append(symbol)\n+            else:\n+                self._symbol_groups[op_name] = [symbol]\n+\n+    def parse_symbols(self, input_file):\n+        if len(self.symbols) > 0:\n+            return\n+        output = subprocess.check_output([\"grep\", \"define\", input_file]).decode().splitlines()\n+        for line in output:\n+            symbol = self._extract_symbol(line)\n+            if symbol is None:\n+                continue\n+            self._symbols[symbol.name] = symbol\n+\n+        self._group_symbols()\n+\n+    def _output_stubs(self):\n+        # Generate python functions in the following format:\n+        # @extern.extern\n+        # def <op_name>(<args>, _builder=None):\n+        #   arg_type_symbol_dict = {[arg_type]: {(symbol, ret_type)}}\n+        #   return extern.dispatch(\"libdevice\", <path>, <args>, <arg_type_symbol_dict>, _builder)\n+        import_str = \"from . import core, extern\\n\"\n+        import_str += \"import os\\n\"\n+        header_str = \"LIBDEVICE_PATH = os.path.dirname(\\n\\tos.path.abspath(__file__)) + \\\"/libdevice.10.bc\\\"\\n\"\n+        func_str = \"\"\n+        for symbols in self._symbol_groups.values():\n+            func_str += \"@extern.extern\\n\"\n+            func_name_str = f\"def {symbols[0].op_name}(\"\n+            for arg_name in symbols[0].arg_names:\n+                func_name_str += f\"{arg_name}, \"\n+            func_name_str += \"_builder=None):\\n\"\n+\n+            return_str = f\"\\treturn extern.elementwise(\\\"{self._name}\\\", LIBDEVICE_PATH, [\"\n+            for arg_name in symbols[0].arg_names:\n+                return_str += f\"{arg_name}, \"\n+            return_str += \"], \\n\"\n+\n+            arg_type_symbol_dict_str = \"{\"\n+            for symbol in symbols:\n+                arg_type_symbol_dict_str += \"(\"\n+                for arg_type in symbol.arg_types:\n+                    arg_type_symbol_dict_str += f'core.dtype(\"{arg_type}\"),'\n+                ret_type = f'core.dtype(\"{symbol.ret_type}\")'\n+                arg_type_symbol_dict_str += \"): (\\\"\" + symbol.name + \"\\\", \" + ret_type + \"),\\n\"\n+            arg_type_symbol_dict_str += \"}\"\n+\n+            return_str += arg_type_symbol_dict_str\n+            return_str += \", _builder)\\n\"\n+\n+            func_str += func_name_str + return_str + \"\\n\"\n+        file_str = import_str + header_str + func_str\n+\n+        return file_str\n+\n+\n+class LLVMDisassembler:\n+    def __init__(self, path):\n+        '''\n+        Invoke llvm-dis to disassemble the given file.\n+        :param path: path to llvm-dis\n+        '''\n+        self._path = path\n+        self._ll_file = \"/tmp/extern_lib.ll\"\n+\n+    def disasm(self, lib_path):\n+        subprocess.Popen([self._path, lib_path, \"-o\", self.ll_file],\n+                         stdout=subprocess.PIPE).communicate()\n+\n+    @property\n+    def ll_file(self):\n+        return self._ll_file\n+\n+    @property\n+    def path(self):\n+        return self._path\n+\n+\n+extern_libs = [\"libdevice\"]\n+\n+\n+def build(llvm_dis_path, lib_path, lib_name, output_dir):\n+    '''\n+      Interface function to build the library file.\n+      :param llvm_dis_path: path to the llvm-dis binary\n+      :param lib_path: path to the external library file\n+      :param lib_name: name of the library\n+      :param output_dir: path to the output directory\n+    '''\n+    if lib_name == \"libdevice\":\n+        extern_lib = Libdevice(lib_path)\n+    else:\n+        raise Exception(f\"Unknown extern library: {lib_name}\")\n+\n+    llvm_disassembler = LLVMDisassembler(llvm_dis_path)\n+    llvm_disassembler.disasm(lib_path)\n+\n+    extern_lib.parse_symbols(llvm_disassembler.ll_file)\n+    extern_lib.generate_stub_file(output_dir)\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"--llvm-dis\", dest=\"llvm_dis_path\", help=\"Path to llvm-dis\", default=\"llvm-dis\")\n+    parser.add_argument(\"--lib-path\", dest=\"lib_path\", help=\"Path to the extern library\")\n+    parser.add_argument(\"--lib-name\", dest=\"lib_name\", help=\"Name of the extern library\")\n+    parser.add_argument(\"--output\", dest=\"output_dir\", help=\"Output file path\", default=\"/tmp/\")\n+    args = parser.parse_args()\n+\n+    build(args.llvm_dis_path, args.lib_path, args.lib_name, args.output_dir)"}]