[{"filename": "include/triton/Analysis/Utility.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "file_content_changes": "@@ -65,7 +65,7 @@ template <typename Int> Int product(llvm::ArrayRef<Int> arr) {\n \n template <typename Int> Int ceil(Int m, Int n) { return (m + n - 1) / n; }\n \n-// output[i] = input[order[i]]\n+/// output[i] = input[order[i]]\n template <typename T, typename RES_T = T>\n SmallVector<RES_T> reorder(ArrayRef<T> input, ArrayRef<unsigned> order) {\n   size_t rank = order.size();\n@@ -80,6 +80,11 @@ SmallVector<RES_T> reorder(ArrayRef<T> input, ArrayRef<unsigned> order) {\n bool isMmaToDotShortcut(triton::gpu::MmaEncodingAttr &mmaLayout,\n                         triton::gpu::DotOperandEncodingAttr &dotOperandLayout);\n \n+/// Multi-root DAG topological sort.\n+/// Performs a topological sort of the Operation in the `toSort` SetVector.\n+/// Returns a topologically sorted SetVector.\n+/// It is faster than mlir::topologicalSort because it prunes nodes that have\n+/// been visited before.\n SetVector<Operation *>\n multiRootTopologicalSort(const SetVector<Operation *> &toSort);\n "}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "file_content_changes": "@@ -176,15 +176,14 @@ struct DFSState {\n   DenseSet<Operation *> seen;\n };\n \n-static void dfsPostorder(Operation *root, DFSState *state) {\n+void dfsPostorder(Operation *root, DFSState *state) {\n   SmallVector<Operation *> queue(1, root);\n   std::vector<Operation *> ops;\n   while (!queue.empty()) {\n     Operation *current = queue.pop_back_val();\n-    if (state->seen.count(current) > 0)\n+    if (!state->seen.insert(current).second)\n       continue;\n     ops.push_back(current);\n-    state->seen.insert(current);\n     for (Value result : current->getResults()) {\n       for (Operation *op : result.getUsers())\n         queue.push_back(op);"}]