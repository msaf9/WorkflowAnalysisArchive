[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM/SharedToDotOperandMMAv2.cpp", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "file_content_changes": "@@ -98,25 +98,29 @@ MMA16816SmemLoader::computeLdmatrixMatOffs(Value warpId, Value lane,\n   Value kMatArr = kOrder == 1 ? s1 : s0;\n   Value nkMatArr = kOrder == 1 ? s0 : s1;\n \n-  // matrix coordinate inside a CTA, the matrix layout is [2x2wpt] for A and\n-  // [2wptx2] for B. e.g. Setting wpt=3, The data layout for A(kOrder=1) is\n-  //   |0 0 1 1 2 2| -> 0,1,2 are the warpids\n-  //   |0 0 1 1 2 2|\n-  //\n-  // for B(kOrder=0) is\n-  //   |0 0|  -> 0,1,2 are the warpids\n-  //   |1 1|\n-  //   |2 2|\n+  // Matrix coordinates inside a CTA,\n+  // the matrix layout is [2wpt[0], 2] for A and [2, 2wpt[1]] for B.\n+  // e.g., Setting wpt=4, the data layout for A(kOrder=1) is\n+  //   |0 0|  -> 0,1,2,3 are the warpids\n   //   |0 0|\n   //   |1 1|\n+  //   |1 1|\n+  //   |2 2|\n   //   |2 2|\n+  //   |3 3|\n+  //   |3 3|\n+  //\n+  // for B(kOrder=0) is\n+  //   |0 1 2 3 0 1 2 3| -> 0,1,2,3 are the warpids\n+  //   |0 1 2 3 0 1 2 3|\n   // Note, for each warp, it handles a 2x2 matrices, that is the coordinate\n   // address (s0,s1) annotates.\n \n   Value matOff[2];\n   matOff[kOrder ^ 1] =\n-      add(mul(warpId, i32_val(warpOffStride)),   // warp offset\n-          mul(nkMatArr, i32_val(matArrStride))); // matrix offset inside a warp\n+      add(mul(warpId, i32_val(warpOffStride)), // warp offset (kOrder=1)\n+          mul(nkMatArr,\n+              i32_val(matArrStride))); // matrix offset inside a warp (kOrder=1)\n   matOff[kOrder] = kMatArr;\n \n   // Physical offset (before swizzling)\n@@ -130,7 +134,13 @@ MMA16816SmemLoader::computeLdmatrixMatOffs(Value warpId, Value lane,\n \n   SmallVector<Value> offs(numPtrs);\n   Value phase = urem(udiv(sOffInMat, i32_val(perPhase)), i32_val(maxPhase));\n-  Value sOff = add(sOffInMat, mul(sMatOff, i32_val(sMatShape)));\n+  // To prevent out-of-bound access of B when wpt * 16 > tile_size.\n+  // In such a case, we need to wrap around the offset of B.\n+  // |0 1 2 3 0 1 2 3| -> | 0(0) 1(1) 2(2) 3(3) |\n+  // |0 1 2 3 0 1 2 3|    | 0(0) 1(1) 2(2) 3(3) |\n+  //          ~~~~~~~ out-of-bound access\n+  Value sOff = urem(add(sOffInMat, mul(sMatOff, i32_val(sMatShape))),\n+                    i32_val(tileShape[order[1]]));\n   for (int i = 0; i < numPtrs; ++i) {\n     Value cMatOffI = add(cMatOff, i32_val(i * pLoadStrideInMat));\n     cMatOffI = xor_(cMatOffI, phase);"}]