[{"filename": "python/test/unit/operators/test_flash_attention.py", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "file_content_changes": "@@ -10,22 +10,23 @@\n                                                  (4, 48, 1024, 64),\n                                                  (4, 48, 1024, 128)])\n @pytest.mark.parametrize('dtype', [torch.float16, torch.bfloat16])\n-def test_op(Z, H, N_CTX, D_HEAD, dtype):\n+@pytest.mark.parametrize('causal', [True, False])\n+@pytest.mark.parametrize('seq_par', [True, False])\n+def test_op(Z, H, N_CTX, D_HEAD, dtype, causal, seq_par):\n     capability = torch.cuda.get_device_capability()\n     if capability[0] < 8:\n         pytest.skip(\"Flash attention only supported for compute capability < 80\")\n     torch.manual_seed(20)\n-    q = torch.empty((Z, H, N_CTX, D_HEAD), dtype=dtype, device=\"cuda\").normal_(mean=0.1, std=0.2).requires_grad_()\n-    k = torch.empty((Z, H, N_CTX, D_HEAD), dtype=dtype, device=\"cuda\").normal_(mean=0.4, std=0.2).requires_grad_()\n-    v = torch.empty((Z, H, N_CTX, D_HEAD), dtype=dtype, device=\"cuda\").normal_(mean=0.3, std=0.2).requires_grad_()\n-    sm_scale = 0.2\n+    q = torch.empty((Z, H, N_CTX, D_HEAD), dtype=dtype, device=\"cuda\").normal_(mean=0., std=0.5).requires_grad_()\n+    k = torch.empty((Z, H, N_CTX, D_HEAD), dtype=dtype, device=\"cuda\").normal_(mean=0., std=0.5).requires_grad_()\n+    v = torch.empty((Z, H, N_CTX, D_HEAD), dtype=dtype, device=\"cuda\").normal_(mean=0., std=0.5).requires_grad_()\n+    sm_scale = 0.5\n     dout = torch.randn_like(q)\n     # reference implementation\n     M = torch.tril(torch.ones((N_CTX, N_CTX), device=\"cuda\"))\n     p = torch.matmul(q, k.transpose(2, 3)) * sm_scale\n-    for z in range(Z):\n-        for h in range(H):\n-            p[:, :, M == 0] = float(\"-inf\")\n+    if causal:\n+        p[:, :, M == 0] = float(\"-inf\")\n     p = torch.softmax(p.float(), dim=-1).to(dtype)\n     # p = torch.exp(p)\n     ref_out = torch.matmul(p, v)\n@@ -34,7 +35,7 @@ def test_op(Z, H, N_CTX, D_HEAD, dtype):\n     ref_dk, k.grad = k.grad.clone(), None\n     ref_dq, q.grad = q.grad.clone(), None\n     # # triton implementation\n-    tri_out = triton.ops.attention(q, k, v, sm_scale)\n+    tri_out = triton.ops.attention(q, k, v, causal, sm_scale, seq_par)\n     # print(ref_out)\n     # print(tri_out)\n     tri_out.backward(dout)"}]