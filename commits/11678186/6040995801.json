[{"filename": "include/triton/Analysis/Utility.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "file_content_changes": "@@ -36,6 +36,8 @@ class ReduceOpHelper {\n \n   triton::ReduceOp getOperation() { return op; }\n \n+  Type getLargestSrcElementType();\n+\n   bool isFastReduction();\n \n   bool isWarpSynchronous();\n@@ -52,7 +54,7 @@ class ReduceOpHelper {\n \n   SmallVector<unsigned> getScratchConfigBasic();\n \n-  SmallVector<SmallVector<unsigned>> getScratchConfigsFast();\n+  SmallVector<unsigned> getScratchConfigsFast();\n \n   unsigned getScratchSizeInBytes();\n "}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "file_content_changes": "@@ -136,47 +136,46 @@ bool ReduceOpHelper::isWarpSynchronous() {\n          (triton::gpu::getWarpsPerCTA(argsLayout)[axis] == 1);\n }\n \n-SmallVector<SmallVector<unsigned>> ReduceOpHelper::getScratchConfigsFast() {\n-  SmallVector<SmallVector<unsigned>> smemShapes(3);\n+SmallVector<unsigned> ReduceOpHelper::getScratchConfigsFast() {\n+  SmallVector<unsigned> smemShape;\n \n   auto argLayout = getSrcLayout();\n   auto argLayoutMma = argLayout.dyn_cast<triton::gpu::MmaEncodingAttr>();\n \n   // that case doesn't need inter-warp communication\n   if (isWarpSynchronous())\n-    return {{0, 0}, {0, 0}};\n+    return {0, 0};\n \n   /// shared memory block0\n-  smemShapes[0] = convertType<unsigned>(getSrcShape());\n-  smemShapes[0][axis] = getInterWarpSize();\n+  smemShape = convertType<unsigned>(getSrcShape());\n+  smemShape[axis] = getInterWarpSize();\n \n-  /// FIXME(Qingyi): This size is actually larger than required.\n-  /// shared memory block1:\n-  auto mod = op->getParentOfType<ModuleOp>();\n-  unsigned numWarps = triton::gpu::TritonGPUDialect::getNumWarps(mod);\n-  unsigned threadsPerWarp =\n-      triton::gpu::TritonGPUDialect::getThreadsPerWarp(mod);\n-  smemShapes[1].push_back(numWarps * threadsPerWarp);\n+  return smemShape;\n+}\n \n-  return smemShapes;\n+Type ReduceOpHelper::getLargestSrcElementType() {\n+  Type elemTy = srcElementTypes[0];\n+  for (const auto &ty : srcElementTypes) {\n+    if (elemTy.getIntOrFloatBitWidth() < ty.getIntOrFloatBitWidth()) {\n+      elemTy = ty;\n+    }\n+  }\n+  return elemTy;\n }\n \n unsigned ReduceOpHelper::getScratchSizeInBytes() {\n   unsigned elems = 0;\n   if (isFastReduction()) {\n-    auto smemShapes = getScratchConfigsFast();\n-    for (const auto &smemShape : smemShapes)\n-      elems = std::max(elems, product<unsigned>(smemShape));\n+    auto smemShape = getScratchConfigsFast();\n+    elems = product<unsigned>(smemShape);\n   } else {\n     auto smemShape = getScratchConfigBasic();\n     elems = product<unsigned>(smemShape);\n   }\n \n-  unsigned bytesPerElem = 0;\n-  for (const auto &ty : srcElementTypes) {\n-    bytesPerElem += ceil<unsigned>(ty.getIntOrFloatBitWidth(), 8);\n-  }\n-  return bytesPerElem * elems;\n+  unsigned bytesPerElem =\n+      ceil<unsigned>(getLargestSrcElementType().getIntOrFloatBitWidth(), 8);\n+  return (bytesPerElem * srcElementTypes.size()) * elems;\n }\n \n bool ReduceOpHelper::isSupportedLayout() {"}, {"filename": "lib/Conversion/TritonGPUToLLVM/ReduceOpToLLVM.cpp", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "file_content_changes": "@@ -9,6 +9,7 @@ using namespace mlir::triton;\n \n using ::mlir::LLVM::delinearize;\n using ::mlir::LLVM::linearize;\n+using ::mlir::LLVM::loadShared;\n using ::mlir::LLVM::shflSync;\n using ::mlir::LLVM::storeShared;\n using ::mlir::triton::gpu::getOrder;\n@@ -475,7 +476,7 @@ struct ReduceOpConversion\n     auto srcLayout = helper.getSrcLayout();\n     auto srcShape = helper.getSrcShape();\n     unsigned axis = op.getAxis();\n-    auto smemShapes = helper.getScratchConfigsFast();\n+    auto smemShape = helper.getScratchConfigsFast();\n \n     auto threadsPerWarp =\n         triton::gpu::getThreadsPerWarpWithUniqueData(srcLayout, srcShape);\n@@ -499,8 +500,7 @@ struct ReduceOpConversion\n \n       SmallVector<Value> writeIdx = indices[key];\n       writeIdx[axis] = warpIdAxis;\n-      Value writeOffset =\n-          linearize(rewriter, loc, writeIdx, smemShapes[0], order);\n+      Value writeOffset = linearize(rewriter, loc, writeIdx, smemShape, order);\n       for (unsigned i = 0; i < op.getNumOperands(); ++i) {\n         auto elemPtrTy = getElementPtrType(op, i);\n         Value writePtr = gep(elemPtrTy, smemBases[i], writeOffset);\n@@ -516,8 +516,8 @@ struct ReduceOpConversion\n                                    ConversionPatternRewriter &rewriter) const {\n     triton::ReduceOp op = helper.getOperation();\n     auto srcLayout = helper.getSrcLayout();\n-    auto smemShapes = helper.getScratchConfigsFast();\n-    unsigned elems = product<unsigned>(smemShapes[0]);\n+    auto smemShape = helper.getScratchConfigsFast();\n+    unsigned elems = product<unsigned>(smemShape);\n     unsigned sizeInterWarps = helper.getInterWarpSizeWithUniqueData();\n     Location loc = op.getLoc();\n \n@@ -539,7 +539,8 @@ struct ReduceOpConversion\n       for (unsigned i = 0; i < op.getNumOperands(); ++i) {\n         auto elemPtrTy = getElementPtrType(op, i);\n         Value readPtr = gep(elemPtrTy, smemBases[i], readOffset);\n-        acc[i] = load(readPtr);\n+        Value threadLoads = icmp_slt(threadId, i32_val(elems));\n+        acc[i] = loadShared(rewriter, loc, readPtr, threadLoads);\n       }\n       warpReduce(rewriter, loc, acc, op, sizeInterWarps);\n \n@@ -573,7 +574,7 @@ struct ReduceOpConversion\n                                   ConversionPatternRewriter &rewriter) const {\n     triton::ReduceOp op = helper.getOperation();\n     Location loc = op.getLoc();\n-    auto smemShapes = helper.getScratchConfigsFast();\n+    auto smemShape = helper.getScratchConfigsFast();\n     auto order = getOrder(helper.getSrcLayout());\n     SmallVector<Value> results(op.getNumOperands());\n     for (unsigned i = 0; i < op.getNumOperands(); ++i) {\n@@ -590,7 +591,7 @@ struct ReduceOpConversion\n           SmallVector<Value> readIdx = resultIndices[j];\n           readIdx.insert(readIdx.begin() + op.getAxis(), i32_val(0));\n           Value readOffset =\n-              linearize(rewriter, loc, readIdx, smemShapes[0], order);\n+              linearize(rewriter, loc, readIdx, smemShape, order);\n           Value readPtr =\n               gep(getElementPtrType(op, i), smemBases[i], readOffset);\n           resultVals[j] = load(readPtr);\n@@ -632,17 +633,19 @@ struct ReduceOpConversion\n     }\n \n     // Compute a shared memory base per operand.\n-    auto smemShapes = helper.getScratchConfigsFast();\n-    unsigned elems = product<unsigned>(smemShapes[0]);\n-    unsigned maxElems = std::max(elems, product<unsigned>(smemShapes[1]));\n+    auto smemShape = helper.getScratchConfigsFast();\n+    unsigned elems = product<unsigned>(smemShape);\n     SmallVector<Value> smemBases(op.getNumOperands());\n     smemBases[0] =\n         bitcast(getSharedMemoryBase(loc, rewriter, op.getOperation()),\n                 getElementPtrType(op, 0));\n+\n+    Type elemTy = helper.getLargestSrcElementType();\n+    auto elemPtrTy = LLVM::LLVMPointerType::get(elemTy, 3);\n     for (unsigned i = 1; i < op.getNumOperands(); ++i) {\n-      smemBases[i] = bitcast(gep(getElementPtrType(op, i - 1), smemBases[i - 1],\n-                                 i32_val(maxElems)),\n-                             getElementPtrType(op, i));\n+      smemBases[i] = bitcast(\n+          gep(elemPtrTy, bitcast(smemBases[i - 1], elemPtrTy), i32_val(elems)),\n+          getElementPtrType(op, i));\n     }\n     storeWarpReduceToSharedMemory(helper, accs, indices, smemBases, rewriter);\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.cpp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "file_content_changes": "@@ -250,6 +250,24 @@ Value storeShared(ConversionPatternRewriter &rewriter, Location loc, Value ptr,\n   return builder.launch(rewriter, loc, void_ty(ctx));\n }\n \n+Value loadShared(ConversionPatternRewriter &rewriter, Location loc, Value ptr,\n+                 Value pred) {\n+  MLIRContext *ctx = rewriter.getContext();\n+  auto ptrTy = ptr.getType().cast<LLVMPointerType>();\n+  assert(ptrTy.getAddressSpace() == 3 && \"Invalid addr space for loadShared\");\n+  auto elemTy = ptrTy.getElementType();\n+  unsigned bitwidth = elemTy.getIntOrFloatBitWidth();\n+\n+  const char *c = bitwidth == 64 ? \"=l\" : (bitwidth == 16 ? \"=h\" : \"=r\");\n+\n+  PTXBuilder builder;\n+  auto *dOpr = builder.newOperand(c);\n+  auto *ptrOpr = builder.newAddrOperand(ptr, \"r\");\n+  auto &ld = builder.create<>(\"ld\")->shared().b(bitwidth);\n+  ld(dOpr, ptrOpr).predicate(pred, \"b\");\n+  return builder.launch(rewriter, loc, elemTy);\n+}\n+\n static Value commonShflSync(Location loc, ConversionPatternRewriter &rewriter,\n                             Value val, int i, const std::string &shuffleType,\n                             const std::string &clamp) {"}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -320,6 +320,9 @@ Value linearize(ConversionPatternRewriter &rewriter, Location loc,\n Value storeShared(ConversionPatternRewriter &rewriter, Location loc, Value ptr,\n                   Value val, Value pred);\n \n+Value loadShared(ConversionPatternRewriter &rewriter, Location loc, Value ptr,\n+                 Value pred);\n+\n Value shflSync(Location loc, ConversionPatternRewriter &rewriter, Value val,\n                int i);\n Value shflUpSync(Location loc, ConversionPatternRewriter &rewriter, Value val,"}]