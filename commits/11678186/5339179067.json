[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "file_content_changes": "@@ -1370,7 +1370,10 @@ def get_reduced_dtype(dtype_str, op):\n                           for op in ['min', 'max',\n                                      'min-with-indices',\n                                      'max-with-indices',\n-                                     'argmin', 'argmax',\n+                                     'argmin-tie-break-fast',\n+                                     'argmin-tie-break-left',\n+                                     'argmax-tie-break-fast',\n+                                     'argmax-tie-break-left',\n                                      'sum']\n                           for dtype in dtypes_with_bfloat16\n                           for shape in [32, 64, 128, 512]])\n@@ -1386,18 +1389,26 @@ def kernel(X, Z, BLOCK: tl.constexpr):\n \n     if 'with-indices' in op:\n         patch = f'z, _ = tl.{op.split(\"-\")[0]}(x, axis=0, return_indices=True)'\n+    elif 'arg' in op:\n+        tie_break_left = 'tie-break-left' in op\n+        patch = f'z = tl.{op.split(\"-\")[0]}(x, axis=0, tie_break_left={tie_break_left})'\n     else:\n         patch = f'z = tl.{op}(x, axis=0)'\n     kernel = patch_kernel(kernel, {'GENERATE_TEST_HERE': patch})\n     # input\n     rs = RandomState(17)\n     # limit the range of integers so that the sum does not overflow\n     x = numpy_random((shape,), dtype_str=dtype_str, rs=rs)\n-    x_tri = to_triton(x, device=device)\n     numpy_op = {'sum': np.sum, 'max': np.max, 'min': np.min,\n                 'max-with-indices': np.max,\n                 'min-with-indices': np.min,\n-                'argmin': np.argmin, 'argmax': np.argmax}[op]\n+                'argmin-tie-break-fast': np.argmin,\n+                'argmin-tie-break-left': np.argmin,\n+                'argmax-tie-break-fast': np.argmax,\n+                'argmax-tie-break-left': np.argmax}[op]\n+    if 'tie-break-left' in op:\n+        x[3:10] = numpy_op(x)\n+    x_tri = to_triton(x, device=device)\n     # numpy result\n     z_dtype_str = 'int32' if op in ('argmin', 'argmax') else dtype_str\n     z_tri_dtype_str = z_dtype_str"}, {"filename": "python/triton/compiler/code_generator.py", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "file_content_changes": "@@ -595,14 +595,12 @@ def visit_Pass(self, node):\n     def visit_Compare(self, node):\n         if not (len(node.comparators) == 1 and len(node.ops) == 1):\n             raise UnsupportedLanguageConstruct(None, node, \"simultaneous multiple comparison is not supported\")\n-        lhs = self.visit(node.left)\n-        rhs = self.visit(node.comparators[0])\n-        lhs_value = _unwrap_if_constexpr(lhs)\n-        rhs_value = _unwrap_if_constexpr(rhs)\n+        lhs = _unwrap_if_constexpr(self.visit(node.left))\n+        rhs = _unwrap_if_constexpr(self.visit(node.comparators[0]))\n         if type(node.ops[0]) == ast.Is:\n-            return constexpr(lhs_value is rhs_value)\n+            return constexpr(lhs is rhs)\n         if type(node.ops[0]) == ast.IsNot:\n-            return constexpr(lhs_value is not rhs_value)\n+            return constexpr(lhs is not rhs)\n         method_name = self._method_name_for_comp_op.get(type(node.ops[0]))\n         if method_name is None:\n             raise UnsupportedLanguageConstruct(None, node, \"AST comparison operator '{}' is not (currently) implemented.\".format(node.ops[0].__name__))\n@@ -990,7 +988,7 @@ def execute_static_assert(self, node: ast.Call) -> None:\n         if not (0 < arg_count <= 2) or len(node.keywords):\n             raise TypeError(\"`static_assert` requires one or two positional arguments only\")\n \n-        passed = _unwrap_if_constexpr(self.visit(node.args[0]))\n+        passed = self.visit(node.args[0])\n         if not isinstance(passed, bool):\n             raise NotImplementedError(\"Assertion condition could not be determined at compile-time. Make sure that it depends only on `constexpr` values\")\n         if not passed:"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "file_content_changes": "@@ -1374,65 +1374,88 @@ def maximum(x, y):\n \n \n @jit\n-def _max_combine(a, b):\n-    return maximum(a, b)\n+def _argmax_combine(value1, index1, value2, index2, tie_break_left):\n+    if tie_break_left:\n+        tie = value1 == value2 and index1 < index2\n+    else:\n+        tie = False\n+    gt = value1 > value2 or tie\n+    v_ret = where(gt, value1, value2)\n+    i_ret = where(gt, index1, index2)\n+    return v_ret, i_ret\n \n \n @jit\n-def _argmax_combine(value1, index1, value2, index2):\n-    gt = value1 > value2\n-    value_ret = where(gt, value1, value2)\n-    index_ret = where(gt, index1, index2)\n-    return value_ret, index_ret\n+def _argmax_combine_tie_break_left(value1, index1, value2, index2):\n+    return _argmax_combine(value1, index1, value2, index2, True)\n+\n+\n+@jit\n+def _argmax_combine_tie_break_fast(value1, index1, value2, index2):\n+    return _argmax_combine(value1, index1, value2, index2, False)\n \n \n @jit\n @_add_reduction_docstr(\"maximum\")\n-def max(input, axis=None, return_indices=False):\n+def max(input, axis=None, return_indices=False, return_indices_tie_break_left=True):\n     input = _promote_reduction_input(input)\n     if return_indices:\n-        return _reduce_with_indices(input, axis, _argmax_combine)\n+        if return_indices_tie_break_left:\n+            return _reduce_with_indices(input, axis, _argmax_combine_tie_break_left)\n+        else:\n+            return _reduce_with_indices(input, axis, _argmax_combine_tie_break_fast)\n     else:\n-        return reduce(input, axis, _max_combine)\n+        return reduce(input, axis, maximum)\n \n \n @jit\n @_add_reduction_docstr(\"maximum index\")\n-def argmax(input, axis):\n-    (_, ret) = max(input, axis, return_indices=True)\n+def argmax(input, axis, tie_break_left=True):\n+    (_, ret) = max(input, axis, return_indices=True, return_indices_tie_break_left=tie_break_left)\n     return ret\n \n # min and argmin\n \n \n @jit\n-def _min_combine(a, b):\n-    # TODO: minimum/maximum doesn't get lowered to fmin/fmax...\n-    return minimum(a, b)\n-\n-\n-@jit\n-def _argmin_combine(value1, index1, value2, index2):\n-    lt = value1 < value2\n+def _argmin_combine(value1, index1, value2, index2, tie_break_left):\n+    if tie_break_left:\n+        tie = value1 == value2 and index1 < index2\n+    else:\n+        tie = False\n+    lt = value1 < value2 or tie\n     value_ret = where(lt, value1, value2)\n     index_ret = where(lt, index1, index2)\n     return value_ret, index_ret\n \n \n+@jit\n+def _argmin_combine_tie_break_left(value1, index1, value2, index2):\n+    return _argmin_combine(value1, index1, value2, index2, True)\n+\n+\n+@jit\n+def _argmin_combine_tie_break_fast(value1, index1, value2, index2):\n+    return _argmin_combine(value1, index1, value2, index2, False)\n+\n+\n @jit\n @_add_reduction_docstr(\"minimum\")\n-def min(input, axis=None, return_indices=False):\n+def min(input, axis=None, return_indices=False, return_indices_tie_break_left=True):\n     input = _promote_reduction_input(input)\n     if return_indices:\n-        return _reduce_with_indices(input, axis, _argmin_combine)\n+        if return_indices_tie_break_left:\n+            return _reduce_with_indices(input, axis, _argmin_combine_tie_break_left)\n+        else:\n+            return _reduce_with_indices(input, axis, _argmin_combine_tie_break_fast)\n     else:\n-        return reduce(input, axis, _min_combine)\n+        return reduce(input, axis, minimum)\n \n \n @jit\n @_add_reduction_docstr(\"minimum index\")\n-def argmin(input, axis):\n-    _, ret = min(input, axis, return_indices=True)\n+def argmin(input, axis, tie_break_left=True):\n+    _, ret = min(input, axis, return_indices=True, return_indices_tie_break_left=tie_break_left)\n     return ret\n \n "}]