[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 122, "deletions": 1, "changes": 123, "file_content_changes": "@@ -4894,6 +4894,127 @@ struct FDivOpConversion\n   }\n };\n \n+/// ====================== atomic_rmw codegen begin ==========================\n+struct AtomicRMWOpConversion\n+    : public ConvertTritonGPUOpToLLVMPattern<triton::AtomicRMWOp>,\n+      public LoadStoreConversionBase {\n+  using ConvertTritonGPUOpToLLVMPattern<\n+      triton::AtomicRMWOp>::ConvertTritonGPUOpToLLVMPattern;\n+\n+  AtomicRMWOpConversion(LLVMTypeConverter &converter,\n+                        AxisInfoAnalysis &axisAnalysisPass,\n+                        PatternBenefit benefit)\n+      : ConvertTritonGPUOpToLLVMPattern<triton::AtomicRMWOp>(converter,\n+                                                             benefit),\n+        LoadStoreConversionBase(axisAnalysisPass) {}\n+\n+  LogicalResult\n+  matchAndRewrite(triton::AtomicRMWOp op, OpAdaptor adaptor,\n+                  ConversionPatternRewriter &rewriter) const override {\n+\n+    auto loc = op.getLoc();\n+    MLIRContext *ctx = rewriter.getContext();\n+\n+    auto atomicRmwAttr = op.atomic_rmw_op();\n+    Value ptr = op.ptr();\n+    Value val = op.val();\n+\n+    Value llPtr = adaptor.ptr();\n+    Value llVal = adaptor.val();\n+\n+    auto valElements = getElementsFromStruct(loc, llVal, rewriter);\n+    auto ptrElements = getElementsFromStruct(loc, llPtr, rewriter);\n+\n+    // TODO[dongdongl]: Support mask and scalar\n+\n+    auto valueTy = op.getResult().getType().dyn_cast<RankedTensorType>();\n+    if (!valueTy)\n+      return failure();\n+    Type valueElemTy =\n+        getTypeConverter()->convertType(valueTy.getElementType());\n+\n+    auto valTy = val.getType().cast<RankedTensorType>();\n+    const size_t valueElemNbits = valueElemTy.getIntOrFloatBitWidth();\n+    auto vec = getVectorSize(ptr);\n+    vec = std::min<unsigned>(vec, valTy.getElementType().isF16() ? 2 : 1);\n+\n+    auto vecTy = vec_ty(valueElemTy, vec);\n+    auto elemsPerThread = getElemsPerThread(val.getType());\n+    SmallVector<Value> resultVals(elemsPerThread);\n+    for (size_t i = 0; i < elemsPerThread; i += vec) {\n+      Value rmvVal = undef(vecTy);\n+      for (int ii = 0; ii < vec; ++ii) {\n+        Value iiVal = createIndexAttrConstant(\n+            rewriter, loc, getTypeConverter()->getIndexType(), ii);\n+        rmvVal = insert_element(vecTy, rmvVal, valElements[i], iiVal);\n+      }\n+      Value rmwPtr = bitcast(ptrElements[i], ptr_ty(valTy.getElementType()));\n+      std::string sTy;\n+      PTXBuilder ptxBuilder;\n+\n+      auto *dstOpr = ptxBuilder.newOperand(\"=r\");\n+      auto *ptrOpr = ptxBuilder.newAddrOperand(rmwPtr, \"r\");\n+      auto *valOpr = ptxBuilder.newOperand(rmvVal, \"r\");\n+\n+      auto &atom = *ptxBuilder.create<>(\"atom\");\n+\n+      atom.o(\"global\").o(\"gpu\");\n+      auto rmwOp = stringifyRMWOp(atomicRmwAttr).str();\n+      auto sBits = std::to_string(valueElemNbits);\n+      switch (atomicRmwAttr) {\n+      case RMWOp::AND:\n+        sTy = \"b\" + sBits;\n+        break;\n+      case RMWOp::OR:\n+        sTy = \"b\" + sBits;\n+        break;\n+      case RMWOp::XOR:\n+        sTy = \"b\" + sBits;\n+        break;\n+      case RMWOp::ADD:\n+        sTy = \"s\" + sBits;\n+        break;\n+      case RMWOp::FADD:\n+        rmwOp = \"add\";\n+        rmwOp += (valueElemNbits == 16 ? \".noftz\" : \"\");\n+        sTy = \"f\" + sBits;\n+        sTy += (vec == 2 && valueElemNbits == 16) ? \"x2\" : \"\";\n+        break;\n+      case RMWOp::MAX:\n+        sTy = \"s\" + sBits;\n+        break;\n+      case RMWOp::MIN:\n+        sTy = \"s\" + sBits;\n+        break;\n+      case RMWOp::UMAX:\n+        rmwOp = \"max\";\n+        sTy = \"u\" + sBits;\n+        break;\n+      case RMWOp::UMIN:\n+        rmwOp = \"min\";\n+        sTy = \"u\" + sBits;\n+        break;\n+      default:\n+        return failure();\n+      }\n+      atom.o(rmwOp).o(sTy);\n+\n+      atom(dstOpr, ptrOpr, valOpr);\n+      auto ret = ptxBuilder.launch(rewriter, loc, valueElemTy, false);\n+      for (int ii = 0; ii < vec; ++ii) {\n+        resultVals[i * vec + ii] =\n+            vec == 1 ? ret : extract_element(vecTy, ret, idx_val(ii));\n+      }\n+    }\n+    Type structTy = getTypeConverter()->convertType(valueTy);\n+    Value resultStruct =\n+        getStructFromElements(loc, resultVals, rewriter, structTy);\n+    rewriter.replaceOp(op, {resultStruct});\n+    return success();\n+  }\n+};\n+/// ====================== atomic_rmw codegen end ==========================\n+\n void populateTritonToLLVMPatterns(mlir::LLVMTypeConverter &typeConverter,\n                                   RewritePatternSet &patterns, int numWarps,\n                                   AxisInfoAnalysis &axisInfoAnalysis,\n@@ -4965,7 +5086,7 @@ void populateTritonToLLVMPatterns(mlir::LLVMTypeConverter &typeConverter,\n   patterns.add<ReduceOpConversion>(typeConverter, allocation, smem, benefit);\n   patterns.add<ConvertLayoutOpConversion>(typeConverter, allocation, smem,\n                                           benefit);\n-\n+  patterns.add<AtomicRMWOpConversion>(typeConverter, axisInfoAnalysis, benefit);\n   patterns.add<ExtractSliceOpConversion>(typeConverter, allocation, smem,\n                                          benefit);\n   patterns.add<GetProgramIdOpConversion>(typeConverter, benefit);"}, {"filename": "test/Conversion/tritongpu_to_llvm.mlir", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "file_content_changes": "@@ -811,3 +811,16 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n     return\n   }\n }\n+\n+// -----\n+\n+#blocked0 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n+module attributes {\"triton_gpu.num-warps\" = 4 : i32} {\n+  // CHECK-LABEL: atomic_add_f32\n+  func @atomic_add_f32(%arg0 : tensor<256x!tt.ptr<f32>, #blocked0>, %arg1 : tensor<256xi1, #blocked0>, %arg2 : tensor<256xf32, #blocked0>) {\n+    // CHECK: llvm.inline_asm\n+    // CHECK-SAME: atom.global.gpu.add.f32\n+    %0 = \"tt.atomic_rmw\" (%arg0, %arg2, %arg1) {atomic_rmw_op = 5 : i32} : (tensor<256x!tt.ptr<f32>, #blocked0>, tensor<256xf32, #blocked0>, tensor<256xi1, #blocked0>) -> tensor<256xf32, #blocked0>\n+    return\n+  }\n+}"}]