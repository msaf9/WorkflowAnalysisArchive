[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "file_content_changes": "@@ -212,17 +212,23 @@ struct CallOpConversion : public ConvertOpToLLVMPattern<triton::CallOp> {\n     // of shared memory and append it to the operands of the callOp.\n     auto loc = callOp.getLoc();\n     auto caller = callOp->getParentOfType<FunctionOpInterface>();\n-    auto base = allocation.getFunctionSharedMemoryBase(caller);\n-    auto *funcAllocation = allocation.getFuncData(caller);\n-    auto bufferId = funcAllocation->getBufferId(callOp);\n-    auto offset = funcAllocation->getOffset(bufferId);\n     auto ptrTy = LLVM::LLVMPointerType::get(\n         this->getTypeConverter()->convertType(rewriter.getI8Type()),\n         NVVM::kSharedMemorySpace);\n-    auto offsetValue = gep(ptrTy, base, i32_val(offset));\n     auto promotedOperands = this->getTypeConverter()->promoteOperands(\n         callOp.getLoc(), /*opOperands=*/callOp->getOperands(),\n         adaptor.getOperands(), rewriter);\n+    auto base = allocation.getFunctionSharedMemoryBase(caller);\n+    auto *funcAllocation = allocation.getFuncData(caller);\n+    auto bufferId = funcAllocation->getBufferId(callOp);\n+    // function doesn't have a shared mem buffer\n+    if (bufferId == (size_t)-1) {\n+      promotedOperands.push_back(base);\n+      return promotedOperands;\n+    }\n+    // function has a shared mem buffer\n+    auto offset = funcAllocation->getOffset(bufferId);\n+    auto offsetValue = gep(ptrTy, base, i32_val(offset));\n     promotedOperands.push_back(offsetValue);\n     return promotedOperands;\n   }"}]