[{"filename": "include/triton/codegen/extern_lib.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "file_content_changes": "@@ -13,6 +13,9 @@ namespace triton {\n \n namespace codegen {\n \n+///\n+/// \\brief ExternLib is a class that represents a library of external functions.\n+///\n class ExternLib {\n  public:\n   ExternLib(const std::string &name, const std::string &path)\n@@ -24,18 +27,30 @@ class ExternLib {\n \n   virtual const std::string &path() const { return path_; }\n \n+  ///\n+  /// \\brief Load the library and return the module.\n+  ///\n   std::unique_ptr<llvm::Module> load(llvm::LLVMContext &ctx);\n \n+  ///\n+  /// \\brief Link the module into the given module.\n+  ///\n   void link(llvm::LLVMContext &ctx, std::unique_ptr<llvm::Module> &llvm,\n             std::unique_ptr<llvm::Module> &mod);\n \n+  ///\n+  /// \\brief Run load, link, and opt on the module.\n+  ///\n   virtual void install(llvm::LLVMContext &ctx,\n                        std::unique_ptr<llvm::Module> &llvm) {\n     auto mod = load(ctx);\n     link(ctx, llvm, mod);\n     opt(ctx, llvm);\n   }\n \n+  ///\n+  /// \\brief Run opt on the module.\n+  ///\n   virtual void opt(llvm::LLVMContext &ctx,\n                    std::unique_ptr<llvm::Module> &llvm) = 0;\n \n@@ -44,18 +59,22 @@ class ExternLib {\n   std::string path_;\n };\n \n+///\n+/// \\brief Concrete class for NVIDIA's libdevice library.\n+///\n class LibDevice final : public ExternLib {\n  public:\n   LibDevice(const std::string &name, const std::string &path)\n       : ExternLib(name, path) {}\n \n   virtual ~LibDevice() = default;\n \n-  virtual void opt(llvm::LLVMContext &ctx, std::unique_ptr<llvm::Module> &llvm);\n+  virtual void opt(llvm::LLVMContext &ctx,\n+                   std::unique_ptr<llvm::Module> &llvm) override;\n };\n \n }  // namespace codegen\n \n }  // namespace triton\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"filename": "include/triton/codegen/pass.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "file_content_changes": "@@ -25,16 +25,17 @@ namespace driver{\n }\n }\n \n-namespace triton {\n-namespace codegen {\n+namespace triton{\n+namespace codegen{\n \n // TODO:\n // There should be a proper pass manager there!\n-std::unique_ptr<llvm::Module> add_passes_to_emit_bin(\n-    ir::module &ir, llvm::LLVMContext &ctx, codegen::target *target,\n-    int num_warps, int num_stages, int &shared_static);\n+std::unique_ptr<llvm::Module> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMContext& ctx,\n+                                                     codegen::target* target,\n+                                                     int num_warps, int num_stages, int &shared_static);\n+\n \n-}  // namespace codegen\n-}  // namespace triton\n+}\n+}\n \n-#endif\n+#endif\n\\ No newline at end of file"}, {"filename": "include/triton/codegen/selection/generator.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "file_content_changes": "@@ -211,9 +211,15 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   void visit_layout_scanline(analysis::scanline_layout*);\n   void visit_layout_shared(analysis::shared_layout*);\n \n-  // libdevice\n+  ///\n+  /// \\brief Add a new external library based on given name and path if it\n+  /// doesn't exist\n+  ///\n   void add_extern_lib(const std::string &lib_name, const std::string &lib_path);\n \n+  ///\n+  /// \\brief get all external libraries\n+  ///\n   const std::map<std::string, std::unique_ptr<ExternLib>> &get_extern_libs() {\n     return extern_libs_;\n   }"}, {"filename": "include/triton/driver/llvm.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "file_content_changes": "@@ -1,22 +1,20 @@\n #include <string>\n-\n #include \"triton/driver/dispatch.h\"\n \n-namespace llvm {\n+namespace llvm{\n class Module;\n }\n \n-namespace triton {\n-namespace driver {\n+namespace triton{\n+namespace driver{\n \n void init_llvm();\n std::string path_to_ptxas(int& version);\n std::string llir_to_ptx(llvm::Module* module, int cc, int version);\n-std::string ptx_to_cubin(const std::string& ptx, const std::string& ptxas_path,\n-                         int cc);\n+std::string ptx_to_cubin(const std::string& ptx, const std::string& ptxas_path, int cc);\n CUmodule ptx_to_cumodule(const std::string& ptx, int cc);\n std::string llir_to_amdgpu(llvm::Module* module, const std::string& proc);\n hipModule_t amdgpu_to_hipmodule(const std::string& path);\n \n-}  // namespace driver\n-}  // namespace triton\n+}\n+}"}, {"filename": "include/triton/ir/builder.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -174,7 +174,7 @@ class builder{\n                                    const std::string &lib_path,\n                                    const std::string &symbol_name,\n                                    const std::vector<value *> &args,\n-                                   type *dst_ty);\n+                                   type *ret_ty);\n   // Built-in instruction\n   value *create_get_program_id(unsigned axis);\n   value *create_get_num_programs(unsigned axis);"}, {"filename": "include/triton/ir/instructions.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -1098,7 +1098,6 @@ class extern_elementwise_inst : public instruction {\n   std::string lib_name_ = \"\";\n   std::string lib_path_ = \"\";\n };\n-\n }\n }\n "}, {"filename": "lib/codegen/pass.cc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "file_content_changes": "@@ -24,18 +24,17 @@\n #include \"triton/codegen/transform/peephole.h\"\n #include \"triton/codegen/transform/pipeline.h\"\n #include \"triton/codegen/transform/prefetch.h\"\n-#include \"triton/driver/llvm.h\"\n #include \"triton/ir/function.h\"\n #include \"triton/ir/module.h\"\n #include \"triton/ir/print.h\"\n \n namespace triton {\n namespace codegen {\n \n-static std::unique_ptr<llvm::Module> link_extern_libs(\n+static void link_extern_libs(\n     const std::map<std::string, std::unique_ptr<ExternLib>>& extern_libs,\n     ir::module& ir, llvm::LLVMContext& ctx,\n-    std::unique_ptr<llvm::Module> llvm) {\n+    std::unique_ptr<llvm::Module>& llvm) {\n   for (const auto& iter : extern_libs) {\n     iter.second->install(ctx, llvm);\n   }\n@@ -59,7 +58,6 @@ static std::unique_ptr<llvm::Module> link_extern_libs(\n   builder.populateModulePassManager(pass);\n \n   pass.run(*llvm);\n-  return llvm;\n }\n \n // TODO:\n@@ -132,7 +130,7 @@ std::unique_ptr<llvm::Module> add_passes_to_emit_bin(\n   isel.visit(ir, *llvm);\n   shared_static = allocation.allocated_size();\n   if (isel.get_extern_libs().size() > 0) {\n-    llvm = link_extern_libs(isel.get_extern_libs(), ir, ctx, std::move(llvm));\n+    link_extern_libs(isel.get_extern_libs(), ir, ctx, llvm);\n   }\n   return llvm;\n }"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "file_content_changes": "@@ -1100,7 +1100,6 @@ void generator::visit_exp_inst(ir::exp_inst* x){\n   }\n }\n \n-\n /**\n  * \\brief Code Generation for `cos`\n  */\n@@ -2851,7 +2850,10 @@ void generator::visit_prefetch_s_inst(ir::prefetch_s_inst *i) {\n     }\n   }\n }\n-void generator::visit_async_wait_inst(ir::async_wait_inst* i) { std::string asm_str = \"cp.async.wait_group \" + std::to_string(i->get_N()) + \";\"; InlineAsm *iasm = InlineAsm::get(FunctionType::get(void_ty, {}), asm_str, \"\", true);\n+\n+void generator::visit_async_wait_inst(ir::async_wait_inst *i) {\n+  std::string asm_str = \"cp.async.wait_group \" + std::to_string(i->get_N()) + \";\";\n+  InlineAsm *iasm = InlineAsm::get(FunctionType::get(void_ty, {}), asm_str, \"\", true);\n   call(iasm);\n }\n \n@@ -2864,15 +2866,16 @@ void generator::visit_extern_elementwise_inst(ir::extern_elementwise_inst *i) {\n     operand_types.push_back(cvt(i->get_operand(j)->get_type()));\n   }\n   Type *ret_type = cvt(i->get_type());\n-  FunctionType *FT = FunctionType::get(ret_type, operand_types, false);\n+  FunctionType *FT =\n+      FunctionType::get(ret_type, std::move(operand_types), false);\n   Function *F = llvm::cast<llvm::Function>(\n       mod_->getOrInsertFunction(i->get_name(), FT).getCallee());\n   for (auto idx : idxs_.at(i)) {\n     std::vector<llvm::Value *> args;\n     for (size_t j = 0; j < i->get_num_operands(); j++) {\n-      args.push_back(vals_[i->get_operand(j)][idx]);\n+      args.emplace_back(vals_[i->get_operand(j)][idx]);\n     }\n-    vals_[i][idx] = call(F, args);\n+    vals_[i][idx] = call(F, std::move(args));\n   }\n   add_extern_lib(i->get_lib_name(), i->get_lib_path());\n }\n@@ -3453,7 +3456,8 @@ void generator::visit(ir::module &src, llvm::Module &dst) {\n     visit_function(fn);\n }\n \n-void generator::add_extern_lib(const std::string &lib_name, const std::string &lib_path) {\n+void generator::add_extern_lib(const std::string &lib_name,\n+                               const std::string &lib_path) {\n   if (extern_libs_.count(lib_name) == 0) {\n     if (lib_name == \"libdevice\") {\n       extern_libs_[lib_name] = std::make_unique<LibDevice>(lib_name, lib_path);\n@@ -3466,5 +3470,5 @@ void generator::add_extern_lib(const std::string &lib_name, const std::string &l\n   }\n }\n \n-}\n-}\n+}  // namespace codegen\n+}  // namespace triton"}, {"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "file_content_changes": "@@ -25,7 +25,6 @@\n #endif\n #include <memory>\n #include <regex>\n-#include <filesystem>\n #include \"triton/driver/llvm.h\"\n #include \"triton/driver/dispatch.h\"\n #include \"triton/driver/error.h\"\n@@ -46,12 +45,10 @@\n #include \"llvm/Target/TargetMachine.h\"\n #include \"llvm/Target/TargetOptions.h\"\n #include \"llvm/IR/LegacyPassManager.h\"\n-#include \"llvm/IR/GlobalValue.h\"\n #include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n #include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n #include \"llvm/Transforms/Utils/Cloning.h\"\n #include \"llvm/Transforms/Scalar.h\"\n-#include \"llvm/Transforms/IPO.h\"\n \n // begin AMD stuff\n #include \"llvm/Support/FileSystem.h\"\n@@ -152,7 +149,7 @@ int vptx(int version){\n   throw std::runtime_error(\"Triton requires CUDA 10+\");\n }\n \n-std::string llir_to_ptx(llvm::Module* module, int cc, int version) {\n+std::string llir_to_ptx(llvm::Module* module, int cc, int version){\n   // LLVM version in use may not officially support target hardware\n   int max_nvvm_cc = 75;\n   int max_nvvm_ptx = 74;\n@@ -192,19 +189,16 @@ std::string llir_to_ptx(llvm::Module* module, int cc, int version) {\n   opt.UnsafeFPMath = false;\n   opt.NoInfsFPMath = false;\n   opt.NoNaNsFPMath = true;\n-  machine = target->createTargetMachine(\n-      module->getTargetTriple(), proc, features, opt, llvm::Reloc::PIC_,\n-      llvm::None, llvm::CodeGenOpt::Aggressive);\n+  machine = target->createTargetMachine(module->getTargetTriple(), proc, features, opt,\n+                                                             llvm::Reloc::PIC_, llvm::None, llvm::CodeGenOpt::Aggressive);\n   // set data layout\n   if(layout.empty())\n     module->setDataLayout(machine->createDataLayout());\n   else\n     module->setDataLayout(layout);\n-\n   // emit machine code\n-  // XXX(Keren): nvvm functions shouldn't be inlined?\n-  //for (llvm::Function &f : module->functions())\n-  //  f.addFnAttr(llvm::Attribute::AlwaysInline);\n+  for (llvm::Function &f : module->functions())\n+    f.addFnAttr(llvm::Attribute::AlwaysInline);\n   llvm::legacy::PassManager pass;\n   llvm::raw_svector_ostream stream(buffer);\n   // emit\n@@ -220,6 +214,7 @@ std::string llir_to_ptx(llvm::Module* module, int cc, int version) {\n   return result;\n }\n \n+\n std::string ptx_to_cubin(const std::string& ptx, const std::string& ptxas, int cc) {\n   // compile ptx with ptxas\n   char _fsrc[L_tmpnam];\n@@ -367,4 +362,3 @@ hipModule_t amdgpu_to_hipmodule(const std::string& path) {\n \n }\n }\n-"}, {"filename": "lib/ir/builder.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -386,9 +386,9 @@ value *builder::create_extern_elementwise(const std::string &lib_name,\n                                           const std::string &lib_path,\n                                           const std::string &symbol_name,\n                                           const std::vector<value *> &args,\n-                                          type *dst_ty) {\n-  return insert(\n-      extern_elementwise_inst::create(ctx_, args, dst_ty, lib_name, lib_path, symbol_name));\n+                                          type *ret_ty) {\n+  return insert(extern_elementwise_inst::create(ctx_, args, ret_ty, lib_name,\n+                                                lib_path, symbol_name));\n }\n \n //===----------------------------------------------------------------------===//"}, {"filename": "lib/ir/instructions.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "file_content_changes": "@@ -1000,11 +1000,12 @@ extern_elementwise_inst::extern_elementwise_inst(\n   }\n }\n \n-extern_elementwise_inst* extern_elementwise_inst::create(\n+extern_elementwise_inst *extern_elementwise_inst::create(\n     context &ctx, const std::vector<value *> &args, type *ret_ty,\n-    const std::string &lib_name, const std::string &lib_path, const std::string &symbol_name,\n-    instruction *next) {\n-  return new extern_elementwise_inst(ctx, args, ret_ty, lib_name, lib_path, symbol_name, next);\n+    const std::string &lib_name, const std::string &lib_path,\n+    const std::string &symbol_name, instruction *next) {\n+  return new extern_elementwise_inst(ctx, args, ret_ty, lib_name, lib_path,\n+                                     symbol_name, next);\n }\n \n // clock"}, {"filename": "python/triton/tools/build_extern.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,6 +1,6 @@\n-from abc import ABC, abstractmethod\n import argparse\n import subprocess\n+from abc import ABC, abstractmethod\n \n \n class Symbol:"}]