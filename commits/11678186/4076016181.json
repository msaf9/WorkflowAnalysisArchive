[{"filename": "test/Analysis/test-alignment.mlir", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "file_content_changes": "@@ -1,6 +1,6 @@\n // RUN: triton-opt %s -test-print-alignment -split-input-file -o %t 2>&1 | FileCheck %s\n \n-// CHECK-LABEL: cast\n+// CHECK-LABEL: @cast\n func.func @cast() {\n   // CHECK: contiguity = [1], divisibility = [1], constancy = [1], constant_value = 1\n   %cst = arith.constant 1 : i32\n@@ -15,7 +15,7 @@ func.func @cast() {\n \n // -----\n \n-// CHECK-LABEL: add\n+// CHECK-LABEL: @add\n func.func @add() {\n   // CHECK: contiguity = [128], divisibility = [1073741824], constancy = [1], constant_value = <none>\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n@@ -32,7 +32,7 @@ func.func @add() {\n \n // -----\n \n-// CHECK-LABEL: sub\n+// CHECK-LABEL: @sub\n func.func @sub() {\n   // CHECK: contiguity = [128], divisibility = [1073741824], constancy = [1], constant_value = <none>\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n@@ -49,7 +49,7 @@ func.func @sub() {\n \n // -----\n \n-// CHECK-LABEL: mul\n+// CHECK-LABEL: @mul\n func.func @mul() {\n   // CHECK: contiguity = [128], divisibility = [1073741824], constancy = [1], constant_value = <none>\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n@@ -70,7 +70,7 @@ func.func @mul() {\n \n // -----\n \n-// CHECK-LABEL: div\n+// CHECK-LABEL: @div\n func.func @div() {\n   // CHECK: contiguity = [128], divisibility = [1073741824], constancy = [1], constant_value = <none>\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n@@ -95,7 +95,7 @@ func.func @div() {\n \n // -----\n \n-// CHECK-LABEL: rem\n+// CHECK-LABEL: @rem\n func.func @rem() {\n   // CHECK: contiguity = [128], divisibility = [1073741824], constancy = [1], constant_value = <none>\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n@@ -120,7 +120,7 @@ func.func @rem() {\n \n // -----\n \n-// CHECK-LABEL: broadcast\n+// CHECK-LABEL: @broadcast\n func.func @broadcast() {\n   // CHECK: contiguity = [1], divisibility = [64], constancy = [128], constant_value = 64\n   %0 = arith.constant dense<64> : tensor<128xi32>\n@@ -133,7 +133,7 @@ func.func @broadcast() {\n \n // -----\n \n-// CHECK-LABEL: splat\n+// CHECK-LABEL: @splat\n func.func @splat(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}) {\n   // CHECK: contiguity = [1, 1], divisibility = [16, 16], constancy = [128, 128], constant_value = <none>\n   %0 = tt.splat %arg0 : (!tt.ptr<f32>) -> tensor<128x128x!tt.ptr<f32>>\n@@ -142,7 +142,7 @@ func.func @splat(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}) {\n \n // -----\n \n-// CHECK-LABEL: cmp\n+// CHECK-LABEL: @cmp\n func.func @cmp() {\n   // CHECK: contiguity = [128], divisibility = [1073741824], constancy = [1], constant_value = <none>\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n@@ -167,7 +167,7 @@ func.func @cmp() {\n \n // -----\n \n-// CHECK-LABEL: logic\n+// CHECK-LABEL: @logic\n func.func @logic() {\n   // CHECK: contiguity = [128], divisibility = [1073741824], constancy = [1], constant_value = <none>\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n@@ -196,7 +196,7 @@ func.func @logic() {\n \n // -----\n \n-// CHECK-LABEL: select\n+// CHECK-LABEL: @select\n func.func @select() {\n   // CHECK: contiguity = [128], divisibility = [1073741824], constancy = [1], constant_value = <none>\n   %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n@@ -257,7 +257,7 @@ func.func @max_min() {\n \n // -----\n \n-// CHECK-LABEL: for\n+// CHECK-LABEL: @for\n func.func @for() {\n   // CHECK: contiguity = [1, 1], divisibility = [4611686018427387904, 4611686018427387904], constancy = [128, 32], constant_value = 0\n   %a_init = arith.constant dense<0> : tensor<128x32xi32>\n@@ -284,9 +284,9 @@ func.func @for() {\n \n // -----\n \n-// CHECK-LABEL: permute_2d\n+// CHECK-LABEL: @permute_2d\n func.func @permute_2d(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32 {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}) {\n-  // CHECK: contiguity = [1, 1], divisibility = [1, 1], constancy = [1, 1], constant_value = <none>\n+  // CHECK: contiguity = [1, 1], divisibility = [1, 1], constancy = [128, 128], constant_value = 1\n   %cst = arith.constant dense<true> : tensor<128x128xi1>\n   // CHECK-NEXT: contiguity = [1, 1], divisibility = [1, 1], constancy = [1, 1], constant_value = <none>\n   %cst_0 = arith.constant dense<0.000000e+00> : tensor<128x128xf32>\n@@ -341,7 +341,7 @@ func.func @permute_2d(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i\n module {\n \n // This is a tiny test for verifying StoreOp-related alignment, It simply store a constant to a buffer.\n-// CHECK-LABEL: store_constant_align\n+// CHECK-LABEL: @store_constant_align\n func.func @store_constant_align(%addr: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n: i32 {tt.divisibility = 16 : i32}) {\n   // CHECK: contiguity = [1], divisibility = [1], constancy = [1], constant_value = <none>\n   %pid = tt.get_program_id {axis = 0 : i32} : i32\n@@ -375,7 +375,7 @@ func.func @store_constant_align(%addr: !tt.ptr<f32> {tt.divisibility = 16 : i32}\n \n // This IR is dumped from vecadd test.\n // Note, the hint {tt.divisibility = 16 : i32} for %n_elements affects the alignment of mask.\n-// CHECK-LABEL: vecadd_mask_align_16\n+// CHECK-LABEL: @vecadd_mask_align_16\n func.func @vecadd_mask_align_16(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n_elements: i32 {tt.divisibility = 16 : i32}) {\n   %c64_i32 = arith.constant 64 : i32\n   %0 = tt.get_program_id {axis = 0 : i32} : i32\n@@ -388,7 +388,7 @@ func.func @vecadd_mask_align_16(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}\n   %7 = tt.splat %arg1 : (!tt.ptr<f32>) -> tensor<64x!tt.ptr<f32>>\n   %8 = tt.addptr %7, %4 : tensor<64x!tt.ptr<f32>>, tensor<64xi32>\n   %9 = tt.splat %n_elements : (i32) -> tensor<64xi32>\n-  // CHECK: arith.cmpi slt, %{{.*}} => contiguity = [1], divisibility = [64], constancy = [16], constant_value = <none>\n+  // CHECK: arith.cmpi slt, %{{.*}} => contiguity = [1], divisibility = [1], constancy = [16], constant_value = <none>\n   %mask = arith.cmpi slt, %4, %9 : tensor<64xi32>\n   %11 = tt.load %6, %mask {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n   %12 = tt.load %8, %mask {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n@@ -404,7 +404,7 @@ func.func @vecadd_mask_align_16(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}\n \n // This IR is dumped from vecadd test.\n // Note, there is no divisibility hint for %n_elements, Triton should assume its divisibility to be 1 by default.\n-// CHECK-LABEL: vecadd_mask_align_1\n+// CHECK-LABEL: @vecadd_mask_align_1\n func.func @vecadd_mask_align_1(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %n_elements: i32) {\n   %c64_i32 = arith.constant 64 : i32\n   %0 = tt.get_program_id {axis = 0 : i32} : i32\n@@ -417,7 +417,7 @@ func.func @vecadd_mask_align_1(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32},\n   %7 = tt.splat %arg1 : (!tt.ptr<f32>) -> tensor<64x!tt.ptr<f32>>\n   %8 = tt.addptr %7, %4 : tensor<64x!tt.ptr<f32>>, tensor<64xi32>\n   %9 = tt.splat %n_elements : (i32) -> tensor<64xi32>\n-  // CHECK: arith.cmpi slt, %{{.*}} => contiguity = [1], divisibility = [64], constancy = [1], constant_value = <none>\n+  // CHECK: arith.cmpi slt, %{{.*}} => contiguity = [1], divisibility = [1], constancy = [1], constant_value = <none>\n   %10 = arith.cmpi slt, %4, %9 : tensor<64xi32>\n   %11 = tt.load %6, %10 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n   %12 = tt.load %8, %10 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>"}, {"filename": "test/lib/Analysis/TestAxisInfo.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -20,7 +20,7 @@ struct TestAxisInfoPass\n     Operation *operation = getOperation();\n     auto &os = llvm::errs();\n     auto opName = SymbolTable::getSymbolName(operation).getValue().str();\n-    os << opName << \"\\n\";\n+    os << \"@\" << opName << \"\\n\";\n \n     std::unique_ptr<DataFlowSolver> solver = createDataFlowSolver();\n     AxisInfoAnalysis *analysis = solver->load<AxisInfoAnalysis>();"}]