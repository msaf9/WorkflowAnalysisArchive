[{"filename": "include/triton/Dialect/Triton/IR/Dialect.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "file_content_changes": "@@ -32,12 +32,14 @@ class DialectInferLayoutInterface\n \n   virtual LogicalResult\n   inferExpandDimsOpEncoding(Attribute operandEncoding, int axis,\n-                            Attribute &resultEncoding) const = 0;\n+                            Attribute &resultEncoding,\n+                            Optional<Location> location) const = 0;\n \n   // Note: this function only verify operand encoding but doesn't infer encoding\n   virtual LogicalResult\n   inferDotOpEncoding(Attribute operandEncoding, int opIdx,\n-                     Attribute retEncoding) const = 0;\n+                     Attribute retEncoding,\n+                     Optional<Location> location) const = 0;\n };\n \n } // namespace triton"}, {"filename": "lib/Dialect/Triton/IR/Ops.cpp", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "file_content_changes": "@@ -187,13 +187,14 @@ mlir::LogicalResult mlir::triton::DotOp::inferReturnTypes(\n   // verify encodings\n   auto aEnc = operands[0].getType().cast<RankedTensorType>().getEncoding();\n   auto bEnc = operands[1].getType().cast<RankedTensorType>().getEncoding();\n+  auto retEnc = accTy.getEncoding();\n   if (aEnc) {\n     assert(bEnc);\n-    Dialect &dialect = aEncoding.getDialect();\n+    Dialect &dialect = aEnc.getDialect();\n     auto interface = dyn_cast<DialectInferLayoutInterface>(&dialect);\n-    if (interface->inferDotOpEncoding(aEnc, 0).failed())\n+    if (interface->inferDotOpEncoding(aEnc, 0, retEnc, location).failed())\n       return mlir::failure();\n-    if (interface->inferDotOpEncoding(bEnc, 1).failed())\n+    if (interface->inferDotOpEncoding(bEnc, 1, retEnc, location).failed())\n       return mlir::failure();\n   }\n   return mlir::success();\n@@ -242,7 +243,7 @@ OpFoldResult SplatOp::fold(ArrayRef<Attribute> operands) {\n \n //-- ExpandDimsOp --\n mlir::LogicalResult mlir::triton::ExpandDimsOp::inferReturnTypes(\n-    MLIRContext *context, Optional<Location> location, ValueRange operands,\n+    MLIRContext *context, Optional<Location> loc, ValueRange operands,\n     DictionaryAttr attributes, RegionRange regions,\n     SmallVectorImpl<Type> &inferredReturnTypes) {\n   // infer shape\n@@ -258,11 +259,9 @@ mlir::LogicalResult mlir::triton::ExpandDimsOp::inferReturnTypes(\n     Dialect &dialect = argEncoding.getDialect();\n     auto inferLayoutInterface = dyn_cast<DialectInferLayoutInterface>(&dialect);\n     if (inferLayoutInterface\n-            ->inferExpandDimsOpEncoding(argEncoding, axis, retEncoding)\n-            .failed()) {\n-      llvm::report_fatal_error(\"failed to infer layout for ExpandDimsOp\");\n-      return mlir::failure();\n-    }\n+            ->inferExpandDimsOpEncoding(argEncoding, axis, retEncoding, loc)\n+            .failed())\n+      return emitOptionalError(loc, \"failed to infer layout for ExpandDimsOp\");\n   }\n   // create type\n   auto argEltTy = argTy.getElementType();"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "file_content_changes": "@@ -546,38 +546,30 @@ struct TritonGPUInferLayoutInterface\n   }\n \n   LogicalResult inferExpandDimsOpEncoding(Attribute operandEncoding, int axis,\n-                                          Attribute &resultEncoding) const {\n+                                          Attribute &resultEncoding,\n+                                          Optional<Location> location) const {\n     auto sliceEncoding = operandEncoding.dyn_cast<SliceEncodingAttr>();\n-    if (!sliceEncoding) {\n-      llvm::report_fatal_error(\n+    if (!sliceEncoding)\n+      return emitOptionalError(location,\n           \"ExpandDimsOp operand encoding must be SliceEncodingAttr\");\n-      return failure();\n-    }\n-    if (sliceEncoding.getDim() != axis) {\n-      llvm::report_fatal_error(\n+    if (sliceEncoding.getDim() != axis)\n+      return emitOptionalError(location,\n           \"Incompatible slice dimension for ExpandDimsOp operand\");\n-      return failure();\n-    }\n     resultEncoding = sliceEncoding.getParent();\n     return success();\n   }\n \n   LogicalResult inferDotOpEncoding(Attribute operandEncoding, int opIdx,\n-                                   Attribute retEncoding) {\n-    if (auto dotOpEnc = dyn_cast<DotOperandEncodingAttr>(operandEncoding)) {\n-      if (opIdx != dotOpEnc.opIdx()) {\n-        llvm::report_fatal_error(\"Wrong opIdx\");\n-        return failure();\n-      }\n-      if (retEncoding != dotOpEnc.parend()) {\n-        llvm::report_fatal_error(\"Incompatible parent encoding\");\n-        return failure();\n-      }\n-    } else {\n-      llvm::report_fatal_error(\n-          \"Dot's a/b's encoding should be of DotOperandEncodingAttr\");\n-      return failure();\n-    }\n+                                   Attribute retEncoding,\n+                                   Optional<Location> location) const {\n+    if (auto dotOpEnc = operandEncoding.dyn_cast<DotOperandEncodingAttr>()) {\n+      if (opIdx != dotOpEnc.getOpIdx())\n+        return emitOptionalError(location, \"Wrong opIdx\");\n+      if (retEncoding != dotOpEnc.getParent())\n+        return emitOptionalError(location, \"Incompatible parent encoding\");\n+    } else\n+      return emitOptionalError(location,\n+        \"Dot's a/b's encoding should be of DotOperandEncodingAttr\");\n     return success();\n   }\n };"}, {"filename": "lib/Dialect/TritonGPU/Transforms/CMakeLists.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -8,7 +8,6 @@ add_mlir_dialect_library(TritonGPUTransforms\n   Combine.cpp\n   Pipeline.cpp\n   Prefetch.cpp\n-  Verifier.cpp\n   Swizzle.cpp\n   TritonGPUConversion.cpp\n "}]