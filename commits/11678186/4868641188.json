[{"filename": "lib/Dialect/TritonGPU/Transforms/RemoveLayoutConversions.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "file_content_changes": "@@ -368,7 +368,7 @@ class RematerializeForward : public mlir::RewritePattern {\n       // don't rematerialize non-element-wise\n       if (!op->hasTrait<mlir::OpTrait::SameOperandsAndResultEncoding>() &&\n           !op->hasTrait<mlir::OpTrait::Elementwise>() &&\n-          !isa<triton::StoreOp>(op)) {\n+          !isa<triton::StoreOp>(op) && !isa<triton::ReduceOp>(op)) {\n         return failure();\n       }\n       // don't rematerialize if it adds an extra conversion that can't\n@@ -378,9 +378,10 @@ class RematerializeForward : public mlir::RewritePattern {\n         SetVector<Operation *> processed;\n         SetVector<Attribute> layout;\n         llvm::MapVector<Value, Attribute> toConvert;\n-        if (argOp && (argOp != cvt) && cvtSlices.count(argOp) == 0 &&\n-            simulateBackwardRematerialization(argOp, processed, layout,\n-                                              toConvert, srcEncoding) > 0) {\n+        int numAddedConvs = simulateBackwardRematerialization(\n+            argOp, processed, layout, toConvert, srcEncoding);\n+        if (argOp && !isa<triton::gpu::ConvertLayoutOp>(argOp) &&\n+            cvtSlices.count(argOp) == 0 && numAddedConvs > 0) {\n           return failure();\n         }\n       }"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Utility.cpp", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "file_content_changes": "@@ -89,11 +89,11 @@ LogicalResult invertEncoding(Attribute targetEncoding, Operation *op,\n }\n \n bool expensiveLoadOrStore(Operation *op, Attribute &targetEncoding) {\n-  // Case 1a: A size 1 tensor is not expensive since all threads will load the\n+  // Case 1: A size 1 tensor is not expensive since all threads will load the\n   // same\n   if (isSingleValue(op->getOperand(0)))\n     return false;\n-  // Case 1b: Tensor of pointers has more threads than elements\n+  // Case 2: Tensor of pointers has more threads than elements\n   // we can presume a high hit-rate that makes it cheap to load\n   auto ptrType = op->getOperand(0).getType().cast<RankedTensorType>();\n   IntegerAttr numWarps =\n@@ -104,28 +104,6 @@ bool expensiveLoadOrStore(Operation *op, Attribute &targetEncoding) {\n     if (ptrType.getNumElements() < numWarps.getInt() * 32)\n       return false;\n   }\n-  // auto ptr = op->getOperand(0);\n-  //// Case 2: We assume that `evict_last` loads/stores have high hit rate\n-  // if (auto load = dyn_cast<triton::LoadOp>(op))\n-  //   if (load.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n-  //     return false;\n-  // if (auto store = dyn_cast<triton::StoreOp>(op))\n-  //   if (store.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n-  //     return false;\n-  // if (auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>()) {\n-  //   auto encoding = tensorTy.getEncoding();\n-  //   // Case 3: Different type conversion is expensive (e.g., mma <->\n-  //   block) if (encoding.getTypeID() != targetEncoding.getTypeID())\n-  //     return true;\n-  //   auto sizePerThread = triton::gpu::getSizePerThread(encoding);\n-  //   auto targetSizePerThread =\n-  //   triton::gpu::getSizePerThread(targetEncoding); auto order =\n-  //   triton::gpu::getOrder(encoding); auto targetOrder =\n-  //   triton::gpu::getOrder(targetEncoding);\n-  //   // Case 4: The targeEncoding may expose more vectorization\n-  //   opportunities return sizePerThread[order[0]] >=\n-  //   targetSizePerThread[targetOrder[0]];\n-  // }\n   return true;\n }\n \n@@ -144,6 +122,12 @@ bool expensiveToRemat(Operation *op, Attribute &targetEncoding) {\n   return false;\n }\n \n+bool canFoldConversion(Operation *op) {\n+  return isa<triton::gpu::ConvertLayoutOp, arith::ConstantOp,\n+             triton::MakeRangeOp, triton::SplatOp, triton::ViewOp,\n+             triton::CatOp>(*op);\n+}\n+\n int simulateBackwardRematerialization(\n     Operation *initOp, SetVector<Operation *> &processed,\n     SetVector<Attribute> &layout, llvm::MapVector<Value, Attribute> &toConvert,\n@@ -189,10 +173,7 @@ int simulateBackwardRematerialization(\n         continue;\n       // If the conversion can be folded into opArgI then\n       // we don't count this conversion as expensive\n-      if (isa<triton::gpu::ConvertLayoutOp, arith::ConstantOp,\n-              triton::MakeRangeOp, triton::SplatOp>(*opArgI))\n-        continue;\n-      if (isa<triton::ViewOp, triton::CatOp>(opArgI))\n+      if (canFoldConversion(opArgI))\n         continue;\n \n       // We add one expensive conversion for the current operand"}]