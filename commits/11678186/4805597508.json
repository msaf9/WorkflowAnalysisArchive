[{"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "file_content_changes": "@@ -541,39 +541,23 @@ scf::ForOp LoopPipeliner::createNewForOp() {\n     mapping.map(arg.value(), newForOp.getRegionIterArgs()[arg.index()]);\n   mapping.map(forOp.getInductionVar(), newForOp.getInductionVar());\n \n-  // 2.1 clone the loop body, replace original args with args of the new ForOp\n+  // 2. clone the loop body, replace original args with args of the new ForOp\n   // Insert async wait if necessary.\n   for (Operation &op : forOp.getBody()->without_terminator()) {\n-    Operation *newOp = builder.clone(op, mapping);\n-    // update mapping of results\n-    for (unsigned dstIdx : llvm::seq(unsigned(0), op.getNumResults()))\n-      mapping.map(op.getResult(dstIdx), newOp->getResult(dstIdx));\n-  }\n-\n-  // 3. replace loads with block args (from prologue)\n-  for (size_t idx = 0; idx < loads.size(); ++idx) {\n-    OpBuilder::InsertionGuard guard(builder);\n-    Value load = loads[idx];\n-    assert(load.hasOneUse() &&\n-           \"we assume that this load has one use (ConvertLayout)\");\n-    Value loadUse = load.getUsers().begin()->getResult(0);\n-    // set insertion point\n-    Value newLoad = mapping.lookup(load);\n-    Value newLoadUse = mapping.lookup(loadUse);\n-    builder.setInsertionPoint(newLoadUse.getDefiningOp());\n-    // create conversion\n+    auto it = std::find(loads.begin(), loads.end(), op.getOperand(0));\n+    if (it == loads.end()) {\n+      Operation *newOp = builder.clone(op, mapping);\n+      continue;\n+    }\n+    // we replace the use new load use with a convert layout\n+    size_t i = std::distance(loads.begin(), it);\n     auto cvt = builder.create<ttg::ConvertLayoutOp>(\n-        loadUse.getLoc(), loadUse.getType(),\n-        newForOp.getRegionIterArgs()[loadIdx + idx]);\n-\n-    // replace uses\n-    newLoadUse.replaceAllUsesWith(cvt.getResult());\n-    // delete old load and layout conversion\n-    newLoadUse.getDefiningOp()->erase();\n-    newLoad.getDefiningOp()->erase();\n+        op.getLoc(), op.getResult(0).getType(),\n+        newForOp.getRegionIterArgs()[loadIdx + i]);\n+    mapping.map(op.getResult(0), cvt.getResult());\n   }\n \n-  // 4. prefetch the next iteration\n+  // 3. prefetch the next iteration\n   SmallVector<Operation *> orderedDeps;\n   for (Operation &op : forOp.getLoopBody().front()) {\n     if (depOps.contains(&op))"}]