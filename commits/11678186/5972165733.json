[{"filename": "include/triton/Dialect/TritonGPU/Transforms/Utility.h", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "file_content_changes": "@@ -101,31 +101,27 @@ class GraphLayoutMarker : public GraphDumper {\n   std::string getColor(const Type &type) const;\n };\n \n-// TODO: Interface\n-LogicalResult invertEncoding(Attribute targetEncoding, Operation *op,\n-                             Attribute &ret);\n+// Infers the encoding of the result of op given the source encoding.\n+std::optional<Attribute> inferDstEncoding(Operation *op, Attribute encoding);\n \n-bool isExpensiveLoadOrStore(Operation *op, Attribute &targetEncoding);\n+// Infers the encoding of the source of op given the result encoding.\n+std::optional<Attribute> inferSrcEncoding(Operation *op, Attribute encoding);\n \n-bool isExpensiveToRemat(Operation *op, Attribute &targetEncoding);\n+bool isExpensiveLoadOrStore(Operation *op);\n \n-// skipInit is True when we only consider the operands of the initOp but\n-// not the initOp itself.\n-int simulateBackwardRematerialization(\n-    Operation *initOp, SetVector<Operation *> &processed,\n-    SetVector<Attribute> &layout, llvm::MapVector<Value, Attribute> &toConvert,\n-    Attribute targetEncoding);\n+bool canFoldIntoConversion(Operation *op, Attribute targetEncoding);\n \n Operation *cloneWithInferType(mlir::OpBuilder &rewriter, Operation *op,\n                               IRMapping &mapping);\n \n-void rematerializeConversionChain(\n-    const llvm::MapVector<Value, Attribute> &toConvert,\n-    mlir::PatternRewriter &rewriter, SetVector<Operation *> &processed,\n-    IRMapping &mapping);\n+// Get backward slice of tensor values starting from the root node along with\n+// encoding propagation.\n+LogicalResult getConvertBackwardSlice(Value root, SetVector<Value> &slice,\n+                                      Attribute rootEncoding,\n+                                      DenseMap<Value, Attribute> &layout);\n \n-LogicalResult canMoveOutOfLoop(BlockArgument arg,\n-                               SmallVector<Operation *> &cvts);\n+// Populate pattern to remove dead cycles in ForOp.\n+void populateForOpDeadArgumentElimination(RewritePatternSet &patterns);\n \n // Convert an \\param index to a multi-dim coordinate given \\param shape and\n // \\param order."}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "file_content_changes": "@@ -473,9 +473,9 @@ struct DFSState {\n   SmallVector<Operation *, 16> topologicalCounts;\n   DenseSet<Operation *> seen;\n \n-  /// We mark each op as ready if all its operands are seen. If an op is ready,\n-  /// we add it to the queue. Otherwise, we keep adding its operands to the\n-  /// ancestors set.\n+  /// We mark each op as ready if all its operands and parents ops are seen. If\n+  /// an op is ready, we add it to the queue. Otherwise, we keep adding its\n+  /// operands to the ancestors set.\n   void addToReadyQueue(Operation *op, DFSSubgraphState &subGraph,\n                        SmallVector<Operation *, 4> &readyQueue) {\n     bool ready = true;\n@@ -486,6 +486,14 @@ struct DFSState {\n         ready = false;\n       }\n     }\n+    Operation *parent = op->getParentOp();\n+    while (parent) {\n+      if (!seen.count(parent)) {\n+        subGraph.push_back(parent);\n+        ready = false;\n+      }\n+      parent = parent->getParentOp();\n+    }\n     if (ready)\n       readyQueue.push_back(op);\n   }"}, {"filename": "lib/Dialect/TritonGPU/Transforms/RemoveLayoutConversions.cpp", "status": "modified", "additions": 639, "deletions": 486, "changes": 1125, "file_content_changes": "@@ -12,11 +12,11 @@\n #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"\n #include \"mlir/Transforms/Passes.h\"\n #include \"mlir/Transforms/RegionUtils.h\"\n+#include \"triton/Analysis/Utility.h\"\n #include \"triton/Dialect/TritonGPU/IR/Dialect.h\"\n #include \"triton/Dialect/TritonGPU/Transforms/Passes.h\"\n #include \"triton/Dialect/TritonGPU/Transforms/TritonGPUConversion.h\"\n #include \"triton/Dialect/TritonGPU/Transforms/Utility.h\"\n-\n #include <memory>\n \n using namespace mlir;\n@@ -82,542 +82,676 @@ class DecomposeDotOperand : public mlir::RewritePattern {\n   }\n };\n \n-// It's beneficial to move the conversion\n-// to after the reduce if necessary since it will be\n-// done on a rank-reduced tensor hence cheaper\n-class SimplifyReduceCvt : public mlir::RewritePattern {\n+//\n+class ConvertDotConvert : public mlir::RewritePattern {\n public:\n-  explicit SimplifyReduceCvt(mlir::MLIRContext *context)\n+  ConvertDotConvert(mlir::MLIRContext *context)\n       : mlir::RewritePattern(triton::gpu::ConvertLayoutOp::getOperationName(),\n-                             2, context) {}\n+                             1, context) {}\n \n-  mlir::LogicalResult\n+  LogicalResult\n   matchAndRewrite(mlir::Operation *op,\n                   mlir::PatternRewriter &rewriter) const override {\n-    if (!llvm::isa<triton::gpu::ConvertLayoutOp>(op))\n+    auto dstOp = cast<triton::gpu::ConvertLayoutOp>(op);\n+    auto dotOp = dstOp.getSrc().getDefiningOp<triton::DotOp>();\n+    if (!dotOp)\n       return mlir::failure();\n-    auto convert = llvm::cast<triton::gpu::ConvertLayoutOp>(op);\n-    triton::ReduceOp reduce;\n-    for (auto &use : convert.getResult().getUses()) {\n-      auto owner = llvm::dyn_cast<triton::ReduceOp>(use.getOwner());\n-      if (!owner) {\n-        continue;\n-      }\n-\n-      // TODO: This only moves conversions from the first argument which is\n-      // fine for argmin/argmax but may not be optimal generally\n-      if (convert.getResult() != owner.getOperands()[0]) {\n-        continue;\n-      }\n-      reduce = owner;\n-      break;\n-    }\n-    if (!reduce)\n+    if (std::distance(dstOp->user_begin(), dstOp->user_end()) != 1 ||\n+        std::distance(dotOp->user_begin(), dotOp->user_end()) != 1)\n       return mlir::failure();\n-\n-    SmallVector<Value> newOperands = reduce.getOperands();\n-\n-    newOperands[0] = convert.getOperand();\n-    auto newEncoding =\n-        newOperands[0].getType().cast<RankedTensorType>().getEncoding();\n-\n-    // this may generate unsupported conversions in the LLVM codegen\n-    if (newEncoding.isa<triton::gpu::MmaEncodingAttr>()) {\n-      return failure();\n-    }\n-\n-    // ReduceOp does not support SharedLayout as its src layout, therefore\n-    // ConvertLayoutOp and ReduceOp should not be swapped when the conversion is\n-    // from SharedLayout to DistributedLayout\n-    if (newEncoding.isa<triton::gpu::SharedEncodingAttr>()) {\n+    auto cvtOp =\n+        dotOp.getOperand(2).getDefiningOp<triton::gpu::ConvertLayoutOp>();\n+    if (!cvtOp)\n+      return mlir::failure();\n+    if (!cvtOp.getSrc().getDefiningOp<triton::LoadOp>())\n       return failure();\n-    }\n-\n-    for (unsigned i = 1; i < newOperands.size(); ++i) {\n-      auto oldTy = newOperands[i].getType().cast<RankedTensorType>();\n-      RankedTensorType newTy =\n-          RankedTensorType::Builder(oldTy).setEncoding(newEncoding);\n-\n-      newOperands[i] = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-          op->getLoc(), newTy, newOperands[i]);\n-    }\n-\n-    rewriter.setInsertionPoint(reduce);\n-    auto newReduce = rewriter.create<triton::ReduceOp>(\n-        op->getLoc(), newOperands, reduce.getAxis());\n-    auto &newCombineOp = newReduce.getCombineOp();\n-    rewriter.cloneRegionBefore(reduce.getCombineOp(), newCombineOp,\n-                               newCombineOp.end());\n-\n-    SmallVector<Value> newRet = newReduce.getResult();\n-    auto oldTypes = reduce.getResult().getType();\n-    for (unsigned i = 0; i < reduce.getNumOperands(); ++i) {\n-      // it's still beneficial to move the conversion\n-      // to after the reduce if necessary since it will be\n-      // done on a rank-reduced tensor hence cheaper\n-      if (newRet[i].getType() != oldTypes[i])\n-        newRet[i] = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-            op->getLoc(), oldTypes[i], newRet[i]);\n-    }\n-    rewriter.replaceAllUsesWith(reduce.getResult(), newRet);\n+    auto dstTy = dstOp.getResult().getType().cast<RankedTensorType>();\n+    auto srcTy = cvtOp.getOperand().getType().cast<RankedTensorType>();\n+    if (dstTy != srcTy)\n+      return mlir::failure();\n \n-    return success();\n+    auto _0f = rewriter.create<arith::ConstantOp>(\n+        op->getLoc(), dstTy.getElementType(),\n+        rewriter.getZeroAttr(dstTy.getElementType()));\n+    auto _0 = rewriter.create<triton::SplatOp>(\n+        op->getLoc(), dotOp.getResult().getType(), _0f);\n+    auto newDot = rewriter.create<triton::DotOp>(\n+        op->getLoc(), dotOp.getResult().getType(), dotOp.getOperand(0),\n+        dotOp.getOperand(1), _0, dotOp.getAllowTF32());\n+    auto newCvt = rewriter.create<triton::gpu::ConvertLayoutOp>(\n+        op->getLoc(), dstTy, newDot.getResult());\n+    rewriter.replaceOpWithNewOp<arith::AddFOp>(op, newCvt, cvtOp.getOperand());\n+    return mlir::success();\n   }\n };\n \n-// Layout conversions can't deduce their return type automatically.\n-// IIUC they are therefore not handled by DRR right now\n-class SimplifyConversion : public mlir::RewritePattern {\n+// Class to propagate layout globally within a function.\n+// The current algorithm works by analysis the IR and doing a one shot rewrite\n+// based on the analysis. The algorithm is as follows:\n+// 1. Find all the anchor ops. These are ops that have a layout we want to\n+// preserve.\n+//\n+// 2. Propagate the layout to every op reachable which is a transitive child of\n+// an anchor op until we reach a fix point.\n+// An op can have multiple transitive anchor parents therefore at this stage\n+// it may have multiple layout associated to it.\n+//\n+// 3. Resolve conflicts by deciding which of the multiple layouts the op should\n+// keep. If one of the parents has a different layout than what is picked a\n+// convert operation will be inserted. After this stage each value should have\n+// only one layout associated.\n+//\n+// 4. Rewrite the IR by walking the function following dominance order. Since we\n+// assume the IR is structured we just need to process the regions in the\n+// correct order. For each op rewrite it using the layout decided by the\n+// analysis phase.\n+class LayoutPropagation {\n public:\n-  explicit SimplifyConversion(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(triton::gpu::ConvertLayoutOp::getOperationName(),\n-                             4, context) {}\n-\n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    if (!llvm::isa<triton::gpu::ConvertLayoutOp>(op))\n-      return mlir::failure();\n-    auto convert = llvm::cast<triton::gpu::ConvertLayoutOp>(op);\n-    return ConvertLayoutOp::canonicalize(convert, rewriter);\n-  }\n+  // Structure to keep track of the layout associated to a value.\n+  struct LayoutInfo {\n+    LayoutInfo(Attribute encoding) { encodings.insert(encoding); }\n+    LayoutInfo() {}\n+    llvm::SmallSetVector<Attribute, 8> encodings;\n+  };\n+  LayoutPropagation(triton::FuncOp F) : funcOp(F) {}\n+  // Find the anchor ops and set their layout in the data structure.\n+  void initAnchorLayout();\n+  // Recursively Propagate the layout to all the users of the anchor ops until\n+  // we reach a fix point.\n+  void propagateLayout();\n+  // Add layouts given in `Info` to the uses of `value`.\n+  SmallVector<Value> propagateToUsers(Value value, LayoutInfo &info);\n+  // Set the encoding to all the values and fill out the values with new layout\n+  // in `changed`.\n+  void setEncoding(ValueRange values, LayoutInfo &info,\n+                   SmallVector<Value> &changed, Operation *op);\n+  // Resolve cases where a value has multiple layouts associated to it.\n+  void resolveConflicts();\n+  // Rewrite the IR for the full module.\n+  void rewrite();\n+  // Rewrite the IR for a region.\n+  void rewriteRegion(Region &R);\n+  // Rewrite an op based on the layout picked by the analysis.\n+  Operation *rewriteOp(Operation *op);\n+  // Rewrite a for op based on the layout picked by the analysis.\n+  Operation *rewriteForOp(scf::ForOp forOp);\n+  Operation *rewriteYieldOp(scf::YieldOp yieldOp);\n+  // Dump the current stage of layout information.\n+  Operation *cloneElementwise(OpBuilder &rewriter, Operation *op,\n+                              Attribute encoding);\n+  // Map the original value to the rewritten one.\n+  void map(Value old, Value newV);\n+  // Return the mapped value in the given encoding. This will insert a convert\n+  // if the encoding is different than the encoding decided at resolve time.\n+  Value getValueAs(Value value, Attribute encoding);\n+  void dump();\n+\n+private:\n+  // map from value to layout information.\n+  llvm::MapVector<Value, LayoutInfo> layouts;\n+  // map of the values rewrite based on their encoding.\n+  DenseMap<std::pair<Value, Attribute>, Value> rewriteMapping;\n+  std::vector<Operation *> opToDelete;\n+  triton::FuncOp funcOp;\n };\n \n-// -----------------------------------------------------------------------------\n-//\n-// -----------------------------------------------------------------------------\n+} // namespace\n \n-// op(cvt(arg_0), arg_1, ..., arg_n)\n-// -> cvt(op(arg_0, cvt(arg_1), ..., cvt(arg_n)))\n-void pushConversionForward(triton::gpu::ConvertLayoutOp cvt,\n-                           SetVector<Operation *> &cvtSlices,\n-                           mlir::PatternRewriter &rewriter) {\n-  auto srcEncoding =\n-      cvt.getOperand().getType().cast<RankedTensorType>().getEncoding();\n-  auto dstEncoding =\n-      cvt.getResult().getType().cast<RankedTensorType>().getEncoding();\n-  IRMapping mapping;\n-  auto op = cvtSlices.front();\n-  for (Value arg : op->getOperands()) {\n-    if (arg.getDefiningOp() == cvt)\n-      mapping.map(arg, cvt.getOperand());\n-    else {\n-      auto oldType = arg.getType().dyn_cast<RankedTensorType>();\n-      // TODO: we may be creating block pointer load/store with mismatching\n-      // pointer type.\n-      if (!oldType)\n+// Look ahead to at the transitive uses and see if there is a convert to mma\n+// operations.\n+static bool hasConvertToMMATransisitiveUse(Operation *op, Attribute encoding) {\n+  SmallVector<Value> queue = {op->getResult(0)};\n+  SetVector<Operation *> forwardSlice;\n+  llvm::SmallDenseSet<Value> seen;\n+  while (!queue.empty()) {\n+    Value currentValue = queue.back();\n+    queue.pop_back();\n+    getForwardSlice(currentValue, &forwardSlice);\n+    for (Operation *op : forwardSlice) {\n+      if (auto convertOp = dyn_cast<triton::gpu::ConvertLayoutOp>(op)) {\n+        if (convertOp.getResult()\n+                .getType()\n+                .cast<RankedTensorType>()\n+                .getEncoding() == encoding)\n+          return true;\n+      }\n+      auto yield = dyn_cast<scf::YieldOp>(op);\n+      if (!yield)\n         continue;\n-      auto newType = RankedTensorType::get(\n-          oldType.getShape(), oldType.getElementType(), srcEncoding);\n-      auto cvtI = rewriter.create<triton::gpu::ConvertLayoutOp>(arg.getLoc(),\n-                                                                newType, arg);\n-      if (Operation *argOp = arg.getDefiningOp())\n-        cvtI->moveAfter(argOp);\n-      mapping.map(arg, cvtI);\n+      auto forOp = dyn_cast<scf::ForOp>(yield.getOperation()->getParentOp());\n+      if (!forOp)\n+        continue;\n+      for (OpOperand &operand : yield->getOpOperands()) {\n+        Operation *def = operand.get().getDefiningOp();\n+        if (def && forwardSlice.count(def) &&\n+            (seen.insert(operand.get()).second == true))\n+          queue.push_back(forOp.getRegionIterArg(operand.getOperandNumber()));\n+      }\n     }\n   }\n-  rewriter.setInsertionPoint(op);\n-  if (op->getNumResults() == 0) {\n-    Operation *newOp = cloneWithInferType(rewriter, op, mapping);\n-    rewriter.eraseOp(op);\n-    return;\n-  }\n-  auto *newOp = cloneWithInferType(rewriter, op, mapping);\n-  auto newType = newOp->getResult(0).getType().cast<RankedTensorType>();\n-  auto newCvtType = RankedTensorType::get(\n-      newType.getShape(), newType.getElementType(), dstEncoding);\n-  auto newCvt = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-      newOp->getLoc(), newCvtType, newOp->getResult(0));\n-  rewriter.replaceOp(op, newCvt->getResults());\n+  return false;\n }\n \n-//\n-class MoveConvertOutOfIf : public mlir::RewritePattern {\n-public:\n-  explicit MoveConvertOutOfIf(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(scf::IfOp::getOperationName(), 2, context) {}\n+// Return true if the op is an op with a layout we don't want to change. We will\n+// propagate the layout starting from anchor ops.\n+static bool isLayoutAnchor(Operation *op) {\n+  if (isa<triton::LoadOp, triton::StoreOp>(op))\n+    return isExpensiveLoadOrStore(op);\n+  if (isa<triton::DotOp, triton::AtomicRMWOp, triton::AtomicCASOp>(op))\n+    return true;\n+  return false;\n+}\n \n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto ifOp = cast<scf::IfOp>(*op);\n-    // If \u201cscf.if\u201d defines no values, \u201cscf.yield\u201d will be inserted implicitly.\n-    // However, \"scf.else\" is not required to be present, so we need to check\n-    // if it exists.\n-    auto thenYield = ifOp.thenYield();\n-    int numOps = thenYield.getNumOperands();\n-    SmallVector<Value> newThenYieldOps = thenYield.getOperands();\n-    SetVector<Operation *> thenCvts;\n-    SmallVector<Type> newRetTypes;\n-\n-    bool hasElse = !ifOp.getElseRegion().empty();\n-\n-    scf::YieldOp elseYield;\n-    SmallVector<Value> newElseYieldOps;\n-    SetVector<Operation *> elseCvts;\n-    if (hasElse) {\n-      elseYield = ifOp.elseYield();\n-      newElseYieldOps = elseYield.getOperands();\n+void LayoutPropagation::initAnchorLayout() {\n+  funcOp.walk([&](Operation *op) {\n+    if (isLayoutAnchor(op)) {\n+      for (auto result : op->getResults()) {\n+        if (auto tensorType = result.getType().dyn_cast<RankedTensorType>()) {\n+          // Workaround, don't popagate MMA layout unless there is a convert\n+          // back to mma further down to avoid generating reduction with MMA\n+          // layout that may have lower performance.\n+          // This can be improved with more aggressive backward propagation.\n+          if (tensorType.getEncoding().isa<triton::gpu::MmaEncodingAttr>() &&\n+              !hasConvertToMMATransisitiveUse(op, tensorType.getEncoding()))\n+            continue;\n+          layouts.insert({result, tensorType.getEncoding()});\n+        }\n+      }\n     }\n+  });\n+}\n \n-    IRMapping mapping;\n-    for (size_t i = 0; i < numOps; i++) {\n-      auto thenCvt =\n-          thenYield.getOperand(i).getDefiningOp<triton::gpu::ConvertLayoutOp>();\n-      if (hasElse) {\n-        auto elseYield = ifOp.elseYield();\n-        auto elseCvt = elseYield.getOperand(i)\n-                           .getDefiningOp<triton::gpu::ConvertLayoutOp>();\n-        if (thenCvt && elseCvt &&\n-            std::distance(elseCvt->user_begin(), elseCvt->user_end()) == 1 &&\n-            std::distance(thenCvt->user_begin(), thenCvt->user_end()) == 1 &&\n-            thenCvt.getOperand().getType() == elseCvt.getOperand().getType()) {\n-          // If thenCvt and elseCvt's type are the same, it means a single\n-          // conversion is enough to replace both of them. We can move the\n-          // conversion out of scf.if and replace both thenCvt and elseCvt with\n-          // the new conversion.\n-          mapping.map(thenCvt.getResult(), thenCvt.getOperand());\n-          thenCvts.insert((Operation *)thenCvt);\n-          newRetTypes.push_back(thenCvt.getOperand().getType());\n-          mapping.map(elseCvt.getResult(), elseCvt.getOperand());\n-          elseCvts.insert((Operation *)elseCvt);\n-        } else\n-          // Cannot move out of scf.if because thenCvt != elseCvt\n-          // Moving it out of scf.if will introduce a new conversion\n-          newRetTypes.push_back(thenYield.getOperand(i).getType());\n-      } else {\n-        if (thenCvt &&\n-            std::distance(thenCvt->user_begin(), thenCvt->user_end()) == 1) {\n-          // If there's only a single use of the conversion then we can move it\n-          mapping.map(thenCvt.getResult(), thenCvt.getOperand());\n-          thenCvts.insert((Operation *)thenCvt);\n-          newRetTypes.push_back(thenCvt.getOperand().getType());\n-        } else\n-          // Cannot move out of scf.if because either there's another use of\n-          // the conversion or there's no conversion at all\n-          newRetTypes.push_back(thenYield.getOperand(i).getType());\n-      }\n+void LayoutPropagation::setEncoding(ValueRange values, LayoutInfo &info,\n+                                    SmallVector<Value> &changed,\n+                                    Operation *op) {\n+  SmallVector<Attribute> encodings(info.encodings.begin(),\n+                                   info.encodings.end());\n+  for (Value value : values) {\n+    if (!value.getType().isa<RankedTensorType>())\n+      continue;\n+    bool hasChanged = false;\n+    for (auto encoding : encodings) {\n+      auto dstEncoding = inferDstEncoding(op, encoding);\n+      if (dstEncoding)\n+        hasChanged |= layouts[value].encodings.insert(*dstEncoding);\n     }\n-    if (mapping.getValueMap().empty())\n-      return mlir::failure();\n+    if (hasChanged)\n+      changed.push_back(value);\n+  }\n+}\n \n-    auto newIfOp = rewriter.create<scf::IfOp>(ifOp.getLoc(), newRetTypes,\n-                                              ifOp.getCondition(), hasElse);\n-    auto rematerialize = [&](Block *block, SetVector<Operation *> &cvts) {\n-      for (Operation &op : block->getOperations()) {\n-        if (cvts.contains(&op)) {\n-          if (mapping.contains(op.getOperand(0)))\n-            mapping.map(op.getResult(0), mapping.lookup(op.getOperand(0)));\n-          continue;\n-        }\n-        cloneWithInferType(rewriter, &op, mapping);\n+SmallVector<Value> LayoutPropagation::propagateToUsers(Value value,\n+                                                       LayoutInfo &info) {\n+  SmallVector<Value> changed;\n+  for (OpOperand &use : value.getUses()) {\n+    Operation *user = use.getOwner();\n+    if (auto forOp = dyn_cast<scf::ForOp>(user)) {\n+      Value arg = forOp.getRegionIterArgForOpOperand(use);\n+      Value result = forOp.getResultForOpOperand(use);\n+      setEncoding({arg, result}, info, changed, user);\n+      continue;\n+    }\n+    if (auto yieldOp = dyn_cast<scf::YieldOp>(user)) {\n+      auto parent = yieldOp->getParentOp();\n+      SmallVector<Value> valuesToPropagate = {\n+          parent->getResult(use.getOperandNumber())};\n+      if (auto forOp = dyn_cast<scf::ForOp>(parent)) {\n+        valuesToPropagate.push_back(\n+            forOp.getRegionIterArg(use.getOperandNumber()));\n+        setEncoding({valuesToPropagate}, info, changed, user);\n       }\n-    };\n-    rewriter.setInsertionPointToEnd(newIfOp.thenBlock());\n-    rematerialize(ifOp.thenBlock(), thenCvts);\n-    if (hasElse) {\n-      rewriter.setInsertionPointToEnd(newIfOp.elseBlock());\n-      rematerialize(ifOp.elseBlock(), elseCvts);\n+      // TODO: handle scf.if and while.\n+      continue;\n     }\n+    // Workaround: don't propagate through truncI\n+    if (isa<arith::TruncIOp>(user))\n+      continue;\n+    if (user->hasTrait<mlir::OpTrait::SameOperandsAndResultEncoding>() ||\n+        user->hasTrait<mlir::OpTrait::Elementwise>() ||\n+        isa<triton::ReduceOp, triton::ExpandDimsOp,\n+            triton::gpu::ConvertLayoutOp>(user)) {\n+      setEncoding(user->getResults(), info, changed, user);\n+      continue;\n+    }\n+  }\n+  return changed;\n+}\n \n-    rewriter.setInsertionPointAfter(newIfOp);\n-    SmallVector<Value> newRetValues = newIfOp.getResults();\n-    for (size_t i = 0; i < numOps; i++) {\n-      if (newIfOp.getResult(i).getType() != ifOp.getResult(i).getType()) {\n-        newRetValues[i] = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-            newIfOp.getLoc(), ifOp.getResult(i).getType(),\n-            newIfOp.getResult(i));\n+void LayoutPropagation::propagateLayout() {\n+  SmallVector<Value> queue;\n+  for (auto it : layouts) {\n+    queue.push_back(it.first);\n+  }\n+  while (!queue.empty()) {\n+    Value currentValue = queue.back();\n+    LayoutInfo &info = layouts[currentValue];\n+    queue.pop_back();\n+    SmallVector<Value> changed = propagateToUsers(currentValue, info);\n+    queue.insert(queue.end(), changed.begin(), changed.end());\n+  }\n+}\n+\n+void LayoutPropagation::resolveConflicts() {\n+  for (auto &it : layouts) {\n+    LayoutInfo &info = it.second;\n+    if (info.encodings.size() <= 1)\n+      continue;\n+    // Hacky resolve, prefer block encoding.\n+    // TODO: add a proper heuristic.\n+    Attribute encoding = *info.encodings.begin();\n+    for (Attribute e : info.encodings) {\n+      if (e.isa<triton::gpu::BlockedEncodingAttr>()) {\n+        encoding = e;\n+        break;\n       }\n     }\n-\n-    rewriter.replaceOp(op, newRetValues);\n-    return mlir::success();\n+    info.encodings.clear();\n+    info.encodings.insert(encoding);\n   }\n-};\n+}\n \n-//\n-class RematerializeForward : public mlir::RewritePattern {\n-public:\n-  explicit RematerializeForward(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(triton::gpu::ConvertLayoutOp::getOperationName(),\n-                             1, context) {}\n+void LayoutPropagation::dump() {\n+  for (auto it : layouts) {\n+    llvm::errs() << \"Value: \";\n+    OpPrintingFlags flags;\n+    flags.skipRegions();\n+    it.first.print(llvm::errs(), flags);\n+    llvm::errs() << \" \\n encoding:\\n\";\n+    for (auto encoding : it.second.encodings) {\n+      encoding.print(llvm::errs());\n+      llvm::errs() << \"\\n\";\n+    }\n+    llvm::errs() << \"--\\n\";\n+  }\n+}\n \n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *cvtOp,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto cvt = dyn_cast<triton::gpu::ConvertLayoutOp>(*cvtOp);\n-    auto srcEncoding =\n-        cvt.getOperand().getType().cast<RankedTensorType>().getEncoding();\n-    auto dstEncoding =\n-        cvt.getResult().getType().cast<RankedTensorType>().getEncoding();\n-    if (srcEncoding.isa<triton::gpu::SharedEncodingAttr>() ||\n-        dstEncoding.isa<triton::gpu::SharedEncodingAttr>())\n-      return failure();\n-    // heuristics for flash attention\n-    if (srcEncoding.isa<triton::gpu::SliceEncodingAttr>())\n-      return failure();\n-    // For cases like:\n-    // %0 = convert_layout %arg0\n-    // We should try to move %0 out of scf.for first, if it couldn't be moved\n-    // out additional conversions will be added to the loop body.\n-    if (!cvt.getOperand().getDefiningOp() &&\n-        isa<scf::ForOp>(cvt->getParentOp()))\n-      return failure();\n+void LayoutPropagation::rewrite() { rewriteRegion(funcOp->getRegion(0)); }\n \n-    SetVector<Operation *> cvtSlices;\n-    auto filter = [&](Operation *op) {\n-      return op->getBlock() == cvt->getBlock() &&\n-             !isa<triton::gpu::ConvertLayoutOp, scf::YieldOp>(op) &&\n-             !(isa<triton::ReduceOp>(op) &&\n-               !op->getResult(0).getType().isa<RankedTensorType>());\n-    };\n-    mlir::getForwardSlice(cvt.getResult(), &cvtSlices, {filter});\n-    if (cvtSlices.empty())\n-      return failure();\n+static bool allowChangingSrcEncoding(Operation *op) {\n+  // For reductions returning a scalar we can change the src encoding without\n+  // affecting the output.\n+  if (isa<triton::ReduceOp>(op) &&\n+      !op->getResultTypes()[0].isa<RankedTensorType>() &&\n+      op->getNumOperands() == 1)\n+    return true;\n+  return false;\n+}\n \n-    for (Operation *op : cvtSlices) {\n-      // don't rematerialize anything expensive\n-      if (isExpensiveToRemat(op, srcEncoding))\n-        return failure();\n-      // don't rematerialize non-element-wise\n-      if (!op->hasTrait<mlir::OpTrait::SameOperandsAndResultEncoding>() &&\n-          !op->hasTrait<mlir::OpTrait::Elementwise>() &&\n-          !isa<triton::StoreOp, triton::AssertOp, triton::PrintOp,\n-               triton::ReduceOp>(op))\n-        return failure();\n-      // don't rematerialize if it adds an extra conversion that can't\n-      // be removed\n-      for (Value arg : op->getOperands()) {\n-        Operation *argOp = arg.getDefiningOp();\n-        SetVector<Operation *> processed;\n-        SetVector<Attribute> layout;\n-        llvm::MapVector<Value, Attribute> toConvert;\n-        int numAddedConvs = simulateBackwardRematerialization(\n-            argOp, processed, layout, toConvert, srcEncoding);\n-        if (argOp && !isa<triton::gpu::ConvertLayoutOp>(argOp) &&\n-            cvtSlices.count(argOp) == 0 && numAddedConvs > 0)\n-          return failure();\n+void LayoutPropagation::rewriteRegion(Region &region) {\n+  SmallVector<Region *> queue = {&region};\n+  while (!queue.empty()) {\n+    Region *currentRegion = queue.back();\n+    queue.pop_back();\n+    for (Operation &op : currentRegion->getOps()) {\n+      bool needRewrite = false;\n+      SmallVector<Value> results = op.getResults();\n+      for (Value result : results) {\n+        auto it = layouts.find(result);\n+        // If we haven't mapped this value skip.\n+        if (it == layouts.end())\n+          continue;\n+        LayoutInfo &info = it->second;\n+        assert(info.encodings.size() == 1 &&\n+               \"we should have resolved to a single encoding\");\n+        auto encoding = result.getType().cast<RankedTensorType>().getEncoding();\n+        // If the encoding is already what we want skip.\n+        if (encoding == *info.encodings.begin())\n+          continue;\n+        needRewrite = true;\n+      }\n+      if (needRewrite) {\n+        Operation *newOp = rewriteOp(&op);\n+        for (Region &R : newOp->getRegions())\n+          queue.push_back(&R);\n+      } else if (auto yieldOp = dyn_cast<scf::YieldOp>(&op)) {\n+        rewriteYieldOp(yieldOp);\n+      } else {\n+        bool canChangeSrcEncoding = allowChangingSrcEncoding(&op);\n+        // If we don't need to rewrite the op we still need to remap the\n+        // operands.\n+        for (OpOperand &operand : op.getOpOperands()) {\n+          auto it = layouts.find(operand.get());\n+          if (it == layouts.end())\n+            continue;\n+          Attribute encoding =\n+              operand.get().getType().cast<RankedTensorType>().getEncoding();\n+          if (canChangeSrcEncoding)\n+            encoding = it->second.encodings[0];\n+          Value newOperand = getValueAs(operand.get(), encoding);\n+          op.setOperand(operand.getOperandNumber(), newOperand);\n+        }\n+        for (Region &R : op.getRegions())\n+          queue.push_back(&R);\n       }\n     }\n+  }\n+  for (Operation *op : llvm::reverse(opToDelete))\n+    op->erase();\n+}\n \n-    // Call SimplifyReduceCvt instead of the general push conversion forward\n-    if (isa<triton::ReduceOp>(cvtSlices.front()))\n-      return failure();\n+void LayoutPropagation::map(Value old, Value newV) {\n+  rewriteMapping[{old, newV.getType().cast<RankedTensorType>().getEncoding()}] =\n+      newV;\n+}\n \n-    pushConversionForward(cvt, cvtSlices, rewriter);\n-    return success();\n+Value LayoutPropagation::getValueAs(Value value, Attribute encoding) {\n+  if (auto tensorType = value.getType().dyn_cast<RankedTensorType>()) {\n+    Value rewrittenValue;\n+    auto layoutIt = layouts.find(value);\n+    if (layoutIt == layouts.end()) {\n+      rewrittenValue = value;\n+    } else {\n+      assert(layoutIt->second.encodings.size() == 1 &&\n+             \"we should have resolved to a single encoding\");\n+      Attribute encodingPicked = *(layoutIt->second.encodings.begin());\n+      if (encodingPicked == tensorType.getEncoding())\n+        rewrittenValue = value;\n+      else\n+        rewrittenValue = rewriteMapping[{value, encodingPicked}];\n+    }\n+    assert(rewrittenValue);\n+    if (rewrittenValue.getType().cast<RankedTensorType>().getEncoding() ==\n+        encoding)\n+      return rewrittenValue;\n+    OpBuilder rewriter(value.getContext());\n+    rewriter.setInsertionPointAfterValue(rewrittenValue);\n+    auto tmpType = RankedTensorType::get(tensorType.getShape(),\n+                                         tensorType.getElementType(), encoding);\n+    Value converted = rewriter.create<triton::gpu::ConvertLayoutOp>(\n+        value.getLoc(), tmpType, rewrittenValue);\n+    // TODO: we could cache the conversion.\n+    return converted;\n   }\n-};\n+  return value;\n+}\n \n-// Layout conversions are expensive. They require going through\n-// shared memory, which is orders of magnitude slower than\n-// other non-i/o operations in the dialect.\n-// It therefore makes sense to remove them whenever possible,\n-// even if it means rematerializing all values whose definitions\n-// are reachable from it without passing through any memory operation.\n-class RematerializeBackward : public mlir::RewritePattern {\n-public:\n-  explicit RematerializeBackward(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(triton::gpu::ConvertLayoutOp::getOperationName(),\n-                             3, context) {}\n+Operation *LayoutPropagation::cloneElementwise(OpBuilder &rewriter,\n+                                               Operation *op,\n+                                               Attribute encoding) {\n+  Operation *newOp = rewriter.clone(*op);\n+  for (OpOperand &operand : op->getOpOperands())\n+    newOp->setOperand(\n+        operand.getOperandNumber(),\n+        getValueAs(operand.get(), *inferSrcEncoding(op, encoding)));\n+  for (unsigned i = 0, e = op->getNumResults(); i < e; ++i) {\n+    auto origType = op->getResult(i).getType().dyn_cast<RankedTensorType>();\n+    if (!origType)\n+      continue;\n+    auto newType = RankedTensorType::get(origType.getShape(),\n+                                         origType.getElementType(), encoding);\n+    newOp->getResult(i).setType(newType);\n+  }\n+  return newOp;\n+}\n \n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *cvt,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    if (!llvm::isa<triton::gpu::ConvertLayoutOp>(cvt))\n-      return mlir::failure();\n-    // we don't touch block arguments\n-    Operation *op = cvt->getOperand(0).getDefiningOp();\n-    if (!op)\n-      return mlir::failure();\n-    // we don't want to rematerialize any conversion to/from shared\n-    if (triton::gpu::isSharedEncoding(cvt->getResults()[0]) ||\n-        triton::gpu::isSharedEncoding(cvt->getOperand(0)))\n-      return mlir::failure();\n-    // we don't handle conversions to DotOperandEncodingAttr\n-    // this is a heuristics to accommodate fused attention\n-    auto targetType = cvt->getResultTypes()[0].cast<RankedTensorType>();\n-    if (targetType.getEncoding().isa<triton::gpu::DotOperandEncodingAttr>())\n-      return mlir::failure();\n-    // DFS\n-    SetVector<Operation *> processed;\n-    SetVector<Attribute> layout;\n-    llvm::MapVector<Value, Attribute> toConvert;\n-    if (simulateBackwardRematerialization(cvt, processed, layout, toConvert,\n-                                          targetType.getEncoding()) > 0)\n-      return mlir::failure();\n+Operation *LayoutPropagation::rewriteForOp(scf::ForOp forOp) {\n+  SmallVector<Value> operands;\n+  OpBuilder rewriter(forOp);\n+  for (auto [operand, result] :\n+       llvm::zip(forOp.getInitArgs(), forOp.getResults())) {\n+    Value convertedOperand = operand;\n+    if (layouts.count(result))\n+      convertedOperand =\n+          getValueAs(operand, *layouts[result].encodings.begin());\n+    operands.push_back(convertedOperand);\n+  }\n+  auto newForOp = rewriter.create<scf::ForOp>(\n+      forOp.getLoc(), forOp.getLowerBound(), forOp.getUpperBound(),\n+      forOp.getStep(), operands);\n+\n+  newForOp.getBody()->getOperations().splice(\n+      newForOp.getBody()->getOperations().begin(),\n+      forOp.getBody()->getOperations());\n+\n+  for (auto [oldResult, newResult] :\n+       llvm::zip(forOp.getResults(), newForOp.getResults())) {\n+    if (oldResult.getType() == newResult.getType()) {\n+      oldResult.replaceAllUsesWith(newResult);\n+      continue;\n+    }\n+    map(oldResult, newResult);\n+  }\n+\n+  for (auto [oldArg, newArg] : llvm::zip(forOp.getBody()->getArguments(),\n+                                         newForOp.getBody()->getArguments())) {\n+    if (oldArg.getType() == newArg.getType()) {\n+      oldArg.replaceAllUsesWith(newArg);\n+      continue;\n+    }\n+    map(oldArg, newArg);\n+  }\n+  opToDelete.push_back(forOp.getOperation());\n+  return newForOp.getOperation();\n+}\n \n-    IRMapping mapping;\n-    rematerializeConversionChain(toConvert, rewriter, processed, mapping);\n-    rewriter.replaceOp(cvt, mapping.lookup(cvt->getOperand(0)));\n+Operation *LayoutPropagation::rewriteYieldOp(scf::YieldOp yieldOp) {\n+  OpBuilder rewriter(yieldOp);\n+  Operation *newYield = rewriter.clone(*yieldOp.getOperation());\n+  Operation *parentOp = yieldOp->getParentOp();\n+  for (OpOperand &operand : yieldOp->getOpOperands()) {\n+    Value result = parentOp->getResult(operand.getOperandNumber());\n+    auto tensorType = result.getType().dyn_cast<RankedTensorType>();\n+    if (!tensorType)\n+      continue;\n+    Value newOperand = getValueAs(operand.get(), tensorType.getEncoding());\n+    newYield->setOperand(operand.getOperandNumber(), newOperand);\n+  }\n+  opToDelete.push_back(yieldOp.getOperation());\n+  return newYield;\n+}\n \n-    return mlir::success();\n+Operation *LayoutPropagation::rewriteOp(Operation *op) {\n+  if (auto forOp = dyn_cast<scf::ForOp>(op)) {\n+    return rewriteForOp(forOp);\n   }\n-};\n+  OpBuilder rewriter(op);\n+  Attribute encoding = *layouts[op->getResult(0)].encodings.begin();\n+  if (auto convertOp = dyn_cast<triton::gpu::ConvertLayoutOp>(op)) {\n+    Attribute srcEncoding = *layouts[convertOp.getOperand()].encodings.begin();\n+    Value src = getValueAs(convertOp.getOperand(), srcEncoding);\n+    auto tensorType = op->getResult(0).getType().cast<RankedTensorType>();\n+    auto newType = RankedTensorType::get(tensorType.getShape(),\n+                                         tensorType.getElementType(), encoding);\n+    auto cvt = rewriter.create<triton::gpu::ConvertLayoutOp>(op->getLoc(),\n+                                                             newType, src);\n+    map(op->getResult(0), cvt.getResult());\n+    opToDelete.push_back(op);\n+    return cvt.getOperation();\n+  }\n+  if (canFoldIntoConversion(op, encoding)) {\n+    Operation *newOp = rewriter.clone(*op);\n+    auto tensorType = op->getResult(0).getType().cast<RankedTensorType>();\n+    auto newType = RankedTensorType::get(tensorType.getShape(),\n+                                         tensorType.getElementType(), encoding);\n+    auto cvt = rewriter.create<triton::gpu::ConvertLayoutOp>(\n+        op->getLoc(), newType, newOp->getResult(0));\n+    map(op->getResult(0), cvt.getResult());\n+    opToDelete.push_back(op);\n+    return cvt.getOperation();\n+  }\n+  if (op->hasTrait<mlir::OpTrait::SameOperandsAndResultEncoding>() ||\n+      op->hasTrait<mlir::OpTrait::Elementwise>() ||\n+      isa<triton::ReduceOp, triton::ExpandDimsOp, triton::gpu::ConvertLayoutOp>(\n+          op)) {\n+    Operation *newOp = cloneElementwise(rewriter, op, encoding);\n+    for (auto [oldResult, newResult] :\n+         llvm::zip(op->getResults(), newOp->getResults()))\n+      map(oldResult, newResult);\n+    opToDelete.push_back(op);\n+    return newOp;\n+  }\n+  assert(0 && \"unexpected op in rewrite\");\n+  return nullptr;\n+}\n \n-// -----------------------------------------------------------------------------\n-//\n-// -----------------------------------------------------------------------------\n+static bool canBeRemat(Operation *op) {\n+  if (isa<triton::LoadOp, triton::StoreOp>(op))\n+    return !isExpensiveLoadOrStore(op);\n+  if (isa<triton::CatOp, triton::ViewOp>(op))\n+    return false;\n+  if (isa<tensor::ExtractSliceOp, triton::gpu::AllocTensorOp,\n+          triton::gpu::InsertSliceAsyncOp, triton::AtomicRMWOp,\n+          triton::AtomicCASOp, triton::DotOp>(op))\n+    return false;\n+  if (isa<scf::IfOp, scf::WhileOp, scf::ConditionOp>(op))\n+    return false;\n+\n+  return true;\n+}\n \n-class MoveConvertOutOfLoop : public mlir::RewritePattern {\n-public:\n-  explicit MoveConvertOutOfLoop(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(scf::ForOp::getOperationName(), 1, context) {}\n-\n-  SmallVector<Value, 4>\n-  rematerializeForLoop(mlir::PatternRewriter &rewriter, scf::ForOp &forOp,\n-                       size_t i, RankedTensorType newType,\n-                       triton::gpu::ConvertLayoutOp origConversion) const {\n-    // Rewrite init argument\n-    auto origType = forOp.getInitArgs()[i].getType().cast<RankedTensorType>();\n-    SmallVector<Value, 4> newInitArgs = forOp.getInitArgs();\n-    newInitArgs[i] = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-        newInitArgs[i].getLoc(), newType, newInitArgs[i]);\n-    // Clone for loop\n-    auto newForOp = rewriter.create<scf::ForOp>(\n-        forOp.getLoc(), forOp.getLowerBound(), forOp.getUpperBound(),\n-        forOp.getStep(), newInitArgs);\n-    newForOp->moveBefore(forOp);\n-    rewriter.setInsertionPointToStart(newForOp.getBody());\n-    IRMapping mapping;\n-    for (const auto &arg : llvm::enumerate(forOp.getRegionIterArgs()))\n-      mapping.map(arg.value(), newForOp.getRegionIterArgs()[arg.index()]);\n-    mapping.map(origConversion.getResult(), newForOp.getRegionIterArgs()[i]);\n-\n-    mapping.map(forOp.getInductionVar(), newForOp.getInductionVar());\n-    for (Operation &op : forOp.getBody()->without_terminator()) {\n-      if (dyn_cast<triton::gpu::ConvertLayoutOp>(op) == origConversion)\n-        continue;\n+// Replace ForOp with a new ForOp with extra operands. The YieldOp is not\n+// updated and needs to be updated separatly for the loop to be correct.\n+static scf::ForOp replaceForOpWithNewSignature(OpBuilder &rewriter,\n+                                               scf::ForOp loop,\n+                                               ValueRange newIterOperands) {\n+  OpBuilder::InsertionGuard g(rewriter);\n+  rewriter.setInsertionPoint(loop);\n+\n+  // Create a new loop before the existing one, with the extra operands.\n+  rewriter.setInsertionPoint(loop);\n+  auto operands = llvm::to_vector<4>(loop.getIterOperands());\n+  operands.append(newIterOperands.begin(), newIterOperands.end());\n+  scf::ForOp newLoop = rewriter.create<scf::ForOp>(\n+      loop.getLoc(), loop.getLowerBound(), loop.getUpperBound(), loop.getStep(),\n+      operands);\n+  newLoop.getBody()->erase();\n+\n+  newLoop.getLoopBody().getBlocks().splice(\n+      newLoop.getLoopBody().getBlocks().begin(),\n+      loop.getLoopBody().getBlocks());\n+  for (Value operand : newIterOperands)\n+    newLoop.getBody()->addArgument(operand.getType(), operand.getLoc());\n+\n+  for (auto it : llvm::zip(loop.getResults(), newLoop.getResults().take_front(\n+                                                  loop.getNumResults())))\n+    std::get<0>(it).replaceAllUsesWith(std::get<1>(it));\n+  return newLoop;\n+}\n \n-      bool convert = llvm::any_of(op.getOperands(), [&](auto operand) {\n-        return operand == origConversion.getOperand();\n-      });\n-      auto convertLayout = [&](Value operand, Value value, Attribute encoding) {\n-        auto tensorType = value.getType().cast<RankedTensorType>();\n-        auto cvtType = RankedTensorType::get(\n-            tensorType.getShape(), tensorType.getElementType(), encoding);\n-        auto cvt = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-            op.getLoc(), cvtType, value);\n-        mapping.map(operand, cvt);\n-      };\n-      DenseMap<Value, Value> cvtValues;\n-      if (convert) {\n-        for (auto operand : op.getOperands()) {\n-          if (operand == origConversion.getOperand() ||\n-              !isa<RankedTensorType>(operand.getType()))\n-            continue;\n-          auto value = mapping.lookupOrDefault(operand);\n-          // Convert to the new type\n-          convertLayout(operand, value, newType.getEncoding());\n-          // Other ops don't use the converted value and we need to restore\n-          cvtValues[operand] = value;\n+static void rewriteSlice(SetVector<Value> &slice,\n+                         DenseMap<Value, Attribute> &layout,\n+                         ConvertLayoutOp convertOp) {\n+\n+  SetVector<Operation *> opsToRewrite;\n+  for (Value v : slice) {\n+    if (v.getDefiningOp()) {\n+      opsToRewrite.insert(v.getDefiningOp());\n+    } else {\n+      opsToRewrite.insert(v.cast<BlockArgument>().getOwner()->getParentOp());\n+      // We also need to rewrite the yield op.\n+      opsToRewrite.insert(v.cast<BlockArgument>().getOwner()->getTerminator());\n+    }\n+  }\n+  opsToRewrite = multiRootTopologicalSort(opsToRewrite);\n+\n+  IRMapping mapping;\n+  SmallVector<Operation *> deadLoops;\n+  OpBuilder builder(slice.begin()->getContext());\n+  for (Operation *op : opsToRewrite) {\n+    if (auto forOp = dyn_cast<scf::ForOp>(op)) {\n+      // Keep a mapping of the operands index to the new operands index.\n+      SmallVector<std::pair<size_t, size_t>> argMapping;\n+      SmallVector<Value> newOperands;\n+      for (auto arg : forOp.getRegionIterArgs()) {\n+        if (slice.count(arg)) {\n+          OpOperand &initVal = forOp.getOpOperandForRegionIterArg(arg);\n+          argMapping.push_back(\n+              std::make_pair(*forOp.getIterArgNumberForOpOperand(initVal),\n+                             forOp.getNumIterOperands() + newOperands.size()));\n+          newOperands.push_back(mapping.lookup(initVal.get()));\n         }\n       }\n-      auto *newOp = cloneWithInferType(rewriter, &op, mapping);\n-      if (convert) {\n-        for (auto result : op.getResults()) {\n-          if (!isa<RankedTensorType>(result.getType()))\n-            continue;\n-          auto value = mapping.lookupOrDefault(result);\n-          auto tensorType = result.getType().cast<RankedTensorType>();\n-          // Convert to the original type\n-          convertLayout(result, value, tensorType.getEncoding());\n-        }\n-        // Restore original values\n-        for (auto [operand, value] : cvtValues)\n-          mapping.map(operand, value);\n+      // Create a new for loop with the new operands.\n+      scf::ForOp newForOp =\n+          replaceForOpWithNewSignature(builder, forOp, newOperands);\n+      deadLoops.push_back(forOp.getOperation());\n+      Block &loopBody = *newForOp.getBody();\n+      for (auto m : argMapping) {\n+        mapping.map(newForOp.getResult(m.first), newForOp.getResult(m.second));\n+        int numIndVars = newForOp.getNumInductionVars();\n+        mapping.map(loopBody.getArgument(m.first + numIndVars),\n+                    loopBody.getArgument(m.second + numIndVars));\n       }\n+      continue;\n     }\n-    // create yield, inserting conversions if necessary\n-    auto yieldOp = forOp.getBody()->getTerminator();\n-    SmallVector<Value, 4> newYieldArgs;\n-    // We use the new type for the result of the conversion\n-    for (Value arg : yieldOp->getOperands())\n-      newYieldArgs.push_back(mapping.lookup(arg));\n-    if (newYieldArgs[i].getType() != newType)\n-      newYieldArgs[i] = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-          yieldOp->getLoc(), newType, newYieldArgs[i]);\n-    rewriter.create<scf::YieldOp>(forOp.getLoc(), newYieldArgs);\n-\n-    // replace\n-    SmallVector<Value, 4> newResults = newForOp->getResults();\n-    newResults[i] = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-        newForOp.getLoc(), origType, newForOp->getResult(i));\n-    newResults[i].getDefiningOp()->moveAfter(newForOp);\n-\n-    return newResults;\n-  }\n-\n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto forOp = cast<scf::ForOp>(op);\n-    auto iterArgs = forOp.getRegionIterArgs();\n-    for (const auto &iterArg : llvm::enumerate(iterArgs)) {\n-      // skip non-tensor types\n-      if (!iterArg.value().getType().isa<RankedTensorType>())\n-        continue;\n-      SmallVector<Operation *> cvts;\n-      if (canMoveOutOfLoop(iterArg.value(), cvts).failed())\n-        continue;\n-      // check\n-      for (auto *op : cvts) {\n-        auto cvt = dyn_cast<triton::gpu::ConvertLayoutOp>(op);\n-        auto targetType = op->getResultTypes()[0].cast<RankedTensorType>();\n-        auto newFor = rematerializeForLoop(rewriter, forOp, iterArg.index(),\n-                                           targetType, cvt);\n-        rewriter.replaceOp(forOp, newFor);\n-        return success();\n+    builder.setInsertionPoint(op);\n+    if (auto yieldOp = dyn_cast<scf::YieldOp>(op)) {\n+      auto yieldOperands = llvm::to_vector(yieldOp.getOperands());\n+      for (Value operand : yieldOp.getOperands()) {\n+        if (slice.count(operand) == 0)\n+          continue;\n+        yieldOperands.push_back(mapping.lookup(operand));\n       }\n+      builder.create<scf::YieldOp>(op->getLoc(), yieldOperands);\n+      op->erase();\n+      continue;\n+    }\n+    if (isa<arith::ConstantOp>(op)) {\n+      Operation *newOp = builder.clone(*op);\n+      auto tensorType = op->getResult(0).getType().cast<RankedTensorType>();\n+      auto newType = RankedTensorType::get(tensorType.getShape(),\n+                                           tensorType.getElementType(),\n+                                           layout[op->getResult(0)]);\n+      auto cvt = builder.create<triton::gpu::ConvertLayoutOp>(\n+          op->getLoc(), newType, newOp->getResult(0));\n+      mapping.map(op->getResult(0), cvt.getResult());\n+      continue;\n+    }\n+    Operation *newOp = builder.clone(*op, mapping);\n+    for (auto [old, newV] : llvm::zip(op->getResults(), newOp->getResults())) {\n+      auto it = layout.find(old);\n+      if (it == layout.end())\n+        continue;\n+      auto newType = RankedTensorType::get(\n+          old.getType().cast<RankedTensorType>().getShape(),\n+          old.getType().cast<RankedTensorType>().getElementType(), it->second);\n+      newV.setType(newType);\n     }\n-    return failure();\n   }\n-};\n+  convertOp.replaceAllUsesWith(mapping.lookup(convertOp.getOperand()));\n+  convertOp.erase();\n+  for (Operation *op : deadLoops)\n+    op->erase();\n+}\n \n-//\n-class ConvertDotConvert : public mlir::RewritePattern {\n-public:\n-  ConvertDotConvert(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(triton::gpu::ConvertLayoutOp::getOperationName(),\n-                             1, context) {}\n+static void backwardRematerialization(ConvertLayoutOp convertOp) {\n+  // we don't want to rematerialize any conversion to/from shared\n+  if (triton::gpu::isSharedEncoding(convertOp.getResult()) ||\n+      triton::gpu::isSharedEncoding(convertOp.getOperand()))\n+    return;\n+  // we don't handle conversions to DotOperandEncodingAttr\n+  // this is a heuristics to accommodate fused attention\n+  auto targetType = convertOp->getResultTypes()[0].cast<RankedTensorType>();\n+  if (targetType.getEncoding().isa<triton::gpu::DotOperandEncodingAttr>())\n+    return;\n \n-  LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto dstOp = cast<triton::gpu::ConvertLayoutOp>(op);\n-    auto dotOp = dstOp.getSrc().getDefiningOp<triton::DotOp>();\n-    if (!dotOp)\n-      return mlir::failure();\n-    if (std::distance(dstOp->user_begin(), dstOp->user_end()) != 1 ||\n-        std::distance(dotOp->user_begin(), dotOp->user_end()) != 1)\n-      return mlir::failure();\n-    auto cvtOp =\n-        dotOp.getOperand(2).getDefiningOp<triton::gpu::ConvertLayoutOp>();\n-    if (!cvtOp)\n-      return mlir::failure();\n-    if (!cvtOp.getSrc().getDefiningOp<triton::LoadOp>())\n-      return failure();\n-    auto dstTy = dstOp.getResult().getType().cast<RankedTensorType>();\n-    auto srcTy = cvtOp.getOperand().getType().cast<RankedTensorType>();\n-    if (dstTy != srcTy)\n-      return mlir::failure();\n+  // 1. Take a backward slice of all the tensor dependencies.\n+  SetVector<Value> slice;\n+  DenseMap<Value, Attribute> layout;\n+  LogicalResult result = getConvertBackwardSlice(\n+      convertOp.getOperand(), slice, targetType.getEncoding(), layout);\n+  if (result.failed() || slice.empty())\n+    return;\n \n-    auto _0f = rewriter.create<arith::ConstantOp>(\n-        op->getLoc(), dstTy.getElementType(),\n-        rewriter.getZeroAttr(dstTy.getElementType()));\n-    auto _0 = rewriter.create<triton::SplatOp>(\n-        op->getLoc(), dotOp.getResult().getType(), _0f);\n-    auto newDot = rewriter.create<triton::DotOp>(\n-        op->getLoc(), dotOp.getResult().getType(), dotOp.getOperand(0),\n-        dotOp.getOperand(1), _0, dotOp.getAllowTF32());\n-    auto newCvt = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-        op->getLoc(), dstTy, newDot.getResult());\n-    rewriter.replaceOpWithNewOp<arith::AddFOp>(op, newCvt, cvtOp.getOperand());\n-    return mlir::success();\n+  // 2. Check if all the operations in the slice can be rematerialized.\n+  for (Value v : slice) {\n+    if (Operation *op = v.getDefiningOp()) {\n+      if (!canBeRemat(op))\n+        return;\n+    }\n   }\n-};\n+  // 3. Rewrite the slice.\n+  rewriteSlice(slice, layout, convertOp);\n+}\n \n-} // namespace\n+static void backwardRematerialization(ModuleOp module) {\n+  SmallVector<ConvertLayoutOp> convertOps;\n+  module.walk(\n+      [&](ConvertLayoutOp convertOp) { convertOps.push_back(convertOp); });\n+  for (ConvertLayoutOp convertOp : convertOps) {\n+    backwardRematerialization(convertOp);\n+  }\n+}\n \n #define GEN_PASS_CLASSES\n #include \"triton/Dialect/TritonGPU/Transforms/Passes.h.inc\"\n@@ -632,18 +766,37 @@ class TritonGPURemoveLayoutConversionsPass\n     MLIRContext *context = &getContext();\n     ModuleOp m = getOperation();\n \n-    mlir::RewritePatternSet patterns(context);\n+    m.walk([](triton::FuncOp funcOp) {\n+      LayoutPropagation layoutPropagation(funcOp);\n+      layoutPropagation.initAnchorLayout();\n+      layoutPropagation.propagateLayout();\n+      layoutPropagation.resolveConflicts();\n+      layoutPropagation.rewrite();\n+    });\n+\n+    mlir::RewritePatternSet cleanUpPatterns(context);\n+    ConvertLayoutOp::getCanonicalizationPatterns(cleanUpPatterns, context);\n+    if (mlir::applyPatternsAndFoldGreedily(m, std::move(cleanUpPatterns))\n+            .failed()) {\n+      signalPassFailure();\n+    }\n \n-    patterns.add<SimplifyConversion>(context);\n-    patterns.add<SimplifyReduceCvt>(context);\n-    patterns.add<RematerializeBackward>(context);\n-    patterns.add<RematerializeForward>(context);\n-    patterns.add<MoveConvertOutOfLoop>(context);\n-    patterns.add<MoveConvertOutOfIf>(context);\n-    patterns.add<DecomposeDotOperand>(context);\n-    patterns.add<ConvertDotConvert>(context);\n+    backwardRematerialization(m);\n+\n+    mlir::RewritePatternSet decomposePatterns(context);\n+    decomposePatterns.add<DecomposeDotOperand>(context);\n+    decomposePatterns.add<ConvertDotConvert>(context);\n+    if (mlir::applyPatternsAndFoldGreedily(m, std::move(decomposePatterns))\n+            .failed()) {\n+      signalPassFailure();\n+    }\n \n-    if (mlir::applyPatternsAndFoldGreedily(m, std::move(patterns)).failed()) {\n+    mlir::RewritePatternSet cleanUpPatterns2(context);\n+    populateForOpDeadArgumentElimination(cleanUpPatterns2);\n+    scf::ForOp::getCanonicalizationPatterns(cleanUpPatterns2, context);\n+    ConvertLayoutOp::getCanonicalizationPatterns(cleanUpPatterns2, context);\n+    if (mlir::applyPatternsAndFoldGreedily(m, std::move(cleanUpPatterns2))\n+            .failed()) {\n       signalPassFailure();\n     }\n   }"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Utility.cpp", "status": "modified", "additions": 195, "deletions": 287, "changes": 482, "file_content_changes": "@@ -240,30 +240,57 @@ std::string GraphLayoutMarker::getColor(const Type &type) const {\n }\n // -------------------------------------------------------------------------- //\n \n-// TODO: Interface\n-LogicalResult invertEncoding(Attribute targetEncoding, Operation *op,\n-                             Attribute &ret) {\n-  ret = targetEncoding;\n-  if (auto expand_dims = dyn_cast<triton::ExpandDimsOp>(op)) {\n-    ret = triton::gpu::SliceEncodingAttr::get(\n-        op->getContext(), expand_dims.getAxis(), targetEncoding);\n-  }\n-  if (auto reduce = dyn_cast<triton::ReduceOp>(op)) {\n-    auto sliceEncoding =\n-        targetEncoding.dyn_cast<triton::gpu::SliceEncodingAttr>();\n-    if (!sliceEncoding)\n-      return failure();\n-    if (sliceEncoding.getDim() != reduce.getAxis())\n-      return failure();\n-    ret = sliceEncoding.getParent();\n-  }\n-  if (isa<triton::ViewOp, triton::CatOp>(op)) {\n-    return failure();\n-  }\n-  return success();\n+static std::optional<Attribute> inferDstEncoding(triton::ReduceOp op,\n+                                                 Attribute encoding) {\n+  return triton::gpu::SliceEncodingAttr::get(op->getContext(), op.getAxis(),\n+                                             encoding);\n+}\n+\n+static std::optional<Attribute> inferDstEncoding(triton::ExpandDimsOp op,\n+                                                 Attribute encoding) {\n+  auto sliceEncoding = encoding.dyn_cast<triton::gpu::SliceEncodingAttr>();\n+  if (!sliceEncoding)\n+    return std::nullopt;\n+  assert(op.getAxis() == sliceEncoding.getDim());\n+  return sliceEncoding.getParent();\n+}\n+\n+static std::optional<Attribute> inferSrcEncoding(triton::ReduceOp op,\n+                                                 Attribute encoding) {\n+  auto sliceEncoding = encoding.dyn_cast<triton::gpu::SliceEncodingAttr>();\n+  if (!sliceEncoding)\n+    return std::nullopt;\n+  assert(op.getAxis() == sliceEncoding.getDim());\n+  return sliceEncoding.getParent();\n }\n \n-bool isExpensiveLoadOrStore(Operation *op, Attribute &targetEncoding) {\n+static std::optional<Attribute> inferSrcEncoding(triton::ExpandDimsOp op,\n+                                                 Attribute encoding) {\n+  return triton::gpu::SliceEncodingAttr::get(op->getContext(), op.getAxis(),\n+                                             encoding);\n+}\n+\n+std::optional<Attribute> inferSrcEncoding(Operation *op, Attribute encoding) {\n+  if (auto reduceOp = dyn_cast<triton::ReduceOp>(op))\n+    return inferSrcEncoding(reduceOp, encoding);\n+  if (auto expand = dyn_cast<triton::ExpandDimsOp>(op))\n+    return inferSrcEncoding(expand, encoding);\n+  if (isa<triton::ViewOp, triton::CatOp>(op))\n+    return std::nullopt;\n+  return encoding;\n+}\n+\n+std::optional<Attribute> inferDstEncoding(Operation *op, Attribute encoding) {\n+  if (auto reduceOp = dyn_cast<triton::ReduceOp>(op))\n+    return inferDstEncoding(reduceOp, encoding);\n+  if (auto expand = dyn_cast<triton::ExpandDimsOp>(op))\n+    return inferDstEncoding(expand, encoding);\n+  if (isa<triton::ViewOp, triton::CatOp>(op))\n+    return std::nullopt;\n+  return encoding;\n+}\n+\n+bool isExpensiveLoadOrStore(Operation *op) {\n   // Case 1: Pointer of tensor is always expensive\n   auto operandType = op->getOperand(0).getType();\n   if (triton::isTensorPointerType(operandType))\n@@ -287,7 +314,7 @@ bool isExpensiveToRemat(Operation *op, Attribute &targetEncoding) {\n   if (!op)\n     return true;\n   if (isa<triton::LoadOp, triton::StoreOp>(op))\n-    return isExpensiveLoadOrStore(op, targetEncoding);\n+    return isExpensiveLoadOrStore(op);\n   if (isa<triton::CatOp>(op))\n     return triton::gpu::isExpensiveCat(cast<triton::CatOp>(op), targetEncoding);\n   if (isa<tensor::ExtractSliceOp, triton::gpu::AllocTensorOp,\n@@ -300,75 +327,21 @@ bool isExpensiveToRemat(Operation *op, Attribute &targetEncoding) {\n   return false;\n }\n \n-bool canFoldConversion(Operation *op, Attribute targetEncoding) {\n+bool canFoldIntoConversion(Operation *op, Attribute targetEncoding) {\n   if (isa<triton::CatOp>(op))\n     return !triton::gpu::isExpensiveCat(cast<triton::CatOp>(op),\n                                         targetEncoding);\n-  return isa<triton::gpu::ConvertLayoutOp, arith::ConstantOp,\n-             triton::MakeRangeOp, triton::SplatOp, triton::ViewOp>(op);\n-}\n-\n-int simulateBackwardRematerialization(\n-    Operation *initOp, SetVector<Operation *> &processed,\n-    SetVector<Attribute> &layout, llvm::MapVector<Value, Attribute> &toConvert,\n-    Attribute targetEncoding) {\n-  // DFS\n-  std::vector<std::pair<Operation *, Attribute>> queue;\n-  queue.emplace_back(initOp, targetEncoding);\n-  // We want to see the effect of converting `initOp` to a new layout\n-  // so we initialize `numCvts = 1`.\n-  int numCvts = 1;\n-  while (!queue.empty()) {\n-    Operation *currOp;\n-    Attribute currLayout;\n-    std::tie(currOp, currLayout) = queue.back();\n-    queue.pop_back();\n-    // If the current operation is expensive to rematerialize,\n-    // we stop everything\n-    if (isExpensiveToRemat(currOp, currLayout))\n-      break;\n-    // A conversion will be removed here (i.e. transferred to operands)\n-    numCvts -= 1;\n-    // Done processing\n-    processed.insert(currOp);\n-    layout.insert(currLayout);\n-    // Add all operands to the queue\n-    for (Value argI : currOp->getOperands()) {\n-      Attribute newEncoding;\n-      // Cannot invert the current encoding for this operand\n-      // we stop everything\n-      if (failed(invertEncoding(currLayout, currOp, newEncoding)))\n-        return INT_MAX;\n-      if (toConvert.count(argI) && toConvert[argI] != newEncoding)\n-        return INT_MAX;\n-      if (auto ptrTy = argI.getType().dyn_cast<triton::PointerType>()) {\n-        if (ptrTy.getPointeeType().isa<RankedTensorType>()) {\n-          return INT_MAX;\n-        }\n-      }\n-\n-      Operation *opArgI = argI.getDefiningOp();\n-      toConvert.insert({argI, newEncoding});\n-      // 1. Only convert RankedTensorType\n-      // 2. Skip if there's no defining op\n-      // 3. Skip if the defining op has already been processed\n-      // 4. Skip or the defining op is in a different block\n-      if (!argI.getType().isa<RankedTensorType>() || !opArgI ||\n-          processed.contains(opArgI) ||\n-          opArgI->getBlock() != currOp->getBlock())\n-        continue;\n-      // If the conversion can be folded into opArgI then\n-      // we don't count this conversion as expensive\n-      if (canFoldConversion(opArgI, newEncoding))\n-        continue;\n-\n-      // We add one expensive conversion for the current operand\n-      numCvts += 1;\n-      queue.emplace_back(opArgI, newEncoding);\n+  if (auto convert = dyn_cast<triton::gpu::ConvertLayoutOp>(op)) {\n+    if (targetEncoding.isa<triton::gpu::MmaEncodingAttr>()) {\n+      auto srcEncoding =\n+          convert.getOperand().getType().cast<RankedTensorType>().getEncoding();\n+      if (targetEncoding != srcEncoding)\n+        return false;\n     }\n+    return true;\n   }\n-  // return net number of conversions\n-  return numCvts;\n+  return isa<triton::gpu::ConvertLayoutOp, arith::ConstantOp,\n+             triton::MakeRangeOp, triton::SplatOp, triton::ViewOp>(op);\n }\n \n //\n@@ -409,213 +382,48 @@ Operation *cloneWithInferType(mlir::OpBuilder &rewriter, Operation *op,\n   return newOp;\n }\n \n-namespace {\n-\n-struct OpUseInfo {\n-  Value value;\n-  Operation *op;\n-  unsigned index;\n-};\n-\n-void getForwardSliceOpUseInfo(Operation *op,\n-                              SetVector<Operation *> *forwardSliceOps,\n-                              SmallVector<OpUseInfo> *forwardOpUseInfo) {\n-  if (!op)\n-    return;\n-\n-  for (Region &region : op->getRegions())\n-    for (Block &block : region)\n-      for (Operation &blockOp : block)\n-        if (forwardSliceOps->count(&blockOp) == 0)\n-          getForwardSliceOpUseInfo(&blockOp, forwardSliceOps, forwardOpUseInfo);\n-  for (Value result : op->getResults()) {\n-    for (OpOperand &operand : result.getUses()) {\n-      auto *blockOp = operand.getOwner();\n-      forwardOpUseInfo->push_back(\n-          {operand.get(), blockOp, operand.getOperandNumber()});\n-      if (forwardSliceOps->count(blockOp) == 0)\n-        getForwardSliceOpUseInfo(blockOp, forwardSliceOps, forwardOpUseInfo);\n-    }\n-  }\n-\n-  forwardSliceOps->insert(op);\n-}\n-} // namespace\n-\n-LogicalResult simulateForwardRematerializationInLoop(Operation *startOp,\n-                                                     BlockArgument arg,\n-                                                     Attribute targetEncoding) {\n-  // heuristics for flash attention\n-  if (targetEncoding.isa<triton::gpu::SharedEncodingAttr>())\n-    return failure();\n-  SetVector<Operation *> cvtSliceOps;\n-  SmallVector<OpUseInfo> cvtSliceOpUseInfo;\n-  getForwardSliceOpUseInfo(startOp, &cvtSliceOps, &cvtSliceOpUseInfo);\n-\n-  // Check if any additional conversion is needed along the way\n-  for (Operation *op : cvtSliceOps) {\n-    if (isa<scf::YieldOp>(op))\n+LogicalResult getConvertBackwardSlice(Value root, SetVector<Value> &slice,\n+                                      Attribute rootEncoding,\n+                                      DenseMap<Value, Attribute> &layout) {\n+  SmallVector<std::pair<Value, Attribute>> queue = {{root, rootEncoding}};\n+  while (!queue.empty()) {\n+    auto [currentValue, encoding] = queue.back();\n+    queue.pop_back();\n+    if (!currentValue.getType().isa<RankedTensorType>())\n       continue;\n-    // The first op doesn't push forward any conversion\n-    if (op != startOp) {\n-      if (isa<triton::ReduceOp>(op) &&\n-          !op->getResult(0).getType().isa<RankedTensorType>())\n-        return failure();\n-      // don't rematerialize anything expensive\n-      if (isExpensiveToRemat(op, targetEncoding))\n-        return failure();\n-      // don't rematerialize non-element-wise\n-      if (!op->hasTrait<mlir::OpTrait::SameOperandsAndResultEncoding>() &&\n-          !op->hasTrait<mlir::OpTrait::Elementwise>() &&\n-          !isa<triton::StoreOp, triton::AssertOp, triton::PrintOp,\n-               triton::ReduceOp>(op))\n-        return failure();\n-    }\n-    // don't rematerialize if it adds an extra conversion that can't\n-    // be removed\n-    for (Value value : op->getOperands()) {\n-      Operation *argOp = arg.getDefiningOp();\n-      SetVector<Operation *> processed;\n-      SetVector<Attribute> layout;\n-      llvm::MapVector<Value, Attribute> toConvert;\n-      int numAddedConvs = simulateBackwardRematerialization(\n-          argOp, processed, layout, toConvert, targetEncoding);\n-      if (argOp && !isa<triton::gpu::ConvertLayoutOp>(argOp) &&\n-          cvtSliceOps.count(argOp) == 0 && numAddedConvs > 0)\n-        return failure();\n-    }\n-  }\n-\n-  // We apply conservative analysis. Only when the final operand's index\n-  // matches the argument's index or their encoding match, we can rematerialize.\n-  for (auto &opUseInfo : cvtSliceOpUseInfo) {\n-    Operation *op = opUseInfo.op;\n-    if (isa<scf::YieldOp>(op)) {\n-      auto yieldIdx = opUseInfo.index;\n-      // 0 is the induction variable\n-      auto argIdx = arg.getArgNumber() - 1;\n-      if (yieldIdx != argIdx) {\n-        auto argType = arg.getType().cast<RankedTensorType>();\n-        auto yieldType =\n-            op->getOperand(yieldIdx).getType().dyn_cast<RankedTensorType>();\n-        if (!yieldType || argType.getEncoding() != yieldType.getEncoding())\n+    // Skip propagating through for op results for now.\n+    // TODO: enable this based on needs.\n+    if (currentValue.getDefiningOp<scf::ForOp>())\n+      return failure();\n+    slice.insert(currentValue);\n+    layout[currentValue] = encoding;\n+    if (auto *definingOp = currentValue.getDefiningOp()) {\n+      if (canFoldIntoConversion(definingOp, encoding))\n+        continue;\n+      for (Value operand : definingOp->getOperands()) {\n+        auto srcEncoding = inferSrcEncoding(definingOp, encoding);\n+        if (!srcEncoding)\n           return failure();\n+        if (slice.count(operand) == 0)\n+          queue.push_back({operand, *srcEncoding});\n       }\n+      continue;\n     }\n-  }\n-  return success();\n-}\n-\n-void rematerializeConversionChain(\n-    const llvm::MapVector<Value, Attribute> &toConvert,\n-    mlir::PatternRewriter &rewriter, SetVector<Operation *> &processed,\n-    IRMapping &mapping) {\n-  SmallVector<Value, 4> sortedValues;\n-  SetVector<Operation *> tmp;\n-  for (auto &item : toConvert) {\n-    Value v = item.first;\n-    if (v.getDefiningOp())\n-      tmp.insert(v.getDefiningOp());\n-    else\n-      sortedValues.push_back(v);\n-  }\n-  tmp = mlir::multiRootTopologicalSort(tmp);\n-  for (Operation *op : tmp)\n-    sortedValues.push_back(op->getResult(0));\n-\n-  for (Value currOperand : sortedValues) {\n-    Value origOperand = currOperand;\n-    // unpack information\n-    Attribute targetLayout = toConvert.lookup(currOperand);\n-    // rematerialize the operand if necessary\n-    Operation *currOperation = currOperand.getDefiningOp();\n-    if (processed.contains(currOperation)) {\n-      Operation *newOperation =\n-          cloneWithInferType(rewriter, currOperation, mapping);\n-      newOperation->moveAfter(currOperation);\n-      currOperation = newOperation;\n-      currOperand = currOperation->getResult(0);\n-    }\n-    // compute target type for the layout cast\n-    auto currType = currOperand.getType().cast<RankedTensorType>();\n-    auto newType = RankedTensorType::get(\n-        currType.getShape(), currType.getElementType(), targetLayout);\n-    auto newOperand = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-        currOperand.getLoc(), newType, currOperand);\n-    if (currOperation)\n-      newOperand->moveAfter(currOperation);\n-    else {\n-      Block *block = currOperand.cast<BlockArgument>().getOwner();\n-      newOperand->moveBefore(block, block->begin());\n+    auto blockArg = cast<BlockArgument>(currentValue);\n+    Block *block = blockArg.getOwner();\n+    Operation *parentOp = block->getParentOp();\n+    if (auto forOp = dyn_cast<scf::ForOp>(parentOp)) {\n+      OpOperand &initOperand = forOp.getOpOperandForRegionIterArg(blockArg);\n+      Value yieldOperand = forOp.getBody()->getTerminator()->getOperand(\n+          blockArg.getArgNumber() - forOp.getNumInductionVars());\n+      queue.push_back({initOperand.get(), encoding});\n+      queue.push_back({yieldOperand, encoding});\n+      continue;\n     }\n-    mapping.map(origOperand, newOperand);\n-  }\n-}\n-\n-LogicalResult canMoveOutOfLoop(BlockArgument arg,\n-                               SmallVector<Operation *> &cvts) {\n-  auto parentOp = arg.getOwner()->getParentOp();\n-  // Don't move if arg is defined in a while loop\n-  if (isa<scf::WhileOp>(parentOp))\n+    // TODO: add support for WhileOp and other region types.\n     return failure();\n-  // Skip if arg is not defined in scf.for\n-  if (!isa<scf::ForOp>(parentOp))\n-    return success();\n-  auto forOp = cast<scf::ForOp>(parentOp);\n-  // We only move `iterArg` out of the loop if\n-  // 1. There is no conversion\n-  // 2. There is only a single conversion\n-  // 3. Moving this conversion out of the loop will not generate any extra\n-  // non-removable conversion\n-  SetVector<RankedTensorType> cvtTypes;\n-  SetVector<Operation *> others;\n-  auto oldType = arg.getType().cast<RankedTensorType>();\n-  for (auto user : arg.getUsers()) {\n-    if (isa<triton::gpu::ConvertLayoutOp>(user)) {\n-      // Don't move if the conversion target is a dot operand or shared memory\n-      auto newType = user->getResults()[0].getType().cast<RankedTensorType>();\n-      if (oldType.getEncoding().isa<triton::gpu::SharedEncodingAttr>() &&\n-          newType.getEncoding().isa<triton::gpu::DotOperandEncodingAttr>()) {\n-        continue;\n-      }\n-      if (newType.getEncoding().isa<triton::gpu::SharedEncodingAttr>()) {\n-        if (newType.getEncoding()\n-                .cast<triton::gpu::SharedEncodingAttr>()\n-                .getVec() == 1)\n-          continue;\n-      }\n-      cvts.emplace_back(user);\n-      cvtTypes.insert(newType);\n-    } else\n-      others.insert(user);\n-  }\n-  // First condition\n-  if (cvts.empty())\n-    return success();\n-  if (cvtTypes.size() == 1) {\n-    // Third condition - part 1:\n-    // If the other or the cvt is in the different block, we cannot push the\n-    // conversion forward or backward\n-    for (auto *cvt : cvts) {\n-      if (cvt->getBlock() != forOp.getBody())\n-        return failure();\n-    }\n-    auto targetEncoding = cvtTypes.front().getEncoding();\n-    for (auto *other : others) {\n-      // Third condition - part 2:\n-      // If the other non-cvt op is in the different block, we cannot push the\n-      // conversion forward or backward\n-      if (other->getBlock() != forOp.getBody())\n-        return failure();\n-      // Third condition - part 3:\n-      // Check if we can directly use arg without conversion\n-      if (simulateForwardRematerializationInLoop(other, arg, targetEncoding)\n-              .failed())\n-        return failure();\n-    }\n-    return success();\n   }\n-  return failure();\n+  return success();\n }\n \n // TODO(thomas): this is duplicated with what is in GPUToLLVM\n@@ -700,4 +508,104 @@ void setRoleId(Operation *op, int roleId) {\n   op->setAttr(\"agent.mutex_role\", attr);\n }\n \n+namespace {\n+\n+/// Detect dead arguments in scf.for op by assuming all the values are dead and\n+/// propagate liveness property.\n+struct ForOpDeadArgElimination : public OpRewritePattern<scf::ForOp> {\n+  using OpRewritePattern<scf::ForOp>::OpRewritePattern;\n+\n+  LogicalResult matchAndRewrite(scf::ForOp forOp,\n+                                PatternRewriter &rewriter) const final {\n+    Block &block = *forOp.getBody();\n+    auto yieldOp = cast<scf::YieldOp>(block.getTerminator());\n+    // Assume that nothing is live at the beginning and mark values as live\n+    // based on uses.\n+    DenseSet<Value> aliveValues;\n+    SmallVector<Value> queue;\n+    // Helper to mark values as live and add them to the queue of value to\n+    // propagate if it is the first time we detect the value as live.\n+    auto markLive = [&](Value val) {\n+      if (!forOp->isAncestor(val.getParentRegion()->getParentOp()))\n+        return;\n+      if (aliveValues.insert(val).second)\n+        queue.push_back(val);\n+    };\n+    // Mark all yield operands as live if the associated forOp result has any\n+    // use.\n+    for (auto result : llvm::enumerate(forOp.getResults())) {\n+      if (!result.value().use_empty())\n+        markLive(yieldOp.getOperand(result.index()));\n+    }\n+    if (aliveValues.size() == forOp.getNumResults())\n+      return failure();\n+    // Operations with side-effects are always live. Mark all theirs operands as\n+    // live.\n+    block.walk([&](Operation *op) {\n+      if (!isa<scf::YieldOp, scf::ForOp>(op) && !wouldOpBeTriviallyDead(op)) {\n+        for (Value operand : op->getOperands())\n+          markLive(operand);\n+      }\n+    });\n+    // Propagate live property until reaching a fixed point.\n+    while (!queue.empty()) {\n+      Value value = queue.pop_back_val();\n+      if (auto nestedFor = value.getDefiningOp<scf::ForOp>()) {\n+        auto result = value.cast<OpResult>();\n+        OpOperand &forOperand = nestedFor.getOpOperandForResult(result);\n+        markLive(forOperand.get());\n+        auto nestedYieldOp =\n+            cast<scf::YieldOp>(nestedFor.getBody()->getTerminator());\n+        Value nestedYieldOperand =\n+            nestedYieldOp.getOperand(result.getResultNumber());\n+        markLive(nestedYieldOperand);\n+        continue;\n+      }\n+      if (Operation *def = value.getDefiningOp()) {\n+        for (Value operand : def->getOperands())\n+          markLive(operand);\n+        continue;\n+      }\n+      // If an argument block is live then the associated yield operand and\n+      // forOp operand are live.\n+      auto arg = value.cast<BlockArgument>();\n+      if (auto forOwner = dyn_cast<scf::ForOp>(arg.getOwner()->getParentOp())) {\n+        if (arg.getArgNumber() < forOwner.getNumInductionVars())\n+          continue;\n+        unsigned iterIdx = arg.getArgNumber() - forOwner.getNumInductionVars();\n+        Value yieldOperand =\n+            forOwner.getBody()->getTerminator()->getOperand(iterIdx);\n+        markLive(yieldOperand);\n+        markLive(forOwner.getIterOperands()[iterIdx]);\n+      }\n+    }\n+    SmallVector<unsigned> deadArg;\n+    for (auto yieldOperand : llvm::enumerate(yieldOp->getOperands())) {\n+      if (aliveValues.contains(yieldOperand.value()))\n+        continue;\n+      if (yieldOperand.value() == block.getArgument(yieldOperand.index() + 1))\n+        continue;\n+      deadArg.push_back(yieldOperand.index());\n+    }\n+    if (deadArg.empty())\n+      return failure();\n+    rewriter.updateRootInPlace(forOp, [&]() {\n+      // For simplicity we just change the dead yield operand to use the\n+      // associated argument and leave the operations and argument removal to\n+      // dead code elimination.\n+      for (unsigned deadArgIdx : deadArg) {\n+        BlockArgument arg = block.getArgument(deadArgIdx + 1);\n+        yieldOp.setOperand(deadArgIdx, arg);\n+      }\n+    });\n+    return success();\n+  }\n+};\n+\n+} // namespace\n+\n+void populateForOpDeadArgumentElimination(RewritePatternSet &patterns) {\n+  patterns.add<ForOpDeadArgElimination>(patterns.getContext());\n+}\n+\n } // namespace mlir"}, {"filename": "test/TritonGPU/combine.mlir", "status": "modified", "additions": 214, "deletions": 3, "changes": 217, "file_content_changes": "@@ -229,8 +229,10 @@ tt.func @loop(%arg0: !tt.ptr<f32>, %arg1: i32, %arg2: !tt.ptr<f32>, %arg3: i32,\n   // CHECK-NEXT: {{.*}} = tt.addptr {{.*}} : tensor<64x64x!tt.ptr<f32, 1>, [[$row_layout]]>, tensor<64x64xi32, [[$row_layout]]>\n   // CHECK-NEXT: scf.yield {{.*}} : tensor<64x64xf32, [[$row_layout]]>, tensor<64x64x!tt.ptr<f32, 1>, [[$row_layout]]>\n   // CHECK-NEXT: }\n-  // CHECK-NEXT: {{.*}} = triton_gpu.convert_layout [[loop_ret]]#0 : (tensor<64x64xf32, [[$row_layout]]>) -> tensor<64x64xf32, [[$col_layout_novec]]>\n   // CHECK-NOT: triton_gpu.convert_layout\n+  //     CHECK: {{.*}} = triton_gpu.convert_layout [[loop_ret]]#0 : (tensor<64x64xf32, [[$row_layout]]>) -> tensor<64x64xf32, [[$col_layout_novec]]>\n+  // CHECK-NOT: triton_gpu.convert_layout\n+  //    CHECK:  tt.return\n   %cst = arith.constant dense<true> : tensor<64x64xi1, #blocked1>\n   %cst_0 = arith.constant dense<64> : tensor<64x64xi32, #blocked1>\n   %c1 = arith.constant 1 : index\n@@ -1125,14 +1127,14 @@ module attributes {\"triton_gpu.num-warps\" = 2 : i32} {\n \n // -----\n \n-// Check if the SimplifyReduceCvt handles convert_layout lifted from the for loop.\n // CHECK-LABEL: reduce_cvt2\n // Match the reduction\n // CHECK: tt.reduce\n // CHECK-SAME: axis = 1\n // CHECK: (tensor<1x256xf32, #blocked>) -> tensor<1xf32, #triton_gpu.slice<{dim = 1, parent = #blocked}>>\n-// CHECK-NEXT: triton_gpu.convert_layout\n+// CHECK: triton_gpu.convert_layout\n // CHECK-NOT: triton_gpu.convert_layout\n+// CHECK: tt.return\n #blocked = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [1, 4], order = [0, 1], CTAsPerCGA = [1, 1], CTASplitNum = [1, 1], CTAOrder = [1, 0]}>\n #blocked1 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>\n #blocked2 = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1], CTAsPerCGA = [1, 1], CTASplitNum = [1, 1], CTAOrder = [1, 0]}>\n@@ -1347,6 +1349,7 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32, \"triton_gpu.threads-per-war\n // Check if MoveConvertOutOfLoop hangs because of adding additional conversions\n // CHECK-LABEL: loop_print\n // CHECK-NOT: triton_gpu.convert_layout\n+//     CHECK: tt.return\n #blocked = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [1, 4], order = [0, 1]}>\n #blocked1 = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}>\n #blocked2 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>\n@@ -1502,3 +1505,211 @@ module attributes {\"triton_gpu.num-warps\" = 4 : i32, \"triton_gpu.threads-per-war\n     tt.return\n   }\n }\n+\n+\n+// -----\n+\n+// Check that we don't have extra convert for flash attention IR.\n+#blocked = #triton_gpu.blocked<{sizePerThread = [4, 4], threadsPerWarp = [2, 16], warpsPerCTA = [4, 1], order = [1, 0], CTAsPerCGA = [1, 1], CTASplitNum = [1, 1], CTAOrder = [1, 0]}>\n+#blocked1 = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>\n+#blocked2 = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1], CTAsPerCGA = [1, 1], CTASplitNum = [1, 1], CTAOrder = [0, 1]}>\n+#blocked3 = #triton_gpu.blocked<{sizePerThread = [1, 8], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0], CTAsPerCGA = [1, 1], CTASplitNum = [1, 1], CTAOrder = [0, 1]}>\n+#blocked4 = #triton_gpu.blocked<{sizePerThread = [1, 1, 8], threadsPerWarp = [4, 1, 8], warpsPerCTA = [4, 1, 1], order = [1, 2, 0], CTAsPerCGA = [1, 1, 1], CTASplitNum = [1, 1, 1], CTAOrder = [1, 0, 2]}>\n+#blocked5 = #triton_gpu.blocked<{sizePerThread = [1, 1, 8], threadsPerWarp = [1, 4, 8], warpsPerCTA = [1, 4, 1], order = [0, 2, 1], CTAsPerCGA = [1, 1, 1], CTASplitNum = [1, 1, 1], CTAOrder = [0, 1, 2]}>\n+#blocked6 = #triton_gpu.blocked<{sizePerThread = [8, 1], threadsPerWarp = [8, 4], warpsPerCTA = [1, 4], order = [0, 1], CTAsPerCGA = [1, 1], CTASplitNum = [1, 1], CTAOrder = [0, 1]}>\n+#blocked7 = #triton_gpu.blocked<{sizePerThread = [8, 1, 1], threadsPerWarp = [8, 1, 4], warpsPerCTA = [1, 1, 4], order = [1, 0, 2], CTAsPerCGA = [1, 1, 1], CTASplitNum = [1, 1, 1], CTAOrder = [1, 0, 2]}>\n+#blocked8 = #triton_gpu.blocked<{sizePerThread = [1, 8, 1], threadsPerWarp = [1, 8, 4], warpsPerCTA = [1, 1, 4], order = [0, 1, 2], CTAsPerCGA = [1, 1, 1], CTASplitNum = [1, 1, 1], CTAOrder = [0, 1, 2]}>\n+#blocked9 = #triton_gpu.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1], CTAsPerCGA = [1, 1], CTASplitNum = [1, 1], CTAOrder = [1, 0]}>\n+module attributes {\"triton_gpu.compute-capability\" = 90 : i32, \"triton_gpu.num-ctas\" = 1 : i32, \"triton_gpu.num-warps\" = 4 : i32, \"triton_gpu.threads-per-warp\" = 32 : i32} {\n+  tt.func public @attention_fw(%arg0: !tt.ptr<f16, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f16, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f16, 1> {tt.divisibility = 16 : i32}, %arg3: f32, %arg4: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg5: !tt.ptr<f16, 1> {tt.divisibility = 16 : i32}, %arg6: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg7: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg8: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg9: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg10: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg11: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg12: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg13: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg14: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg15: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg16: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg17: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg18: i32, %arg19: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg20: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}, %arg21: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 8 : i32}) attributes {noinline = false} {\n+    %c0_i64 = arith.constant 0 : i64\n+    %c64_i64 = arith.constant 64 : i64\n+    %cst = arith.constant dense<0.000000e+00> : tensor<128x64xf16, #blocked>\n+    %cst_0 = arith.constant dense<0xFF800000> : tensor<128xf32, #blocked1>\n+    %cst_1 = arith.constant dense<0.000000e+00> : tensor<128xf32, #blocked1>\n+    %c64_i32 = arith.constant 64 : i32\n+    %c0_i32 = arith.constant 0 : i32\n+    %cst_2 = arith.constant dense<0.000000e+00> : tensor<128x64xf32, #blocked2>\n+    %cst_3 = arith.constant 1.44269502 : f32\n+    %c128_i32 = arith.constant 128 : i32\n+    %0 = tt.get_program_id x : i32\n+    %1 = tt.get_program_id y : i32\n+    %2 = arith.muli %1, %arg7 : i32\n+    %3 = arith.muli %1, %arg10 : i32\n+    %4 = tt.addptr %arg0, %2 : !tt.ptr<f16, 1>, i32\n+    %5 = arith.muli %0, %c128_i32 : i32\n+    %6 = arith.extsi %arg8 : i32 to i64\n+    %7 = arith.extsi %5 : i32 to i64\n+    %8 = tt.addptr %arg1, %3 : !tt.ptr<f16, 1>, i32\n+    %9 = arith.addi %arg20, %arg21 : i32\n+    %10 = arith.extsi %arg11 : i32 to i64\n+    %11 = tt.addptr %arg2, %3 : !tt.ptr<f16, 1>, i32\n+    %12 = arith.extsi %arg14 : i32 to i64\n+    %13 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32, #blocked1>\n+    %14 = tt.splat %5 : (i32) -> tensor<128xi32, #blocked1>\n+    %15 = arith.addi %14, %13 : tensor<128xi32, #blocked1>\n+    %16 = arith.mulf %arg3, %cst_3 : f32\n+    %17 = tt.splat %4 : (!tt.ptr<f16, 1>) -> tensor<128x64x!tt.ptr<f16, 1>, #blocked3>\n+    %18 = tt.splat %7 : (i64) -> tensor<128xi64, #blocked3>\n+    %19 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32, #blocked3>\n+    %20 = arith.extsi %19 : tensor<128xi32, #blocked3> to tensor<128xi64, #blocked3>\n+    %21 = arith.addi %18, %20 : tensor<128xi64, #blocked3>\n+    %22 = triton_gpu.convert_layout %21 : (tensor<128xi64, #blocked3>) -> tensor<128xi64, #triton_gpu.slice<{dim = 1, parent = #blocked4}>>\n+    %23 = tt.expand_dims %22 {axis = 1 : i32} : (tensor<128xi64, #triton_gpu.slice<{dim = 1, parent = #blocked4}>>) -> tensor<128x1xi64, #blocked4>\n+    %24 = tt.splat %6 : (i64) -> tensor<128x1xi64, #blocked4>\n+    %25 = arith.muli %23, %24 : tensor<128x1xi64, #blocked4>\n+    %26 = tt.broadcast %25 : (tensor<128x1xi64, #blocked4>) -> tensor<128x64xi64, #blocked4>\n+    %27 = triton_gpu.convert_layout %26 : (tensor<128x64xi64, #blocked4>) -> tensor<128x64xi64, #blocked3>\n+    %28 = tt.addptr %17, %27 : tensor<128x64x!tt.ptr<f16, 1>, #blocked3>, tensor<128x64xi64, #blocked3>\n+    %29 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32, #blocked3>\n+    %30 = arith.extsi %29 : tensor<64xi32, #blocked3> to tensor<64xi64, #blocked3>\n+    %31 = triton_gpu.convert_layout %30 : (tensor<64xi64, #blocked3>) -> tensor<64xi64, #triton_gpu.slice<{dim = 0, parent = #blocked5}>>\n+    %32 = tt.expand_dims %31 {axis = 0 : i32} : (tensor<64xi64, #triton_gpu.slice<{dim = 0, parent = #blocked5}>>) -> tensor<1x64xi64, #blocked5>\n+    %33 = tt.broadcast %32 : (tensor<1x64xi64, #blocked5>) -> tensor<128x64xi64, #blocked5>\n+    %34 = triton_gpu.convert_layout %33 : (tensor<128x64xi64, #blocked5>) -> tensor<128x64xi64, #blocked3>\n+    %35 = tt.addptr %28, %34 : tensor<128x64x!tt.ptr<f16, 1>, #blocked3>, tensor<128x64xi64, #blocked3>\n+    %36 = tt.load %35 {boundaryCheck = array<i32>, cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<128x64xf16, #blocked3>\n+    %37 = triton_gpu.convert_layout %36 : (tensor<128x64xf16, #blocked3>) -> tensor<128x64xf16, #blocked2>\n+    %38 = tt.splat %16 : (f32) -> tensor<128x64xf32, #blocked2>\n+    %39 = arith.extf %37 : tensor<128x64xf16, #blocked2> to tensor<128x64xf32, #blocked2>\n+    %40 = arith.mulf %39, %38 : tensor<128x64xf32, #blocked2>\n+    %41 = arith.truncf %40 : tensor<128x64xf32, #blocked2> to tensor<128x64xf16, #blocked2>\n+// CHECK-NOT: triton_gpu.convert_layout\n+//     CHECK: scf.for\n+// CHECK-NOT:   triton_gpu.convert_layout\n+//     CHECK:   triton_gpu.convert_layout %{{.*}} #triton_gpu.dot_op\n+//     CHECK:   triton_gpu.convert_layout %{{.*}} #triton_gpu.dot_op\n+// CHECK-NOT:   triton_gpu.convert_layout\n+//     CHECK:   tt.dot\n+// CHECK-NOT:   triton_gpu.convert_layout\n+//     CHECK:   triton_gpu.convert_layout %{{.*}} #triton_gpu.dot_op\n+//     CHECK:   triton_gpu.convert_layout %{{.*}} #triton_gpu.dot_op\n+// CHECK-NOT:   triton_gpu.convert_layout\n+//     CHECK:   tt.dot\n+//     CHECK:   scf.yield\n+    %42:5 = scf.for %arg22 = %c0_i32 to %9 step %c64_i32 iter_args(%arg23 = %cst_2, %arg24 = %cst_1, %arg25 = %cst_0, %arg26 = %c0_i64, %arg27 = %c0_i64) -> (tensor<128x64xf32, #blocked2>, tensor<128xf32, #blocked1>, tensor<128xf32, #blocked1>, i64, i64)  : i32 {\n+      %78 = tt.splat %8 : (!tt.ptr<f16, 1>) -> tensor<64x64x!tt.ptr<f16, 1>, #blocked6>\n+      %79 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32, #blocked6>\n+      %80 = arith.extsi %79 : tensor<64xi32, #blocked6> to tensor<64xi64, #blocked6>\n+      %81 = triton_gpu.convert_layout %80 : (tensor<64xi64, #blocked6>) -> tensor<64xi64, #triton_gpu.slice<{dim = 1, parent = #blocked7}>>\n+      %82 = tt.expand_dims %81 {axis = 1 : i32} : (tensor<64xi64, #triton_gpu.slice<{dim = 1, parent = #blocked7}>>) -> tensor<64x1xi64, #blocked7>\n+      %83 = tt.broadcast %82 : (tensor<64x1xi64, #blocked7>) -> tensor<64x64xi64, #blocked7>\n+      %84 = triton_gpu.convert_layout %83 : (tensor<64x64xi64, #blocked7>) -> tensor<64x64xi64, #blocked6>\n+      %85 = tt.addptr %78, %84 : tensor<64x64x!tt.ptr<f16, 1>, #blocked6>, tensor<64x64xi64, #blocked6>\n+      %86 = tt.splat %arg26 : (i64) -> tensor<64xi64, #blocked6>\n+      %87 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32, #blocked6>\n+      %88 = arith.extsi %87 : tensor<64xi32, #blocked6> to tensor<64xi64, #blocked6>\n+      %89 = arith.addi %86, %88 : tensor<64xi64, #blocked6>\n+      %90 = triton_gpu.convert_layout %89 : (tensor<64xi64, #blocked6>) -> tensor<64xi64, #triton_gpu.slice<{dim = 0, parent = #blocked8}>>\n+      %91 = tt.expand_dims %90 {axis = 0 : i32} : (tensor<64xi64, #triton_gpu.slice<{dim = 0, parent = #blocked8}>>) -> tensor<1x64xi64, #blocked8>\n+      %92 = tt.splat %10 : (i64) -> tensor<1x64xi64, #blocked8>\n+      %93 = arith.muli %91, %92 : tensor<1x64xi64, #blocked8>\n+      %94 = tt.broadcast %93 : (tensor<1x64xi64, #blocked8>) -> tensor<64x64xi64, #blocked8>\n+      %95 = triton_gpu.convert_layout %94 : (tensor<64x64xi64, #blocked8>) -> tensor<64x64xi64, #blocked6>\n+      %96 = tt.addptr %85, %95 : tensor<64x64x!tt.ptr<f16, 1>, #blocked6>, tensor<64x64xi64, #blocked6>\n+      %97 = tt.load %96 {boundaryCheck = array<i32>, cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64x64xf16, #blocked6>\n+      %98 = tt.splat %11 : (!tt.ptr<f16, 1>) -> tensor<64x64x!tt.ptr<f16, 1>, #blocked3>\n+      %99 = tt.splat %arg27 : (i64) -> tensor<64xi64, #blocked3>\n+      %100 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32, #blocked3>\n+      %101 = arith.extsi %100 : tensor<64xi32, #blocked3> to tensor<64xi64, #blocked3>\n+      %102 = arith.addi %99, %101 : tensor<64xi64, #blocked3>\n+      %103 = triton_gpu.convert_layout %102 : (tensor<64xi64, #blocked3>) -> tensor<64xi64, #triton_gpu.slice<{dim = 1, parent = #blocked4}>>\n+      %104 = tt.expand_dims %103 {axis = 1 : i32} : (tensor<64xi64, #triton_gpu.slice<{dim = 1, parent = #blocked4}>>) -> tensor<64x1xi64, #blocked4>\n+      %105 = tt.splat %12 : (i64) -> tensor<64x1xi64, #blocked4>\n+      %106 = arith.muli %104, %105 : tensor<64x1xi64, #blocked4>\n+      %107 = tt.broadcast %106 : (tensor<64x1xi64, #blocked4>) -> tensor<64x64xi64, #blocked4>\n+      %108 = triton_gpu.convert_layout %107 : (tensor<64x64xi64, #blocked4>) -> tensor<64x64xi64, #blocked3>\n+      %109 = tt.addptr %98, %108 : tensor<64x64x!tt.ptr<f16, 1>, #blocked3>, tensor<64x64xi64, #blocked3>\n+      %110 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32, #blocked3>\n+      %111 = arith.extsi %110 : tensor<64xi32, #blocked3> to tensor<64xi64, #blocked3>\n+      %112 = triton_gpu.convert_layout %111 : (tensor<64xi64, #blocked3>) -> tensor<64xi64, #triton_gpu.slice<{dim = 0, parent = #blocked5}>>\n+      %113 = tt.expand_dims %112 {axis = 0 : i32} : (tensor<64xi64, #triton_gpu.slice<{dim = 0, parent = #blocked5}>>) -> tensor<1x64xi64, #blocked5>\n+      %114 = tt.broadcast %113 : (tensor<1x64xi64, #blocked5>) -> tensor<64x64xi64, #blocked5>\n+      %115 = triton_gpu.convert_layout %114 : (tensor<64x64xi64, #blocked5>) -> tensor<64x64xi64, #blocked3>\n+      %116 = tt.addptr %109, %115 : tensor<64x64x!tt.ptr<f16, 1>, #blocked3>, tensor<64x64xi64, #blocked3>\n+      %117 = tt.load %116 {boundaryCheck = array<i32>, cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64x64xf16, #blocked3>\n+      %118 = triton_gpu.convert_layout %41 : (tensor<128x64xf16, #blocked2>) -> tensor<128x64xf16, #triton_gpu.dot_op<{opIdx = 0, parent = #blocked}>>\n+      %119 = triton_gpu.convert_layout %97 : (tensor<64x64xf16, #blocked6>) -> tensor<64x64xf16, #triton_gpu.dot_op<{opIdx = 1, parent = #blocked}>>\n+      %120 = tt.dot %118, %119, %cst {allowTF32 = true} : tensor<128x64xf16, #triton_gpu.dot_op<{opIdx = 0, parent = #blocked}>> * tensor<64x64xf16, #triton_gpu.dot_op<{opIdx = 1, parent = #blocked}>> -> tensor<128x64xf16, #blocked>\n+      %121 = triton_gpu.convert_layout %120 : (tensor<128x64xf16, #blocked>) -> tensor<128x64xf16, #blocked2>\n+      %122 = arith.extf %121 : tensor<128x64xf16, #blocked2> to tensor<128x64xf32, #blocked2>\n+      %123 = \"tt.reduce\"(%122) <{axis = 1 : i32}> ({\n+      ^bb0(%arg28: f32, %arg29: f32):\n+        %153 = arith.maxf %arg28, %arg29 : f32\n+        tt.reduce.return %153 : f32\n+      }) : (tensor<128x64xf32, #blocked2>) -> tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked2}>>\n+      %124 = triton_gpu.convert_layout %123 : (tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked2}>>) -> tensor<128xf32, #blocked1>\n+      %125 = arith.maxf %arg25, %124 : tensor<128xf32, #blocked1>\n+      %126 = arith.subf %arg25, %125 : tensor<128xf32, #blocked1>\n+      %127 = tt.extern_elementwise %126 {pure = true, libname = \"libdevice\", libpath = \"/root/.pyenv/versions/3.9.9/lib/python3.9/site-packages/triton/language/../third_party/cuda/lib/libdevice.10.bc\", symbol = \"__nv_exp2f\"} : (tensor<128xf32, #blocked1>) -> tensor<128xf32, #blocked1>\n+      %128 = triton_gpu.convert_layout %125 : (tensor<128xf32, #blocked1>) -> tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked9}>>\n+      %129 = tt.expand_dims %128 {axis = 1 : i32} : (tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked9}>>) -> tensor<128x1xf32, #blocked9>\n+      %130 = triton_gpu.convert_layout %129 : (tensor<128x1xf32, #blocked9>) -> tensor<128x1xf32, #blocked2>\n+      %131 = tt.broadcast %130 : (tensor<128x1xf32, #blocked2>) -> tensor<128x64xf32, #blocked2>\n+      %132 = arith.subf %122, %131 : tensor<128x64xf32, #blocked2>\n+      %133 = tt.extern_elementwise %132 {pure = true, libname = \"libdevice\", libpath = \"/root/.pyenv/versions/3.9.9/lib/python3.9/site-packages/triton/language/../third_party/cuda/lib/libdevice.10.bc\", symbol = \"__nv_exp2f\"} : (tensor<128x64xf32, #blocked2>) -> tensor<128x64xf32, #blocked2>\n+      %134 = arith.mulf %arg24, %cst_1 : tensor<128xf32, #blocked1>\n+      %135 = arith.addf %134, %127 : tensor<128xf32, #blocked1>\n+      %136 = triton_gpu.convert_layout %135 : (tensor<128xf32, #blocked1>) -> tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked9}>>\n+      %137 = tt.expand_dims %136 {axis = 1 : i32} : (tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked9}>>) -> tensor<128x1xf32, #blocked9>\n+      %138 = triton_gpu.convert_layout %137 : (tensor<128x1xf32, #blocked9>) -> tensor<128x1xf32, #blocked2>\n+      %139 = tt.broadcast %138 : (tensor<128x1xf32, #blocked2>) -> tensor<128x64xf32, #blocked2>\n+      %140 = arith.mulf %arg23, %139 : tensor<128x64xf32, #blocked2>\n+      %141 = arith.truncf %133 : tensor<128x64xf32, #blocked2> to tensor<128x64xf16, #blocked2>\n+      %142 = triton_gpu.convert_layout %141 : (tensor<128x64xf16, #blocked2>) -> tensor<128x64xf16, #triton_gpu.dot_op<{opIdx = 0, parent = #blocked}>>\n+      %143 = triton_gpu.convert_layout %117 : (tensor<64x64xf16, #blocked3>) -> tensor<64x64xf16, #triton_gpu.dot_op<{opIdx = 1, parent = #blocked}>>\n+      %144 = triton_gpu.convert_layout %140 : (tensor<128x64xf32, #blocked2>) -> tensor<128x64xf32, #blocked>\n+      %145 = tt.dot %142, %143, %144 {allowTF32 = true} : tensor<128x64xf16, #triton_gpu.dot_op<{opIdx = 0, parent = #blocked}>> * tensor<64x64xf16, #triton_gpu.dot_op<{opIdx = 1, parent = #blocked}>> -> tensor<128x64xf32, #blocked>\n+      %146 = triton_gpu.convert_layout %145 : (tensor<128x64xf32, #blocked>) -> tensor<128x64xf32, #blocked2>\n+      %147 = arith.mulf %arg24, %127 : tensor<128xf32, #blocked1>\n+      %148 = \"tt.reduce\"(%133) <{axis = 1 : i32}> ({\n+      ^bb0(%arg28: f32, %arg29: f32):\n+        %153 = arith.addf %arg28, %arg29 : f32\n+        tt.reduce.return %153 : f32\n+      }) : (tensor<128x64xf32, #blocked2>) -> tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked2}>>\n+      %149 = triton_gpu.convert_layout %148 : (tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked2}>>) -> tensor<128xf32, #blocked1>\n+      %150 = arith.addf %147, %149 : tensor<128xf32, #blocked1>\n+      %151 = arith.addi %arg26, %c64_i64 : i64\n+      %152 = arith.addi %arg27, %c64_i64 : i64\n+      scf.yield %146, %150, %125, %151, %152 : tensor<128x64xf32, #blocked2>, tensor<128xf32, #blocked1>, tensor<128xf32, #blocked1>, i64, i64\n+    }\n+    %43 = triton_gpu.convert_layout %42#1 : (tensor<128xf32, #blocked1>) -> tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked9}>>\n+    %44 = tt.expand_dims %43 {axis = 1 : i32} : (tensor<128xf32, #triton_gpu.slice<{dim = 1, parent = #blocked9}>>) -> tensor<128x1xf32, #blocked9>\n+    %45 = triton_gpu.convert_layout %44 : (tensor<128x1xf32, #blocked9>) -> tensor<128x1xf32, #blocked2>\n+    %46 = tt.broadcast %45 : (tensor<128x1xf32, #blocked2>) -> tensor<128x64xf32, #blocked2>\n+    %47 = arith.divf %42#0, %46 : tensor<128x64xf32, #blocked2>\n+    %48 = arith.muli %1, %arg20 : i32\n+    %49 = tt.addptr %arg4, %48 : !tt.ptr<f32, 1>, i32\n+    %50 = tt.splat %49 : (!tt.ptr<f32, 1>) -> tensor<128x!tt.ptr<f32, 1>, #blocked1>\n+    %51 = tt.addptr %50, %15 : tensor<128x!tt.ptr<f32, 1>, #blocked1>, tensor<128xi32, #blocked1>\n+    %52 = tt.extern_elementwise %42#1 {pure = true, libname = \"libdevice\", libpath = \"/root/.pyenv/versions/3.9.9/lib/python3.9/site-packages/triton/language/../third_party/cuda/lib/libdevice.10.bc\", symbol = \"__nv_log2f\"} : (tensor<128xf32, #blocked1>) -> tensor<128xf32, #blocked1>\n+    %53 = arith.addf %42#2, %52 : tensor<128xf32, #blocked1>\n+    tt.store %51, %53 {cache = 1 : i32, evict = 1 : i32} : tensor<128xf32, #blocked1>\n+    %54 = tt.addptr %arg5, %2 : !tt.ptr<f16, 1>, i32\n+    %55 = arith.extsi %arg17 : i32 to i64\n+    %56 = arith.extsi %5 : i32 to i64\n+    %57 = arith.truncf %47 : tensor<128x64xf32, #blocked2> to tensor<128x64xf16, #blocked2>\n+    %58 = triton_gpu.convert_layout %57 : (tensor<128x64xf16, #blocked2>) -> tensor<128x64xf16, #blocked3>\n+    %59 = tt.splat %54 : (!tt.ptr<f16, 1>) -> tensor<128x64x!tt.ptr<f16, 1>, #blocked3>\n+    %60 = tt.splat %56 : (i64) -> tensor<128xi64, #blocked3>\n+    %61 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32, #blocked3>\n+    %62 = arith.extsi %61 : tensor<128xi32, #blocked3> to tensor<128xi64, #blocked3>\n+    %63 = arith.addi %60, %62 : tensor<128xi64, #blocked3>\n+    %64 = triton_gpu.convert_layout %63 : (tensor<128xi64, #blocked3>) -> tensor<128xi64, #triton_gpu.slice<{dim = 1, parent = #blocked4}>>\n+    %65 = tt.expand_dims %64 {axis = 1 : i32} : (tensor<128xi64, #triton_gpu.slice<{dim = 1, parent = #blocked4}>>) -> tensor<128x1xi64, #blocked4>\n+    %66 = tt.splat %55 : (i64) -> tensor<128x1xi64, #blocked4>\n+    %67 = arith.muli %65, %66 : tensor<128x1xi64, #blocked4>\n+    %68 = tt.broadcast %67 : (tensor<128x1xi64, #blocked4>) -> tensor<128x64xi64, #blocked4>\n+    %69 = triton_gpu.convert_layout %68 : (tensor<128x64xi64, #blocked4>) -> tensor<128x64xi64, #blocked3>\n+    %70 = tt.addptr %59, %69 : tensor<128x64x!tt.ptr<f16, 1>, #blocked3>, tensor<128x64xi64, #blocked3>\n+    %71 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32, #blocked3>\n+    %72 = arith.extsi %71 : tensor<64xi32, #blocked3> to tensor<64xi64, #blocked3>\n+    %73 = triton_gpu.convert_layout %72 : (tensor<64xi64, #blocked3>) -> tensor<64xi64, #triton_gpu.slice<{dim = 0, parent = #blocked5}>>\n+    %74 = tt.expand_dims %73 {axis = 0 : i32} : (tensor<64xi64, #triton_gpu.slice<{dim = 0, parent = #blocked5}>>) -> tensor<1x64xi64, #blocked5>\n+    %75 = tt.broadcast %74 : (tensor<1x64xi64, #blocked5>) -> tensor<128x64xi64, #blocked5>\n+    %76 = triton_gpu.convert_layout %75 : (tensor<128x64xi64, #blocked5>) -> tensor<128x64xi64, #blocked3>\n+    %77 = tt.addptr %70, %76 : tensor<128x64x!tt.ptr<f16, 1>, #blocked3>, tensor<128x64xi64, #blocked3>\n+    tt.store %77, %58 {cache = 1 : i32, evict = 1 : i32} : tensor<128x64xf16, #blocked3>\n+    tt.return\n+  }\n+}"}, {"filename": "test/TritonGPU/dot-operands.mlir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,4 +1,4 @@\n-// RUN: triton-opt %s -split-input-file -tritongpu-optimize-dot-operands -tritongpu-remove-layout-conversions -canonicalize | FileCheck %s\n+// RUN: triton-opt %s -split-input-file -tritongpu-optimize-dot-operands -canonicalize | FileCheck %s\n \n #Cv2 = #triton_gpu.mma<{versionMajor = 2, warpsPerCTA = [4, 1]}>\n #Av2k1 = #triton_gpu.dot_op<{opIdx = 0, parent = #Cv2, kWidth=1}>"}]