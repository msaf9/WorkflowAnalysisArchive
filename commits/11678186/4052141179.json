[{"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 121, "deletions": 62, "changes": 183, "file_content_changes": "@@ -34,6 +34,10 @@ static int64_t gcd(int64_t a, int64_t b) {\n   return gcdImpl(a, b, &x, &y);\n }\n \n+static constexpr int log2Int(int64_t num) {\n+  return (num > 1) ? 1 + log2Int(num / 2) : 0;\n+}\n+\n //===----------------------------------------------------------------------===//\n // AxisInfo\n //===----------------------------------------------------------------------===//\n@@ -174,7 +178,7 @@ class ConstantOpAxisInfoVisitor final\n };\n \n template <typename OpTy>\n-class AddOpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n+class AddSubOpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n public:\n   using BinaryOpVisitorImpl<OpTy>::BinaryOpVisitorImpl;\n \n@@ -203,42 +207,13 @@ class AddOpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n                                           const AxisInfo &rhs) override {\n     if (lhs.getConstantValue().has_value() &&\n         rhs.getConstantValue().has_value())\n-      return {lhs.getConstantValue().value() + rhs.getConstantValue().value()};\n-    return {};\n-  }\n-};\n-\n-template <typename OpTy>\n-class SubOpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n-public:\n-  using BinaryOpVisitorImpl<OpTy>::BinaryOpVisitorImpl;\n-\n-private:\n-  int64_t getContiguity(OpTy op, const AxisInfo &lhs, const AxisInfo &rhs,\n-                        int dim) override {\n-    return std::max(gcd(lhs.getConstancy(dim), rhs.getContiguity(dim)),\n-                    gcd(lhs.getContiguity(dim), rhs.getConstancy(dim)));\n-  }\n-\n-  int64_t getDivisibility(OpTy op, const AxisInfo &lhs, const AxisInfo &rhs,\n-                          int dim) override {\n-    // lhs = k * d_lhs = k * k' * gcd(d_lhs, d_rhs)\n-    // rhs = p * d_rhs = p * p' * gcd(d_lhs, d_rhs)\n-    // lhs + rhs = k * d_lhs + p * d_rhs = (k * d_lhs + p * d_rhs) *\n-    // gcd(d_lhs, d_rhs)\n-    return gcd(lhs.getDivisibility(dim), rhs.getDivisibility(dim));\n-  }\n-\n-  int64_t getConstancy(OpTy op, const AxisInfo &lhs, const AxisInfo &rhs,\n-                       int dim) override {\n-    return gcd(lhs.getConstancy(dim), rhs.getConstancy(dim));\n-  }\n-\n-  std::optional<int64_t> getConstantValue(OpTy op, const AxisInfo &lhs,\n-                                          const AxisInfo &rhs) override {\n-    if (lhs.getConstantValue().has_value() &&\n-        rhs.getConstantValue().has_value())\n-      return {lhs.getConstantValue().value() - rhs.getConstantValue().value()};\n+      if constexpr (std::is_same_v<OpTy, arith::AddIOp> ||\n+                    std::is_same_v<OpTy, triton::AddPtrOp>)\n+        return {lhs.getConstantValue().value() +\n+                rhs.getConstantValue().value()};\n+      else\n+        return {lhs.getConstantValue().value() -\n+                rhs.getConstantValue().value()};\n     return {};\n   }\n };\n@@ -645,63 +620,143 @@ class SelectOpAxisInfoVisitor final : public AxisInfoVisitorImpl<OpTy> {\n   }\n };\n \n-class AndIOpAxisInfoVisitor final : public BinaryOpVisitorImpl<arith::AndIOp> {\n+template <typename OpTy>\n+class LogicalOpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n public:\n-  using BinaryOpVisitorImpl<arith::AndIOp>::BinaryOpVisitorImpl;\n+  using BinaryOpVisitorImpl<OpTy>::BinaryOpVisitorImpl;\n \n private:\n-  int64_t getConstancy(arith::AndIOp op, const AxisInfo &lhs,\n-                       const AxisInfo &rhs, int dim) override {\n+  int64_t getConstancy(OpTy op, const AxisInfo &lhs, const AxisInfo &rhs,\n+                       int dim) override {\n     return gcd(lhs.getConstancy(dim), rhs.getConstancy(dim));\n   }\n \n-  std::optional<int64_t> getConstantValue(arith::AndIOp op, const AxisInfo &lhs,\n+  std::optional<int64_t> getConstantValue(OpTy op, const AxisInfo &lhs,\n                                           const AxisInfo &rhs) override {\n     if (lhs.getConstantValue().has_value() &&\n         rhs.getConstantValue().has_value())\n-      return {lhs.getConstantValue().value() & rhs.getConstantValue().value()};\n+      if constexpr (std::is_same<OpTy, arith::AndIOp>::value)\n+        return {lhs.getConstantValue().value() &\n+                rhs.getConstantValue().value()};\n+      else if constexpr (std::is_same<OpTy, arith::OrIOp>::value)\n+        return {lhs.getConstantValue().value() |\n+                rhs.getConstantValue().value()};\n+      else if constexpr (std::is_same<OpTy, arith::XOrIOp>::value)\n+        return {lhs.getConstantValue().value() ^\n+                rhs.getConstantValue().value()};\n     return {};\n   }\n };\n \n-class OrIOpAxisInfoVisitor final : public BinaryOpVisitorImpl<arith::OrIOp> {\n+class ShLIOpAxisInfoVisitor final : public BinaryOpVisitorImpl<arith::ShLIOp> {\n public:\n-  using BinaryOpVisitorImpl<arith::OrIOp>::BinaryOpVisitorImpl;\n+  using BinaryOpVisitorImpl<arith::ShLIOp>::BinaryOpVisitorImpl;\n \n private:\n-  int64_t getConstancy(arith::OrIOp op, const AxisInfo &lhs,\n+  int64_t getContiguity(arith::ShLIOp op, const AxisInfo &lhs,\n+                        const AxisInfo &rhs, int dim) override {\n+    if (rhs.getConstantValue().has_value() &&\n+        rhs.getConstantValue().value() == 0)\n+      return lhs.getContiguity(dim);\n+    else\n+      return 1;\n+  }\n+\n+  int64_t getDivisibility(arith::ShLIOp op, const AxisInfo &lhs,\n+                          const AxisInfo &rhs, int dim) override {\n+    auto shift = rhs.getConstantValue().has_value()\n+                     ? rhs.getConstantValue().value()\n+                     : rhs.getDivisibility(dim);\n+    auto numBits = log2Int(lhs.getDivisibility(dim));\n+    auto maxBits = log2Int(highestPowOf2Divisor<int64_t>(0));\n+    // Make sure the return value doesn't exceed highestPowOf2Divisor<int64>(0)\n+    if (shift + numBits > maxBits)\n+      return highestPowOf2Divisor<int64_t>(0);\n+    return lhs.getDivisibility(dim) << shift;\n+  }\n+\n+  int64_t getConstancy(arith::ShLIOp op, const AxisInfo &lhs,\n                        const AxisInfo &rhs, int dim) override {\n     return gcd(lhs.getConstancy(dim), rhs.getConstancy(dim));\n   }\n \n-  std::optional<int64_t> getConstantValue(arith::OrIOp op, const AxisInfo &lhs,\n+  std::optional<int64_t> getConstantValue(arith::ShLIOp op, const AxisInfo &lhs,\n                                           const AxisInfo &rhs) override {\n     if (lhs.getConstantValue().has_value() &&\n         rhs.getConstantValue().has_value())\n-      return {lhs.getConstantValue().value() | rhs.getConstantValue().value()};\n+      return {lhs.getConstantValue().value() << rhs.getConstantValue().value()};\n     return {};\n   }\n };\n \n-class XorIOpAxisInfoVisitor final : public BinaryOpVisitorImpl<arith::XOrIOp> {\n+template <typename OpTy>\n+class ShROpAxisInfoVisitor final : public BinaryOpVisitorImpl<OpTy> {\n public:\n-  using BinaryOpVisitorImpl<arith::XOrIOp>::BinaryOpVisitorImpl;\n+  using BinaryOpVisitorImpl<OpTy>::BinaryOpVisitorImpl;\n \n private:\n-  int64_t getConstancy(arith::XOrIOp op, const AxisInfo &lhs,\n-                       const AxisInfo &rhs, int dim) override {\n+  int64_t getContiguity(OpTy op, const AxisInfo &lhs, const AxisInfo &rhs,\n+                        int dim) override {\n+    if (rhs.getConstantValue().has_value() &&\n+        rhs.getConstantValue().value() == 0)\n+      return lhs.getContiguity(dim);\n+    else\n+      return 1;\n+  }\n+\n+  int64_t getDivisibility(OpTy op, const AxisInfo &lhs, const AxisInfo &rhs,\n+                          int dim) override {\n+    if (rhs.getConstantValue().has_value())\n+      return std::max<int64_t>(1, lhs.getDivisibility(dim) /\n+                                      (1 << rhs.getConstantValue().value()));\n+    else\n+      return std::max<int64_t>(1, lhs.getDivisibility(dim) /\n+                                      (1 << rhs.getDivisibility(dim)));\n+  }\n+\n+  int64_t getConstancy(OpTy op, const AxisInfo &lhs, const AxisInfo &rhs,\n+                       int dim) override {\n     return gcd(lhs.getConstancy(dim), rhs.getConstancy(dim));\n   }\n \n-  std::optional<int64_t> getConstantValue(arith::XOrIOp op, const AxisInfo &lhs,\n+  std::optional<int64_t> getConstantValue(OpTy op, const AxisInfo &lhs,\n                                           const AxisInfo &rhs) override {\n     if (lhs.getConstantValue().has_value() &&\n         rhs.getConstantValue().has_value())\n-      return {lhs.getConstantValue().value() ^ rhs.getConstantValue().value()};\n+      return {lhs.getConstantValue().value() >> rhs.getConstantValue().value()};\n     return {};\n   }\n };\n \n+template <typename OpTy>\n+class MaxMinOpAxisInfoVisitor final : public AxisInfoVisitorImpl<OpTy> {\n+public:\n+  using AxisInfoVisitorImpl<OpTy>::AxisInfoVisitorImpl;\n+\n+  AxisInfo getAxisInfo(OpTy op,\n+                       ArrayRef<LatticeElement<AxisInfo> *> operands) override {\n+    auto lhsInfo = operands[0]->getValue();\n+    auto rhsInfo = operands[1]->getValue();\n+    std::optional<int64_t> constantValue;\n+    if (lhsInfo.getConstantValue().has_value() &&\n+        rhsInfo.getConstantValue().has_value()) {\n+      if constexpr (std::is_same_v<OpTy, arith::MaxSIOp> ||\n+                    std::is_same_v<OpTy, arith::MaxUIOp>)\n+        constantValue = {std::max(lhsInfo.getConstantValue().value(),\n+                                  rhsInfo.getConstantValue().value())};\n+      else if constexpr (std::is_same_v<OpTy, arith::MinSIOp> ||\n+                         std::is_same_v<OpTy, arith::MinUIOp>)\n+        constantValue = {std::min(lhsInfo.getConstantValue().value(),\n+                                  rhsInfo.getConstantValue().value())};\n+    }\n+    auto rank = lhsInfo.getRank();\n+    return AxisInfo(/*knownContiguity=*/AxisInfo::DimVectorT(rank, 1),\n+                    /*knownDivisibility=*/AxisInfo::DimVectorT(rank, 1),\n+                    /*knownConstancy=*/AxisInfo::DimVectorT(rank, 1),\n+                    /*constantValue=*/constantValue);\n+  }\n+};\n+\n //===----------------------------------------------------------------------===//\n // AxisInfoAnalysis\n //===----------------------------------------------------------------------===//\n@@ -723,9 +778,9 @@ AxisInfoAnalysis::AxisInfoAnalysis(MLIRContext *context)\n                   CastOpAxisInfoVisitor<triton::BitcastOp>>();\n   visitors.append<MakeRangeOpAxisInfoVisitor>();\n   visitors.append<ConstantOpAxisInfoVisitor>();\n-  visitors.append<AddOpAxisInfoVisitor<triton::AddPtrOp>,\n-                  AddOpAxisInfoVisitor<arith::AddIOp>>();\n-  visitors.append<SubOpAxisInfoVisitor<arith::SubIOp>>();\n+  visitors.append<AddSubOpAxisInfoVisitor<triton::AddPtrOp>,\n+                  AddSubOpAxisInfoVisitor<arith::AddIOp>,\n+                  AddSubOpAxisInfoVisitor<arith::SubIOp>>();\n   visitors.append<MulIOpAxisInfoVisitor>();\n   visitors.append<DivOpAxisInfoVisitor<arith::DivSIOp>,\n                   DivOpAxisInfoVisitor<arith::DivUIOp>>();\n@@ -736,13 +791,17 @@ AxisInfoAnalysis::AxisInfoAnalysis(MLIRContext *context)\n   visitors.append<ExpandDimsOpAxisInfoVisitor>();\n   visitors.append<CmpOpAxisInfoVisitor<arith::CmpIOp>,\n                   CmpOpAxisInfoVisitor<triton::gpu::CmpIOp>>();\n-  visitors.append<AndIOpAxisInfoVisitor, OrIOpAxisInfoVisitor,\n-                  XorIOpAxisInfoVisitor>();\n+  visitors.append<LogicalOpAxisInfoVisitor<arith::AndIOp>,\n+                  LogicalOpAxisInfoVisitor<arith::OrIOp>,\n+                  LogicalOpAxisInfoVisitor<arith::XOrIOp>>();\n   visitors.append<SelectOpAxisInfoVisitor<mlir::SelectOp>,\n                   SelectOpAxisInfoVisitor<triton::gpu::SelectOp>>();\n-  // TODO: Add more visitors\n-  // max/min\n-  // bitwise ops\n+  visitors.append<ShLIOpAxisInfoVisitor, ShROpAxisInfoVisitor<arith::ShRUIOp>,\n+                  ShROpAxisInfoVisitor<arith::ShRSIOp>>();\n+  visitors.append<MaxMinOpAxisInfoVisitor<arith::MaxSIOp>,\n+                  MaxMinOpAxisInfoVisitor<arith::MaxUIOp>,\n+                  MaxMinOpAxisInfoVisitor<arith::MinSIOp>,\n+                  MaxMinOpAxisInfoVisitor<arith::MinUIOp>>();\n }\n \n ChangeResult AxisInfoAnalysis::visitOperation("}, {"filename": "test/Analysis/test-alignment.mlir", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "file_content_changes": "@@ -219,6 +219,44 @@ func @select() {\n \n // -----\n \n+func @shift() {\n+  // CHECK: Contiguity: [128] ; Divisibility: [1073741824] ; Constancy: [1] ; ConstantValue: [None]\n+  %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [8] ; Constancy: [128] ; ConstantValue: [8]\n+  %1 = arith.constant dense<8> : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [4] ; Constancy: [128] ; ConstantValue: [4]\n+  %2 = arith.constant dense<4> : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [274877906944] ; Constancy: [1] ; ConstantValue: [None]\n+  %3 = arith.shli %0, %1 : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [67108864] ; Constancy: [1] ; ConstantValue: [None]\n+  %4 = arith.shrsi %0, %2 : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [128] ; Constancy: [128] ; ConstantValue: [128]\n+  %5 = arith.shli %1, %2 : tensor<128xi32>\n+  return\n+}\n+\n+// -----\n+\n+func @max_min() {\n+  // CHECK: Contiguity: [128] ; Divisibility: [1073741824] ; Constancy: [1] ; ConstantValue: [None]\n+  %0 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [128] ; Divisibility: [64] ; Constancy: [1] ; ConstantValue: [None]\n+  %1 = tt.make_range {end = 192 : i32, start = 64 : i32} : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [1] ; Constancy: [1] ; ConstantValue: [None]\n+  %2 = arith.maxsi %0, %1 : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [1] ; Constancy: [1] ; ConstantValue: [None]\n+  %3 = arith.minsi %0, %1 : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [8] ; Constancy: [128] ; ConstantValue: [8]\n+  %4 = arith.constant dense<8> : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [4] ; Constancy: [128] ; ConstantValue: [4]\n+  %5 = arith.constant dense<4> : tensor<128xi32>\n+  // CHECK-NEXT: Contiguity: [1] ; Divisibility: [1] ; Constancy: [1] ; ConstantValue: [8]\n+  %6 = arith.maxsi %4, %5 : tensor<128xi32>\n+  return\n+}\n+\n+// -----\n+\n // CHECK-LABEL: for\n func @for() {\n   // CHECK: Contiguity: [1, 1] ; Divisibility: [4611686018427387904, 4611686018427387904] ; Constancy: [128, 32] ; ConstantValue: [0]"}]