[{"filename": "python/test/backend/extension_backend.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "file_content_changes": "@@ -2,15 +2,11 @@\n #include <stdio.h>\n #include <stdlib.h>\n \n-\n-\n static PyObject *getDeviceProperties(PyObject *self, PyObject *args) {\n   // create a struct to hold device properties\n-  return Py_BuildValue(\"{s:i, s:i, s:i, s:i, s:i}\", \"max_shared_mem\",\n-                       1024, \"multiprocessor_count\",\n-                       16, \"sm_clock_rate\",\n-                       2100, \"mem_clock_rate\", 2300,\n-                       \"mem_bus_width\", 2400);\n+  return Py_BuildValue(\"{s:i, s:i, s:i, s:i, s:i}\", \"max_shared_mem\", 1024,\n+                       \"multiprocessor_count\", 16, \"sm_clock_rate\", 2100,\n+                       \"mem_clock_rate\", 2300, \"mem_bus_width\", 2400);\n }\n \n static PyObject *loadBinary(PyObject *self, PyObject *args) {"}, {"filename": "python/test/backend/test_device_backend.py", "status": "modified", "additions": 22, "deletions": 70, "changes": 92, "file_content_changes": "@@ -2,20 +2,20 @@\n import gc\n import hashlib\n import os\n-from pathlib import Path\n import shutil\n import subprocess\n-import sys\n import sysconfig\n import tempfile\n import tracemalloc\n-import setuptools\n+from pathlib import Path\n \n+import setuptools\n import torch\n+\n import triton\n import triton.language as tl\n-from triton.common.build import quiet\n from triton.common.backend import BaseBackend, register_backend\n+from triton.common.build import quiet\n from triton.compiler.make_launcher import make_so_cache_key\n from triton.runtime.cache import get_cache_manager\n from triton.runtime.driver import DriverBase\n@@ -182,102 +182,53 @@ def make_launcher_stub(self, name, signature, constants):\n             return cache_path\n \n     def _generate_launcher(self, constants, signature):\n-        def ty_to_cpp(ty):\n-            if ty[0] == '*':\n-                return \"void *\"\n-\n-            return {\n-                \"i1\": \"int32_t\",\n-                \"i8\": \"int8_t\",\n-                \"i16\": \"int16_t\",\n-                \"i32\": \"int32_t\",\n-                \"i64\": \"int64_t\",\n-                \"u32\": \"uint32_t\",\n-                \"u64\": \"uint64_t\",\n-                \"fp16\": \"float\",\n-                \"bf16\": \"float\",\n-                \"fp32\": \"float\",\n-                \"f32\": \"float\",\n-                \"fp64\": \"double\",\n-            }[ty]\n-\n-        arg_decls = ', '.join(f\"{ty_to_cpp(ty)} arg{i}\" for i, ty in signature.items())\n-\n-        def _extracted_type(ty):\n-            if ty[0] == '*':\n-                return \"PyObject*\"\n-            return {\n-                'i1': 'int32_t',\n-                'i32': 'int32_t',\n-                'i64': 'int64_t',\n-                'u32': 'uint32_t',\n-                'u64': 'uint64_t',\n-                'fp16': 'float',\n-                'bf16': 'float',\n-                'fp32': 'float',\n-                'f32': 'float',\n-                'fp64': 'double',\n-            }[ty]\n-\n-        def format_of(ty):\n-            return {\n-                \"PyObject*\": \"O\",\n-                \"float\": \"f\",\n-                \"double\": \"d\",\n-                \"long\": \"l\",\n-                \"uint32_t\": \"I\",\n-                \"int32_t\": \"i\",\n-                \"uint64_t\": \"K\",\n-                \"int64_t\": \"L\",\n-            }[ty]\n-\n-        format = \"iiiiiKKOOO\" + ''.join([format_of(_extracted_type(ty)) for ty in signature.values()])\n-\n         # generate glue code\n-        src = f\"\"\"\n+        src = \"\"\"\n         #define __EXTENSION_BACKEND__\n         #include <Python.h>\n         #include <stdio.h>\n \n-        static PyObject* launch(PyObject* self, PyObject* args) {{\n+        static PyObject* launch(PyObject* self, PyObject* args) {\n         printf(\"Launch empty kernel for extension backend\\\\n\");\n \n-        if (PyErr_Occurred()) {{\n+        if (PyErr_Occurred()) {\n             return NULL;\n-        }}\n+        }\n \n         // return None\n         Py_INCREF(Py_None);\n         return Py_None;\n-        }}\n+        }\n \n-        static PyMethodDef ModuleMethods[] = {{\n-        {{\"launch\", launch, METH_VARARGS, \"Entry point for all kernels with this signature\"}},\n-        {{NULL, NULL, 0, NULL}} // sentinel\n-        }};\n+        static PyMethodDef ModuleMethods[] = {\n+        {\"launch\", launch, METH_VARARGS, \"Entry point for all kernels with this signature\"},\n+        {NULL, NULL, 0, NULL} // sentinel\n+        };\n \n-        static struct PyModuleDef ModuleDef = {{\n+        static struct PyModuleDef ModuleDef = {\n         PyModuleDef_HEAD_INIT,\n         \\\"__triton_launcher\\\",\n         NULL, //documentation\n         -1, //size\n         ModuleMethods\n-        }};\n+        };\n \n-        PyMODINIT_FUNC PyInit___triton_launcher(void) {{\n+        PyMODINIT_FUNC PyInit___triton_launcher(void) {\n         PyObject *m = PyModule_Create(&ModuleDef);\n-        if(m == NULL) {{\n+        if(m == NULL) {\n             return NULL;\n-        }}\n+        }\n         PyModule_AddFunctions(m, ModuleMethods);\n         return m;\n-        }}\n+        }\n         \"\"\"\n \n         return src\n \n+\n register_backend(\"cpu\", ExtensionBackend)\n \n+\n @triton.jit\n def kernel(in_ptr0, out_ptr0, xnumel, XBLOCK: tl.constexpr):\n     xnumel = 10\n@@ -288,6 +239,7 @@ def kernel(in_ptr0, out_ptr0, xnumel, XBLOCK: tl.constexpr):\n     tmp0 = tl.load(in_ptr0 + (x0), xmask)\n     tl.store(out_ptr0 + (x0 + tl.zeros([XBLOCK], tl.int32)), tmp0, xmask)\n \n+\n tracemalloc.start()\n try:\n     inp = torch.randn(10)"}, {"filename": "python/triton/common/backend.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -72,6 +72,7 @@ def get_architecture_descriptor(self, **kwargs):\n     def create_backend(cls, device_type: str):\n         return cls(device_type)\n \n+\n _backends: Dict[str, BaseBackend] = {}\n \n \n@@ -82,4 +83,3 @@ def register_backend(device_type: str, backend_cls: type):\n \n def get_backend(device_type: str):\n     return _backends[device_type] if device_type in _backends else None\n-"}, {"filename": "python/triton/compiler/compiler.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "file_content_changes": "@@ -13,12 +13,12 @@\n \n import triton\n import triton._C.libtriton.triton as _triton\n+from ..common.backend import get_backend\n from ..runtime import driver\n # TODO: runtime.errors\n from ..runtime.autotuner import OutOfResources\n from ..runtime.cache import get_cache_manager\n from ..tools.disasm import extract\n-from ..common.backend import get_backend\n from .code_generator import ast_to_ttir\n from .make_launcher import make_stub\n \n@@ -374,8 +374,8 @@ def compile(fn, **kwargs):\n         assert _device_backend\n         arch = _device_backend.get_architecture_descriptor(**kwargs)\n \n-    is_cuda = device_type == \"cuda\"\n-    is_hip = device_type == \"hip\"\n+    is_cuda = device_type == \"cuda\" and _is_cuda(arch)\n+    is_hip = device_type in [\"cuda\", \"hip\"] and not is_cuda\n     context = _triton.ir.context()\n     asm = dict()\n     constants = kwargs.get(\"constants\", dict())"}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "file_content_changes": "@@ -303,8 +303,7 @@ def {self.fn.__name__}({', '.join(self.arg_names)}, grid, num_warps=4, num_stage\n     grid_0 = grid[0]\n     grid_1 = grid[1] if grid_size > 1 else 1\n     grid_2 = grid[2] if grid_size > 2 else 1\n-    device_types = {device_types}\n-    device_types.remove('')\n+    device_types = [device_type for device_type in {device_types} if device_type != '']\n     device_type = device_types[0] if len(device_types) > 0 else 'cuda'\n     if device is None:\n         if device_type in ['cuda', 'hip']:"}]