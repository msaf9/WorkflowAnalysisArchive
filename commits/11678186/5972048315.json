[{"filename": "lib/Conversion/NVGPUToLLVM/NVGPUToLLVMPass.cpp", "status": "modified", "additions": 155, "deletions": 89, "changes": 244, "file_content_changes": "@@ -33,7 +33,6 @@ class NVGPUOpPatternBase : public mlir::RewritePattern {\n                             Location &loc,\n                             mlir::PatternRewriter &rewriter) const {\n     if (val.getType().isa<LLVM::LLVMPointerType>()) {\n-      std::cout << \"Pointer found\" << std::endl;\n       if (std::holds_alternative<std::string>(constraint)) {\n         auto constraintStr = std::get<std::string>(constraint);\n         if (constraintStr == \"r\") {\n@@ -1051,26 +1050,33 @@ class WGMMADescCreateOpPattern\n   }\n };\n \n-class OffsetOfSts64OpPattern : public mlir::RewritePattern {\n+class OffsetOfSts64OpPattern\n+    : public NVGPUOpPatternBase<ttn::OffsetOfSts64Op, OffsetOfSts64OpPattern> {\n public:\n-  OffsetOfSts64OpPattern(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(ttn::OffsetOfSts64Op::getOperationName(), 1,\n-                             context) {}\n+  using Base = NVGPUOpPatternBase<ttn::OffsetOfSts64Op, OffsetOfSts64OpPattern>;\n+  using Base::Base;\n \n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto ctx = rewriter.getContext();\n-    auto offsetOfSts64Op = llvm::dyn_cast<ttn::OffsetOfSts64Op>(op);\n-    if (!offsetOfSts64Op)\n-      return mlir::failure();\n-    auto loc = op->getLoc();\n-    auto threadId = offsetOfSts64Op.getThreadId();\n-    auto rowOfWarp = offsetOfSts64Op.getRowOfWarp();\n-    auto elemIdx = offsetOfSts64Op.getElemIdx();\n-    auto leadingDimOffset = offsetOfSts64Op.getLeadingDimOffset();\n-    auto rowStride = offsetOfSts64Op.getRowStride();\n-    auto swizzleEnabled = offsetOfSts64Op.getSwizzleEnabled();\n+  std::vector<std::string> getOutputConstraints(ttn::OffsetOfSts64Op op) const {\n+    return {\"=r\"};\n+  }\n+\n+  OperandsAndConstraints\n+  getOperandsAndConstraints(ttn::OffsetOfSts64Op op) const {\n+    OperandsAndConstraints operandsAndConstraints;\n+    auto threadId = op.getThreadId();\n+    auto rowOfWarp = op.getRowOfWarp();\n+    auto elemIdx = op.getElemIdx();\n+\n+    operandsAndConstraints.push_back({threadId, \"r\"});\n+    operandsAndConstraints.push_back({elemIdx, \"r\"});\n+    operandsAndConstraints.push_back({rowOfWarp, \"r\"});\n+\n+    return operandsAndConstraints;\n+  }\n+\n+  std::string getPtxAsm(ttn::OffsetOfSts64Op op) const {\n+    auto rowStride = op.getRowStride();\n+    auto swizzleEnabled = op.getSwizzleEnabled();\n \n     if (swizzleEnabled) {\n       assert((rowStride == 32 || rowStride == 64 || rowStride == 128) &&\n@@ -1090,49 +1096,77 @@ class OffsetOfSts64OpPattern : public mlir::RewritePattern {\n       maxPhase = 2;\n     }\n \n-    auto laneId = and_(threadId, i32_val(0x1f));\n-    auto myRow =\n-        add(mul(and_(lshr(elemIdx, i32_val(1)), i32_val(0x1)), i32_val(8)),\n-            udiv(laneId, i32_val(4)));\n-    auto myCol = add(mul(udiv(elemIdx, i32_val(4)), i32_val(8)),\n-                     mul(urem(laneId, i32_val(4)), i32_val(2)));\n-    myRow = add(myRow, rowOfWarp);\n-    auto phase = urem(udiv(myRow, i32_val(perPhase)), i32_val(maxPhase));\n-    auto lineOffset =\n-        add(mul(urem(myRow, i32_val(perPhase)), i32_val(rowStride)),\n-            mul(myCol, i32_val(4)));\n-    auto colOffset =\n-        add(mul(xor_(udiv(lineOffset, i32_val(16)), phase), i32_val(16)),\n-            urem(lineOffset, i32_val(16)));\n-    auto offset =\n-        add(mul(udiv(myRow, i32_val(perPhase)), i32_val(128)), colOffset);\n-\n-    rewriter.replaceOp(op, {offset});\n-    return mlir::success();\n+    auto ptxAsm = \"{\\n\"\n+                  \".reg .u32 a<9>;      \\n\"\n+                  \"and.b32 a0, $1, 0x1f;\\n\" // laneid\n+                  \"shr.b32 a1, $2, 4; \\n\"\n+                  \"and.b32 a1, a1, 0x1; \\n\"\n+                  \"div.u32 a2, a0, 4; \\n\"\n+                  \"mad.lo.u32 a2, a1, 8, a2; \\n\" // myRow\n+                  \"div.u32 a3, $2, 4; \\n\"\n+                  \"rem.u32 a4, a0, 4; \\n\"\n+                  \"mul.lo.u32 a4, a4, 2; \\n\"\n+                  \"mad.lo.u32 a4, a3, 8, a4; \\n\" // myCol\n+                  \"add.u32 a2, a2, $3; \\n\"       // myRow = myRow + rowOfWarp\n+                  \"div.u32 a3, a2, \" +\n+                  std::to_string(perPhase) +\n+                  \"; \\n\"\n+                  \"rem.u32 a3, a3, \" +\n+                  std::to_string(maxPhase) +\n+                  \"; \\n\" // phase\n+                  \"rem.u32 a5, a2, \" +\n+                  std::to_string(perPhase) +\n+                  \"; \\n\" // lineOffset\n+                  \"mul.lo.u32 a5, a5, \" +\n+                  std::to_string(rowStride) +\n+                  \"; \\n\"\n+                  \"mad.lo.u32 a5, a4, 4, a5; \\n\" // lineOffset\n+                  \"div.u32 a6, a5, 16; \\n\"\n+                  \"xor.b32 a6, a6, a3; \\n\" // colOffset\n+                  \"rem.u32 a7, a5, 16; \\n\"\n+                  \"mad.lo.u32 a7, a6, 16, a7; \\n\" // colOffset\n+                  \"div.u32 a8, a2, \" +\n+                  std::to_string(perPhase) +\n+                  \"; \\n\"\n+                  \"mad.lo.u32 $0, a8, 128, a7; \\n\" // offset\n+                  \"}\";\n+    return ptxAsm;\n   }\n };\n \n-class OffsetOfStmatrixV4OpPattern : public mlir::RewritePattern {\n+class OffsetOfStmatrixV4OpPattern\n+    : public NVGPUOpPatternBase<ttn::OffsetOfStmatrixV4Op,\n+                                OffsetOfStmatrixV4OpPattern> {\n public:\n-  OffsetOfStmatrixV4OpPattern(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(ttn::OffsetOfStmatrixV4Op::getOperationName(), 1,\n-                             context) {}\n+  using Base = NVGPUOpPatternBase<ttn::OffsetOfStmatrixV4Op,\n+                                  OffsetOfStmatrixV4OpPattern>;\n+  using Base::Base;\n \n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto ctx = rewriter.getContext();\n-    auto offsetOfStmatrixV4Op = llvm::dyn_cast<ttn::OffsetOfStmatrixV4Op>(op);\n-    if (!offsetOfStmatrixV4Op)\n-      return mlir::failure();\n-    auto loc = op->getLoc();\n-    auto threadId = offsetOfStmatrixV4Op.getThreadId();\n-    auto rowOfWarp = offsetOfStmatrixV4Op.getRowOfWarp();\n-    auto elemIdx = offsetOfStmatrixV4Op.getElemIdx();\n-    auto leadingDimOffset = offsetOfStmatrixV4Op.getLeadingDimOffset();\n-    auto rowStride = offsetOfStmatrixV4Op.getRowStride();\n-    auto swizzleEnabled = offsetOfStmatrixV4Op.getSwizzleEnabled();\n+  std::vector<std::string>\n+  getOutputConstraints(ttn::OffsetOfStmatrixV4Op op) const {\n+    return {\"=r\"};\n+  }\n+\n+  OperandsAndConstraints\n+  getOperandsAndConstraints(ttn::OffsetOfStmatrixV4Op op) const {\n+    OperandsAndConstraints operandsAndConstraints;\n+    auto threadId = op.getThreadId();\n+    auto rowOfWarp = op.getRowOfWarp();\n+    auto elemIdx = op.getElemIdx();\n+\n+    operandsAndConstraints.push_back({threadId, \"r\"});\n+    operandsAndConstraints.push_back({elemIdx, \"r\"});\n+    operandsAndConstraints.push_back({rowOfWarp, \"r\"});\n+\n+    return operandsAndConstraints;\n+  }\n \n+  std::string getPtxAsm(ttn::OffsetOfStmatrixV4Op op) const {\n+    auto leadingDimOffset = op.getLeadingDimOffset();\n+    auto rowStride = op.getRowStride();\n+    auto swizzleEnabled = op.getSwizzleEnabled();\n+\n+    std::string ptxAsm;\n     if (swizzleEnabled) {\n       uint32_t perPhase = 0;\n       uint32_t maxPhase = 0;\n@@ -1147,41 +1181,73 @@ class OffsetOfStmatrixV4OpPattern : public mlir::RewritePattern {\n         maxPhase = 2;\n       }\n \n-      Value iterOfCol = udiv(elemIdx, i32_val(8));\n-      Value myRow = add(rowOfWarp, and_(threadId, i32_val(0xf)));\n-      Value myCol =\n-          mul(and_(lshr(threadId, i32_val(4)), i32_val(0x1)), i32_val(8));\n-      myCol = add(myCol, mul(iterOfCol, i32_val(16)));\n-\n-      Value offset0 =\n-          mul(udiv(myCol, i32_val(rowStride)), i32_val(leadingDimOffset));\n-      myCol = urem(myCol, i32_val(rowStride));\n-\n-      Value phase = urem(udiv(myRow, i32_val(perPhase)), i32_val(maxPhase));\n-\n-      Value lineOffset =\n-          add(mul(urem(myRow, i32_val(perPhase)), i32_val(rowStride)), myCol);\n-      Value colOffset =\n-          add(mul(xor_(udiv(lineOffset, i32_val(8)), phase), i32_val(8)),\n-              urem(lineOffset, i32_val(8)));\n-      Value offset1 =\n-          add(mul(udiv(myRow, i32_val(perPhase)), i32_val(64)), colOffset);\n-\n-      Value res = add(offset1, offset0);\n-\n-      rewriter.replaceOp(op, {res});\n+      ptxAsm =\n+          \"{\\n\"\n+          \".reg .u32 a<10>;      \\n\"\n+          \"div.u32 a0, $2, 8; \\n\"    // iterOfCol = udiv(elemIdx, i32_val(8))\n+          \"and.b32 a1, $1, 0xf; \\n\"  // myRow = and_(threadId, i32_val(0xf))\n+          \"add.u32 a1, a1, $3; \\n\"   // myRow = myRow + rowOfWarp\n+          \"shr.b32 a2, $1, 4; \\n\"    // myCol = lshr(threadId, i32_val(4))\n+          \"and.b32 a2, a2, 0x1; \\n\"  // myCol = and_(myCol, i32_val(0x1))\n+          \"mul.lo.u32 a2, a2, 8; \\n\" // myCol = mul(myCol, i32_val(8))\n+          \"mad.lo.u32 a2, a0, 16, a2; \\n\" // myCol = add(myCol,\n+                                          // mul(iterOfCol, i32_val(16)))\n+          \"div.u32 a3, a2, \" +\n+          std::to_string(rowStride) +\n+          \"; \\n\" // offset0 = udiv(myCol, i32_val(rowStride))\n+          \"mul.lo.u32 a3, a3, \" +\n+          std::to_string(leadingDimOffset) +\n+          \"; \\n\" // offset0 = mul(offset0, i32_val(leadingDimOffset))\n+          \"rem.u32 a2, a2, \" +\n+          std::to_string(rowStride) +\n+          \"; \\n\" // myCol = myCol % rowStride\n+          \"div.u32 a4, a1, \" +\n+          std::to_string(perPhase) +\n+          \"; \\n\" // phase =  myrow // perPhase\n+          \"rem.u32 a4, a4, \" +\n+          std::to_string(maxPhase) +\n+          \"; \\n\" // phase = phase % maxPhase\n+          \"rem.u32 a5, a1, \" +\n+          std::to_string(perPhase) +\n+          \"; \\n\" // lineOffset = urem(myRow, i32_val(perPhase))\n+          \"mad.lo.u32 a5, a5, \" +\n+          std::to_string(rowStride) +\n+          \", a2; \\n\" // lineOffset = add(mul(lineOffset, rowStride), myCol)\n+          \"div.u32 a6, a5, 8; \\n\"  // colOffset = udiv(lineOffset, i32_val(8)\n+          \"xor.b32 a6, a6, a4; \\n\" // colOffset = xor_(colOffset, phase)\n+          \"rem.u32 a7, a5, 8; \\n\"  // temp = urem(lineOffset, i32_val(8)\n+          \"mad.lo.u32 a7, a6, 8, a7; \\n\" // colOffset = add(mul(colOffset,\n+                                         // i32_val(8)), temp)\n+          \"div.u32 a8, a1, \" +\n+          std::to_string(perPhase) +\n+          \"; \\n\" // offset1 = udiv(myRow, i32_val(perPhase))\n+          \"mad.lo.u32 a9, a8, 64, a7; \\n\" // offset1 = add(mul(offset1,\n+                                          // i32_val(64)), colOffset)\n+          \"add.u32 $0, a9, a3; \\n\"        // result = add(offset1, offset0)\n+          \"}\";\n     } else {\n-      Value iterOfCol = udiv(elemIdx, i32_val(4));\n-      Value myRow = add(rowOfWarp, and_(threadId, i32_val(0xf)));\n-      Value myCol =\n-          mul(and_(lshr(threadId, i32_val(4)), i32_val(0x1)), i32_val(8));\n-      myCol = add(myCol, mul(iterOfCol, i32_val(16)));\n-\n-      Value offset =\n-          add(mul(myRow, i32_val(rowStride)), mul(myCol, i32_val(2)));\n-      rewriter.replaceOp(op, {offset});\n+      ptxAsm = \"{\\n\"\n+               \".reg .u64 a<5>;      \\n\"\n+               \"div.u32 a0, $2, 4; \\n\"    // iterOfCol = udiv(elemIdx,\n+                                          // i32_val(4))\n+               \"and.b32 a1, $1, 0xf; \\n\"  // myRow = and_(threadId,\n+                                          // i32_val(0xf))\n+               \"add.u32 a1, a1, $3; \\n\"   // myRow = myRow + rowOfWarp\n+               \"shr.b32 a2, $1, 4; \\n\"    // myCol = lshr(threadId,\n+                                          // i32_val(4))\n+               \"and.b32 a2, a2, 0x1; \\n\"  // myCol = and_(myCol,\n+                                          // i32_val(0x1))\n+               \"mul.lo.u32 a2, a2, 8; \\n\" // myCol = mul(myCol,\n+                                          // i32_val(8))\n+               \"mul.u32 a3, a1, \" +\n+               std::to_string(rowStride) +\n+               \"; \\n\"                         // offset = myRow * rowStride\n+               \"mad.lo.u32 $0, a2, 2, a3; \\n\" // result = add(mul(myCol,\n+                                              // i32_val(2)), offset)\n+               \"}\\n\";\n     }\n-    return mlir::success();\n+\n+    return ptxAsm;\n   }\n };\n "}]