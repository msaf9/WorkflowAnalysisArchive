[{"filename": "lib/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.cpp", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "file_content_changes": "@@ -686,9 +686,12 @@ class CFBranchPattern : public OpConversionPattern<cf::BranchOp> {\n   LogicalResult\n   matchAndRewrite(cf::BranchOp op, cf::BranchOp::Adaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n-    addNamedAttrs(rewriter.replaceOpWithNewOp<cf::BranchOp>(\n-                      op, op.getSuccessor(), adaptor.getOperands()),\n-                  adaptor.getAttributes());\n+    auto converter = getTypeConverter();\n+    auto newOp = rewriter.replaceOpWithNewOp<cf::BranchOp>(\n+        op, op.getSuccessor(), adaptor.getOperands());\n+    if (failed(rewriter.convertRegionTypes(newOp.getSuccessor()->getParent(),\n+                                           *converter)))\n+      return failure();\n     return success();\n   }\n };\n@@ -713,14 +716,36 @@ class CFCondBranchPattern : public OpConversionPattern<cf::CondBranchOp> {\n     if (failed(rewriter.convertRegionTypes(newOp.getFalseDest()->getParent(),\n                                            *converter)))\n       return failure();\n+    rewriter.eraseOp(op);\n+    return success();\n+  }\n+};\n+\n+class FuncOpPattern : public OpConversionPattern<func::FuncOp> {\n+public:\n+  using OpConversionPattern<func::FuncOp>::OpConversionPattern;\n+\n+  LogicalResult\n+  matchAndRewrite(func::FuncOp op, OpAdaptor adaptor,\n+                  ConversionPatternRewriter &rewriter) const override {\n+    auto converter = getTypeConverter();\n+    auto newOp = rewriter.replaceOpWithNewOp<func::FuncOp>(\n+        op, op.getName(), op.getFunctionType());\n+    addNamedAttrs(newOp, adaptor.getAttributes());\n+    rewriter.inlineRegionBefore(op.getBody(), newOp.getBody(),\n+                                newOp.getBody().end());\n+    if (failed(rewriter.convertRegionTypes(&newOp.getBody(), *converter)))\n+      return failure();\n+\n     return success();\n   }\n };\n \n void populateCFPatterns(TritonGPUTypeConverter &typeConverter,\n                         RewritePatternSet &patterns) {\n   MLIRContext *context = patterns.getContext();\n-  patterns.add<CFBranchPattern, CFCondBranchPattern>(typeConverter, context);\n+  patterns.add<FuncOpPattern, CFCondBranchPattern, CFBranchPattern>(\n+      typeConverter, context);\n }\n //\n "}, {"filename": "lib/Dialect/TritonGPU/Transforms/RemoveLayoutConversions.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -595,7 +595,7 @@ class TritonGPURemoveLayoutConversionsPass\n     patterns.add<DecomposeDotOperand>(context);\n     patterns.add<ConvertDotConvert>(context);\n \n-    if (applyPatternsAndFoldGreedily(m, std::move(patterns)).failed()) {\n+    if (mlir::applyPatternsAndFoldGreedily(m, std::move(patterns)).failed()) {\n       signalPassFailure();\n     }\n "}, {"filename": "lib/Dialect/TritonGPU/Transforms/TritonGPUConversion.cpp", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "file_content_changes": "@@ -14,11 +14,10 @@ using namespace mlir::triton::gpu;\n TritonGPUTypeConverter::TritonGPUTypeConverter(MLIRContext *context,\n                                                int numWarps)\n     : context(context), numWarps(numWarps) {\n-  // TODO: how does MLIR pick the right conversion?\n   addConversion([](Type type) { return type; });\n   addConversion([this](RankedTensorType tensorType) -> RankedTensorType {\n     // types with encoding are already in the right format\n-    // TODO: check for layout encodings specifically\n+    // TODO: check for layout encodings more specifically\n     if (tensorType.getEncoding())\n       return tensorType;\n     // pessimistic values for attributes:\n@@ -41,16 +40,19 @@ TritonGPUTypeConverter::TritonGPUTypeConverter(MLIRContext *context,\n   // This will create newArg, and map(origArg, newArg)\n   addArgumentMaterialization([&](OpBuilder &builder,\n                                  RankedTensorType tensorType, ValueRange inputs,\n-                                 Location loc) {\n-    llvm_unreachable(\"Argument rematerialization not implemented\");\n+                                 Location loc) -> llvm::Optional<Value> {\n+    llvm_unreachable(\"Argument rematerialization should not happen in Triton \"\n+                     \"-> TritonGPU conversion\");\n     return std::nullopt;\n   });\n \n   // If the origValue still has live user(s), use this to\n   // convert origValue to newValue\n   addSourceMaterialization([&](OpBuilder &builder, RankedTensorType tensorType,\n-                               ValueRange inputs, Location loc) {\n-    llvm_unreachable(\"Source rematerialization not implemented\");\n+                               ValueRange inputs,\n+                               Location loc) -> llvm::Optional<Value> {\n+    llvm_unreachable(\"Source rematerialization should not happen in Triton -> \"\n+                     \"TritonGPU Conversion\");\n     return std::nullopt;\n   });\n \n@@ -62,9 +64,6 @@ TritonGPUTypeConverter::TritonGPUTypeConverter(MLIRContext *context,\n     auto cast =\n         builder.create<triton::gpu::ConvertLayoutOp>(loc, tensorType, inputs);\n     return Optional<Value>(cast.getResult());\n-    // return Optional<Value>(cast.getResult(0));\n-    // llvm_unreachable(\"Not implemented\");\n-    // return std::nullopt;\n   });\n }\n \n@@ -82,10 +81,16 @@ TritonGPUConversionTarget::TritonGPUConversionTarget(\n                scf::ReduceReturnOp>();\n \n   addDynamicallyLegalDialect<arith::ArithDialect, math::MathDialect,\n-                             triton::TritonDialect, scf::SCFDialect>(\n+                             func::FuncDialect, triton::TritonDialect,\n+                             cf::ControlFlowDialect, scf::SCFDialect>(\n       [&](Operation *op) {\n-        if (typeConverter.isLegal(op))\n+        bool hasLegalRegions = true;\n+        for (auto &region : op->getRegions()) {\n+          hasLegalRegions = hasLegalRegions && typeConverter.isLegal(&region);\n+        }\n+        if (hasLegalRegions && typeConverter.isLegal(op)) {\n           return true;\n+        }\n         return false;\n       });\n "}]