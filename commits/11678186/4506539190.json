[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "file_content_changes": "@@ -783,7 +783,7 @@ def serialized_add(data, Lock):\n     data = torch.zeros((128,), device='cuda', dtype=torch.float32)\n     ref = torch.full((128,), 64.0)\n     serialized_add[(64,)](data, Lock)\n-    np.testing.assert_allclose(data, ref)\n+    np.testing.assert_allclose(to_numpy(data), to_numpy(ref))\n \n \n # ---------------\n@@ -1212,8 +1212,8 @@ def kernel(X, stride_xm, stride_xn,\n     # numpy result\n     z_ref = x.transpose(*perm)\n     # compare\n-    np.testing.assert_allclose(z_tri, z_ref)\n-    np.testing.assert_allclose(z_tri_contiguous, z_ref)\n+    np.testing.assert_allclose(to_numpy(z_tri), z_ref)\n+    np.testing.assert_allclose(to_numpy(z_tri_contiguous), z_ref)\n     # parse ptx to make sure ld/st are vectorized\n     ptx = pgm.asm['ptx']\n     assert 'ld.global.v4' in ptx\n@@ -1475,7 +1475,7 @@ def _kernel(z, BLOCK: tl.constexpr,\n         tl.store(z + off, val)\n     _kernel[(1,)](z_tri, START=start, END=start + BLOCK, BLOCK=BLOCK)\n     z_ref = torch.arange(start, BLOCK + start, dtype=torch.int32, device=device)\n-    np.testing.assert_allclose(z_tri, z_ref)\n+    np.testing.assert_allclose(to_numpy(z_tri), to_numpy(z_ref))\n \n # ---------------\n # test load\n@@ -1511,7 +1511,7 @@ def _kernel(in_ptr, out_ptr, in_size: tl.constexpr, out_size: tl.constexpr):\n     kernel[(1,)](input, output, input_size, output_size)\n \n     reference_out = torch.cat((input, torch.ones((size_diff,), dtype=dtype, device=device)))\n-    np.testing.assert_allclose(output, reference_out)\n+    np.testing.assert_allclose(output.cpu(), reference_out.cpu())\n \n # Testing masked loads with an intermate copy to shared memory run.\n "}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -198,6 +198,9 @@ def _type_of(key):\n             \"uint32\": \"u32\",\n             \"uint64\": \"u64\",\n         }\n+        # reinterpret can create triton type\n+        for v in list(tys.values()):\n+            tys[v] = v\n         return key if isinstance(key, str) else f\"*{tys[dtype_str]}\"\n \n     def _make_signature(self, sig_key):"}]