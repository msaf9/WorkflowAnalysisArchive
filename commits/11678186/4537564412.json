[{"filename": "include/triton/Conversion/TritonGPUToLLVM/PTXAsmFormat.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -149,7 +149,7 @@ struct PTXBuilder {\n   // Otherwise if the register is only used in the true branch or the false\n   // branch but not both, the register is undefined and ptxas can perform\n   // aggressive optimizations that may lead to incorrect results.\n-  Operand *newOperand(StringRef constraint, bool init = false);\n+  Operand *newOperand(StringRef constraint, bool init = false, int numBits = 0);\n \n   // Create a constant integer operand.\n   Operand *newConstantOperand(int64_t v);\n@@ -176,7 +176,7 @@ struct PTXBuilder {\n     return argArchive.back().get();\n   }\n \n-  void initOperand(Operand *opr);\n+  void initOperand(Operand *opr, int numBits);\n \n   // Make the operands in argArchive follow the provided \\param order.\n   void reorderArgArchive(ArrayRef<Operand *> order) {"}, {"filename": "lib/Conversion/TritonGPUToLLVM/LoadStoreOpToLLVM.cpp", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "file_content_changes": "@@ -108,7 +108,7 @@ struct LoadOpConversion\n     }\n \n     // vectorized iteration through all the pointer/mask/other elements\n-    const int valueElemNbits =\n+    const int valueElemNBits =\n         std::max(8u, valueElemTy.getIntOrFloatBitWidth());\n     const int numVecs = numElems / vec;\n \n@@ -117,11 +117,11 @@ struct LoadOpConversion\n       // TODO: optimization when ptr is GEP with constant offset\n       size_t in_off = 0;\n \n-      const size_t maxWordWidth = std::max<size_t>(32, valueElemNbits);\n-      const size_t totalWidth = valueElemNbits * vec;\n+      const size_t maxWordWidth = std::max<size_t>(32, valueElemNBits);\n+      const size_t totalWidth = valueElemNBits * vec;\n       const size_t width = std::min(totalWidth, maxWordWidth);\n       const size_t nWords = std::max<size_t>(1, totalWidth / width);\n-      const size_t wordNElems = width / valueElemNbits;\n+      const size_t wordNElems = width / valueElemNBits;\n       const size_t movWidth = width < 16 ? 16 : width;\n       assert(wordNElems * nWords * numVecs == numElems);\n \n@@ -141,8 +141,9 @@ struct LoadOpConversion\n       // prepare asm operands\n       auto *dstsOpr = ptxBuilder.newListOperand();\n       for (size_t wordIdx = 0; wordIdx < nWords; ++wordIdx) {\n-        auto *opr = ptxBuilder.newOperand(writeConstraint,\n-                                          /*init=*/true); // =r operations\n+        auto *opr =\n+            ptxBuilder.newOperand(writeConstraint, /*init=*/true,\n+                                  /*numBits=*/movWidth); // =r operations\n         dstsOpr->listAppend(opr);\n       }\n \n@@ -180,7 +181,7 @@ struct LoadOpConversion\n           PTXInstr &mov =\n               ptxBuilder.create<>(\"mov\")->o(\"u\" + std::to_string(movWidth));\n \n-          size_t size = width / valueElemNbits;\n+          size_t size = width / valueElemNBits;\n \n           auto vecTy = LLVM::getFixedVectorType(valueElemTy, size);\n           Value v = undef(vecTy);\n@@ -195,8 +196,8 @@ struct LoadOpConversion\n           PTXInstr::Operand *opr{};\n \n           if (otherIsSplatConstInt) {\n-            for (size_t s = 0; s < 32; s += valueElemNbits)\n-              splatVal |= splatVal << valueElemNbits;\n+            for (size_t s = 0; s < 32; s += valueElemNBits)\n+              splatVal |= splatVal << valueElemNBits;\n             opr = ptxBuilder.newConstantOperand(splatVal);\n           } else\n             opr = ptxBuilder.newOperand(v, readConstraint);\n@@ -227,10 +228,10 @@ struct LoadOpConversion\n           curr = ret;\n         }\n         curr = bitcast(curr, LLVM::getFixedVectorType(valueElemTy,\n-                                                      width / valueElemNbits));\n+                                                      width / valueElemNBits));\n         rets.push_back(curr);\n       }\n-      int tmp = width / valueElemNbits;\n+      int tmp = width / valueElemNBits;\n       for (size_t ii = 0; ii < vec; ++ii) {\n         Value vecIdx = createIndexAttrConstant(\n             rewriter, loc, this->getTypeConverter()->getIndexType(), ii % tmp);\n@@ -306,18 +307,18 @@ struct StoreOpConversion\n \n     const size_t dtsize =\n         std::max<int>(1, valueElemTy.getIntOrFloatBitWidth() / 8);\n-    const size_t valueElemNbits = dtsize * 8;\n+    const size_t valueElemNBits = dtsize * 8;\n \n     const int numVecs = elemsPerThread / vec;\n     for (size_t vecStart = 0; vecStart < elemsPerThread; vecStart += vec) {\n       // TODO: optimization when ptr is AddPtr with constant offset\n       size_t in_off = 0;\n \n-      const size_t maxWordWidth = std::max<size_t>(32, valueElemNbits);\n-      const size_t totalWidth = valueElemNbits * vec;\n+      const size_t maxWordWidth = std::max<size_t>(32, valueElemNBits);\n+      const size_t totalWidth = valueElemNBits * vec;\n       const size_t width = std::min(totalWidth, maxWordWidth);\n       const size_t nWords = std::max<size_t>(1, totalWidth / width);\n-      const size_t wordNElems = width / valueElemNbits;\n+      const size_t wordNElems = width / valueElemNBits;\n       assert(wordNElems * nWords * numVecs == elemsPerThread);\n \n       // TODO(Superjomn) Add cache policy fields to StoreOp.\n@@ -408,6 +409,7 @@ struct AtomicCASOpConversion\n     Type valueElemTy =\n         TensorTy ? getTypeConverter()->convertType(TensorTy.getElementType())\n                  : op.getResult().getType();\n+    auto valueElemNBits = valueElemTy.getIntOrFloatBitWidth();\n     auto tid = tid_val();\n     Value pred = icmp_eq(tid, i32_val(0));\n     PTXBuilder ptxBuilderMemfence;\n@@ -423,7 +425,8 @@ struct AtomicCASOpConversion\n     Value casVal = valElements[0];\n \n     PTXBuilder ptxBuilderAtomicCAS;\n-    auto *dstOpr = ptxBuilderAtomicCAS.newOperand(\"=r\", /*init=*/true);\n+    auto *dstOpr = ptxBuilderAtomicCAS.newOperand(\"=r\", /*init=*/true,\n+                                                  /*numBits=*/valueElemNBits);\n     auto *ptrOpr = ptxBuilderAtomicCAS.newAddrOperand(casPtr, \"l\");\n     auto *cmpOpr = ptxBuilderAtomicCAS.newOperand(casCmp, \"r\");\n     auto *valOpr = ptxBuilderAtomicCAS.newOperand(casVal, \"r\");\n@@ -491,7 +494,7 @@ struct AtomicRMWOpConversion\n     Type valueElemTy =\n         tensorTy ? getTypeConverter()->convertType(tensorTy.getElementType())\n                  : op.getResult().getType();\n-    const size_t valueElemNbits = valueElemTy.getIntOrFloatBitWidth();\n+    const size_t valueElemNBits = valueElemTy.getIntOrFloatBitWidth();\n     auto elemsPerThread = getElemsPerThread(val.getType());\n     // vec = 1, numElements = 1 for scalar\n     auto vec = getVectorSize(ptr);\n@@ -522,16 +525,17 @@ struct AtomicRMWOpConversion\n       Value rmwMask = llMask ? and_(mask, maskElements[i]) : mask;\n       std::string sTy;\n       PTXBuilder ptxBuilderAtomicRMW;\n-      std::string tyId = valueElemNbits * vec == 64\n+      std::string tyId = valueElemNBits * vec == 64\n                              ? \"l\"\n-                             : (valueElemNbits * vec == 32 ? \"r\" : \"h\");\n-      auto *dstOpr = ptxBuilderAtomicRMW.newOperand(\"=\" + tyId, /*init=*/true);\n+                             : (valueElemNBits * vec == 32 ? \"r\" : \"h\");\n+      auto *dstOpr = ptxBuilderAtomicRMW.newOperand(\"=\" + tyId, /*init=*/true,\n+                                                    /*numBits=*/valueElemNBits);\n       auto *ptrOpr = ptxBuilderAtomicRMW.newAddrOperand(rmwPtr, \"l\");\n       auto *valOpr = ptxBuilderAtomicRMW.newOperand(rmwVal, tyId);\n \n       auto &atom = ptxBuilderAtomicRMW.create<>(\"atom\")->global().o(\"gpu\");\n       auto rmwOp = stringifyRMWOp(atomicRmwAttr).str();\n-      auto sBits = std::to_string(valueElemNbits);\n+      auto sBits = std::to_string(valueElemNBits);\n       switch (atomicRmwAttr) {\n       case RMWOp::AND:\n         sTy = \"b\" + sBits;\n@@ -547,9 +551,9 @@ struct AtomicRMWOpConversion\n         break;\n       case RMWOp::FADD:\n         rmwOp = \"add\";\n-        rmwOp += (valueElemNbits == 16 ? \".noftz\" : \"\");\n+        rmwOp += (valueElemNBits == 16 ? \".noftz\" : \"\");\n         sTy = \"f\" + sBits;\n-        sTy += (vec == 2 && valueElemNbits == 16) ? \"x2\" : \"\";\n+        sTy += (vec == 2 && valueElemNBits == 16) ? \"x2\" : \"\";\n         break;\n       case RMWOp::MAX:\n         sTy = \"s\" + sBits;"}, {"filename": "lib/Conversion/TritonGPUToLLVM/PTXAsmFormat.cpp", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "file_content_changes": "@@ -19,21 +19,26 @@ PTXBuilder::newOperand(mlir::Value value, StringRef constraint,\n   return opr;\n }\n \n-void PTXBuilder::initOperand(Operand *opr) {\n+void PTXBuilder::initOperand(Operand *opr, int numBits) {\n+  // If numBits is not specified, we use 32 as default.\n+  numBits = numBits ? numBits : 32;\n+  // If numBits is less than 16, we use 16 as default because PTX does not\n+  // support 8-bit mov.\n+  numBits = numBits < 16 ? 16 : numBits;\n   auto *zero = newConstantOperand(0);\n-  auto numBits = opr->constraint[1] == 'r' ? 32 : 64;\n   auto &init = create<>(\"mov\")->o(\"u\" + std::to_string(numBits));\n   init(opr, zero);\n }\n \n-PTXBuilder::Operand *PTXBuilder::newOperand(StringRef constraint, bool init) {\n+PTXBuilder::Operand *PTXBuilder::newOperand(StringRef constraint, bool init,\n+                                            int numBits) {\n   // Constraint should be something like \"=r\"\n   assert(!constraint.empty() && constraint[0] == '=');\n   auto *opr = newOperand();\n   opr->idx = oprCounter++;\n   opr->constraint = constraint;\n   if (init) {\n-    initOperand(opr);\n+    initOperand(opr, numBits);\n   }\n   return opr;\n }"}]