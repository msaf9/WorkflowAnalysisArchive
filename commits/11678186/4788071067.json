[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "file_content_changes": "@@ -99,17 +99,17 @@ struct FuncOpConversion : public FuncOpConversionBase {\n         this->getTypeConverter()->convertType(rewriter.getI8Type()), 3);\n     // 1. Modify the function type to add the new argument.\n     auto funcTy = funcOp.getFunctionType();\n-    auto amendedInputTy = llvm::to_vector<4>(funcTy.getInputs());\n+    auto amendedInputTy = llvm::to_vector(funcTy.getInputs());\n     amendedInputTy.push_back(ptrTy);\n     auto amendedFuncTy = FunctionType::get(funcTy.getContext(), amendedInputTy,\n                                            funcTy.getResults());\n     // 2. Modify the function attributes to disable inline\n-    SmallVector<NamedAttribute, 4> amendedAttrs;\n+    SmallVector<NamedAttribute> amendedAttrs;\n     amendedAttrs.push_back(\n         rewriter.getNamedAttr(\"noinline\", rewriter.getBoolAttr(true)));\n     filterFuncAttributes(funcOp, /*filterArgAttrs=*/true, amendedAttrs);\n     // 3. Modify the argument attributes to add the new argument.\n-    auto amendedArgAttrs = llvm::to_vector<4>(funcOp.getAllArgAttrs());\n+    auto amendedArgAttrs = llvm::to_vector(funcOp.getAllArgAttrs());\n     amendedArgAttrs.emplace_back(DictionaryAttr::get(ctx));\n     amendedAttrs.push_back(rewriter.getNamedAttr(\n         funcOp.getArgAttrsAttrName(), rewriter.getArrayAttr(amendedArgAttrs)));\n@@ -216,7 +216,7 @@ struct CallOpConversion : public ConvertOpToLLVMPattern<triton::CallOp> {\n     // Pack the result types into a struct.\n     Type packedResult = nullptr;\n     unsigned numResults = callOp.getNumResults();\n-    auto resultTypes = llvm::to_vector<4>(callOp.getResultTypes());\n+    auto resultTypes = llvm::to_vector(callOp.getResultTypes());\n \n     if (numResults != 0) {\n       if (!(packedResult =\n@@ -234,7 +234,7 @@ struct CallOpConversion : public ConvertOpToLLVMPattern<triton::CallOp> {\n   getCallOpResults(triton::CallOp callOp, LLVM::CallOp newCallOp,\n                    ConversionPatternRewriter &rewriter) const {\n     auto numResults = callOp.getNumResults();\n-    SmallVector<Value, 4> results;\n+    SmallVector<Value> results;\n     if (numResults < 2) {\n       // If < 2 results, packing did not do anything and we can just return.\n       results.append(newCallOp.result_begin(), newCallOp.result_end());"}]