[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "file_content_changes": "@@ -293,12 +293,9 @@ struct ConvertLayoutOpConversion\n       }\n \n       if (needTrans) {\n-        auto [isARow, isBRow, isAVec4, isBVec4, _] =\n-            mma.decodeVoltaLayoutStates();\n-        DotOpMmaV1ConversionHelper helper(mma);\n         // do transpose\n-        int numM = helper.getElemsM(mma.getWarpsPerCTA()[0], shape[0], isARow,\n-                                    isAVec4);\n+        auto aEncoding = DotOperandEncodingAttr::get(mma.getContext(), 0, mma);\n+        int numM = aEncoding.getMMAv1NumOuter(shape);\n         int numN = accumSizePerThread / numM;\n \n         for (int r = 0; r < numM; r++) {"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.cpp", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "file_content_changes": "@@ -422,23 +422,6 @@ DotOpMmaV1ConversionHelper::getMNCoords(Value thread,\n   return coords; // {M,N} in row-major\n }\n \n-void DotOpMmaV1ConversionHelper::AParam::build(bool isARow) {\n-  int packSize0 = (isARow || isAVec4) ? 1 : 2;\n-  int repM = 2 * packSize0;\n-  int repK = 1;\n-  int spwM = fpw[0] * 4 * repM;\n-  rep.assign({repM, 0, repK});\n-  spw.assign({spwM, 0, 1});\n-  vec = 2 * rep[0];\n-}\n-\n-void DotOpMmaV1ConversionHelper::BParam::build(bool isBRow) {\n-  int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n-  rep.assign({0, 2 * packSize1, 1});\n-  spw.assign({0, fpw[1] * 4 * rep[1], 1});\n-  vec = 2 * rep[1];\n-}\n-\n std::tuple<int, int>\n DotOpMmaV2ConversionHelper::getRepMN(const RankedTensorType &tensorTy) {\n   auto mmaLayout = tensorTy.getEncoding().cast<MmaEncodingAttr>();"}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotOpHelpers.h", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "file_content_changes": "@@ -46,38 +46,6 @@ struct DotOpMmaV1ConversionHelper {\n   explicit DotOpMmaV1ConversionHelper(MmaEncodingAttr mmaLayout)\n       : mmaLayout(mmaLayout), wpt(mmaLayout.getWarpsPerCTA()) {}\n \n-  // Help to share some variables across multiple functions for A.\n-  // TODO[Superjomn]: refactor and restrict this to only use in DotOp\n-  // conversion.\n-  struct AParam {\n-    SmallVector<int> rep;\n-    SmallVector<int> spw;\n-    bool isAVec4{};\n-    int vec{}; // This could only used in DotOp, not in\n-               // loadA/loadB/TypeConverter\n-\n-    AParam(bool isARow, bool isAVec4) : isAVec4(isAVec4) { build(isARow); }\n-\n-  private:\n-    void build(bool isARow);\n-  };\n-\n-  // Help to share some variables across multiple functions for A.\n-  // TODO[Superjomn]: refactor and restrict this to only use in DotOp\n-  // conversion.\n-  struct BParam {\n-    SmallVector<int> rep;\n-    SmallVector<int> spw;\n-    bool isBVec4{};\n-    int vec{}; // This could only used in DotOp, not in\n-               // loadA/loadB/TypeConverter\n-\n-    BParam(bool isBRow, bool isBVec4) : isBVec4(isBVec4) { build(isBRow); }\n-\n-  private:\n-    void build(bool isBRow);\n-  };\n-\n   static ArrayRef<unsigned> getMmaInstrShape() { return instrShape; }\n \n   static Type getMmaRetType(TensorType operand) {\n@@ -94,12 +62,6 @@ struct DotOpMmaV1ConversionHelper {\n     return struct_ty(SmallVector<Type>{vecTy});\n   }\n \n-  // int numElemsPerThreadA(ArrayRef<int64_t> shape, bool isARow, bool isAVec4,\n-  //                        int vec) const;\n-\n-  // int numElemsPerThreadB(ArrayRef<int64_t> shape, bool isBRow, bool isBVec4,\n-  //                        int vec) const;\n-\n   // Loading $a from smem to registers, returns a LLVM::Struct.\n   Value loadA(Value tensor, const SharedMemoryObject &smemObj, Value thread,\n               Location loc, TritonGPUToLLVMTypeConverter *converter,\n@@ -129,15 +91,6 @@ struct DotOpMmaV1ConversionHelper {\n       Value llStruct, int NK, ConversionPatternRewriter &rewriter,\n       TritonGPUToLLVMTypeConverter *typeConverter, Type type) const;\n \n-  // Get the number of elements of this thread in M axis. The N axis could be\n-  // further deduced with the accSize / elemsM. \\param wpt: the wpt in M axis\n-  // \\param M: the shape in M axis\n-  int getElemsM(int wpt, int M, bool isARow, bool isAVec4) {\n-    DotOpMmaV1ConversionHelper::AParam param(isARow, isAVec4);\n-    int shapePerCTAM = param.spw[0] * wpt;\n-    return M / shapePerCTAM * param.rep[0];\n-  }\n-\n   using CoordTy = SmallVector<Value>;\n   // Get the coordinates(m,n) of the elements emit by a thread in accumulator.\n   static SmallVector<CoordTy>"}]