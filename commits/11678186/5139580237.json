[{"filename": "CMakeLists.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -215,6 +215,7 @@ if(TRITON_BUILD_PYTHON_MODULE)\n     ${conversion_libs}\n \n     # optimizations\n+    MLIRBytecodeWriter\n     MLIRPass\n     MLIRTransforms\n     MLIRLLVMDialect"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "file_content_changes": "@@ -3,6 +3,8 @@\n #include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/IR/Verifier.h\"\n \n+#include \"mlir/Bytecode/BytecodeWriter.h\"\n+\n #include \"mlir/Conversion/Passes.h\"\n #include \"mlir/Pass/Pass.h\"\n #include \"mlir/Pass/PassManager.h\"\n@@ -348,6 +350,14 @@ void init_triton_ir(py::module &&m) {\n              self.print(os);\n              return str;\n            })\n+      .def(\"bytecode\",\n+           [](mlir::ModuleOp &self) -> py::bytearray {\n+             std::string bytecode;\n+             llvm::raw_string_ostream os(bytecode);\n+             if (failed(mlir::writeBytecodeToFile(self, os)))\n+               throw std::runtime_error(\"Failed to write module bytecode\");\n+             return py::bytearray(bytecode);\n+           })\n       .def(\"push_back\",\n            [](mlir::ModuleOp &self, mlir::triton::FuncOp &funcOp) -> void {\n              self.push_back(funcOp);"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "file_content_changes": "@@ -467,6 +467,21 @@ def broadcast_kernel(x_ptr, y_ptr, y_broadcasted_ptr, M: tl.constexpr, N: tl.con\n     broadcast_kernel[(1,)](x_tri, y_tri, y_broadcasted_tri, M=M, N=N)\n     assert (y_broadcasted_np == to_numpy(y_broadcasted_tri)).all()\n \n+# ------------------\n+# test invalid slice\n+# ------------------\n+\n+\n+def test_invalid_slice():\n+    dst = torch.empty(128, device='cuda')\n+\n+    @triton.jit\n+    def _kernel(dst):\n+        dst[10:]\n+\n+    with pytest.raises(triton.CompilationError, match='unsupported tensor index'):\n+        _kernel[(1,)](dst=dst)\n+\n \n # ----------------\n # test expand_dims"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -711,7 +711,7 @@ def __getitem__(self, slices, _builder=None):\n         for dim, sl in enumerate(slices):\n             if isinstance(sl, constexpr) and sl.value is None:\n                 ret = semantic.expand_dims(ret, dim, _builder)\n-            elif sl == slice(None, None, None):\n+            elif isinstance(sl, slice) and sl.start is None and sl.stop is None and sl.step is None:\n                 pass\n             else:\n                 assert False, f\"unsupported tensor index: {sl}\""}]