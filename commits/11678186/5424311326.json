[{"filename": "lib/Dialect/TritonGPU/Transforms/RemoveLayoutConversions.cpp", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "file_content_changes": "@@ -472,31 +472,21 @@ class MoveConvertOutOfLoop : public mlir::RewritePattern {\n     for (const auto &arg : llvm::enumerate(forOp.getRegionIterArgs()))\n       mapping.map(arg.value(), newForOp.getRegionIterArgs()[arg.index()]);\n     mapping.map(origConversion.getResult(), newForOp.getRegionIterArgs()[i]);\n-    // the iter arg of interest may have other uses than the conversion\n-    // we're hoisting out of the loop. If that's the case we will\n-    // need to add extra conversions for all uses... which is only useful\n-    // if these extra conversions can be removed by another pattern\n-    auto oldArg = forOp.getRegionIterArgs()[i];\n-    auto newArg = newForOp.getRegionIterArgs()[i];\n-    auto newArgFallback = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-        newForOp.getLoc(), origType, newArg);\n \n     mapping.map(forOp.getInductionVar(), newForOp.getInductionVar());\n     for (Operation &op : forOp.getBody()->without_terminator()) {\n       if (&op == (Operation *)(&origConversion))\n         continue;\n       Operation *newOp = rewriter.clone(op, mapping);\n-      if (find(oldArg.getUsers(), &op) != oldArg.getUsers().end())\n-        newOp->replaceUsesOfWith(newArg, newArgFallback);\n     }\n-\n     // create yield, inserting conversions if necessary\n     auto yieldOp = forOp.getBody()->getTerminator();\n     SmallVector<Value, 4> newYieldArgs;\n     for (Value arg : yieldOp->getOperands())\n       newYieldArgs.push_back(mapping.lookup(arg));\n-    newYieldArgs[i] = rewriter.create<triton::gpu::ConvertLayoutOp>(\n-        yieldOp->getLoc(), newType, newYieldArgs[i]);\n+    if (newYieldArgs[i].getType() != newType)\n+      newYieldArgs[i] = rewriter.create<triton::gpu::ConvertLayoutOp>(\n+          yieldOp->getLoc(), newType, newYieldArgs[i]);\n     rewriter.create<scf::YieldOp>(forOp.getLoc(), newYieldArgs);\n \n     // replace"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Utility.cpp", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "file_content_changes": "@@ -297,7 +297,7 @@ LogicalResult canMoveOutOfLoop(BlockArgument arg,\n   // 2. There is only a single conversion\n   // 3. Moving this conversion out of the loop will not generate any extra\n   // non-removable conversion\n-  DenseSet<Type> cvtTypes;\n+  SetVector<RankedTensorType> cvtTypes;\n   SetVector<Operation *> others;\n   auto oldType = arg.getType().cast<RankedTensorType>();\n   for (auto user : arg.getUsers()) {\n@@ -326,23 +326,34 @@ LogicalResult canMoveOutOfLoop(BlockArgument arg,\n     // Second condition\n     if (others.empty())\n       return success();\n-    // Third condition: not complete\n+    // Third condition - part 1:\n     // If the other or the cvt is in the different block, we cannot push the\n     // conversion forward or backward\n     for (auto *cvt : cvts) {\n       if (cvt->getBlock() != forOp.getBody())\n         return failure();\n     }\n-    auto srcEncoding = oldType.getEncoding();\n+    auto targetEncoding = cvtTypes.front().getEncoding();\n     for (auto *other : others) {\n+      // Third condition - part 2:\n+      // If the other non-cvt op is in the different block, we cannot push the\n+      // conversion forward or backward\n       if (other->getBlock() != forOp.getBody())\n         return failure();\n+      // Third condition - part 3:\n+      // %0 (enc1) = cvt %arg (enc0)\n+      // other %0 (enc1), %1 (enc0) => other %0 (enc1), %1 (enc1)\n+      // Check if %2 (enc1) = cvt %1 (enc0) can be eliminated\n       SetVector<Operation *> processed;\n       SetVector<Attribute> layout;\n       llvm::MapVector<Value, Attribute> toConvert;\n-      if (simulateBackwardRematerialization(other, processed, layout, toConvert,\n-                                            srcEncoding) > 0)\n-        return failure();\n+      for (auto operand : other->getOperands()) {\n+        auto argOp = operand.getDefiningOp();\n+        if (argOp && !isa<triton::gpu::ConvertLayoutOp>(argOp) &&\n+            simulateBackwardRematerialization(argOp, processed, layout,\n+                                              toConvert, targetEncoding) > 0)\n+          return failure();\n+      }\n     }\n     return success();\n   }"}]