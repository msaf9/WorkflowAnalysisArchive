[{"filename": "python/src/triton.cc", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "file_content_changes": "@@ -319,28 +319,22 @@ void init_triton_ir(py::module &&m) {\n   m.def(\n       \"parse_mlir_module\",\n       [](const std::string &inputFilename, mlir::MLIRContext &context) {\n-        // open file\n-        std::string errorMessage;\n-        auto input = mlir::openInputFile(inputFilename, &errorMessage);\n-        if (!input)\n-          throw std::runtime_error(errorMessage);\n-\n         // initialize registry\n         mlir::DialectRegistry registry;\n         registry.insert<mlir::triton::TritonDialect,\n                         mlir::triton::gpu::TritonGPUDialect,\n                         mlir::math::MathDialect, mlir::arith::ArithmeticDialect,\n                         mlir::StandardOpsDialect, mlir::scf::SCFDialect>();\n-\n         context.appendDialectRegistry(registry);\n         context.loadAllAvailableDialects();\n-        context.allowUnregisteredDialects();\n \n         // parse module\n-        llvm::SourceMgr sourceMgr;\n-        sourceMgr.AddNewSourceBuffer(std::move(input), llvm::SMLoc());\n         mlir::OwningOpRef<mlir::ModuleOp> module(\n-            mlir::parseSourceFile(sourceMgr, &context));\n+            mlir::parseSourceFile(inputFilename, &context));\n+        // locations are incompatible with ptx < 7.5 !\n+        module->walk([](mlir::Operation *op) {\n+          op->setLoc(mlir::UnknownLoc::get(op->getContext()));\n+        });\n         if (!module)\n           throw std::runtime_error(\"Parse MLIR file failed.\");\n "}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1282,17 +1282,17 @@ def make_fn_cache_key(fn_hash, signature, configs, constants, num_warps, num_sta\n def read_or_execute(cache_manager, force_compile, file_name, metadata,\n                     run_if_found: Callable[[str], bytes] = None,\n                     run_if_not_found: Callable = None):\n+    suffix = file_name.split(\".\")[1]\n     if not force_compile and cache_manager.has_file(file_name):\n       module = run_if_found(cache_manager._make_path(file_name))\n       data = module if isinstance(module, bytes) else str(module).encode(\"utf-8\")\n       md5 = hashlib.md5(data).hexdigest()\n-      suffix = file_name.split(\".\")[1]\n       has_changed = metadata and md5 != metadata[\"md5\"][suffix]\n       return module, md5, has_changed, True\n     module = run_if_not_found()\n     data = module if isinstance(module, bytes) else str(module).encode(\"utf-8\")\n     md5 = hashlib.md5(data).hexdigest()\n-    cache_manager.put(data, file_name, True)\n+    cache_manager.put(data, file_name, True if isinstance(data, bytes) else data)\n     return module, md5, True, False\n \n "}]