[{"filename": "include/triton/codegen/pass.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "file_content_changes": "@@ -25,18 +25,16 @@ namespace driver{\n }\n }\n \n-namespace triton{\n-namespace codegen{\n+namespace triton {\n+namespace codegen {\n \n // TODO:\n // There should be a proper pass manager there!\n-std::pair<std::unique_ptr<llvm::Module>, bool> add_passes_to_emit_bin(ir::module &ir, llvm::LLVMContext& ctx,\n-                                                                      codegen::target* target,\n-                                                                      int sm, int num_warps,\n-                                                                      int num_stages, int &shared_static);\n-\n+std::unique_ptr<llvm::Module> add_passes_to_emit_bin(\n+    ir::module &ir, llvm::LLVMContext &ctx, codegen::target *target, int sm,\n+    int num_warps, int num_stages, int &shared_static);\n \n-}\n-}\n+}  // namespace codegen\n+}  // namespace triton\n \n #endif"}, {"filename": "include/triton/codegen/selection/generator.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "file_content_changes": "@@ -209,14 +209,16 @@ class generator: public ir::visitor, public analysis::layout_visitor {\n   void visit_layout_scanline(analysis::scanline_layout*);\n   void visit_layout_shared(analysis::shared_layout*);\n \n-  std::unique_ptr<Module> get_libdevice_module();\n-  void init_libdevice_module();\n+  // libdevice\n+  bool has_libdevice_functions() { return has_libdevice_functions_; }\n \n-private:\n+  void init_libdevice_functions() { has_libdevice_functions_ = true; }\n+\n+ private:\n   LLVMContext *ctx_;\n   Builder* builder_;\n   Module *mod_;\n-  std::unique_ptr<Module> libdevice_mod_;\n+  bool has_libdevice_functions_ = false;\n \n   analysis::axes *a_axes_;\n   analysis::swizzle *swizzle_;"}, {"filename": "include/triton/driver/llvm.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -10,7 +10,8 @@ namespace driver{\n \n void init_llvm();\n std::string path_to_ptxas(int& version);\n-std::string llir_to_ptx(llvm::Module* module, int cc, int version, bool link);\n+std::string path_to_libdevice();\n+std::string llir_to_ptx(llvm::Module* module, int cc, int version);\n std::string ptx_to_cubin(const std::string& ptx, const std::string& ptxas_path, int cc);\n CUmodule ptx_to_cumodule(const std::string& ptx, int cc);\n std::string llir_to_amdgpu(llvm::Module* module, const std::string& proc);"}, {"filename": "lib/codegen/pass.cc", "status": "modified", "additions": 63, "deletions": 5, "changes": 68, "file_content_changes": "@@ -14,19 +14,77 @@\n #include \"triton/codegen/transform/pipeline.h\"\n #include \"triton/codegen/transform/prefetch.h\"\n #include \"triton/codegen/transform/inline.h\"\n+#include \"triton/driver/llvm.h\"\n #include \"triton/ir/function.h\"\n #include \"triton/ir/module.h\"\n #include \"triton/ir/print.h\"\n+#include \"llvm/IR/Constants.h\"\n #include \"llvm/IR/Module.h\"\n #include \"llvm/IR/LegacyPassManager.h\"\n #include \"llvm/IR/Verifier.h\"\n+#include \"llvm/IRReader/IRReader.h\"\n+#include \"llvm/Transforms/IPO.h\"\n+#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n #include \"llvm/Linker/Linker.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n+\n namespace triton {\n namespace codegen {\n \n+static std::unique_ptr<llvm::Module> link_libdevice(\n+    ir::module& ir, llvm::LLVMContext& ctx,\n+    std::unique_ptr<llvm::Module> llvm) {\n+  std::string module_path = driver::path_to_libdevice();\n+  llvm::SMDiagnostic err;\n+  auto libdevice_mod = llvm::parseIRFile(module_path, err, ctx);\n+  if (!libdevice_mod) {\n+    throw std::runtime_error(\"Failed to load libdevice at \" + module_path);\n+  }\n+\n+  // Set triple and data layout of libdevice to match the target module\n+  if (llvm::Linker::linkModules(*llvm, std::move(libdevice_mod))) {\n+    throw std::runtime_error(\"Failed to link libdevice at \" + module_path);\n+  }\n+\n+  // Internalize all device functions\n+  std::set<llvm::StringRef> function_names;\n+  for (auto& func : ir.get_function_list()) {\n+    function_names.insert(func->get_name());\n+  }\n+  llvm::legacy::PassManager pass;\n+  pass.add(llvm::createInternalizePass([&](const llvm::GlobalValue& v) -> bool {\n+    if (function_names.count(v.getName()) != 0) {\n+      return true;\n+    }\n+    return false;\n+  }));\n+\n+  // Add nvvm reflect flags to llvm module\n+  // (i32 4 indicates that the value set here overrides the value in another\n+  // module we link with. See the LangRef <LangRef.html#module-flags-metadata>\n+  // for details.)\n+  llvm::Type* I32 = llvm::Type::getInt32Ty(ctx);\n+  llvm::Metadata* md_four =\n+      llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 4));\n+  llvm::Metadata* md_name = llvm::MDString::get(ctx, \"nvvm-reflect-ftz\");\n+  llvm::Metadata* md_one =\n+      llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 1));\n+  llvm::MDNode* reflect = llvm::MDNode::get(ctx, {md_four, md_name, md_one});\n+  llvm->addModuleFlag(reflect);\n+\n+  // Cleanup unused functions caused by reflection\n+  llvm::PassManagerBuilder builder;\n+  builder.OptLevel = 3;\n+  builder.SizeLevel = 0;\n+  builder.populateModulePassManager(pass);\n+\n+  pass.run(*llvm);\n+  return llvm;\n+}\n+\n // TODO:\n // There should be a proper pass manager there!\n-std::pair<std::unique_ptr<llvm::Module>, bool> add_passes_to_emit_bin(\n+std::unique_ptr<llvm::Module> add_passes_to_emit_bin(\n     ir::module& ir, llvm::LLVMContext& ctx, codegen::target* target, int cc,\n     int num_warps, int num_stages, int& shared_static) {\n   // generate llvm code\n@@ -93,12 +151,12 @@ std::pair<std::unique_ptr<llvm::Module>, bool> add_passes_to_emit_bin(\n   // ir.print(std::cout);\n   isel.visit(ir, *llvm);\n   shared_static = allocation.allocated_size();\n-  bool link = false;\n-  if (isel.get_libdevice_module()) {\n-    llvm::Linker::linkModules(*llvm, std::move(isel.get_libdevice_module()));\n+  if (isel.has_libdevice_functions()) {\n+    llvm = link_libdevice(ir, ctx, std::move(llvm));\n   }\n-  return std::make_pair(std::move(llvm), link);\n+  return llvm;\n }\n \n+\n } // namespace codegen\n } // namespace triton"}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "file_content_changes": "@@ -20,8 +20,6 @@\n #include \"llvm/IR/BasicBlock.h\"\n #include \"llvm/IR/Attributes.h\"\n #include \"llvm/IR/InlineAsm.h\"\n-#include \"llvm/IRReader/IRReader.h\"\n-#include \"llvm/Support/SourceMgr.h\"\n #include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\n \n namespace triton{\n@@ -1102,15 +1100,6 @@ void generator::visit_exp_inst(ir::exp_inst* x){\n   }\n }\n \n-std::unique_ptr<Module> generator::get_libdevice_module() {\n-  StringRef module_path = \"/usr/local/cuda/nvvm/libdevice/libdevice.10.bc\";\n-  SMDiagnostic err;\n-  auto libdevice_mod = parseIRFile(module_path, err, *ctx_);\n-  return libdevice_mod;\n-}\n-\n-void generator::init_libdevice_module() {\n-}\n \n /**\n  * \\brief Code Generation for `cos`\n@@ -1120,14 +1109,15 @@ void generator::visit_cos_inst(ir::cos_inst* x){\n   //FunctionType *fn_ty = FunctionType::get(f32_ty, tys, false);\n   //InlineAsm *cos = InlineAsm::get(fn_ty, \"cos.approx.f32 $0, $0;\", \"=f,0\", false);\n   // Replace it with acos to test libdevice for now\n+  init_libdevice_functions();\n   FunctionType *FT =\n       FunctionType::get(f32_ty, f32_ty, false);\n   Function *F = llvm::cast<llvm::Function>(\n       mod_->getOrInsertFunction(\"__nv_cosf\", FT).getCallee());\n   for(auto idx: idxs_.at(x)){\n     vals_[x][idx] = call(F, std::vector<llvm::Value*>{vals_[x->get_operand(0)][idx]});\n   }\n- }\n+}\n \n /**\n  * \\brief Code Generation for `umulhi`"}, {"filename": "lib/driver/llvm.cc", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "file_content_changes": "@@ -25,6 +25,7 @@\n #endif\n #include <memory>\n #include <regex>\n+#include <filesystem>\n #include \"triton/driver/llvm.h\"\n #include \"triton/driver/dispatch.h\"\n #include \"triton/driver/error.h\"\n@@ -151,7 +152,21 @@ int vptx(int version){\n   throw std::runtime_error(\"Triton requires CUDA 10+\");\n }\n \n-std::string llir_to_ptx(llvm::Module* module, int cc, int version, bool link){\n+std::string path_to_libdevice() {\n+  // search pathes for libdevice\n+  std::string triton_libdevice = tools::getenv(\"TRITON_LIBDEVICE_PATH\");\n+  if (triton_libdevice.empty() || !std::filesystem::exists(triton_libdevice)) {\n+    triton_libdevice = \"/usr/local/cuda/nvvm/libdevice/libdevice.10.bc\";\n+    if (!std::filesystem::exists(triton_libdevice)) {\n+      throw std::runtime_error(\n+          \"`libdevice` was not found in TRITON_LIBDEVICE_PATH or \"\n+          \"/usr/local/cuda/nvvm/libdevice/\");\n+    }\n+  }\n+  return triton_libdevice;\n+}\n+\n+std::string llir_to_ptx(llvm::Module* module, int cc, int version) {\n   // LLVM version in use may not officially support target hardware\n   int max_nvvm_cc = 75;\n   int max_nvvm_ptx = 74;\n@@ -199,24 +214,8 @@ std::string llir_to_ptx(llvm::Module* module, int cc, int version, bool link){\n     module->setDataLayout(machine->createDataLayout());\n   else\n     module->setDataLayout(layout);\n-  \n-  std::set<llvm::StringRef> function_names; \n-  // emit machine code\n-  for (llvm::Function &f : module->functions()) {\n-    f.addFnAttr(llvm::Attribute::AlwaysInline);\n-    function_names.insert(f.getFunction().getName());\n-  }\n \n   llvm::legacy::PassManager pass;\n-  if (link) {\n-    pass.add(\n-        llvm::createInternalizePass([&](const llvm::GlobalValue& v) -> bool {\n-          if (function_names.count(v.getName()) != 0) {\n-            return true;\n-          }\n-          return false;\n-        }));\n-  }\n   llvm::raw_svector_ostream stream(buffer);\n   // emit\n   machine->addPassesToEmitFile(pass, stream, nullptr, llvm::CodeGenFileType::CGFT_AssemblyFile);\n@@ -231,7 +230,6 @@ std::string llir_to_ptx(llvm::Module* module, int cc, int version, bool link){\n   return result;\n }\n \n-\n std::string ptx_to_cubin(const std::string& ptx, const std::string& ptxas, int cc) {\n   // compile ptx with ptxas\n   char _fsrc[L_tmpnam];"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "file_content_changes": "@@ -19,7 +19,6 @@\n #include <stdexcept>\n #include <string>\n #include \"llvm/IR/Module.h\"\n-#include \"llvm/IR/LegacyPassManager.h\"\n #include \"llvm/IR/Verifier.h\"\n \n namespace py = pybind11;\n@@ -470,8 +469,6 @@ std::tuple<uint64_t, uint64_t, uint64_t, uint64_t> hip_load_binary(const std::st\n std::tuple<std::string, asm_map_t, int> cu_compile_ttir(const std::string& name, ir::module &ir, \n                                                                uint64_t device, int num_warps, int num_stages,\n                                                                asm_map_t &asm_map){\n-\n-  int n_shared_bytes;\n   py::gil_scoped_release allow_threads;\n   llvm::LLVMContext ctx;\n   // device properties\n@@ -483,14 +480,16 @@ std::tuple<std::string, asm_map_t, int> cu_compile_ttir(const std::string& name,\n   std::string ptxas_path = drv::path_to_ptxas(version);\n   // Triton-IR -> NVPTX LLVM-IR\n   triton::codegen::nvidia_cu_target target(cc);\n-  auto[llvm, link] = triton::codegen::add_passes_to_emit_bin(ir, ctx, &target, cc, num_warps, num_stages, n_shared_bytes);\n+  int n_shared_bytes;\n+  auto llvm = triton::codegen::add_passes_to_emit_bin(\n+      ir, ctx, &target, cc, num_warps, num_stages, n_shared_bytes);\n   std::string tmp;\n   llvm::raw_string_ostream llir(tmp);\n   llir << *llvm;\n   llir.flush();\n   asm_map[\"llir\"] = py::cast(tmp);\n   // LLVM-IR -> PTX\n-  std::string ptx = drv::llir_to_ptx(llvm.get(), cc, version, link);\n+  std::string ptx = drv::llir_to_ptx(llvm.get(), cc, version);\n   asm_map[\"ptx\"] = py::cast(ptx);\n   // PTX -> Binary\n   std::string cubin = drv::ptx_to_cubin(ptx, ptxas_path, cc);\n@@ -509,7 +508,8 @@ std::tuple<std::string, asm_map_t, int> hip_compile_ttir(const std::string& name\n   // Triton-IR -> NVPTX LLVM-IR\n   triton::codegen::amd_cl_target target;\n   int n_shared_bytes;\n-  auto[llvm, link] = triton::codegen::add_passes_to_emit_bin(ir, ctx, &target, 70, num_warps, num_stages, n_shared_bytes);\n+  auto llvm = triton::codegen::add_passes_to_emit_bin(\n+      ir, ctx, &target, 70, num_warps, num_stages, n_shared_bytes);\n   std::string tmp;\n   llvm::raw_string_ostream llir(tmp);\n   llir << *llvm;"}]