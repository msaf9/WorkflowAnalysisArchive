[{"filename": "include/triton/Conversion/TritonGPUToLLVM/PtxAsmFormat.h", "status": "modified", "additions": 37, "deletions": 64, "changes": 101, "file_content_changes": "@@ -201,10 +201,17 @@ struct PTXInstrCommon {\n   // clang-format on\n \n   // Set operands of this instruction.\n-  PTXInstrExecution &operator()(llvm::ArrayRef<Operand *> oprs);\n+  PTXInstrExecution &operator()(llvm::ArrayRef<Operand *> oprs,\n+                                bool onlyAttachMLIRArgs = false);\n \n protected:\n-  PTXInstrExecution &call(llvm::ArrayRef<Operand *> oprs);\n+  // \"Call\" the instruction with operands.\n+  // \\param oprs The operands of this instruction.\n+  // \\param onlyAttachMLIRArgs Indicate that it simply attach the MLIR Arguments\n+  // to the inline Asm without generating the operand ids(such as $0, $1) in PTX\n+  // code.\n+  PTXInstrExecution &call(llvm::ArrayRef<Operand *> oprs,\n+                          bool onlyAttachMLIRArgs = false);\n \n   PTXBuilder *builder{};\n   llvm::SmallVector<std::string, 4> instrParts;\n@@ -234,70 +241,18 @@ template <class ConcreteT> struct PTXInstrBase : public PTXInstrCommon {\n \n struct PTXInstr : public PTXInstrBase<PTXInstr> {\n   using PTXInstrBase<PTXInstr>::PTXInstrBase;\n-};\n-\n-// A helper for PTX ld/st instruction.\n-// Usage:\n-// PtxIOInstr store(\"st\");\n-// store.predicate(pValue).global().v(32).b(1); // @%0 st.global.v32.b1\n-// store.addAddr(addrValue, \"l\", off);\n-struct PTXIOInstr : public PTXInstrBase<PTXIOInstr> {\n-  using PTXInstrBase<PTXIOInstr>::PTXInstrBase;\n-\n-  // Add \".global\" suffix to instruction\n-  PTXIOInstr &global(bool predicate = true) {\n-    o(\"global\", predicate);\n-    return *this;\n-  }\n-\n-  // Add \".shared\" suffix to instruction\n-  PTXIOInstr &shared(bool predicate = true) {\n-    o(\"shared\", predicate);\n-    return *this;\n-  }\n-\n-  // Add \".v\" suffix to instruction\n-  PTXIOInstr &v(int vecWidth, bool predicate = true) {\n-    if (vecWidth > 1) {\n-      o(\"v\" + std::to_string(vecWidth), predicate);\n-    }\n-    return *this;\n-  }\n \n-  // Add \".b\" suffix to instruction\n-  PTXIOInstr &b(int width) {\n-    o(\"b\" + std::to_string(width));\n-    return *this;\n-  }\n-};\n-\n-struct PTXCpAsyncInstrBase : public PTXInstrBase<PTXCpAsyncInstrBase> {\n-  explicit PTXCpAsyncInstrBase(PTXBuilder *builder)\n-      : PTXInstrBase(builder, \"cp.async\") {}\n-};\n+  // Append a \".global\" to the instruction.\n+  PTXInstr &global();\n \n-struct PTXCpAsyncCommitGroupInstr : public PTXCpAsyncInstrBase {\n-  explicit PTXCpAsyncCommitGroupInstr(PTXBuilder *builder)\n-      : PTXCpAsyncInstrBase(builder) {\n-    o(\"commit_group\");\n-  }\n-};\n+  // Append a \".shared\" to the instruction.\n+  PTXInstr &shared();\n \n-struct PTXCpAsyncWaitGroupInstr : public PTXCpAsyncInstrBase {\n-  explicit PTXCpAsyncWaitGroupInstr(PTXBuilder *builder)\n-      : PTXCpAsyncInstrBase(builder) {\n-    o(\"wait_group\");\n-  }\n-};\n+  // Append a \".v[0-9]+\" to the instruction\n+  PTXInstr &v(int vecWidth, bool predicate = true);\n \n-struct PTXCpAsyncLoadInstr : public PTXCpAsyncInstrBase {\n-  explicit PTXCpAsyncLoadInstr(PTXBuilder *builder,\n-                               triton::CacheModifier modifier)\n-      : PTXCpAsyncInstrBase(builder) {\n-    o(triton::stringifyCacheModifier(modifier).str());\n-    o(\"shared\");\n-    o(\"global\");\n-  }\n+  // Append a\".b[0-9]+\" to the instruction\n+  PTXInstr &b(int width);\n };\n \n // Record the operands and context for \"launching\" a PtxInstr.\n@@ -308,8 +263,10 @@ struct PTXInstrExecution {\n \n   PTXInstrExecution() = default;\n   explicit PTXInstrExecution(PTXInstrCommon *instr,\n-                             llvm::ArrayRef<Operand *> oprs)\n-      : argsInOrder(oprs.begin(), oprs.end()), instr(instr) {}\n+                             llvm::ArrayRef<Operand *> oprs,\n+                             bool onlyAttachMLIRArgs)\n+      : argsInOrder(oprs.begin(), oprs.end()), instr(instr),\n+        onlyAttachMLIRArgs(onlyAttachMLIRArgs) {}\n \n   // Prefix a predicate to the instruction.\n   PTXInstrExecution &predicate(mlir::Value value, StringRef constraint = \"b\") {\n@@ -330,6 +287,22 @@ struct PTXInstrExecution {\n \n   PTXInstrCommon *instr{};\n   Operand *pred{};\n+  bool onlyAttachMLIRArgs{};\n+};\n+\n+//// =============================== Some instruction wrappers\n+///===============================\n+// We add the wrappers to make the usage more intuitive by avoiding mixing the\n+// PTX code with some trivial C++ code.\n+\n+struct PTXCpAsyncLoadInstr : PTXInstrBase<PTXCpAsyncLoadInstr> {\n+  explicit PTXCpAsyncLoadInstr(PTXBuilder *builder,\n+                               triton::CacheModifier modifier)\n+      : PTXInstrBase(builder, \"cp.async\") {\n+    o(triton::stringifyCacheModifier(modifier).str());\n+    o(\"shared\");\n+    o(\"global\");\n+  }\n };\n \n } // namespace triton"}, {"filename": "lib/Conversion/TritonGPUToLLVM/PtxAsmFormat.cpp", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "file_content_changes": "@@ -128,28 +128,33 @@ std::string PTXBuilder::dump() const {\n   return strJoin(lines, \"\\n\\t\");\n }\n \n-PTXInstrExecution &PTXInstrCommon::call(ArrayRef<Operand *> oprs) {\n+PTXInstrExecution &PTXInstrCommon::call(ArrayRef<Operand *> oprs,\n+                                        bool onlyAttachMLIRArgs) {\n   builder->executions.emplace_back(\n-      std::make_unique<PTXInstrExecution>(this, oprs));\n+      std::make_unique<PTXInstrExecution>(this, oprs, onlyAttachMLIRArgs));\n   return *builder->executions.back();\n }\n \n-PTXInstrExecution &PTXInstrCommon::operator()(ArrayRef<Operand *> oprs) {\n-  return call(oprs);\n+PTXInstrExecution &PTXInstrCommon::operator()(ArrayRef<Operand *> oprs,\n+                                              bool onlyAttachMLIRArgs) {\n+  return call(oprs, onlyAttachMLIRArgs);\n }\n \n std::string PTXInstrExecution::dump() const {\n   std::string osStr;\n   llvm::raw_string_ostream os(osStr);\n+\n+  std::string instrRepr = strJoin(instr->instrParts, \".\");\n+  if (onlyAttachMLIRArgs)\n+    return instrRepr;\n+\n   if (pred) {\n     if (!pred->repr)\n       os << \"@\" << pred->dump() << \" \";\n     else\n       os << pred->repr(pred->idx) << \" \";\n   }\n \n-  std::string instrRepr = strJoin(instr->instrParts, \".\");\n-\n   llvm::SmallVector<std::string, 4> argReprs;\n   for (auto *arg : argsInOrder) {\n     argReprs.push_back(arg->dump());\n@@ -174,5 +179,27 @@ PTXInstrExecution::getArgList() const {\n   return args;\n }\n \n+PTXInstr &PTXInstr::global() {\n+  o(\"global\");\n+  return *this;\n+}\n+\n+PTXInstr &PTXInstr::shared() {\n+  o(\"shared\");\n+  return *this;\n+}\n+\n+PTXInstr &PTXInstr::v(int vecWidth, bool predicate) {\n+  if (vecWidth > 1) {\n+    o(\"v\" + std::to_string(vecWidth), predicate);\n+  }\n+  return *this;\n+}\n+\n+PTXInstr &PTXInstr::b(int width) {\n+  o(\"b\" + std::to_string(width));\n+  return *this;\n+}\n+\n } // namespace triton\n } // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "file_content_changes": "@@ -388,9 +388,9 @@ static Value storeShared(ConversionPatternRewriter &rewriter, Location loc,\n   const char *c = bits == 64 ? \"l\" : (bits == 16 ? \"h\" : \"r\");\n \n   PTXBuilder builder;\n-  auto &st = builder.create<PTXIOInstr>(\"st\")->shared().b(bits);\n   auto *ptrOpr = builder.newAddrOperand(ptr, \"r\");\n   auto *valOpr = builder.newOperand(val, c);\n+  auto &st = builder.create<>(\"st\")->shared().b(bits);\n   st(ptrOpr, valOpr).predicate(pred, \"b\");\n   return builder.launch(rewriter, loc, void_ty(ctx));\n }\n@@ -1005,7 +1005,6 @@ struct LoadOpConversion\n       const bool hasL2EvictPolicy = false;\n \n       PTXBuilder ptxBuilder;\n-      auto &ld = *ptxBuilder.create<PTXIOInstr>(\"ld\");\n \n       Value pred = mask ? maskElems[vecStart] : int_val(1, 1);\n \n@@ -1025,16 +1024,18 @@ struct LoadOpConversion\n           ptxBuilder.newAddrOperand(ptrElems[vecStart], \"l\", in_off);\n \n       // Define the instruction opcode\n-      ld.o(\"volatile\", op.isVolatile())\n-          .global()\n-          .o(\"ca\", op.cache() == triton::CacheModifier::CA)\n-          .o(\"cg\", op.cache() == triton::CacheModifier::CG)\n-          .o(\"L1::evict_first\",\n-             op.evict() == triton::EvictionPolicy::EVICT_FIRST)\n-          .o(\"L1::evict_last\", op.evict() == triton::EvictionPolicy::EVICT_LAST)\n-          .o(\"L1::cache_hint\", hasL2EvictPolicy)\n-          .v(nWords)\n-          .b(width);\n+      auto &ld = ptxBuilder.create<>(\"ld\")\n+                     ->o(\"volatile\", op.isVolatile())\n+                     .global()\n+                     .o(\"ca\", op.cache() == triton::CacheModifier::CA)\n+                     .o(\"cg\", op.cache() == triton::CacheModifier::CG)\n+                     .o(\"L1::evict_first\",\n+                        op.evict() == triton::EvictionPolicy::EVICT_FIRST)\n+                     .o(\"L1::evict_last\",\n+                        op.evict() == triton::EvictionPolicy::EVICT_LAST)\n+                     .o(\"L1::cache_hint\", hasL2EvictPolicy)\n+                     .v(nWords)\n+                     .b(width);\n \n       PTXBuilder::Operand *evictOpr{};\n \n@@ -1049,8 +1050,8 @@ struct LoadOpConversion\n \n       if (other) {\n         for (size_t ii = 0; ii < nWords; ++ii) {\n-          PTXInstr &mov = *ptxBuilder.create<>(\"mov\");\n-          mov.o(\"u\" + std::to_string(width));\n+          PTXInstr &mov =\n+              ptxBuilder.create<>(\"mov\")->o(\"u\" + std::to_string(width));\n \n           size_t size = width / valueElemNbits;\n \n@@ -1222,7 +1223,7 @@ struct StoreOpConversion\n           ptxBuilder.newAddrOperand(ptrElems[vecStart], \"l\", in_off);\n \n       auto &ptxStoreInstr =\n-          ptxBuilder.create<PTXIOInstr>(\"st\")->global().v(nWords).b(width);\n+          ptxBuilder.create<>(\"st\")->global().v(nWords).b(width);\n       ptxStoreInstr(asmAddr, asmArgList).predicate(maskVal, \"b\");\n \n       Type boolTy = getTypeConverter()->convertType(rewriter.getIntegerType(1));\n@@ -4827,7 +4828,7 @@ struct AsyncWaitOpConversion\n   matchAndRewrite(triton::gpu::AsyncWaitOp op, OpAdaptor adaptor,\n                   ConversionPatternRewriter &rewriter) const override {\n     PTXBuilder ptxBuilder;\n-    auto &asyncWaitOp = *ptxBuilder.create<PTXCpAsyncWaitGroupInstr>();\n+    auto &asyncWaitOp = *ptxBuilder.create<>(\"cp.async.wait_group\");\n     auto num = op->getAttrOfType<IntegerAttr>(\"num\").getInt();\n     asyncWaitOp(ptxBuilder.newConstantOperand(num));\n \n@@ -5050,7 +5051,7 @@ struct InsertSliceAsyncOpConversion\n     }\n \n     PTXBuilder ptxBuilder;\n-    ptxBuilder.create<PTXCpAsyncCommitGroupInstr>()->operator()();\n+    ptxBuilder.create<>(\"cp.async.commit_group\")->operator()();\n     ptxBuilder.launch(rewriter, loc, void_ty(getContext()));\n     rewriter.replaceOp(op, llDst);\n     return success();\n@@ -5203,9 +5204,7 @@ struct AtomicRMWOpConversion\n       auto *ptrOpr = ptxBuilder.newAddrOperand(rmwPtr, \"r\");\n       auto *valOpr = ptxBuilder.newOperand(rmvVal, \"r\");\n \n-      auto &atom = *ptxBuilder.create<>(\"atom\");\n-\n-      atom.o(\"global\").o(\"gpu\");\n+      auto &atom = ptxBuilder.create<>(\"atom\")->global().o(\"gpu\");\n       auto rmwOp = stringifyRMWOp(atomicRmwAttr).str();\n       auto sBits = std::to_string(valueElemNbits);\n       switch (atomicRmwAttr) {"}, {"filename": "unittest/Conversion/TritonGPUToLLVM/PtxAsmFormatTest.cpp", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "file_content_changes": "@@ -76,7 +76,7 @@ TEST_F(PtxAsmFormatTest, complexInstruction) {\n \n   auto &ld =\n       builder\n-          .create<PTXIOInstr>(\"ld\") //\n+          .create<>(\"ld\") //\n           ->o(\"volatile\", isVolatile)\n           .global()\n           .o(\"ca\", cache == CacheModifier::CA)\n@@ -121,5 +121,20 @@ TEST_F(PtxAsmFormatTest, MultiLinePTX) {\n   EXPECT_EQ(values[1], v[2]); // $1 -> v[2]\n }\n \n+TEST_F(PtxAsmFormatTest, onlyAttachMLIRArgs) {\n+  PTXBuilder builder;\n+  const char *ptxCode =\n+      \".param .b64 param0;\\n\" // prepare param0 (format string)\n+      \"st.param.b64 [param0], %0;\\n\";\n+\n+  auto &ptxSnippet = *builder.create(ptxCode);\n+  auto *opr = builder.newOperand(v[0], \"r\");\n+  ptxSnippet({opr}, true);\n+\n+  EXPECT_EQ(builder.dump(), ptxCode);\n+  ASSERT_EQ(builder.getAllMLIRArgs()[0], v[0]);\n+  ASSERT_EQ(builder.getAllMLIRArgs().size(), 1);\n+}\n+\n } // namespace triton\n } // namespace mlir"}]