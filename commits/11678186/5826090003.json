[{"filename": "include/triton/Conversion/TritonGPUToLLVM/PTXAsmFormat.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "file_content_changes": "@@ -151,6 +151,12 @@ struct PTXBuilder {\n   // aggressive optimizations that may lead to incorrect results.\n   Operand *newOperand(StringRef constraint, bool init = false);\n \n+  // Create a new operand that is tied to a previous operand. In this case the\n+  // asm would be permitted to write to an input register. Instead of providing\n+  // constraint code for this operand, the constraint code of the tied operand\n+  // is used.\n+  Operand *newOperand(unsigned operandIndex);\n+\n   // Create a constant integer operand.\n   Operand *newConstantOperand(int64_t v);\n   // Create a constant operand with explicit code specified."}, {"filename": "lib/Conversion/NVGPUToLLVM/NVGPUToLLVMPass.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -651,7 +651,7 @@ class WGMMAOpPattern : public mlir::RewritePattern {\n     args += \"}, \";\n \n     for (uint32_t i = asmOpIdx - numCRegs; i < asmOpIdx; ++i) {\n-      auto *opr = ptxBuilder.newOperand(std::to_string(i));\n+      auto *opr = ptxBuilder.newOperand(i);\n       oprs.push_back(opr);\n     }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/PTXAsmFormat.cpp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "file_content_changes": "@@ -40,7 +40,7 @@ void PTXBuilder::initOperand(Operand *opr) {\n \n PTXBuilder::Operand *PTXBuilder::newOperand(StringRef constraint, bool init) {\n   // Constraint should be something like \"=r\"\n-  // assert(constraint.size() == 2 && constraint[0] == '=');\n+  assert(constraint.size() == 2 && constraint[0] == '=');\n   auto *opr = newOperand();\n   opr->idx = oprCounter++;\n   opr->constraint = constraint;\n@@ -50,6 +50,14 @@ PTXBuilder::Operand *PTXBuilder::newOperand(StringRef constraint, bool init) {\n   return opr;\n }\n \n+PTXBuilder::Operand *PTXBuilder::newOperand(unsigned operandIndex) {\n+  assert(operandIndex < oprCounter && \"operand index out of range\");\n+  auto *opr = newOperand();\n+  opr->idx = oprCounter++;\n+  opr->constraint = std::to_string(operandIndex);\n+  return opr;\n+}\n+\n PTXBuilder::Operand *PTXBuilder::newConstantOperand(const std::string &v) {\n   argArchive.emplace_back(std::make_unique<Operand>());\n   argArchive.back()->repr = [v](int idx) { return v; };"}]