[{"filename": "python/src/triton.cc", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "file_content_changes": "@@ -437,46 +437,51 @@ typedef std::map<std::string, py::object> asm_map_t;\n void init_triton_codegen(py::module &&m) {\n   m.def(\"compile_ttir\",\n       [](backend_t backend, ir::module &ir, uint64_t device, int num_warps, int num_stages, py::dict& extern_libs, size_t cc) {\n-          py::gil_scoped_release allow_threads;\n-          std::string name = ir.get_function_list()[0]->get_name();\n-          // record asm as we generate\n-          asm_map_t asm_map;\n           std::ostringstream ttir;\n-          ir.print(ttir);\n-          asm_map[\"ttir\"] = py::cast(ttir.str());\n-          llvm::LLVMContext ctx;\n-          // construct extern lib map\n-          triton::codegen::ExternLibMap extern_lib_map;\n-          for (auto item : extern_libs) {\n-            auto name = item.first.cast<std::string>();\n-            auto path = item.second.cast<std::string>();\n-            extern_lib_map.emplace(\n-                name, triton::codegen::create_extern_lib(name, path));\n-          }\n-          // device properties\n-          if (cc == 0) {\n-            CUdevice dev = (CUdevice)device;\n-            size_t major = cuGetInfo<CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR>(dev);\n-            size_t minor = cuGetInfo<CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR>(dev);\n-            cc = major*10 + minor;\n-          }\n-          int version;\n-          std::string ptxas_path = drv::path_to_ptxas(version);\n-          // Triton-IR -> NVPTX LLVM-IR\n-          triton::codegen::nvidia_cu_target target(cc);\n           int n_shared_bytes;\n-          auto llvm = triton::codegen::add_passes_to_emit_bin(\n-              ir, ctx, &target, num_warps, num_stages, n_shared_bytes, extern_lib_map);\n           std::string tmp;\n-          llvm::raw_string_ostream llir(tmp);\n-          llir << *llvm;\n-          llir.flush();\n+          std::string ptx;\n+          std::string cubin;\n+          std::string name;\n+          { // Scope where the GIL is released\n+            py::gil_scoped_release allow_threads;\n+            name = ir.get_function_list()[0]->get_name();\n+            ir.print(ttir);\n+            llvm::LLVMContext ctx;\n+            // construct extern lib map\n+            triton::codegen::ExternLibMap extern_lib_map;\n+            for (auto item : extern_libs) {\n+              auto name = item.first.cast<std::string>();\n+              auto path = item.second.cast<std::string>();\n+              extern_lib_map.emplace(\n+                  name, triton::codegen::create_extern_lib(name, path));\n+            }\n+            // device properties\n+            if (cc == 0) {\n+              CUdevice dev = (CUdevice)device;\n+              size_t major = cuGetInfo<CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR>(dev);\n+              size_t minor = cuGetInfo<CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR>(dev);\n+              cc = major*10 + minor;\n+            }\n+            int version;\n+            std::string ptxas_path = drv::path_to_ptxas(version);\n+            // Triton-IR -> NVPTX LLVM-IR\n+            triton::codegen::nvidia_cu_target target(cc);\n+            auto llvm = triton::codegen::add_passes_to_emit_bin(\n+                ir, ctx, &target, num_warps, num_stages, n_shared_bytes, extern_lib_map);\n+            llvm::raw_string_ostream llir(tmp);\n+            llir << *llvm;\n+            llir.flush();\n+            // LLVM-IR -> PTX\n+            ptx = drv::llir_to_ptx(llvm.get(), cc, version);\n+            // PTX -> Binary\n+            cubin = drv::ptx_to_cubin(ptx, ptxas_path, cc);\n+          }\n+          asm_map_t asm_map;\n+          asm_map[\"ttir\"] = py::cast(ttir.str());\n           asm_map[\"llir\"] = py::cast(tmp);\n-          // LLVM-IR -> PTX\n-          std::string ptx = drv::llir_to_ptx(llvm.get(), cc, version);\n           asm_map[\"ptx\"] = py::cast(ptx);\n-          // PTX -> Binary\n-          std::string cubin = drv::ptx_to_cubin(ptx, ptxas_path, cc);\n+\n           if(!cubin.empty()){\n             py::bytes bytes(cubin);\n             asm_map[\"cubin\"] = bytes;"}]