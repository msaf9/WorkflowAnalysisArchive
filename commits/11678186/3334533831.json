[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -1400,8 +1400,6 @@ struct ExtractSliceOpConversion\n   }\n };\n \n-// TODO: rewrite Ternary/Binary/Unary as Elementwise\n-\n // A CRTP style of base class.\n template <typename SourceOp, typename DestOp, typename ConcreteT>\n class ElementwiseOpConversionBase"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "file_content_changes": "@@ -16,9 +16,9 @@\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.h\"\n #include \"triton/tools/sys/getenv.hpp\"\n #include \"llvm/IR/Constants.h\"\n-#include \"llvm/Support/SourceMgr.h\"\n #include \"llvm/IRReader/IRReader.h\"\n #include \"llvm/Linker/Linker.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n \n namespace mlir {\n namespace triton {\n@@ -152,13 +152,16 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n   std::map<std::string, std::string> extern_libs;\n   SmallVector<LLVM::LLVMFuncOp> funcs;\n   module.walk([&](LLVM::LLVMFuncOp func) {\n-    if (func.isExternal()) funcs.push_back(func);\n+    if (func.isExternal())\n+      funcs.push_back(func);\n   });\n \n   for (auto &func : funcs) {\n     if (func.getOperation()->hasAttr(\"libname\")) {\n-      auto name = func.getOperation()->getAttr(\"libname\").dyn_cast<StringAttr>();\n-      auto path = func.getOperation()->getAttr(\"libpath\").dyn_cast<StringAttr>();\n+      auto name =\n+          func.getOperation()->getAttr(\"libname\").dyn_cast<StringAttr>();\n+      auto path =\n+          func.getOperation()->getAttr(\"libpath\").dyn_cast<StringAttr>();\n       if (name) {\n         std::string lib_name = name.str();\n         extern_libs[lib_name] = path.str();\n@@ -167,10 +170,12 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n   }\n \n   if (module.getOperation()->hasAttr(\"triton_gpu.externs\")) {\n-    auto dict = module.getOperation()->getAttr(\"triton_gpu.externs\").dyn_cast<DictionaryAttr>();\n-    for (auto& attr : dict) {\n+    auto dict = module.getOperation()\n+                    ->getAttr(\"triton_gpu.externs\")\n+                    .dyn_cast<DictionaryAttr>();\n+    for (auto &attr : dict) {\n       extern_libs[attr.getName().strref().trim().str()] =\n-        attr.getValue().dyn_cast<StringAttr>().strref().trim().str();\n+          attr.getValue().dyn_cast<StringAttr>().strref().trim().str();\n     }\n   }\n \n@@ -181,31 +186,33 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n   }\n \n   llvm::SMDiagnostic err;\n-  for (auto& lib : extern_libs) {\n+  for (auto &lib : extern_libs) {\n     auto ext_mod = llvm::parseIRFile(lib.second, err, *llvmContext);\n     if (!ext_mod) {\n-      llvm::errs() <<\"Failed to load extern lib \" << lib.first;\n+      llvm::errs() << \"Failed to load extern lib \" << lib.first;\n       return nullptr;\n     }\n     ext_mod->setTargetTriple(llvmir->getTargetTriple());\n     ext_mod->setDataLayout(llvmir->getDataLayout());\n \n     if (llvm::Linker::linkModules(*llvmir, std::move(ext_mod))) {\n-      llvm::errs() <<\"Failed to link extern lib \" << lib.first;\n+      llvm::errs() << \"Failed to link extern lib \" << lib.first;\n       return nullptr;\n     }\n   }\n \n   return llvmir;\n }\n \n-void addExternalLibs(mlir::ModuleOp& module, const std::vector<std::string>& names, const std::vector<std::string>& paths) {\n+void addExternalLibs(mlir::ModuleOp &module,\n+                     const std::vector<std::string> &names,\n+                     const std::vector<std::string> &paths) {\n   if (names.empty() || names.size() != paths.size())\n     return;\n \n   llvm::SmallVector<NamedAttribute, 2> attrs;\n \n-  for(size_t i=0; i<names.size(); ++i) {\n+  for (size_t i = 0; i < names.size(); ++i) {\n     auto name = StringAttr::get(module->getContext(), names[i]);\n     auto path = StringAttr::get(module->getContext(), paths[i]);\n     NamedAttribute attr(name, path);"}]