[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -2101,8 +2101,8 @@ class MMA16816SmemLoader {\n         tileShape(tileShape.begin(), tileShape.end()),\n         instrShape(instrShape.begin(), instrShape.end()),\n         matShape(matShape.begin(), matShape.end()), perPhase(perPhase),\n-        maxPhase(maxPhase), elemBytes(elemBytes), rewriter(rewriter),\n-        loc(loc), ctx(rewriter.getContext()) {\n+        maxPhase(maxPhase), elemBytes(elemBytes), rewriter(rewriter), loc(loc),\n+        ctx(rewriter.getContext()) {\n     cMatShape = matShape[order[0]];\n     sMatShape = matShape[order[1]];\n \n@@ -2991,7 +2991,7 @@ struct MMA16816ConversionHelper {\n     }\n \n     // step1. Perform loading.\n-    for (int  m = 0; m < numRepM; ++m)\n+    for (int m = 0; m < numRepM; ++m)\n       for (int k = 0; k < numRepK; ++k)\n         loadFn(2 * m, 2 * k);\n \n@@ -3191,7 +3191,7 @@ struct MMA16816ConversionHelper {\n   Value composeValuesToDotOperandLayoutStruct(const ValueTable &vals, int n0,\n                                               int n1) const {\n     std::vector<Value> elems;\n-    for (int  m = 0; m < n0; ++m)\n+    for (int m = 0; m < n0; ++m)\n       for (int k = 0; k < n1; ++k) {\n         elems.push_back(vals.at({2 * m, 2 * k}));\n         elems.push_back(vals.at({2 * m, 2 * k + 1}));"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "file_content_changes": "@@ -537,15 +537,17 @@ struct TritonGPUInferLayoutInterface\n     : public triton::DialectInferLayoutInterface {\n   using DialectInferLayoutInterface::DialectInferLayoutInterface;\n \n-  LogicalResult inferReduceOpEncoding(Attribute operandEncoding, unsigned axis,\n-                                      Attribute &resultEncoding) const override {\n+  LogicalResult\n+  inferReduceOpEncoding(Attribute operandEncoding, unsigned axis,\n+                        Attribute &resultEncoding) const override {\n     resultEncoding = SliceEncodingAttr::get(getDialect()->getContext(), axis,\n                                             operandEncoding);\n     return success();\n   }\n \n-  LogicalResult inferExpandDimsOpEncoding(Attribute operandEncoding, unsigned axis,\n-                                          Attribute &resultEncoding) const override  {\n+  LogicalResult\n+  inferExpandDimsOpEncoding(Attribute operandEncoding, unsigned axis,\n+                            Attribute &resultEncoding) const override {\n     auto sliceEncoding = operandEncoding.dyn_cast<SliceEncodingAttr>();\n     if (!sliceEncoding) {\n       llvm::report_fatal_error("}]