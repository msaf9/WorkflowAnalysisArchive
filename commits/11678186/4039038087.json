[{"filename": "include/triton/Analysis/Utility.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -80,6 +80,9 @@ SmallVector<RES_T> reorder(ArrayRef<T> input, ArrayRef<unsigned> order) {\n bool isMmaToDotShortcut(triton::gpu::MmaEncodingAttr &mmaLayout,\n                         triton::gpu::DotOperandEncodingAttr &dotOperandLayout);\n \n+SetVector<Operation *>\n+multiRootTopologicalSort(const SetVector<Operation *> &toSort);\n+\n } // namespace mlir\n \n #endif // TRITON_ANALYSIS_UTILITY_H"}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "file_content_changes": "@@ -164,4 +164,66 @@ bool isMmaToDotShortcut(triton::gpu::MmaEncodingAttr &mmaLayout,\n          dotOperandLayout.getParent() == mmaLayout;\n }\n \n+namespace {\n+/// DFS post-order implementation that maintains a global count to work across\n+/// multiple invocations, to help implement topological sort on multi-root DAGs.\n+/// We traverse all operations but only record the ones that appear in\n+/// `toSort` for the final result.\n+struct DFSState {\n+  DFSState(const SetVector<Operation *> &set) : toSort(set), seen() {}\n+  const SetVector<Operation *> &toSort;\n+  SmallVector<Operation *, 16> topologicalCounts;\n+  DenseSet<Operation *> seen;\n+};\n+\n+static void dfsPostorder(Operation *root, DFSState *state) {\n+  SmallVector<Operation *> queue(1, root);\n+  std::vector<Operation *> ops;\n+  while (!queue.empty()) {\n+    Operation *current = queue.pop_back_val();\n+    if (state->seen.count(current) > 0)\n+      continue;\n+    ops.push_back(current);\n+    state->seen.insert(current);\n+    for (Value result : current->getResults()) {\n+      for (Operation *op : result.getUsers())\n+        queue.push_back(op);\n+    }\n+    for (Region &region : current->getRegions()) {\n+      for (Operation &op : region.getOps())\n+        queue.push_back(&op);\n+    }\n+  }\n+\n+  for (Operation *op : llvm::reverse(ops)) {\n+    if (state->toSort.count(op) > 0)\n+      state->topologicalCounts.push_back(op);\n+  }\n+}\n+\n+} // namespace\n+\n+SetVector<Operation *>\n+multiRootTopologicalSort(const SetVector<Operation *> &toSort) {\n+  if (toSort.empty()) {\n+    return toSort;\n+  }\n+\n+  // Run from each root with global count and `seen` set.\n+  DFSState state(toSort);\n+  for (auto *s : toSort) {\n+    assert(toSort.count(s) == 1 && \"NYI: multi-sets not supported\");\n+    dfsPostorder(s, &state);\n+  }\n+\n+  // Reorder and return.\n+  SetVector<Operation *> res;\n+  for (auto it = state.topologicalCounts.rbegin(),\n+            eit = state.topologicalCounts.rend();\n+       it != eit; ++it) {\n+    res.insert(*it);\n+  }\n+  return res;\n+}\n+\n } // namespace mlir"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -635,7 +635,7 @@ class RematerializeBackward : public mlir::RewritePattern {\n       else\n         sortedValues.push_back(v);\n     }\n-    tmp = mlir::topologicalSort(tmp);\n+    tmp = mlir::multiRootTopologicalSort(tmp);\n     for (Operation *op : tmp)\n       sortedValues.push_back(op->getResult(0));\n "}]