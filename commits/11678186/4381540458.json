[{"filename": "lib/Dialect/TritonGPU/Transforms/Utility.cpp", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "file_content_changes": "@@ -93,27 +93,27 @@ bool expensiveLoadOrStore(Operation *op, Attribute &targetEncoding) {\n   // same\n   if (isSingleValue(op->getOperand(0)))\n     return false;\n-  auto ptr = op->getOperand(0);\n-  // Case 2: We assume that `evict_last` loads/stores have high hit rate\n-  if (auto load = dyn_cast<triton::LoadOp>(op))\n-    if (load.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n-      return false;\n-  if (auto store = dyn_cast<triton::StoreOp>(op))\n-    if (store.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n-      return false;\n-  if (auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>()) {\n-    auto encoding = tensorTy.getEncoding();\n-    // Case 3: Different type conversion is expensive (e.g., mma <-> block)\n-    if (encoding.getTypeID() != targetEncoding.getTypeID())\n-      return true;\n-    auto sizePerThread = triton::gpu::getSizePerThread(encoding);\n-    auto targetSizePerThread = triton::gpu::getSizePerThread(targetEncoding);\n-    auto order = triton::gpu::getOrder(encoding);\n-    auto targetOrder = triton::gpu::getOrder(targetEncoding);\n-    // Case 4: The targeEncoding may expose more vectorization opportunities\n-    return sizePerThread[order[0]] >= targetSizePerThread[targetOrder[0]];\n-  }\n-  return false;\n+  // auto ptr = op->getOperand(0);\n+  //// Case 2: We assume that `evict_last` loads/stores have high hit rate\n+  // if (auto load = dyn_cast<triton::LoadOp>(op))\n+  //   if (load.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n+  //     return false;\n+  // if (auto store = dyn_cast<triton::StoreOp>(op))\n+  //   if (store.getEvict() == triton::EvictionPolicy::EVICT_LAST)\n+  //     return false;\n+  // if (auto tensorTy = ptr.getType().dyn_cast<RankedTensorType>()) {\n+  //   auto encoding = tensorTy.getEncoding();\n+  //   // Case 3: Different type conversion is expensive (e.g., mma <-> block)\n+  //   if (encoding.getTypeID() != targetEncoding.getTypeID())\n+  //     return true;\n+  //   auto sizePerThread = triton::gpu::getSizePerThread(encoding);\n+  //   auto targetSizePerThread = triton::gpu::getSizePerThread(targetEncoding);\n+  //   auto order = triton::gpu::getOrder(encoding);\n+  //   auto targetOrder = triton::gpu::getOrder(targetEncoding);\n+  //   // Case 4: The targeEncoding may expose more vectorization opportunities\n+  //   return sizePerThread[order[0]] >= targetSizePerThread[targetOrder[0]];\n+  // }\n+  return true;\n }\n \n bool expensiveToRemat(Operation *op, Attribute &targetEncoding) {"}]