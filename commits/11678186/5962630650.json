[{"filename": "lib/Dialect/TritonGPU/Transforms/AccelerateMatmul.cpp", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "file_content_changes": "@@ -102,7 +102,8 @@ warpsPerTileV3(tt::DotOp dotOp, const ArrayRef<int64_t> shape, int numWarps,\n class BlockedToMMA : public mlir::RewritePattern {\n   int computeCapability;\n   mutable int mmaV1Counter{}; // used to generate ID for MMAv1 encoding\n-  mutable unsigned mmaV3InstrN{};\n+  mutable llvm::SmallVector<llvm::SetVector<Operation *>> dotOpSetVector;\n+  mutable llvm::SmallVector<unsigned> mmaV3InstrNs;\n \n   static bool bwdFilter(Operation *op) {\n     return op->getNumOperands() == 1 &&\n@@ -146,26 +147,33 @@ class BlockedToMMA : public mlir::RewritePattern {\n   }\n \n   unsigned getMmaV3InstrN(tt::DotOp dotOp, unsigned currN) const {\n-    if (mmaV3InstrN > 0)\n-      return mmaV3InstrN;\n+    auto type = dotOp.getResult().getType().cast<RankedTensorType>();\n+    if (type.getEncoding().isa<MmaEncodingAttr>())\n+      return currN;\n+    for (size_t i = 0; i < dotOpSetVector.size(); ++i) {\n+      if (dotOpSetVector[i].count(dotOp.getOperation()) > 0)\n+        return mmaV3InstrNs[i];\n+    }\n \n-    mmaV3InstrN = currN;\n     SetVector<Operation *> slices;\n     mlir::getForwardSlice(dotOp.getResult(), &slices);\n-    auto iter =\n-        llvm::find_if(slices, [](Operation *op) { return isa<tt::DotOp>(op); });\n-\n-    if (iter != slices.end()) {\n-      tt::DotOp nextDotOp = dyn_cast<tt::DotOp>(*iter);\n-      auto type = nextDotOp.getResult().getType().cast<RankedTensorType>();\n-      auto AType = nextDotOp.getOperand(0).getType().cast<RankedTensorType>();\n-      auto shapePerCTA = ttg::getShapePerCTA(type);\n-      auto instrShape = mmaVersionToInstrShape(3, shapePerCTA, AType);\n-\n-      if (instrShape[1] < currN)\n-        mmaV3InstrN = instrShape[1];\n+    mlir::getBackwardSlice(dotOp.getOperation(), &slices);\n+    unsigned N = currN;\n+    llvm::SetVector<Operation *> dotOpSet;\n+    for (Operation *iter : slices) {\n+      if (auto nextDotOp = dyn_cast<tt::DotOp>(iter)) {\n+        auto type = nextDotOp.getResult().getType().cast<RankedTensorType>();\n+        auto AType = nextDotOp.getOperand(0).getType().cast<RankedTensorType>();\n+        auto shapePerCTA = ttg::getShapePerCTA(type);\n+        auto instrShape = mmaVersionToInstrShape(3, shapePerCTA, AType);\n+        dotOpSet.insert(iter);\n+        if (instrShape[1] < N)\n+          N = instrShape[1];\n+      }\n     }\n-    return mmaV3InstrN;\n+    mmaV3InstrNs.push_back(N);\n+    dotOpSetVector.push_back(dotOpSet);\n+    return N;\n   }\n \n   static Value getMMAv3Operand(Value v, mlir::PatternRewriter &rewriter,"}]