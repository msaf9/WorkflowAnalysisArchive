[{"filename": "include/triton/Dialect/Triton/IR/Traits.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "file_content_changes": "@@ -104,17 +104,6 @@ class SameLoadStoreOperandsAndResultEncoding\n   }\n };\n \n-template <typename ConcreteType>\n-class ElementwiseOrNoArg : public TraitBase<ConcreteType, ElementwiseOrNoArg> {\n-public:\n-  static LogicalResult verifyTrait(Operation *op) {\n-    if (op->getNumOperands() == 0)\n-      return success();\n-    // call element-wise trait\n-    return Elementwise<ConcreteType>::verifyTrait(op);\n-  }\n-};\n-\n } // namespace OpTrait\n } // namespace mlir\n "}, {"filename": "include/triton/Dialect/Triton/IR/TritonInterfaces.td", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -10,6 +10,5 @@ def SameLoadStoreOperandsShape : NativeOpTrait<\"SameLoadStoreOperandsShape\">;\n def SameLoadStoreOperandsAndResultShape : NativeOpTrait<\"SameLoadStoreOperandsAndResultShape\">;\n def SameLoadStoreOperandsEncoding : NativeOpTrait<\"SameLoadStoreOperandsEncoding\">;\n def SameLoadStoreOperandsAndResultEncoding : NativeOpTrait<\"SameLoadStoreOperandsAndResultEncoding\">;\n-def ElementwiseOrNoArg : NativeOpTrait<\"ElementwiseOrNoArg\">;\n \n #endif // TRITON_INTERFACES"}, {"filename": "include/triton/Dialect/Triton/IR/TritonOps.td", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -420,7 +420,7 @@ def TT_ReduceReturnOp: TT_Op<\"reduce.return\",\n //\n // External Elementwise op\n //\n-def TT_ExtElemwiseOp : TT_Op<\"ext_elemwise\", [ElementwiseOrNoArg,\n+def TT_ExtElemwiseOp : TT_Op<\"ext_elemwise\", [Elementwise,\n                                               SameOperandsAndResultEncoding,\n                                               SameVariadicOperandSize]> {\n     let summary = \"ext_elemwise\";\n@@ -435,7 +435,7 @@ def TT_ExtElemwiseOp : TT_Op<\"ext_elemwise\", [ElementwiseOrNoArg,\n \n     let results = (outs TT_Type:$result);\n \n-    let assemblyFormat = \"operands attr-dict `:` type(operands) `->` type($result)\";\n+    let assemblyFormat = \"operands attr-dict `:` functional-type(operands, $result)\";\n }\n \n //"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -224,7 +224,6 @@ static bool linkExternLib(llvm::Module &module, llvm::StringRef name,\n   extMod->setTargetTriple(module.getTargetTriple());\n   extMod->setDataLayout(module.getDataLayout());\n \n-  llvm::outs() << path << \"\\n\";\n   if (llvm::Linker::linkModules(module, std::move(extMod),\n                                 llvm::Linker::Flags::LinkOnlyNeeded)) {\n     llvm::errs() << \"Failed to link \" << path;"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "file_content_changes": "@@ -2275,12 +2275,34 @@ def kernel(InitI, Bound, CutOff, OutI, OutJ):\n #     print(m[0])\n #     print(n[0])\n \n+# -----------------------\n+# test extra\n+# -----------------------\n+\n+\n+def test_globaltimer():\n+\n+    @triton.jit\n+    def kernel(Out1, Out2):\n+        start = tl.extra.cuda.globaltimer()\n+        for i in range(10):\n+            tl.store(Out1, tl.load(Out1) + 1)\n+        end = tl.extra.cuda.globaltimer()\n+        tl.store(Out2, end - start)\n+\n+    out1 = to_triton(np.zeros((1,), dtype=np.int64), device='cuda')\n+    out2 = to_triton(np.zeros((1,), dtype=np.int64), device='cuda')\n+    h = kernel[(1,)](out1, out2)\n+    assert out2[0] > 0\n+    # 2 inlined globaltimers + one extra in the wrapper extern function\n+    assert h.asm[\"ptx\"].count(\"%globaltimer\") == 3\n \n # -----------------------\n # test layout conversions\n # -----------------------\n # TODO: backend should be tested separately\n \n+\n layouts = [\n     # MmaLayout(version=1, warps_per_cta=[1, 4]),\n     MmaLayout(version=(2, 0), warps_per_cta=[1, 4]),"}]