[{"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "file_content_changes": "@@ -1200,11 +1200,20 @@ void generator::visit_atomic_rmw_inst(ir::atomic_rmw_inst *atom) {\n \n   // vector size\n   int vec = 1;\n+  Value *mask = builder_->getInt1(true);\n   if(atom->get_type()->is_block_ty()){\n     int ld = ords_.at(ptr)[0];\n     unsigned alignment = alignment_->get(ptr, ld);\n     vec = std::min<int>(layouts_->get(ptr)->to_scanline()->nts(ld), alignment);\n     vec = std::min(vec, val->get_type()->get_tile_element_ty()->is_fp16_ty() ? 2 : 1);\n+    // Since the scanline layout may assign the same idx for multiple thread.\n+    // We have to avoid duplicate atomic operations\n+    auto *val_layout = layouts_->get(val)->to_scanline();\n+    auto &shape = val_layout->get_shape();\n+    auto numel = 1;\n+    std::for_each(shape.begin(), shape.end(), [&](auto dim) { numel *= dim; });\n+    Value *thread_id = tgt_->get_local_id(mod_, *builder_, 0);\n+    mask = icmp_ult(mul(thread_id, i32(idxs_.at(val).size())), i32(numel));\n   }\n \n   for(int i = 0; i < idxs_.at(val).size(); i += vec){\n@@ -1214,6 +1223,7 @@ void generator::visit_atomic_rmw_inst(ir::atomic_rmw_inst *atom) {\n       rmw_val = insert_elt(rmw_val, vals_[val][idxs_[val][i+ii]], ii);\n     Value *rmw_ptr = vals_[ptr][idx];\n     Value *rmw_msk = vals_[msk][idx];\n+    rmw_msk = and_(rmw_msk, mask);\n     if(vec == 1)\n       rmw_val = extract_elt(rmw_val, i32(0));\n     Type* ty = rmw_val->getType();"}]