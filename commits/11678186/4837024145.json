[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM/SharedToDotOperandMMAv2.cpp", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "file_content_changes": "@@ -243,36 +243,6 @@ SmallVector<Value> MMA16816SmemLoader::computeLdsMatOffs(Value warpOff,\n   return offs;\n }\n \n-Type getMatType(Type argType) {\n-  MLIRContext *ctx = argType.getContext();\n-  // floating point types\n-  Type fp32x1Ty = vec_ty(type::f32Ty(ctx), 1);\n-  Type fp16x2Ty = vec_ty(type::f16Ty(ctx), 2);\n-  Type i16x2Ty = vec_ty(type::i16Ty(ctx), 2);\n-  Type fp16x2Pack4Ty =\n-      LLVM::LLVMStructType::getLiteral(ctx, SmallVector<Type>(4, fp16x2Ty));\n-  // LLVM 14.0 does not support bf16 type, so we use i16 instead.\n-  Type bf16x2Pack4Ty =\n-      LLVM::LLVMStructType::getLiteral(ctx, SmallVector<Type>(4, i16x2Ty));\n-  Type fp32Pack4Ty =\n-      LLVM::LLVMStructType::getLiteral(ctx, SmallVector<Type>(4, fp32x1Ty));\n-  // integer types\n-  Type i8x4Ty = vec_ty(type::i8Ty(ctx), 4);\n-  Type i8x4Pack4Ty =\n-      LLVM::LLVMStructType::getLiteral(ctx, SmallVector<Type>(4, i8x4Ty));\n-\n-  if (argType.isF16())\n-    return fp16x2Pack4Ty;\n-  else if (argType.isBF16())\n-    return bf16x2Pack4Ty;\n-  else if (argType.isF32())\n-    return fp32Pack4Ty;\n-  else if (argType.isInteger(8))\n-    return i8x4Pack4Ty;\n-  else\n-    llvm::report_fatal_error(\"mma16816 data type not supported\");\n-}\n-\n std::tuple<Value, Value, Value, Value>\n MMA16816SmemLoader::loadX4(int mat0, int mat1, ArrayRef<Value> offs,\n                            ArrayRef<Value> ptrs, Type matTy,\n@@ -378,22 +348,14 @@ MMA16816SmemLoader::loadX4(int mat0, int mat1, ArrayRef<Value> offs,\n         Value val = load(ptr);\n         Value canonval = bitcast(val, vec_ty(canonInt, canonWidth));\n         for (int w = 0; w < canonWidth; ++w) {\n-          retElems[idx + w * 2] =\n-              insert_element(retElems[idx + w * 2],\n+          retElems[idx + w * kWidth / vecWidth] =\n+              insert_element(retElems[idx + w * kWidth / vecWidth],\n                              extract_element(canonval, i32_val(w)), i32_val(e));\n         }\n       }\n     }\n     return {bitcast(retElems[0], i32_ty), bitcast(retElems[1], i32_ty),\n             bitcast(retElems[2], i32_ty), bitcast(retElems[3], i32_ty)};\n-\n-    // Value ptr0 = gep(ptr_ty(vec_ty(i32_ty, 2), 3), ptrs[0][0], ii[0]);\n-    // Value ptr1 = gep(ptr_ty(vec_ty(i32_ty, 2), 3), ptrs[0][0], ii[1]);\n-    // Value v0 = load(ptr0);\n-    // Value v1 = load(ptr1);\n-    // return {extract_element(v0, i32_val(0)), extract_element(v1, i32_val(0)),\n-    //         extract_element(v0, i32_val(1)), extract_element(v1,\n-    //         i32_val(1))};\n   }\n }\n \n@@ -416,9 +378,8 @@ MMA16816SmemLoader::MMA16816SmemLoader(\n \n   // rule: k must be the fast-changing axis.\n   needTrans = kOrder != order[0];\n-  // canUseLdmatrix = elemBytes == 2 || (!needTrans); // b16\n-  // canUseLdmatrix = false;\n-  canUseLdmatrix = elemBytes == 1 && !needTrans;\n+  canUseLdmatrix = elemBytes == 2 || (!needTrans);\n+  canUseLdmatrix = canUseLdmatrix && (kWidth == 4 / elemBytes);\n \n   if (canUseLdmatrix) {\n     // Each CTA, the warps is arranged as [1xwpt] if not transposed,"}]