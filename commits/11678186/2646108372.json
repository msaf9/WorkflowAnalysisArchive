[{"filename": "python/build_extern.py", "status": "renamed", "additions": 9, "deletions": 8, "changes": 17, "file_content_changes": "@@ -289,11 +289,12 @@ def build(llvm_dis_path, lib_path, lib_name, output_dir):\n     extern_lib.generate_stub_file(output_dir)\n \n \n-parser = argparse.ArgumentParser()\n-parser.add_argument(\"-llvm\", dest=\"llvm_dis_path\", help=\"path to llvm-dis\", default=\"llvm-dis\")\n-parser.add_argument(\"--lib-path\", dest=\"lib_path\", help=\"path to the extern library\")\n-parser.add_argument(\"--lib-name\", dest=\"lib_name\", help=\"name of the extern library\")\n-parser.add_argument(\"-o\", dest=\"output_dir\", help=\"output file path\", default=\"/tmp/\")\n-args = parser.parse_args()\n-\n-build(args.llvm_dis_path, args.lib_path, args.lib_name, args.output_dir)\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"-llvm\", dest=\"llvm_dis_path\", help=\"path to llvm-dis\", default=\"llvm-dis\")\n+    parser.add_argument(\"--lib-path\", dest=\"lib_path\", help=\"path to the extern library\")\n+    parser.add_argument(\"--lib-name\", dest=\"lib_name\", help=\"name of the extern library\")\n+    parser.add_argument(\"-o\", dest=\"output_dir\", help=\"output file path\", default=\"/tmp/\")\n+    args = parser.parse_args()\n+\n+    build(args.llvm_dis_path, args.lib_path, args.lib_name, args.output_dir)"}, {"filename": "python/setup.py", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "file_content_changes": "@@ -10,6 +10,7 @@\n import urllib.request\n from distutils.version import LooseVersion\n \n+import build_extern\n from setuptools import Extension, setup\n from setuptools.command.build_ext import build_ext\n \n@@ -37,13 +38,12 @@ def get_llvm():\n     if paths:\n         return '', ''\n     if platform.system() == \"Windows\":\n-        return '', ''\n+        raise RuntimeError(\"Triton is not supported on Windows\")\n     # download if nothing is installed\n     name = 'clang+llvm-11.0.1-x86_64-linux-gnu-ubuntu-16.04'\n     dir = os.path.join(os.environ[\"HOME\"], \".triton\", \"llvm\")\n-    llvm_include_dir = '{dir}/{name}/include'.format(dir=dir, name=name)\n-    llvm_library_dir = '{dir}/{name}/lib'.format(dir=dir, name=name)\n-    if not os.path.exists(llvm_library_dir):\n+    llvm_dir = os.path.join(dir, name)\n+    if not os.path.exists(llvm_dir):\n         os.makedirs(dir, exist_ok=True)\n         try:\n             shutil.rmtree(os.path.join(dir, name))\n@@ -54,23 +54,28 @@ def get_llvm():\n         ftpstream = urllib.request.urlopen(url)\n         file = tarfile.open(fileobj=ftpstream, mode=\"r|xz\")\n         file.extractall(path=dir)\n-    return llvm_include_dir, llvm_library_dir\n+    return llvm_dir\n \n \n class CMakeExtension(Extension):\n-    def __init__(self, name, path, sourcedir=\"\"):\n+    def __init__(self, name, path, externlib_dir, sourcedir=\"\"):\n         Extension.__init__(self, name, sources=[])\n         self.sourcedir = os.path.abspath(sourcedir)\n         self.path = path\n+        self.externlib_dir = os.path.abspath(externlib_dir)\n \n \n class CMakeBuild(build_ext):\n \n-    user_options = build_ext.user_options + [('base-dir=', None, 'base directory of Triton')]\n+    user_options = build_ext.user_options + [('base-dir=', None, 'base directory of Triton'),\n+                                             ('cuda-dir=', None, 'CUDA directory'),\n+                                             ('enable-libdevice', None, 'enable libdevice')]\n \n     def initialize_options(self):\n         build_ext.initialize_options(self)\n         self.base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))\n+        self.cuda_dir = \"/usr/local/cuda\"\n+        self.enable_libdevice = True\n \n     def finalize_options(self):\n         build_ext.finalize_options(self)\n@@ -88,17 +93,29 @@ def run(self):\n             if cmake_version < \"3.1.0\":\n                 raise RuntimeError(\"CMake >= 3.1.0 is required on Windows\")\n \n+        # get llvm\n+        llvm_dir = get_llvm()\n+\n         for ext in self.extensions:\n-            self.build_extension(ext)\n+            # build external libraries\n+            self.build_external(ext, llvm_dir)\n+            self.build_extension(ext, llvm_dir)\n \n-    def build_extension(self, ext):\n-        llvm_include_dir, llvm_library_dir = get_llvm()\n-        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.path)))\n+    def build_external(self, ext, llvm_dir):\n+        llvm_dis_path = os.path.join(llvm_dir, \"bin\", \"llvm-dis\")\n+        if self.enable_libdevice:\n+            build_extern.build(llvm_dis_path, os.path.join(self.cuda_dir, \"nvvm\", \"libdevice\", \"libdevice.10.bc\"),\n+                               \"libdevice\", ext.externlib_dir)\n+\n+    def build_extension(self, ext, llvm_dir):\n         # create build directories\n+        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.path)))\n         if not os.path.exists(self.build_temp):\n             os.makedirs(self.build_temp)\n-        # python directories\n-        python_include_dirs = [distutils.sysconfig.get_python_inc()] + ['/usr/local/cuda/include']\n+        # configuration\n+        python_include_dirs = [distutils.sysconfig.get_python_inc()] + [self.cuda_dir + \"/include\"]\n+        llvm_include_dir = \"\" if llvm_dir == \"\" else os.path.join(llvm_dir, \"include\")\n+        llvm_library_dir = \"\" if llvm_dir == \"\" else os.path.join(llvm_dir, \"lib\")\n         cmake_args = [\n             \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=\" + extdir,\n             \"-DBUILD_TUTORIALS=OFF\",\n@@ -109,7 +126,6 @@ def build_extension(self, ext):\n             # '-DCMAKE_VERBOSE_MAKEFILE:BOOL=ON',\n             \"-DPYTHON_INCLUDE_DIRS=\" + \";\".join(python_include_dirs)\n         ]\n-        # configuration\n         cfg = get_build_type()\n         build_args = [\"--config\", cfg]\n \n@@ -123,6 +139,7 @@ def build_extension(self, ext):\n             cmake_args += [\"-DCMAKE_BUILD_TYPE=\" + cfg]\n             build_args += [\"--\", '-j' + str(2 * multiprocessing.cpu_count())]\n \n+        # run build commands\n         env = os.environ.copy()\n         subprocess.check_call([\"cmake\", self.base_dir] + cmake_args, cwd=self.build_temp, env=env)\n         subprocess.check_call([\"cmake\", \"--build\", \".\"] + build_args, cwd=self.build_temp)\n@@ -135,15 +152,15 @@ def build_extension(self, ext):\n     author_email=\"phil@openai.com\",\n     description=\"A language and compiler for custom Deep Learning operations\",\n     long_description=\"\",\n-    packages=[\"triton\", \"triton/_C\", \"triton/language\", \"triton/tools\", \"triton/ops\", \"triton/ops/blocksparse\"],\n+    packages=[\"triton\", \"triton/_C\", \"triton/language\", \"tools\", \"triton/ops\", \"triton/ops/blocksparse\"],\n     install_requires=[\n         \"cmake\",\n         \"filelock\",\n         \"torch\",\n     ],\n     package_data={\"triton/ops\": [\"*.c\"], \"triton/ops/blocksparse\": [\"*.c\"]},\n     include_package_data=True,\n-    ext_modules=[CMakeExtension(\"triton\", \"triton/_C/\")],\n+    ext_modules=[CMakeExtension(\"triton\", \"triton/_C/\", \"triton/language/\")],\n     cmdclass={\"build_ext\": CMakeBuild},\n     zip_safe=False,\n     # for PyPI"}, {"filename": "python/triton/language/__init__.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1,4 +1,4 @@\n # flake8: noqa: F401\n-from . import core, random, extern\n+from . import core, extern, random\n from .core import *\n from .random import *"}]