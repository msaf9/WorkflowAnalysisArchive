[{"filename": "include/triton/Conversion/TritonGPUToLLVM/PtxAsmFormat.h", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "file_content_changes": "@@ -173,19 +173,21 @@ struct PTXBuilder {\n   }\n \n   // Make the oprands in argArchive follow the provided \\param order.\n-  void reorderArgArchive(ArrayRef<Operand*> order) {\n+  void reorderArgArchive(ArrayRef<Operand *> order) {\n     assert(order.size() == argArchive.size());\n-    // The order in argArchive is unnecessary when onlyAttachMLIRArgs=false, but it do necessary when onlyAttachMLIRArgs is true for the $0,$1.. are determined by PTX code snippet passed from external.\n-    sort(argArchive.begin(), argArchive.end(), [&](std::unique_ptr<Operand>& a, std::unique_ptr<Operand>& b){\n-      auto ida = std::find(order.begin(), order.end(), a.get());\n-      auto idb = std::find(order.begin(), order.end(), b.get());\n-      assert (ida != order.end());\n-      assert (idb != order.end());\n-      return ida < idb;\n-    });\n+    // The order in argArchive is unnecessary when onlyAttachMLIRArgs=false, but\n+    // it do necessary when onlyAttachMLIRArgs is true for the $0,$1.. are\n+    // determined by PTX code snippet passed from external.\n+    sort(argArchive.begin(), argArchive.end(),\n+         [&](std::unique_ptr<Operand> &a, std::unique_ptr<Operand> &b) {\n+           auto ida = std::find(order.begin(), order.end(), a.get());\n+           auto idb = std::find(order.begin(), order.end(), b.get());\n+           assert(ida != order.end());\n+           assert(idb != order.end());\n+           return ida < idb;\n+         });\n   }\n \n-\n   friend struct PTXInstr;\n   friend struct PTXInstrCommon;\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/PtxAsmFormat.cpp", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "file_content_changes": "@@ -131,8 +131,11 @@ std::string PTXBuilder::dump() const {\n PTXInstrExecution &PTXInstrCommon::call(ArrayRef<Operand *> oprs,\n                                         bool onlyAttachMLIRArgs) {\n   if (onlyAttachMLIRArgs) {\n-    // Nearly impossible to make the $0,$1 in two PTX code snippets to point to the same MLIR values in onlyAttachMLIRArgs mode.\n-    assert(builder->executions.empty() && \"builder can only hold a single execution when onlyAttachMIIRArgs is true.\");\n+    // Nearly impossible to make the $0,$1 in two PTX code snippets to point to\n+    // the same MLIR values in onlyAttachMLIRArgs mode.\n+    assert(builder->executions.empty() &&\n+           \"builder can only hold a single execution when onlyAttachMIIRArgs \"\n+           \"is true.\");\n     builder->reorderArgArchive(oprs);\n   }\n \n@@ -155,7 +158,6 @@ std::string PTXInstrExecution::dump() const {\n   if (onlyAttachMLIRArgs)\n     return instrRepr;\n \n-\n   if (pred) {\n     if (!pred->repr)\n       os << \"@\" << pred->dump() << \" \";"}, {"filename": "unittest/Conversion/TritonGPUToLLVM/PtxAsmFormatTest.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -126,13 +126,13 @@ TEST_F(PtxAsmFormatTest, onlyAttachMLIRArgs) {\n   const char *ptxCode =\n       \".param .b64 param0;\\n\" // prepare param0 (format string)\n       \"st.param.b64 [param0], %0;\\n\"\n-  \"st.param.b64 [param0], %1;\\n\"\n-  \"st.param.b64 [param0], %2;\\n\";\n+      \"st.param.b64 [param0], %1;\\n\"\n+      \"st.param.b64 [param0], %2;\\n\";\n \n   auto &ptxSnippet = *builder.create(ptxCode);\n   auto *opr0 = builder.newOperand(v[0], \"r\");\n-  auto *opr1= builder.newOperand(v[1], \"r\");\n-  auto *opr2= builder.newOperand(v[2], \"r\");\n+  auto *opr1 = builder.newOperand(v[1], \"r\");\n+  auto *opr2 = builder.newOperand(v[2], \"r\");\n   ptxSnippet({opr1, opr2, opr0}, true);\n \n   EXPECT_EQ(builder.dump(), ptxCode);"}]