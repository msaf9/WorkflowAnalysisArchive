[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "file_content_changes": "@@ -2639,8 +2639,8 @@ def add_fn_static_cond(x, cond: tl.constexpr):\n         return x + 1\n \n \n-@pytest.mark.parametrize(\"call_type\", [\"attribute\", \"attribute_chain\", \"attribute_nested\", \"attribute_jit\",\n-                                       \"jit\", \"jit_return\", \"jit_ifexp\", \"jit_expr\",\n+@pytest.mark.parametrize(\"call_type\", [\"attribute\", \"attribute_jit\",\n+                                       \"jit\", \"jit_if\", \"jit_ifexp\", \"jit_expr\",\n                                        \"jit_static_cond\", \"jit_noinline\", \"jit_extern\"])\n def test_if_call(call_type):\n     @triton.jit\n@@ -2653,18 +2653,8 @@ def kernel(Out, call_type: tl.constexpr):\n                 a = o\n                 a = a.to(tl.int32).to(tl.int32) + 1\n                 o = a\n-        elif call_type == \"attribute_chain\":\n-            # t is an unknown name\n-            if pid == 0:\n-                t = Out\n-                a = tl.load(t + 1 - 1).to(tl.int32) + 1\n-                o = a\n-        elif call_type == \"attribute_nested\":\n-            if pid == 0:\n-                t = Out\n-                a = tl.load(t + tl.load(t)).to(tl.int32) + 1\n-                o = a\n         elif call_type == \"attribute_jit\":\n+            # call attribute and jit function\n             if pid == 0:\n                 a = o\n                 a = tl.load(Out + add_fn(a) - 1).to(tl.int32) + 1\n@@ -2675,7 +2665,7 @@ def kernel(Out, call_type: tl.constexpr):\n                 a = o\n                 a = add_fn(a)\n                 o = a\n-        elif call_type == \"jit_return\":\n+        elif call_type == \"jit_if\":\n             # function without end_if block\n             if pid == 0:\n                 a = o\n@@ -2688,26 +2678,25 @@ def kernel(Out, call_type: tl.constexpr):\n                 a = add_fn(a) if pid == 0 else add_fn_return(a, pid)\n                 o = a\n         elif call_type == \"jit_expr\":\n-            a = o\n-            if pid == 1:\n-                return\n-            a = add_fn(a)\n+            # call without return\n             if pid == 0:\n-                # call without return\n+                a = o + 1\n                 add_fn_expr(Out, a)\n-            o = a\n+                o = a\n         elif call_type == \"jit_static_cond\":\n             if pid == 0:\n-                a = add_fn_static_cond(o, call_type)\n+                a = o + 1\n+                add_fn_static_cond(o, call_type)\n                 o = a\n         elif call_type == \"jit_noinline\":\n             if pid == 0:\n-                a = o\n-                a = add_fn_noinline(a)\n+                a = o + 1\n+                add_fn_noinline(a)\n                 o = a\n         elif call_type == \"jit_extern\":\n             if pid == 0:\n-                a = tl.cdiv(o + 1, o + 1)\n+                a = o + 1\n+                tl.cdiv(a, a)\n                 o = a\n \n         tl.store(Out, o)"}, {"filename": "python/triton/compiler/code_generator.py", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "file_content_changes": "@@ -97,6 +97,7 @@ def __exit__(self, *args, **kwargs):\n         self.generator.local_defs = self.prev_defs\n \n \n+# Check if the given syntax node has an \"early\" return\n class ContainsReturnChecker(ast.NodeVisitor):\n     def __init__(self, gscope):\n         self.gscope = gscope\n@@ -126,16 +127,18 @@ def generic_visit(self, node) -> bool:\n         return ret\n \n     def visit_Attribute(self, node: ast.Attribute) -> bool:\n+        # If the left part is a name, it's possible that\n+        # we call triton native function or a jit function from another module.\n+        # If the left part is not a name, it must return a tensor or a constexpr\n+        # whose methods do not contain return statements\n+        # e.g., (tl.load(x)).to(y)\n+        # So we only check if the expressions within value have return or not\n         if isinstance(node.value, ast.Name):\n             if node.value.id in self.gscope:\n                 value = self.gscope[node.value.id]\n                 fn = getattr(value, node.attr)\n                 return self._visit_function(fn)\n             return False\n-        # If the left part is not a name, it must return a tensor or a constexpr\n-        # whose methods do not contain return statements\n-        # e.g., (tl.load(x)).to(y)\n-        # So we only check if the expressions within value have return or not\n         return self.visit(node.value)\n \n     def visit_Name(self, node: ast.Name) -> bool:\n@@ -150,7 +153,14 @@ def visit_Return(self, node: ast.Return) -> bool:\n         return True\n \n     def visit_Assign(self, node: ast.Assign) -> bool:\n-        return self.visit(node.value)\n+        # There couldn't be an early return\n+        # x = ...\n+        return False\n+\n+    def visit_AugAssign(self, node: ast.AugAssign) -> bool:\n+        # There couldn't be an early return\n+        # x += ...\n+        return False\n \n     def visit_Module(self, node: ast.Module) -> bool:\n         return self._visit_stmts(node.body)"}]