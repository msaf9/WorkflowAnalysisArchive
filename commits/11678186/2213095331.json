[{"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -744,6 +744,7 @@ void generator::visit_load_inst(ir::load_inst* x){\n     auto   ord = ords_.at(op);\n     size_t aln = alignment_->get(op, ord[0]);\n     size_t max_eq = mx ? alignment_->get_cst_info(mx->get_mask_operand())[ord[0]].num_cst : 1;\n+    max_eq = std::max<size_t>(max_eq, 1);\n     aln = std::min(aln, max_eq);\n     auto layout = layouts_->get(x)->to_scanline();\n     if(layout){\n@@ -902,6 +903,7 @@ void generator::visit_store_inst(ir::store_inst * x){\n     size_t aln = alignment_->get(ptr_op, ord[0]);\n     size_t nts = axes_.at(a_axes_->get(x->get_pointer_operand(), ord[0])).contiguous;\n     size_t max_eq = mx ? alignment_->get_cst_info(mx->get_mask_operand())[ord[0]].num_cst : 1;\n+    max_eq = std::max<size_t>(max_eq, 1);\n     aln = std::min(aln, max_eq);\n     vec  = std::min(nts, aln);\n   }"}, {"filename": "python/test/unit/runtime/test_comm.py", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "file_content_changes": "@@ -1,98 +0,0 @@\n-import subprocess\r\n-\r\n-import numpy as np\r\n-import pytest\r\n-import torch\r\n-\r\n-import triton\r\n-import triton.language as tl\r\n-\r\n-\r\n-def get_p2p_matrix():\r\n-    try:\r\n-        stdout = subprocess.check_output([\"nvidia-smi\", \"topo\", \"-p2p\", \"n\"]).decode(\"ascii\")\r\n-    except subprocess.CalledProcessError:\r\n-        return pytest.skip(\"No multi-GPU topology\", allow_module_level=True)\r\n-\r\n-    lines = stdout.split(\"Legend\")[0].split('\\n')[1:]\r\n-    matrix = np.array([line.split('\\t')[1:-1] for line in lines][:-2])\r\n-    if matrix.size <= 1:\r\n-        return pytest.skip(\"No multi-GPU topology\", allow_module_level=True)\r\n-    else:\r\n-        return matrix\r\n-\r\n-\r\n-def get_p2p_devices():\r\n-    matrix = get_p2p_matrix()\r\n-    idx = np.where(matrix == \"OK\")\r\n-    return [f\"cuda:{idx[0][0]}\", f\"cuda:{idx[1][0]}\"] if len(idx[0]) > 0 else []\r\n-\r\n-\r\n-def get_non_p2p_devices():\r\n-    matrix = get_p2p_matrix()\r\n-    idx = np.where(matrix == \"NS\")\r\n-    return [f\"cuda:{idx[0][0]}\", f\"cuda:{idx[1][0]}\"] if len(idx[0]) > 0 else []\r\n-\r\n-\r\n-p2p_devices = get_p2p_devices()\r\n-non_p2p_devices = get_non_p2p_devices()\r\n-\r\n-\r\n-@triton.jit\r\n-def _copy(from_ptr, to_ptr, N, **meta):\r\n-    pid = tl.program_id(0)\r\n-    offsets = pid * meta['BLOCK'] + tl.arange(0, meta['BLOCK'])\r\n-    values = tl.load(from_ptr + offsets, mask=offsets < N)\r\n-    tl.store(to_ptr + offsets, values, mask=offsets < N)\r\n-\r\n-\r\n-@pytest.mark.skipif(not p2p_devices, reason=\"No pair of device with P2P support\")\r\n-@pytest.mark.parametrize(\"device_kernel, device_from, device_to, stream_from, stream_to\",\r\n-                         [(device_kernel, device_from, device_to, stream_from, stream_to)\r\n-                          for device_kernel in p2p_devices\r\n-                          for device_from in p2p_devices\r\n-                          for device_to in p2p_devices\r\n-                          for stream_from in ['default', 'custom']\r\n-                          for stream_to in ['default', 'custom']\r\n-                          ])\r\n-def test_p2p(device_kernel, device_from, device_to, stream_from, stream_to):\r\n-    if device_to == device_from:\r\n-        return pytest.skip()\r\n-\r\n-    torch.cuda.set_device(device_kernel)\r\n-    N = 512\r\n-    grid = lambda meta: (triton.cdiv(N, meta['BLOCK']),)\r\n-\r\n-    with torch.cuda.stream(None if stream_from == 'default' else torch.cuda.Stream(device_from)):\r\n-        x_from = torch.randn(N, dtype=torch.float32, device=device_from)\r\n-    with torch.cuda.stream(None if stream_to == 'default' else torch.cuda.Stream(device_to)):\r\n-        x_to = torch.empty(N, dtype=torch.float32, device=device_to)\r\n-\r\n-    _copy[grid](x_from, x_to, N, BLOCK=1024)\r\n-    assert torch.allclose(x_from, x_to.to(device_from))\r\n-\r\n-\r\n-@pytest.mark.skipif(not non_p2p_devices, reason=\"No pair of device with no P2P support\")\r\n-@pytest.mark.parametrize(\"device_kernel, device_from, device_to, stream_from, stream_to\",\r\n-                         [(device_kernel, device_from, device_to, stream_from, stream_to)\r\n-                          for device_kernel in non_p2p_devices\r\n-                          for device_from in non_p2p_devices\r\n-                          for device_to in non_p2p_devices\r\n-                          for stream_from in ['default', 'custom']\r\n-                          for stream_to in ['default', 'custom']\r\n-                          ])\r\n-def test_non_p2p(device_kernel, device_from, device_to, stream_from, stream_to):\r\n-    if device_to == device_from:\r\n-        return pytest.skip()\r\n-\r\n-    with pytest.raises(RuntimeError):\r\n-        torch.cuda.set_device(device_kernel)\r\n-        N = 512\r\n-        grid = lambda meta: (triton.cdiv(N, meta['BLOCK']),)\r\n-\r\n-        with torch.cuda.stream(None if stream_from == 'default' else torch.cuda.Stream(device_from)):\r\n-            x_from = torch.randn(N, dtype=torch.float32, device=device_from)\r\n-        with torch.cuda.stream(None if stream_to == 'default' else torch.cuda.Stream(device_to)):\r\n-            x_to = torch.empty(N, dtype=torch.float32, device=device_to)\r\n-\r\n-        _copy[grid](x_from, x_to, N, BLOCK=1024)\r"}]