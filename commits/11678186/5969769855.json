[{"filename": "lib/Conversion/NVGPUToLLVM/NVGPUToLLVMPass.cpp", "status": "modified", "additions": 77, "deletions": 63, "changes": 140, "file_content_changes": "@@ -32,19 +32,25 @@ class NVGPUOpPatternBase : public mlir::RewritePattern {\n   mlir::Value convertToType(mlir::Value val, Constraint constraint,\n                             Location &loc,\n                             mlir::PatternRewriter &rewriter) const {\n-    if (val.getType().isa<PointerType>()) {\n+    if (val.getType().isa<LLVM::LLVMPointerType>()) {\n+      std::cout << \"Pointer found\" << std::endl;\n       if (std::holds_alternative<std::string>(constraint)) {\n         auto constraintStr = std::get<std::string>(constraint);\n-        if (constraintStr == \"ptr\") {\n-          return val;\n-        } else if (constraintStr == \"r\") {\n+        if (constraintStr == \"r\") {\n           return ptrtoint(i32_ty, val);\n         } else if (constraintStr == \"l\") {\n           return ptrtoint(i64_ty, val);\n         } else {\n-          assert(false && \"Unsupported type conversion\");\n+          return val;\n         }\n       }\n+      return val;\n+    } else {\n+      if (std::holds_alternative<std::string>(constraint)) {\n+        auto bitwidth = val.getType().getIntOrFloatBitWidth();\n+        auto constraintStr = std::get<std::string>(constraint);\n+        return zext(IntegerType::get(rewriter.getContext(), bitwidth), val);\n+      }\n     }\n     return val;\n   }\n@@ -965,75 +971,83 @@ class WGMMAOpPattern : public NVGPUOpPatternBase<ttn::WGMMAOp, WGMMAOpPattern> {\n   }\n };\n \n-class ClusterCTAIdOpPattern : public mlir::RewritePattern {\n+class ClusterCTAIdOpPattern\n+    : public NVGPUOpPatternBase<ttn::ClusterCTAIdOp, ClusterCTAIdOpPattern> {\n public:\n-  ClusterCTAIdOpPattern(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(ttn::ClusterCTAIdOp::getOperationName(), 1,\n-                             context) {}\n+  using Base = NVGPUOpPatternBase<ttn::ClusterCTAIdOp, ClusterCTAIdOpPattern>;\n+  using Base::Base;\n \n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto ctx = rewriter.getContext();\n-    auto clusterCTAIdOp = llvm::dyn_cast<ttn::ClusterCTAIdOp>(op);\n-    if (!clusterCTAIdOp)\n-      return mlir::failure();\n-    auto loc = op->getLoc();\n+  std::vector<std::string> getOutputConstraints(ttn::ClusterCTAIdOp op) const {\n+    return {\"=r\"};\n+  }\n \n-    auto x = getSRegValue(rewriter, loc, \"%cluster_ctaid.x\");\n-    auto y = getSRegValue(rewriter, loc, \"%cluster_ctaid.y\");\n-    auto z = getSRegValue(rewriter, loc, \"%cluster_ctaid.z\");\n-    auto nx = getSRegValue(rewriter, loc, \"%cluster_nctaid.x\");\n-    auto ny = getSRegValue(rewriter, loc, \"%cluster_nctaid.y\");\n-    auto res = add(x, mul(add(y, mul(z, ny)), nx));\n-    rewriter.replaceOp(op, {res});\n-    return mlir::success();\n+  std::string getPtxAsm(ttn::ClusterCTAIdOp op) const {\n+    auto ptxAsm = \"{\\n\"\n+                  \".reg .u32 a<5>;              \\n\"\n+                  \"mov.u32 a0, %cluster_ctaid.x;\\n\"  // x\n+                  \"mov.u32 a1, %cluster_ctaid.y;\\n\"  // y\n+                  \"mov.u32 a2, %cluster_ctaid.z;\\n\"  // z\n+                  \"mov.u32 a3, %cluster_nctaid.x;\\n\" // nx\n+                  \"mov.u32 a4, %cluster_nctaid.y;\\n\" // ny\n+                  \"mad.lo.u32 a1, a2, a4, a1;     \\n\"\n+                  \"mad.lo.u32 $0, a1, a3, a0;     \\n\"\n+                  \"}\";\n+    return ptxAsm;\n   }\n };\n \n-class WGMMADescCreateOpPattern : public mlir::RewritePattern {\n+class WGMMADescCreateOpPattern\n+    : public NVGPUOpPatternBase<ttn::WGMMADescCreateOp,\n+                                WGMMADescCreateOpPattern> {\n public:\n-  WGMMADescCreateOpPattern(mlir::MLIRContext *context)\n-      : mlir::RewritePattern(ttn::WGMMADescCreateOp::getOperationName(), 1,\n-                             context) {}\n+  using Base =\n+      NVGPUOpPatternBase<ttn::WGMMADescCreateOp, WGMMADescCreateOpPattern>;\n+  using Base::Base;\n \n-  mlir::LogicalResult\n-  matchAndRewrite(mlir::Operation *op,\n-                  mlir::PatternRewriter &rewriter) const override {\n-    auto ctx = rewriter.getContext();\n-    auto wgmmaDescCreateOp = llvm::dyn_cast<ttn::WGMMADescCreateOp>(op);\n-    if (!wgmmaDescCreateOp)\n-      return mlir::failure();\n-    auto loc = op->getLoc();\n-    auto buffer = wgmmaDescCreateOp.getBuffer();\n-    auto height = wgmmaDescCreateOp.getHeight();\n-    uint32_t mode = static_cast<uint32_t>(wgmmaDescCreateOp.getMode());\n+  std::vector<std::string>\n+  getOutputConstraints(ttn::WGMMADescCreateOp op) const {\n+    return {\"=l\"};\n+  }\n \n-    auto smem_nvvm_pointer = ptrtoint(i64_ty, buffer);\n+  OperandsAndConstraints\n+  getOperandsAndConstraints(ttn::WGMMADescCreateOp op) const {\n+    OperandsAndConstraints operandsAndConstraints;\n+    auto buffer = op.getBuffer();\n+    auto height = op.getHeight();\n+\n+    operandsAndConstraints.push_back({buffer, \"l\"});\n+    operandsAndConstraints.push_back({height, \"l\"});\n \n-    Value desc = int_val(64, 0);\n+    return operandsAndConstraints;\n+  }\n+\n+  std::string getPtxAsm(ttn::WGMMADescCreateOp op) const {\n+    uint32_t mode = static_cast<uint32_t>(op.getMode());\n     uint64_t swizzling = (mode == 1 ? 128 : mode == 2 ? 64 : 32);\n-    Value swizzling_ = int_val(64, swizzling);\n-    Value smem_address_bit = smem_nvvm_pointer;\n-\n-    Value strideDimension =\n-        lshr(shl(swizzling_, int_val(64, 3)), int_val(64, 4));\n-    Value height64 = zext(i64_ty, height);\n-    Value leadingDimension = lshr(mul(height64, swizzling_), int_val(64, 4));\n-\n-    // Value baseOffset = int_val(64, 0);\n-    Value startAddr =\n-        lshr(shl(smem_address_bit, int_val(64, 46)), int_val(64, 50));\n-\n-    Value mode_ = int_val(64, mode);\n-    desc = or_(desc, shl(mode_, int_val(64, 62)));\n-    desc = or_(desc, shl(strideDimension, int_val(64, 32)));\n-    desc = or_(desc, shl(leadingDimension, int_val(64, 16)));\n-    // desc = or_(desc, shl(baseOffset, int_val(64, 49)));\n-    desc = or_(desc, startAddr);\n-\n-    rewriter.replaceOp(op, {desc});\n-    return mlir::success();\n+    auto ptxAsm = \"{\\n\"\n+                  \".reg .u64 a<5>;                              \\n\"\n+                  \"mov.u64 a0, \" +\n+                  std::to_string(swizzling) +\n+                  \";\\n\"\n+                  \"shl.b64 a1, a0, 3;\\n\" // stride dimension\n+                  \"shr.b64 a1, a1, 4;\\n\" // stride dimension\n+                  \"mul.lo.u64 a2, $2, \" +\n+                  std::to_string(swizzling) +\n+                  \";\\n\"                    // leadingDimension\n+                  \"shr.b64 a2, a2, 4;\\n\"   // leadingDimension\n+                  \"shl.b64 a3, $1, 46; \\n\" // startAddr\n+                  \"shr.b64 a3, a3, 50; \\n\" // startAddr\n+                  \"mov.u64 a4, \" +\n+                  std::to_string(mode) +\n+                  \"; \\n\" // mode\n+                  \"shl.b64 a4, a4, 62; \\n\"\n+                  \"shl.b64 a1, a1, 32; \\n\"\n+                  \"or.b64 a1, a4, a1; \\n\"\n+                  \"shl.b64 a2, a2, 16; \\n\"\n+                  \"or.b64 a1, a1, a2; \\n\"\n+                  \"or.b64 $0, a1, a3; \\n\"\n+                  \"}\";\n+    return ptxAsm;\n   }\n };\n "}]