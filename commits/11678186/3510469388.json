[{"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "file_content_changes": "@@ -99,9 +99,6 @@ translateLLVMToLLVMIR(llvm::LLVMContext *llvmContext, mlir::ModuleOp module) {\n     return nullptr;\n   }\n \n-  // Initialize LLVM targets.\n-  mlir::ExecutionEngine::setupTargetTriple(llvmModule.get());\n-\n   auto optPipeline = mlir::makeOptimizingTransformer(\n       /*optLevel=*/3, /*sizeLevel=*/0,\n       /*targetMachine=*/nullptr);"}, {"filename": "lib/Target/PTX/PTXTranslation.cpp", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "file_content_changes": "@@ -12,29 +12,28 @@\n \n namespace triton {\n \n-static void init_llvm() {\n+static void initLLVM() {\n   LLVMInitializeNVPTXTargetInfo();\n   LLVMInitializeNVPTXTarget();\n   LLVMInitializeNVPTXTargetMC();\n   LLVMInitializeNVPTXAsmPrinter();\n }\n \n-static bool find_and_replace(std::string &str, const std::string &begin,\n-                             const std::string &end,\n-                             const std::string &target) {\n-  size_t start_replace = str.find(begin);\n-  if (start_replace == std::string::npos)\n+static bool findAndReplace(std::string &str, const std::string &begin,\n+                           const std::string &end, const std::string &target) {\n+  size_t startReplace = str.find(begin);\n+  if (startReplace == std::string::npos)\n     return false;\n-  size_t end_replace = str.find(end, start_replace);\n-  if (end_replace == std::string::npos)\n+  size_t endReplace = str.find(end, startReplace);\n+  if (endReplace == std::string::npos)\n     return false;\n-  str.replace(start_replace, end_replace + 1 - start_replace, target);\n+  str.replace(startReplace, endReplace + 1 - startReplace, target);\n   return true;\n }\n \n-static std::string llir_to_ptx(llvm::Module *module, int capability, int ptx) {\n+static void linkExternal(llvm::Module &module) {\n   bool hasExternal = false;\n-  for (auto &func : *module) {\n+  for (auto &func : module) {\n     if (func.hasExternalLinkage()) {\n       hasExternal = true;\n       break;\n@@ -51,98 +50,95 @@ static std::string llir_to_ptx(llvm::Module *module, int capability, int ptx) {\n                                           .parent_path() /\n                                       \"python\" / \"triton\" / \"language\" /\n                                       \"libdevice.10.bc\";\n-    if (mlir::triton::linkExternLib(*module, libdevice.string()))\n+    if (mlir::triton::linkExternLib(module, libdevice.string()))\n       llvm::errs() << \"link failed for: \" << libdevice.string();\n-  }\n \n-  // please check https://llvm.org/docs/NVPTXUsage.html#reflection-parameters\n-  // this will enable fast math path in libdevice\n-  // for example, when enable nvvm-reflect-ftz, sqrt.approx.f32 will change to\n-  // sqrt.approx.ftz.f32\n-  {\n-    auto &ctx = module->getContext();\n+    // please check https://llvm.org/docs/NVPTXUsage.html#reflection-parameters\n+    // this will enable fast math path in libdevice\n+    // for example, when enable nvvm-reflect-ftz, sqrt.approx.f32 will change to\n+    // sqrt.approx.ftz.f32\n+    auto &ctx = module.getContext();\n     llvm::Type *I32 = llvm::Type::getInt32Ty(ctx);\n     llvm::Metadata *mdFour =\n         llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 4));\n     llvm::Metadata *mdName = llvm::MDString::get(ctx, \"nvvm-reflect-ftz\");\n     llvm::Metadata *mdOne =\n         llvm::ConstantAsMetadata::get(llvm::ConstantInt::getSigned(I32, 1));\n     llvm::MDNode *reflect = llvm::MDNode::get(ctx, {mdFour, mdName, mdOne});\n-    module->addModuleFlag(reflect);\n+    module.addModuleFlag(reflect);\n   }\n+}\n+\n+std::string translateLLVMIRToPTX(llvm::Module &module, int cc, int version) {\n+  linkExternal(module);\n+\n   // LLVM version in use may not officially support target hardware\n-  int max_nvvm_cc = 75;\n-  // int max_nvvm_ptx = 74;\n+  int maxNNVMCC = 75;\n   // options\n   auto options = llvm::cl::getRegisteredOptions();\n-  auto *short_ptr =\n+  auto *shortPtr =\n       static_cast<llvm::cl::opt<bool> *>(options[\"nvptx-short-ptr\"]);\n-  assert(short_ptr);\n-  short_ptr->setValue(true);\n+  assert(shortPtr);\n+  shortPtr->setValue(true);\n   // compute capability\n-  std::string sm = \"sm_\" + std::to_string(capability);\n+  std::string sm = \"sm_\" + std::to_string(cc);\n   // max PTX version\n-  int ptx_major = ptx / 10;\n-  int ptx_minor = ptx % 10;\n+  int ptxMajor = version / 10;\n+  int ptxMinor = version % 10;\n   // create\n   llvm::SmallVector<char, 0> buffer;\n   std::string triple = \"nvptx64-nvidia-cuda\";\n-  std::string proc = \"sm_\" + std::to_string(std::min(capability, max_nvvm_cc));\n+  std::string proc = \"sm_\" + std::to_string(std::min(cc, maxNNVMCC));\n   std::string layout = \"\";\n   std::string features = \"\";\n   // std::string features = \"+ptx\" + std::to_string(std::min(ptx,\n   // max_nvvm_ptx));\n-  init_llvm();\n+  initLLVM();\n   // verify and store llvm\n   llvm::legacy::PassManager pm;\n   pm.add(llvm::createVerifierPass());\n-  pm.run(*module);\n+  pm.run(module);\n   // module->print(llvm::outs(), nullptr);\n \n   // create machine\n-  module->setTargetTriple(triple);\n+  module.setTargetTriple(triple);\n   std::string error;\n   auto target =\n-      llvm::TargetRegistry::lookupTarget(module->getTargetTriple(), error);\n+      llvm::TargetRegistry::lookupTarget(module.getTargetTriple(), error);\n   llvm::TargetOptions opt;\n   opt.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n   opt.UnsafeFPMath = false;\n   opt.NoInfsFPMath = false;\n   opt.NoNaNsFPMath = true;\n   llvm::TargetMachine *machine = target->createTargetMachine(\n-      module->getTargetTriple(), proc, features, opt, llvm::Reloc::PIC_,\n+      module.getTargetTriple(), proc, features, opt, llvm::Reloc::PIC_,\n       llvm::None, llvm::CodeGenOpt::Aggressive);\n   // set data layout\n   if (layout.empty())\n-    module->setDataLayout(machine->createDataLayout());\n+    module.setDataLayout(machine->createDataLayout());\n   else\n-    module->setDataLayout(layout);\n+    module.setDataLayout(layout);\n   // emit machine code\n-  for (llvm::Function &f : module->functions())\n+  for (llvm::Function &f : module.functions())\n     f.addFnAttr(llvm::Attribute::AlwaysInline);\n   llvm::legacy::PassManager pass;\n   llvm::raw_svector_ostream stream(buffer);\n   // emit\n   machine->addPassesToEmitFile(pass, stream, nullptr,\n                                llvm::CodeGenFileType::CGFT_AssemblyFile);\n-  pass.run(*module);\n+  pass.run(module);\n \n   // post-process\n   std::string result(buffer.begin(), buffer.end());\n-  find_and_replace(result, \".version\", \"\\n\",\n-                   \".version \" + std::to_string(ptx_major) + \".\" +\n-                       std::to_string(ptx_minor) + \"\\n\");\n-  find_and_replace(result, \".target\", \"\\n\", \".target \" + sm + \"\\n\");\n-  while (find_and_replace(result, \"\\t// begin inline asm\", \"\\n\", \"\"))\n+  findAndReplace(result, \".version\", \"\\n\",\n+                 \".version \" + std::to_string(ptxMajor) + \".\" +\n+                     std::to_string(ptxMinor) + \"\\n\");\n+  findAndReplace(result, \".target\", \"\\n\", \".target \" + sm + \"\\n\");\n+  while (findAndReplace(result, \"\\t// begin inline asm\", \"\\n\", \"\"))\n     ;\n-  while (find_and_replace(result, \"\\t// end inline asm\", \"\\n\", \"\"))\n+  while (findAndReplace(result, \"\\t// end inline asm\", \"\\n\", \"\"))\n     ;\n   return result;\n }\n \n-std::string translateLLVMIRToPTX(llvm::Module &module, int cc, int version) {\n-  auto ptxCode = llir_to_ptx(&module, cc, version);\n-  return ptxCode;\n-}\n-\n } // namespace triton"}]