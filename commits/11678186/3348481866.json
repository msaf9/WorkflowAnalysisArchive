[{"filename": "include/triton/Dialect/Triton/IR/Dialect.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -31,13 +31,13 @@ class DialectInferLayoutInterface\n                         Attribute &resultEncoding) const = 0;\n \n   virtual LogicalResult\n-  inferExpandDimsOpEncoding(Attribute operandEncoding, int axis,\n+  inferExpandDimsOpEncoding(Attribute operandEncoding, unsigned axis,\n                             Attribute &resultEncoding,\n                             Optional<Location> location) const = 0;\n \n   // Note: this function only verify operand encoding but doesn't infer encoding\n   virtual LogicalResult\n-  inferDotOpEncoding(Attribute operandEncoding, int opIdx,\n+  inferDotOpEncoding(Attribute operandEncoding, unsigned opIdx,\n                      Attribute retEncoding,\n                      Optional<Location> location) const = 0;\n };"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "file_content_changes": "@@ -603,9 +603,10 @@ struct TritonGPUInferLayoutInterface\n     return success();\n   }\n \n-  LogicalResult inferExpandDimsOpEncoding(Attribute operandEncoding, int axis,\n-                                          Attribute &resultEncoding,\n-                                          Optional<Location> location) const {\n+  LogicalResult\n+  inferExpandDimsOpEncoding(Attribute operandEncoding, unsigned axis,\n+                            Attribute &resultEncoding,\n+                            Optional<Location> location) const override {\n     auto sliceEncoding = operandEncoding.dyn_cast<SliceEncodingAttr>();\n     if (!sliceEncoding)\n       return emitOptionalError(\n@@ -617,9 +618,9 @@ struct TritonGPUInferLayoutInterface\n     return success();\n   }\n \n-  LogicalResult inferDotOpEncoding(Attribute operandEncoding, int opIdx,\n+  LogicalResult inferDotOpEncoding(Attribute operandEncoding, unsigned opIdx,\n                                    Attribute retEncoding,\n-                                   Optional<Location> location) const {\n+                                   Optional<Location> location) const override {\n     if (auto dotOpEnc = operandEncoding.dyn_cast<DotOperandEncodingAttr>()) {\n       if (opIdx != dotOpEnc.getOpIdx())\n         return emitOptionalError(location, \"Wrong opIdx\");"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -506,7 +506,6 @@ class RematerializeForward : public mlir::RewritePattern {\n     auto forOp = dyn_cast<scf::ForOp>(cvt->getParentOp());\n     if (!forOp)\n       return mlir::failure();\n-    auto yieldOp = cast<scf::YieldOp>(forOp.getBody()->getTerminator());\n     auto isInLoop = [&](Operation *op) { return op->getParentOp() == forOp; };\n \n     SetVector<Operation *> cvtSlices;"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Pipeline.cpp", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "file_content_changes": "@@ -176,26 +176,26 @@ LoopPipeliner::getSwizzleType(ttg::DotOperandEncodingAttr dotOpEnc,\n     perPhase = std::max<int>(perPhase, 1);\n \n     // index of the inner dimension in `order`\n-    int inner = (opIdx == 0) ? 0 : 1;\n+    unsigned inner = (opIdx == 0) ? 0 : 1;\n     if (version == 1) {\n       maxPhase = (order[inner] == 1 ? 8 : 4) / perPhase;\n       // TODO: handle rep (see\n       // https://github.com/openai/triton/blob/master/lib/codegen/analysis/layout.cc#L209)\n     } else if (version == 2) {\n       auto eltTy = ty.getElementType();\n-      std::vector<size_t> mat_shape = {8, 8,\n-                                       2 * 64 / eltTy.getIntOrFloatBitWidth()};\n+      std::vector<size_t> matShape = {8, 8,\n+                                      2 * 64 / eltTy.getIntOrFloatBitWidth()};\n       // for now, disable swizzle when using transposed int8 tensor cores\n       if (ty.getElementType().isInteger(8) && order[0] == inner)\n         perPhase = 1;\n       else {\n         if (opIdx == 0) { // compute swizzling for A operand\n-          vec = order[0] == 1 ? mat_shape[2] : mat_shape[0]; // k : m\n-          int mmaStride = order[0] == 1 ? mat_shape[0] : mat_shape[2];\n+          vec = order[0] == 1 ? matShape[2] : matShape[0]; // k : m\n+          int mmaStride = order[0] == 1 ? matShape[0] : matShape[2];\n           maxPhase = mmaStride / perPhase;\n         } else if (opIdx == 1) { // compute swizzling for B operand\n-          vec = order[0] == 1 ? mat_shape[1] : mat_shape[2]; // n : k\n-          int mmaStride = order[0] == 1 ? mat_shape[2] : mat_shape[1];\n+          vec = order[0] == 1 ? matShape[1] : matShape[2]; // n : k\n+          int mmaStride = order[0] == 1 ? matShape[2] : matShape[1];\n           maxPhase = mmaStride / perPhase;\n         } else\n           llvm_unreachable(\"invalid operand index\");\n@@ -418,8 +418,8 @@ void LoopPipeliner::emitPrologue() {\n   } // for (int stage = 0; stage < numStages - 1; ++stage)\n \n   // async.wait & extract_slice\n-  Operation *asyncWait = builder.create<ttg::AsyncWaitOp>(\n-      loads[0].getLoc(), loads.size() * (numStages - 2));\n+  builder.create<ttg::AsyncWaitOp>(loads[0].getLoc(),\n+                                   loads.size() * (numStages - 2));\n   loopIterIdx = builder.create<arith::ConstantIntOp>(iv.getLoc(), 0, 32);\n   for (Value loadOp : loads) {\n     auto sliceType = loadsMapping[loadOp].getType().cast<RankedTensorType>();"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Prefetch.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -131,7 +131,7 @@ LogicalResult Prefetcher::initialize() {\n     return failure();\n \n   // returns source of cvt\n-  auto getPrefetchSrc = [this](Value v) -> Value {\n+  auto getPrefetchSrc = [](Value v) -> Value {\n     // TODO: Check if the layout of src is SharedEncodingAttr\n     if (auto cvt = v.getDefiningOp<triton::gpu::ConvertLayoutOp>())\n       return cvt.src();"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Swizzle.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -67,7 +67,6 @@ struct SwizzlePass : public TritonGPUSwizzleBase<SwizzlePass> {\n \n   void runOnOperation() override {\n     Operation *op = getOperation();\n-    MLIRContext *context = &getContext();\n     // replace blocked -> dot_op with\n     // blocked -> shared -> dot_op in order to\n     // expose opportunities for swizzling"}]