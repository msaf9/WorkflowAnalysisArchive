[{"filename": "bin/triton-opt.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -29,7 +29,6 @@ int main(int argc, char **argv) {\n   mlir::test::registerTestMembarPass();\n   mlir::triton::registerConvertTritonToTritonGPUPass();\n   mlir::triton::registerConvertTritonGPUToLLVMPass();\n-  mlir::triton::registerConvertTritonFuncToLLVMPass();\n \n   // TODO: register Triton & TritonGPU passes\n   mlir::DialectRegistry registry;"}, {"filename": "include/triton/Conversion/Passes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -2,6 +2,7 @@\n #define TRITON_CONVERSION_PASSES_H\n \n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n+#include \"triton/Conversion/TritonGPUToLLVM/ArithToIndexPass.h\"\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h\"\n #include \"triton/Conversion/TritonToTritonGPU/TritonToTritonGPUPass.h\"\n "}, {"filename": "include/triton/Conversion/Passes.td", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "file_content_changes": "@@ -49,14 +49,18 @@ def ConvertTritonGPUToLLVM : Pass<\"convert-triton-gpu-to-llvm\", \"mlir::ModuleOp\"\n     ];\n }\n \n-def ConvertTritonFuncToLLVM : Pass<\"convert-triton-func-to-llvm\", \"mlir::ModuleOp\"> {\n-    let summary = \"Convert Triton functions to LLVM\";\n+def TritonConvertArithToIndex : Pass<\"triton-convert-arith-to-index\", \"mlir::ModuleOp\"> {\n+\n+    let summary = \"Convert arith to index\";\n+    \n+    let constructor = \"mlir::triton::createTritonConvertArithToIndexPass()\";\n \n     let description = [{\n-      Handles pointers and annotations\n+      Convert arith operation on index values to corresponding ops in the index dialect.\n+      We need this because SCFToCF conversion currently generates arith ops on indices.\n     }];\n \n-    let constructor = \"mlir::triton::createConvertTritonFuncToLLVMPass()\";\n+    let dependentDialects = [\"mlir::arith::ArithDialect\"];\n }\n \n #endif"}, {"filename": "include/triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "file_content_changes": "@@ -15,8 +15,6 @@ namespace triton {\n std::unique_ptr<OperationPass<ModuleOp>>\n createConvertTritonGPUToLLVMPass(int computeCapability = 80);\n \n-std::unique_ptr<OperationPass<ModuleOp>> createConvertTritonFuncToLLVMPass();\n-\n } // namespace triton\n \n } // namespace mlir"}, {"filename": "lib/Conversion/TritonGPUToLLVM/CMakeLists.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -1,4 +1,5 @@\n add_mlir_conversion_library(TritonGPUToLLVM\n+    ArithToIndexPass.cpp\n     ConvertLayoutOpToLLVM.cpp\n     DotOpToLLVM.cpp\n     ElementwiseOpToLLVM.cpp"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "file_content_changes": "@@ -394,67 +394,6 @@ class ConvertTritonGPUToLLVM\n   }\n };\n \n-class TritonArithToIndexConversionTarget : public ConversionTarget {\n-public:\n-  static bool hasIndexResultOrOperand(Operation *op) {\n-    if (!op)\n-      return false;\n-    bool hasRetIndex = llvm::find_if(op->getResultTypes(), [](Type type) {\n-                         return type.isIndex();\n-                       }) != op->getResultTypes().end();\n-    bool hasArgIndex = llvm::find_if(op->getOperandTypes(), [](Type type) {\n-                         return type.isIndex();\n-                       }) != op->getOperandTypes().end();\n-    return !hasRetIndex && !hasArgIndex;\n-  }\n-\n-  explicit TritonArithToIndexConversionTarget(MLIRContext &ctx)\n-      : ConversionTarget(ctx) {\n-    addLegalDialect<index::IndexDialect>();\n-    addDynamicallyLegalDialect<arith::ArithDialect>(hasIndexResultOrOperand);\n-  }\n-};\n-\n-#undef add\n-\n-template <class SrcOp, class DstOp>\n-LogicalResult replaceArithWithIndex(SrcOp op, PatternRewriter &rewriter) {\n-  // if (!hasIndexResultOrOperand(&*op))\n-  //   return failure();\n-  rewriter.replaceOpWithNewOp<DstOp>(op, op->getResultTypes(),\n-                                     op->getOperands(), op->getAttrs());\n-  return success();\n-}\n-\n-LogicalResult replaceArithCmpWithIndexCmp(arith::CmpIOp op,\n-                                          PatternRewriter &rewriter) {\n-  // if (!hasIndexResultOrOperand(&*op))\n-  //   return failure();\n-  rewriter.replaceOpWithNewOp<index::CmpOp>(\n-      op, op.getResult().getType(), (index::IndexCmpPredicate)op.getPredicate(),\n-      op.getOperand(0), op.getOperand(1));\n-  return success();\n-}\n-\n-class ConvertTritonFuncToLLVM\n-    : public ConvertTritonFuncToLLVMBase<ConvertTritonFuncToLLVM> {\n-public:\n-  void runOnOperation() override {\n-    MLIRContext *context = &getContext();\n-    ModuleOp mod = getOperation();\n-    int numWarps = triton::gpu::TritonGPUDialect::getNumWarps(mod);\n-    TritonArithToIndexConversionTarget target(*context);\n-    RewritePatternSet patterns(context);\n-    patterns.add(replaceArithWithIndex<arith::IndexCastOp, index::CastSOp>);\n-    patterns.add(replaceArithWithIndex<arith::ConstantOp, index::ConstantOp>);\n-    patterns.add(replaceArithWithIndex<arith::AddIOp, index::AddOp>);\n-    patterns.add(replaceArithCmpWithIndexCmp);\n-    if (failed(applyPartialConversion(mod, target, std::move(patterns)))) {\n-      return signalPassFailure();\n-    }\n-  }\n-};\n-\n } // anonymous namespace\n \n namespace mlir {\n@@ -465,9 +404,5 @@ createConvertTritonGPUToLLVMPass(int computeCapability) {\n   return std::make_unique<::ConvertTritonGPUToLLVM>(computeCapability);\n }\n \n-std::unique_ptr<OperationPass<ModuleOp>> createConvertTritonFuncToLLVMPass() {\n-  return std::make_unique<::ConvertTritonFuncToLLVM>();\n-}\n-\n } // namespace triton\n } // namespace mlir"}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -12,6 +12,7 @@\n #include \"mlir/Target/LLVMIR/Export.h\"\n #include \"mlir/Target/LLVMIR/LLVMTranslationInterface.h\"\n #include \"mlir/Transforms/Passes.h\"\n+#include \"triton/Conversion/TritonGPUToLLVM/ArithToIndexPass.h\"\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h\"\n #include \"triton/Tools/Sys/GetEnv.hpp\"\n #include \"llvm/ADT/APInt.h\"\n@@ -295,7 +296,7 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n       /*printAfterOnlyOnFailure*/ false, llvm::dbgs(), printingFlags);\n \n   pm.addPass(mlir::createConvertSCFToCFPass());\n-  pm.addPass(mlir::triton::createConvertTritonFuncToLLVMPass());\n+  pm.addPass(createTritonConvertArithToIndexPass());\n   pm.addPass(mlir::createConvertIndexToLLVMPass());\n   pm.addPass(createConvertTritonGPUToLLVMPass(computeCapability));\n   pm.addPass(mlir::createArithToLLVMConversionPass());"}]