[{"filename": "include/triton/Dialect/Triton/IR/Dialect.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "file_content_changes": "@@ -45,6 +45,12 @@ class DialectInferLayoutInterface\n   inferDotOpEncoding(Attribute operandEncoding, unsigned opIdx,\n                      Attribute retEncoding,\n                      std::optional<Location> location) const = 0;\n+\n+  // Verify that the encoding are compatible to be used together in a dot\n+  // operation\n+  virtual LogicalResult\n+  verifyDotOpEncodingCompatibility(Operation *op, Attribute operandEncodingA,\n+                                   Attribute operandEncodingB) const = 0;\n };\n \n } // namespace triton"}, {"filename": "lib/Dialect/Triton/IR/Ops.cpp", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "file_content_changes": "@@ -6,7 +6,6 @@\n #include \"mlir/IR/OperationSupport.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"triton/Dialect/Triton/IR/Types.h\"\n-#include \"triton/Dialect/TritonGPU/IR/Attributes.h\"\n \n namespace mlir {\n namespace triton {\n@@ -404,18 +403,17 @@ LogicalResult mlir::triton::DotOp::verify() {\n   auto bTy = getOperand(1).getType().cast<RankedTensorType>();\n   if (aTy.getElementType() != bTy.getElementType())\n     return emitError(\"element types of operands A and B must match\");\n-  auto aEncoding =\n-      aTy.getEncoding().dyn_cast_or_null<triton::gpu::DotOperandEncodingAttr>();\n-  auto bEncoding =\n-      bTy.getEncoding().dyn_cast_or_null<triton::gpu::DotOperandEncodingAttr>();\n+  auto aEncoding = aTy.getEncoding();\n+  auto bEncoding = bTy.getEncoding();\n   if (!aEncoding && !bEncoding)\n     return mlir::success();\n   // Verify that the encodings are valid.\n   if (!aEncoding || !bEncoding)\n     return emitError(\"mismatching encoding between A and B operands\");\n-  if (aEncoding.getMMAv2kWidth() != bEncoding.getMMAv2kWidth())\n-    return emitError(\"mismatching kWidth between A and B operands\");\n-  return mlir::success();\n+  Dialect &dialect = aEncoding.getDialect();\n+  auto interface = cast<DialectInferLayoutInterface>(&dialect);\n+  return interface->verifyDotOpEncodingCompatibility(getOperation(), aEncoding,\n+                                                     bEncoding);\n }\n \n //-- ReduceOp --"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "file_content_changes": "@@ -1106,6 +1106,23 @@ struct TritonGPUInferLayoutInterface\n           location, \"Dot's a/b's encoding should be of DotOperandEncodingAttr\");\n     return success();\n   }\n+\n+  LogicalResult\n+  verifyDotOpEncodingCompatibility(Operation *op, Attribute operandEncodingA,\n+                                   Attribute operandEncodingB) const override {\n+    auto aEncoding =\n+        operandEncodingA.dyn_cast<triton::gpu::DotOperandEncodingAttr>();\n+    auto bEncoding =\n+        operandEncodingB.dyn_cast<triton::gpu::DotOperandEncodingAttr>();\n+    if (!aEncoding && !bEncoding)\n+      return mlir::success();\n+    // Verify that the encodings are valid.\n+    if (!aEncoding || !bEncoding)\n+      return op->emitError(\"mismatching encoding between A and B operands\");\n+    if (aEncoding.getMMAv2kWidth() != bEncoding.getMMAv2kWidth())\n+      return op->emitError(\"mismatching kWidth between A and B operands\");\n+    return success();\n+  }\n };\n \n //===----------------------------------------------------------------------===//"}]