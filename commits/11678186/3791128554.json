[{"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 5, "deletions": 74, "changes": 79, "file_content_changes": "@@ -1176,7 +1176,8 @@ class FixupLoop : public mlir::RewritePattern {\n     for (size_t i = 0; i < newInitArgs.size(); i++) {\n       auto initArg = newInitArgs[i];\n       auto regionArg = forOp.getRegionIterArgs()[i];\n-      if (newInitArgs[i].getType() != forOp.getRegionIterArgs()[i].getType()) {\n+      if (newInitArgs[i].getType() != forOp.getRegionIterArgs()[i].getType() ||\n+          newInitArgs[i].getType() != forOp.getResultTypes()[i]) {\n         shouldRematerialize = true;\n         break;\n       }\n@@ -1192,9 +1193,10 @@ class FixupLoop : public mlir::RewritePattern {\n     BlockAndValueMapping mapping;\n     for (const auto &arg : llvm::enumerate(forOp.getRegionIterArgs()))\n       mapping.map(arg.value(), newForOp.getRegionIterArgs()[arg.index()]);\n+    mapping.map(forOp.getInductionVar(), newForOp.getInductionVar());\n \n     for (Operation &op : forOp.getBody()->getOperations()) {\n-      Operation *newOp = rewriter.clone(op, mapping);\n+      rewriter.clone(op, mapping);\n     }\n     rewriter.replaceOp(forOp, newForOp.getResults());\n     return success();\n@@ -1329,7 +1331,7 @@ class UpdateMMAVersionMinorForVolta : public mlir::RewritePattern {\n       rewriteCvtToMma(op, rewriter);\n       break;\n     default:\n-      assert(false && \"Not supported\");\n+      llvm::report_fatal_error(\"Not supported rewrite kind\");\n     }\n   }\n \n@@ -1392,71 +1394,6 @@ class UpdateMMAVersionMinorForVolta : public mlir::RewritePattern {\n   }\n };\n \n-class RematerializeForloopForVolta : public RewritePattern {\n-\n-  const DenseMap<MmaEncodingAttr, MmaEncodingAttr> &mmaToUpdate;\n-\n-public:\n-  RematerializeForloopForVolta(\n-      mlir::MLIRContext *ctx,\n-      const DenseMap<MmaEncodingAttr, MmaEncodingAttr> &mmaToUpdate)\n-      : RewritePattern(scf::ForOp::getOperationName(), 1 /*benefit*/, ctx),\n-        mmaToUpdate(mmaToUpdate) {}\n-\n-  LogicalResult matchAndRewrite(Operation *op,\n-                                PatternRewriter &rewriter) const override {\n-    auto forOp = cast<scf::ForOp>(op);\n-    auto iterOps = forOp.getIterOperands();\n-    auto resTypes = forOp->getResultTypes();\n-    bool needRematerialize{};\n-    for (auto type : resTypes)\n-      if (auto tensorTy = type.dyn_cast<RankedTensorType>()) {\n-        if (!tensorTy.getEncoding())\n-          continue;\n-        if (auto mma = tensorTy.getEncoding().dyn_cast<MmaEncodingAttr>()) {\n-          if (!mmaToUpdate.count(mma))\n-            continue;\n-          needRematerialize = true;\n-          break;\n-        }\n-      }\n-\n-    if (needRematerialize) {\n-      auto res = rematerializeForLoop(rewriter, forOp);\n-      rewriter.replaceOp(op, res);\n-      return success();\n-    }\n-    return failure();\n-  }\n-\n-  SmallVector<Value, 4> rematerializeForLoop(mlir::PatternRewriter &rewriter,\n-                                             scf::ForOp &forOp) const {\n-    auto newForOp = rewriter.create<scf::ForOp>(\n-        forOp.getLoc(), forOp.getLowerBound(), forOp.getUpperBound(),\n-        forOp.getStep(), forOp.getInitArgs());\n-\n-    newForOp->moveBefore(forOp);\n-    rewriter.setInsertionPointToStart(newForOp.getBody());\n-    BlockAndValueMapping mapping;\n-    for (const auto &arg : llvm::enumerate(forOp.getRegionIterArgs()))\n-      mapping.map(arg.value(), newForOp.getRegionIterArgs()[arg.index()]);\n-    mapping.map(forOp.getInductionVar(), newForOp.getInductionVar());\n-\n-    for (auto &op : forOp.getBody()->without_terminator()) {\n-      rewriter.clone(op, mapping);\n-    }\n-\n-    SmallVector<Value, 4> newYieldArgs;\n-    auto yieldOp = forOp.getBody()->getTerminator();\n-    for (Value arg : yieldOp->getOperands())\n-      newYieldArgs.push_back(mapping.lookup(arg));\n-    rewriter.create<scf::YieldOp>(forOp.getLoc(), newYieldArgs);\n-\n-    auto newResults = newForOp->getResults();\n-    return newResults;\n-  }\n-};\n-\n } // namespace\n \n #define GEN_PASS_CLASSES\n@@ -1512,12 +1449,6 @@ class TritonGPUCombineOpsPass\n       if (applyPatternsAndFoldGreedily(m, std::move(patterns), config).failed())\n         signalPassFailure();\n     }\n-    {\n-      mlir::RewritePatternSet patterns(context);\n-      patterns.add<RematerializeForloopForVolta>(context, mmaToUpdate);\n-      if (applyPatternsAndFoldGreedily(m, std::move(patterns)).failed())\n-        signalPassFailure();\n-    }\n \n     mlir::RewritePatternSet loopFixup(context);\n     loopFixup.add<FixupLoop>(context);"}]