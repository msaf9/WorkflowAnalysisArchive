[{"filename": "lib/codegen/analysis/liveness.cc", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "file_content_changes": "@@ -14,13 +14,14 @@ namespace analysis{\n void liveness::run(ir::module &mod) {\n   intervals_.clear();\n \n-  std::map<ir::value*, shared_layout*> layouts_map;\n+  std::map<ir::value*, std::set<shared_layout*>> layouts_map;\n   for(auto &x: layouts_->get_all()){\n     shared_layout* layout = x.second->to_shared();\n     if(!layout)\n       continue;\n-    for(ir::value* v:layout->get_values())\n-      layouts_map[v] = layout;\n+    for(ir::value* v:layout->get_values()){\n+      layouts_map[v].insert(layout);\n+    }\n   }\n \n \n@@ -33,12 +34,18 @@ void liveness::run(ir::module &mod) {\n       // gen\n       std::set<shared_layout*> gen;\n       for(ir::value* v: i->ops())\n-      if(layouts_map.find(v) != layouts_map.end())\n-        gen.insert(layouts_map.at(v));\n+      for(shared_layout* layout: layouts_map[v])\n+        gen.insert(layout);\n       // kill\n       std::set<shared_layout*> kill;\n-      if(layouts_map.find(i) != layouts_map.end())\n-        kill.insert(layouts_map.at(i));\n+      for(shared_layout* layout: layouts_map[i])\n+        kill.insert(layout);\n+      // temporaries are handled separately\n+      if(layouts_->has_tmp(i)){\n+        gen.insert(layouts_->get(layouts_->tmp(i))->to_shared());\n+        kill.insert(layouts_->get(layouts_->tmp(i))->to_shared());\n+      }\n+\n       // new sets\n       std::set<shared_layout*> live_out_minus_kill;\n       std::set_difference(live_out[i].begin(), live_out[i].end(), kill.begin(), kill.end(), \n@@ -76,35 +83,6 @@ void liveness::run(ir::module &mod) {\n       intervals_[layout] = segment{INT32_MAX, 0};\n   }\n \n-\n-\n-\n-  // // create live intervals\n-  // for(auto &x: layouts_->get_all()) {\n-  //   shared_layout* layout = x.second->to_shared();\n-  //   if(!layout)\n-  //     continue;\n-  //   // users\n-  //   std::set<ir::user*> users;\n-  //   for(ir::value *v: layout->get_values()){\n-  //     for(ir::user *u: v->get_users())\n-  //       users.insert(u);\n-  //   } \n-  //   // compute intervals\n-  //   unsigned start = INT32_MAX;\n-  //   for(ir::value *v: layout->get_values())\n-  //     if(indices.find(v) != indices.end())\n-  //       start = std::min(start, indices.at(v));\n-  //   unsigned end = 0;\n-  //   for(ir::user *u: users)\n-  //     if(indices.find(u) != indices.end())\n-  //       end = std::max(end, indices.at(u));\n-  //   if(end == 0)\n-  //     end = start + 1;\n-  //   intervals_[layout] = segment{start, end};\n-  // }\n-\n-\n   for(auto& x: live_out)\n   for(shared_layout* layout: x.second)\n     intervals_[layout].start = std::min<int>(intervals_[layout].start, indices[x.first]);\n@@ -119,7 +97,6 @@ void liveness::run(ir::module &mod) {\n     shared_layout* layout = x.second->to_shared();\n     if(!layout)\n       continue;\n-    // std::cout << intervals_[layout].start << \" \" << intervals_[layout].end << std::endl;\n   }\n \n   "}, {"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "file_content_changes": "@@ -2074,10 +2074,13 @@ void generator::visit_mma16816(ir::dot_inst* C, ir::value *A, ir::value *B, ir::\n   // left-hand-side values\n   std::map<std::pair<unsigned, unsigned>, Value*> ha;\n   std::map<std::pair<unsigned, unsigned>, Value*> hb;\n+  // if true, this will move pointer declarations to the entry basic block\n \n   BasicBlock* CurrBB = builder_->GetInsertBlock();\n   BasicBlock* FirstBB = &CurrBB->getParent()->getEntryBlock();\n-  if(FirstBB != CurrBB)\n+  bool licm_ptrs = false;\n+  licm_ptrs = (FirstBB != CurrBB);\n+  if(licm_ptrs)\n     builder_->SetInsertPoint(FirstBB->getTerminator());\n \n   Value* thread = tgt_->get_local_id(mod_, *builder_, 0);\n@@ -2111,20 +2114,21 @@ void generator::visit_mma16816(ir::dot_inst* C, ir::value *A, ir::value *B, ir::\n   analysis::shared_layout* layout_a = layouts_->get(C->get_operand(0))->to_shared();\n   bool is_a_shared = layout_a != nullptr;\n   if(is_a_shared) {\n-    if(FirstBB != CurrBB)\n-      builder_->SetInsertPoint(FirstBB->getTerminator());\n     const int per_phase_a = swizzle_->get_per_phase(layout_a);\n     const int max_phase_a = swizzle_->get_max_phase(layout_a);\n     mma16816_smem_loader a_loader(layout->wpt(0), ord_a, /*k_order*/1, shape_a, \n                                   {mma_instr_m, mma_instr_k}, {mat_shape_m, mat_shape_k}, \n                                   per_phase_a, max_phase_a, dtsize_a, builder_, add, mul, gep);\n     std::vector<Value*> off_a = a_loader.compute_offs(warp_m, lane);\n     int num_ptr_a = a_loader.get_num_ptr();\n-    builder_->SetInsertPoint(CurrBB);\n     // pointers\n     std::vector<Value*> ptrs_a(num_ptr_a);\n+    if(licm_ptrs)\n+      builder_->SetInsertPoint(CurrBB);\n     for(int i = 0; i < num_ptr_a; i++)\n       ptrs_a[i] = bit_cast(gep(shmems_[A], {off_a[i]}), smem_ptr_ty);\n+    if(licm_ptrs)\n+      builder_->SetInsertPoint(FirstBB->getTerminator());\n     // loading function\n     load_a = [&,a_loader,ptrs_a,off_a](int m, int k, int inc, bool is_prefetch) mutable {\n       auto [ha0, ha1, ha2, ha3] = a_loader.load_x4(m, k, inc, is_prefetch, phiA, shared_pre_ptr_[layout_a],\n@@ -2165,8 +2169,6 @@ void generator::visit_mma16816(ir::dot_inst* C, ir::value *A, ir::value *B, ir::\n     };\n   }\n \n-  if(FirstBB != CurrBB)\n-    builder_->SetInsertPoint(FirstBB->getTerminator());\n \n   // | -> n (col-major)\n   // v (s0_0(0), | (stride: wpt(1)) | s1_0(2)  | *num_rep_n\n@@ -2191,12 +2193,16 @@ void generator::visit_mma16816(ir::dot_inst* C, ir::value *A, ir::value *B, ir::\n                                 mma_instr_b, mat_shape_b,\n                                 per_phase_b, max_phase_b, dtsize_b, builder_, add, mul, gep);\n   std::vector<Value*> off_b = b_loader.compute_offs(warp_n, lane);\n-  builder_->SetInsertPoint(CurrBB);\n+\n+  if(licm_ptrs)\n+    builder_->SetInsertPoint(CurrBB);\n   // pointers\n   int num_ptr_b = b_loader.get_num_ptr();\n   std::vector<Value*> ptrs_b(num_ptr_b);\n   for(int i = 0; i < num_ptr_b; i++)\n     ptrs_b[i] = bit_cast(gep(shmems_[B], {off_b[i]}), smem_ptr_ty);\n+\n+    \n   // loading function\n   std::function<void(int,int,int,bool)> load_b;\n   load_b = [&](int n, int k, int inc, bool is_prefetch) {"}]