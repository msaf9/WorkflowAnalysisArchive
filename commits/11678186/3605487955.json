[{"filename": "lib/Analysis/Membar.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "file_content_changes": "@@ -81,9 +81,11 @@ void MembarAnalysis::transfer(Operation *op, RegionInfo *regionInfo,\n     return;\n   }\n \n-  if (isa<triton::gpu::AsyncWaitOp>(op)) {\n+  if (isa<triton::gpu::AsyncWaitOp>(op) &&\n+      !isa<gpu::BarrierOp>(op->getNextNode())) {\n     // If the current op is an async wait, we insert a barrier op and sync\n-    // previous reads and writes.\n+    // if the next op is not a barrier\n+    regionInfo->sync();\n     OpBuilder::InsertionGuard g(*builder);\n     builder->setInsertionPointAfter(op);\n     builder->create<gpu::BarrierOp>(op->getLoc());"}, {"filename": "python/tests/test_gemm.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "file_content_changes": "@@ -288,4 +288,8 @@ def matmul_kernel(\n \n     golden = torch.matmul(a, b)\n     golden_abs_err, golden_rel_err = get_proper_err(a, b, golden)\n-    torch.testing.assert_close(c, golden, rtol=max(1e-4, 1.5 * golden_rel_err), atol=max(1e-4, 1.5 * golden_abs_err))\n+    if allow_tf32:\n+        # TF32 is not accurate enough\n+        torch.testing.assert_close(c, golden, rtol=max(1e-2, 1.5 * golden_rel_err), atol=max(1e-2, 1.5 * golden_abs_err))\n+    else:\n+        torch.testing.assert_close(c, golden, rtol=max(1e-4, 1.5 * golden_rel_err), atol=max(1e-4, 1.5 * golden_abs_err))"}]