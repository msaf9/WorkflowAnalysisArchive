[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "file_content_changes": "@@ -625,29 +625,29 @@ def visit_ExtSlice(self, node):\n         return [self.visit(dim) for dim in node.dims]\n \n     def visit_For(self, node):\n-        iterator = self.visit(node.iter.func)\n-        if iterator != self.builtins['range']:\n+        Iterator = self.visit(node.iter.func)\n+        iter_args = [self.visit(arg) for arg in node.iter.args]\n+        if Iterator == triton.language.static_range:\n+            iterator = Iterator(*iter_args)\n+            static_range = range(iterator.start.value, \n+                                 iterator.end.value, \n+                                 iterator.step.value)\n+            for i in static_range:\n+                self.lscope[node.target.id] = triton.language.constexpr(i)\n+                self.visit_compound_statement(node.body)\n+                for stmt in node.orelse:\n+                    ast.NodeVisitor.generic_visit(self, stmt)\n+            return\n+\n+        if Iterator != self.builtins['range']:\n             raise RuntimeError('Only `range` iterator currently supported')\n+\n         # visit iterator arguments\n         # note: only `range` iterator is supported now\n-        iter_args = [self.visit(arg) for arg in node.iter.args]\n         # collect lower bound (lb), upper bound (ub), and step\n         lb = iter_args[0] if len(iter_args) > 1 else self.visit(ast.Num(0))\n         ub = iter_args[1] if len(iter_args) > 1 else self.visit(node.iter.args[0])\n         step = iter_args[2] if len(iter_args) > 2 else self.visit(ast.Num(1))\n-        # static for loops: all iterator arguments are constexpr\n-        if isinstance(lb, triton.language.constexpr) and \\\n-           isinstance(ub, triton.language.constexpr) and \\\n-           isinstance(step, triton.language.constexpr):\n-            sta_range = iterator(lb.value, ub.value, step.value)\n-            static_unrolling = os.environ.get('TRITON_STATIC_LOOP_UNROLLING', False)\n-            if static_unrolling and len(sta_range) <= 10:\n-                for i in sta_range:\n-                    self.lscope[node.target.id] = triton.language.constexpr(i)\n-                    self.visit_compound_statement(node.body)\n-                    for stmt in node.orelse:\n-                        ast.NodeVisitor.generic_visit(self, stmt)\n-                return\n         # handle negative constant step (not supported by scf.for in MLIR)\n         negative_step = False\n         if isinstance(step, triton.language.constexpr) and step.value < 0:"}, {"filename": "python/triton/language/__init__.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -65,6 +65,7 @@\n     store,\n     sum,\n     swizzle2d,\n+    static_range,\n     tensor,\n     trans,\n     triton,\n@@ -162,6 +163,7 @@\n     \"sin\",\n     \"softmax\",\n     \"sqrt\",\n+    \"static_range\",\n     \"store\",\n     \"sum\",\n     \"swizzle2d\","}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "file_content_changes": "@@ -1307,3 +1307,32 @@ def printf(prefix, *args, _builder=None):\n     for arg in args:\n         new_args.append(_to_tensor(arg, _builder))\n     return semantic.printf(new_prefix, new_args, _builder)\n+\n+# -----------------------\n+# Iterators\n+# -----------------------\n+\n+class static_range:\n+\n+  \"\"\"Iterator that counts upward forever.\"\"\"\n+\n+  def __init__(self, arg1, arg2=None, step=None):\n+      assert isinstance(arg1, constexpr)\n+      if step is None:\n+          self.step = constexpr(1)\n+      else:\n+          assert isinstance(step, constexpr)\n+          self.step = step\n+      if arg2 is None:\n+          self.start = constexpr(0)\n+          self.end = arg1\n+      else:\n+          assert isinstance(arg2, constexpr)\n+          self.start = arg1\n+          self.end = arg2\n+\n+  def __iter__(self):\n+      raise RuntimeError(\"static_range can only be used in @triton.jit'd functions\")\n+\n+  def __next__(self):\n+      raise RuntimeError(\"static_range can only be used in @triton.jit'd functions\")\n\\ No newline at end of file"}, {"filename": "python/triton/language/random.py", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "file_content_changes": "@@ -11,13 +11,12 @@\n # randint\n # -------------------\n \n-\n @triton.jit\n def philox_impl(c0, c1, c2, c3, k0, k1, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n     \"\"\"\n     Run `n_rounds` rounds of Philox for state (c0, c1, c2, c3) and key (k0, k1).\n     \"\"\"\n-    for _ in range(n_rounds):\n+    for _ in tl.static_range(n_rounds):\n         # update random state\n         A = PHILOX_ROUND_A\n         B = PHILOX_ROUND_B"}]