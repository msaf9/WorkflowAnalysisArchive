[{"filename": "CMakeLists.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -72,6 +72,8 @@ if (NOT MLIR_DIR)\n       find_package(LLVM 11 REQUIRED COMPONENTS \"nvptx;amdgpu\")\n     endif()\n     message(STATUS \"Found LLVM ${LLVM_PACKAGE_VERSION}\")\n+    # FindLLVM outputs LLVM_LIBRARY_DIRS but we expect LLVM_LIBRARY_DIR here\n+    set(LLVM_LIBRARY_DIR ${LLVM_LIBRARY_DIRS})\n     if(APPLE)\n       set(CMAKE_OSX_DEPLOYMENT_TARGET \"10.14\")\n     endif()"}, {"filename": "cmake/FindLLVM.cmake", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "file_content_changes": "@@ -33,14 +33,12 @@\n # We also want an user-specified LLVM_ROOT_DIR to take precedence over the\n # system default locations such as /usr/local/bin. Executing find_program()\n # multiples times is the approach recommended in the docs.\n-set(llvm_config_names llvm-config-12.0 llvm-config120 llvm-config-12 llvm-config-12-64\n-                      llvm-config-11.0 llvm-config110 llvm-config-11 llvm-config-11-64\n-                      llvm-config-10.0 llvm-config100 llvm-config-10 llvm-config-10-64\n-                      llvm-config-9.0 llvm-config90 llvm-config-9 llvm-config-9-64\n-                      llvm-config-8.0 llvm-config80 llvm-config-8 llvm-config-8-64\n-                      llvm-config-7.0 llvm-config70 llvm-config-7 llvm-config-7-64\n-                      llvm-config-6.0 llvm-config60\n+set(llvm_config_names llvm-config-6.0 llvm-config60\n                       llvm-config)\n+foreach(v RANGE 7 17)\n+    # names like llvm-config-7.0 llvm-config70 llvm-config-7 llvm-config-7-64\n+    list(PREPEND llvm_config_names llvm-config-${v}.0 llvm-config${v}0 llvm-config-${v} llvm-config-${v}-64)\n+endforeach()\n find_program(LLVM_CONFIG\n     NAMES ${llvm_config_names}\n     PATHS ${LLVM_ROOT_DIR}/bin NO_DEFAULT_PATH"}, {"filename": "include/triton/Analysis/Utility.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "file_content_changes": "@@ -65,7 +65,7 @@ template <typename Int> Int product(llvm::ArrayRef<Int> arr) {\n \n template <typename Int> Int ceil(Int m, Int n) { return (m + n - 1) / n; }\n \n-/// output[i] = input[order[i]]\n+// output[i] = input[order[i]]\n template <typename T, typename RES_T = T>\n SmallVector<RES_T> reorder(ArrayRef<T> input, ArrayRef<unsigned> order) {\n   size_t rank = order.size();\n@@ -89,14 +89,6 @@ bool isSingleValue(Value value);\n bool isMmaToDotShortcut(triton::gpu::MmaEncodingAttr &mmaLayout,\n                         triton::gpu::DotOperandEncodingAttr &dotOperandLayout);\n \n-/// Multi-root DAG topological sort.\n-/// Performs a topological sort of the Operation in the `toSort` SetVector.\n-/// Returns a topologically sorted SetVector.\n-/// It is faster than mlir::topologicalSort because it prunes nodes that have\n-/// been visited before.\n-SetVector<Operation *>\n-multiRootTopologicalSort(const SetVector<Operation *> &toSort);\n-\n } // namespace mlir\n \n #endif // TRITON_ANALYSIS_UTILITY_H"}, {"filename": "lib/Analysis/Utility.cpp", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "file_content_changes": "@@ -177,65 +177,4 @@ bool isSingleValue(Value value) {\n   return true;\n }\n \n-namespace {\n-/// DFS post-order implementation that maintains a global count to work across\n-/// multiple invocations, to help implement topological sort on multi-root DAGs.\n-/// We traverse all operations but only record the ones that appear in\n-/// `toSort` for the final result.\n-struct DFSState {\n-  DFSState(const SetVector<Operation *> &set) : toSort(set), seen() {}\n-  const SetVector<Operation *> &toSort;\n-  SmallVector<Operation *, 16> topologicalCounts;\n-  DenseSet<Operation *> seen;\n-};\n-\n-void dfsPostorder(Operation *root, DFSState *state) {\n-  SmallVector<Operation *> queue(1, root);\n-  std::vector<Operation *> ops;\n-  while (!queue.empty()) {\n-    Operation *current = queue.pop_back_val();\n-    if (!state->seen.insert(current).second)\n-      continue;\n-    ops.push_back(current);\n-    for (Value result : current->getResults()) {\n-      for (Operation *op : result.getUsers())\n-        queue.push_back(op);\n-    }\n-    for (Region &region : current->getRegions()) {\n-      for (Operation &op : region.getOps())\n-        queue.push_back(&op);\n-    }\n-  }\n-\n-  for (Operation *op : llvm::reverse(ops)) {\n-    if (state->toSort.count(op) > 0)\n-      state->topologicalCounts.push_back(op);\n-  }\n-}\n-\n-} // namespace\n-\n-SetVector<Operation *>\n-multiRootTopologicalSort(const SetVector<Operation *> &toSort) {\n-  if (toSort.empty()) {\n-    return toSort;\n-  }\n-\n-  // Run from each root with global count and `seen` set.\n-  DFSState state(toSort);\n-  for (auto *s : toSort) {\n-    assert(toSort.count(s) == 1 && \"NYI: multi-sets not supported\");\n-    dfsPostorder(s, &state);\n-  }\n-\n-  // Reorder and return.\n-  SetVector<Operation *> res;\n-  for (auto it = state.topologicalCounts.rbegin(),\n-            eit = state.topologicalCounts.rend();\n-       it != eit; ++it) {\n-    res.insert(*it);\n-  }\n-  return res;\n-}\n-\n } // namespace mlir"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -674,7 +674,7 @@ class RematerializeBackward : public mlir::RewritePattern {\n       else\n         sortedValues.push_back(v);\n     }\n-    tmp = mlir::multiRootTopologicalSort(tmp);\n+    tmp = mlir::topologicalSort(tmp);\n     for (Operation *op : tmp)\n       sortedValues.push_back(op->getResult(0));\n "}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "file_content_changes": "@@ -625,29 +625,29 @@ def visit_ExtSlice(self, node):\n         return [self.visit(dim) for dim in node.dims]\n \n     def visit_For(self, node):\n-        iterator = self.visit(node.iter.func)\n-        if iterator != self.builtins['range']:\n-            raise RuntimeError('Only `range` iterator currently supported')\n+        IteratorClass = self.visit(node.iter.func)\n+        iter_args = [self.visit(arg) for arg in node.iter.args]\n+        if IteratorClass == triton.language.static_range:\n+            iterator = IteratorClass(*iter_args)\n+            static_range = range(iterator.start.value,\n+                                 iterator.end.value,\n+                                 iterator.step.value)\n+            for i in static_range:\n+                self.lscope[node.target.id] = triton.language.constexpr(i)\n+                self.visit_compound_statement(node.body)\n+                for stmt in node.orelse:\n+                    ast.NodeVisitor.generic_visit(self, stmt)\n+            return\n+\n+        if IteratorClass != self.builtins['range']:\n+            raise RuntimeError('Only `range` and `static_range` iterators are currently supported')\n+\n         # visit iterator arguments\n         # note: only `range` iterator is supported now\n-        iter_args = [self.visit(arg) for arg in node.iter.args]\n         # collect lower bound (lb), upper bound (ub), and step\n         lb = iter_args[0] if len(iter_args) > 1 else self.visit(ast.Num(0))\n         ub = iter_args[1] if len(iter_args) > 1 else self.visit(node.iter.args[0])\n         step = iter_args[2] if len(iter_args) > 2 else self.visit(ast.Num(1))\n-        # static for loops: all iterator arguments are constexpr\n-        if isinstance(lb, triton.language.constexpr) and \\\n-           isinstance(ub, triton.language.constexpr) and \\\n-           isinstance(step, triton.language.constexpr):\n-            sta_range = iterator(lb.value, ub.value, step.value)\n-            static_unrolling = os.environ.get('TRITON_STATIC_LOOP_UNROLLING', False)\n-            if static_unrolling and len(sta_range) <= 10:\n-                for i in sta_range:\n-                    self.lscope[node.target.id] = triton.language.constexpr(i)\n-                    self.visit_compound_statement(node.body)\n-                    for stmt in node.orelse:\n-                        ast.NodeVisitor.generic_visit(self, stmt)\n-                return\n         # handle negative constant step (not supported by scf.for in MLIR)\n         negative_step = False\n         if isinstance(step, triton.language.constexpr) and step.value < 0:\n@@ -1545,7 +1545,7 @@ def compile(fn, **kwargs):\n                  lambda src: ast_to_ttir(src, signature, configs[0], constants)),\n         \"ttgir\": (lambda path: _triton.ir.parse_mlir_module(path, context),\n                   lambda src: ttir_to_ttgir(src, num_warps, num_stages, capability)),\n-        \"llir\": (lambda path: Path(path).read_bytes(),\n+        \"llir\": (lambda path: Path(path).read_text(),\n                  lambda src: ttgir_to_llir(src, extern_libs, capability)),\n         \"ptx\": (lambda path: Path(path).read_text(),\n                 lambda src: llir_to_ptx(src, capability)),"}, {"filename": "python/triton/language/__init__.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -65,6 +65,7 @@\n     store,\n     sum,\n     swizzle2d,\n+    static_range,\n     tensor,\n     trans,\n     triton,\n@@ -162,6 +163,7 @@\n     \"sin\",\n     \"softmax\",\n     \"sqrt\",\n+    \"static_range\",\n     \"store\",\n     \"sum\",\n     \"swizzle2d\","}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "file_content_changes": "@@ -1307,3 +1307,33 @@ def printf(prefix, *args, _builder=None):\n     for arg in args:\n         new_args.append(_to_tensor(arg, _builder))\n     return semantic.printf(new_prefix, new_args, _builder)\n+\n+# -----------------------\n+# Iterators\n+# -----------------------\n+\n+\n+class static_range:\n+\n+    \"\"\"Iterator that counts upward forever.\"\"\"\n+\n+    def __init__(self, arg1, arg2=None, step=None):\n+        assert isinstance(arg1, constexpr)\n+        if step is None:\n+            self.step = constexpr(1)\n+        else:\n+            assert isinstance(step, constexpr)\n+            self.step = step\n+        if arg2 is None:\n+            self.start = constexpr(0)\n+            self.end = arg1\n+        else:\n+            assert isinstance(arg2, constexpr)\n+            self.start = arg1\n+            self.end = arg2\n+\n+    def __iter__(self):\n+        raise RuntimeError(\"static_range can only be used in @triton.jit'd functions\")\n+\n+    def __next__(self):\n+        raise RuntimeError(\"static_range can only be used in @triton.jit'd functions\")"}, {"filename": "python/triton/language/random.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -17,7 +17,7 @@ def philox_impl(c0, c1, c2, c3, k0, k1, n_rounds: tl.constexpr = N_ROUNDS_DEFAUL\n     \"\"\"\n     Run `n_rounds` rounds of Philox for state (c0, c1, c2, c3) and key (k0, k1).\n     \"\"\"\n-    for _ in range(n_rounds):\n+    for _ in tl.static_range(n_rounds):\n         # update random state\n         A = PHILOX_ROUND_A\n         B = PHILOX_ROUND_B"}]