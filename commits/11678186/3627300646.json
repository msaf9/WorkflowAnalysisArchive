[{"filename": ".github/workflows/integration-tests.yml", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "file_content_changes": "@@ -17,7 +17,7 @@ jobs:\n         id: set-matrix\n         run: |\n           if [ x\"${{ github.repository }}\" == x\"openai/triton\" ]; then\n-            echo '::set-output name=matrix::[[\"self-hosted\", \"A10\"], \"macos-10.15\"]'\n+            echo '::set-output name=matrix::[[\"self-hosted\", \"A10\"], [\"self-hosted\", \"V100\"], \"macos-10.15\"]'\n           else\n             echo '::set-output name=matrix::[\"ubuntu-latest\", \"macos-10.15\"]'\n           fi\n@@ -79,11 +79,18 @@ jobs:\n           lit -v \"$LIT_TEST_DIR\"\n \n       - name: Run python tests\n-        if: ${{matrix.runner[0] == 'self-hosted'}}\n+        if: ${{matrix.runner[0] == 'self-hosted' && matrix.runner[1] == 'A10'}}\n         run: |\n           cd python/tests\n           pytest\n \n+      # TODO[Superjomn] Enable all the tests on V100 if available\n+      - name: Run python tests on V100\n+        if: ${{matrix.runner[0] == 'self-hosted' && matrix.runner[1] == 'V100'}}\n+        run: |\n+          cd python/tests\n+          pytest test_gemm.py::test_gemm_no_scf_for_mmav1\n+\n       - name: Run CXX unittests\n         run: |\n           cd python/"}, {"filename": "include/triton/Dialect/TritonGPU/IR/TritonGPUAttrDefs.td", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "file_content_changes": "@@ -87,17 +87,25 @@ A_{3, 2}  A_{3, 3}  A_{3, 0}  A_{3, 1} ...   [phase 1] /\n         // number of rows per phase\n         int perPhase = 128 / (shape[order[0]] * (eltTy.getIntOrFloatBitWidth() / 8));\n         perPhase = std::max<int>(perPhase, 1);\n-        \n+\n         // index of the inner dimension in `order`\n         unsigned inner = (opIdx == 0) ? 0 : 1;\n \n         // ---- begin version 1 ----\n-        // TODO: handle rep (see\n-        // https://github.com/openai/triton/blob/master/lib/codegen/analysis/layout.cc#L209)\n         if (version == 1) {\n+          bool is_row = order[0] != 0;\n+          bool is_vec4 = opIdx == 0 ? !is_row && (shape[order[0]] <= 16) :\n+              is_row && (shape[order[0]] <= 16);\n+          // TODO[Superjomn]: Support the case when is_vec4=false later\n+          // Currently, we only support ld.v2, for the mma layout varies with different ld vector width.\n+          is_vec4 = true;\n+          int pack_size = opIdx == 0 ? ((is_row || is_vec4) ? 1 : 2) :\n+                                       ((is_row && !is_vec4) ? 2 : 1);\n+          int rep = 2 * pack_size;\n           int maxPhase = (order[inner] == 1 ? 8 : 4) / perPhase;\n-          return $_get(context, 1, perPhase, maxPhase, order);\n-        } \n+          int vec = 2 * rep;\n+          return $_get(context, vec, perPhase, maxPhase, order);\n+        }\n \n         // ---- begin version 2 ----\n         if (version == 2) {\n@@ -106,23 +114,23 @@ A_{3, 2}  A_{3, 3}  A_{3, 0}  A_{3, 1} ...   [phase 1] /\n           // for now, disable swizzle when using transposed int8 tensor cores\n           if (eltTy.isInteger(8) && order[0] == inner)\n             return $_get(context, 1, 1, 1, order);\n-            \n+\n           // --- handle A operand ---\n           if (opIdx == 0) { // compute swizzling for A operand\n               int vec = (order[0] == 1) ? matShape[2] : matShape[0]; // k : m\n               int mmaStride = (order[0] == 1) ? matShape[0] : matShape[2];\n               int maxPhase = mmaStride / perPhase;\n               return $_get(context, vec, perPhase, maxPhase, order);\n-          } \n+          }\n \n           // --- handle B operand ---\n           if (opIdx == 1) {\n               int vec = (order[0] == 1) ? matShape[1] : matShape[2]; // n : k\n               int mmaStride = (order[0] == 1) ? matShape[2] : matShape[1];\n               int maxPhase = mmaStride / perPhase;\n               return $_get(context, vec, perPhase, maxPhase, order);\n-          } \n-            \n+          }\n+\n           llvm_unreachable(\"invalid operand index\");\n         }\n "}, {"filename": "lib/Conversion/TritonGPUToLLVM/DotHelpers.h", "status": "modified", "additions": 62, "deletions": 76, "changes": 138, "file_content_changes": "@@ -39,15 +39,6 @@ using ::mlir::triton::gpu::DotOperandEncodingAttr;\n using ::mlir::triton::gpu::MmaEncodingAttr;\n using ::mlir::triton::gpu::SharedEncodingAttr;\n \n-// Forward declaration necessary functions locates in TritonGPUToLLVM.cpp .\n-llvm::SmallVector<mlir::Value>\n-getElementsFromStruct(mlir::Location loc, mlir::Value llvmStruct,\n-                      mlir::ConversionPatternRewriter &rewriter);\n-\n-mlir::LLVM::SharedMemoryObject\n-getSharedMemoryObjectFromStruct(mlir::Location loc, mlir::Value llvmStruct,\n-                                mlir::ConversionPatternRewriter &rewriter);\n-\n // Helper for conversion of DotOp with mma<version=1>, that is sm<80\n struct DotOpMmaV1ConversionHelper {\n   MmaEncodingAttr mmaLayout;\n@@ -710,17 +701,13 @@ class MMA16816SmemLoader {\n       if (kOrder == 1) {\n         elems[0] = load(gep(elemPtrTy, ptr, sOffsetElemVal));\n         elems[1] = load(gep(elemPtrTy, ptr2, sOffsetElemVal));\n-        elems[2] =\n-            load(gep(elemPtrTy, ptr, sOffsetArrElemVal));\n-        elems[3] =\n-            load(gep(elemPtrTy, ptr2, sOffsetArrElemVal));\n+        elems[2] = load(gep(elemPtrTy, ptr, sOffsetArrElemVal));\n+        elems[3] = load(gep(elemPtrTy, ptr2, sOffsetArrElemVal));\n       } else {\n         elems[0] = load(gep(elemPtrTy, ptr, sOffsetElemVal));\n         elems[2] = load(gep(elemPtrTy, ptr2, sOffsetElemVal));\n-        elems[1] =\n-            load(gep(elemPtrTy, ptr, sOffsetArrElemVal));\n-        elems[3] =\n-            load(gep(elemPtrTy, ptr2, sOffsetArrElemVal));\n+        elems[1] = load(gep(elemPtrTy, ptr, sOffsetArrElemVal));\n+        elems[3] = load(gep(elemPtrTy, ptr2, sOffsetArrElemVal));\n       }\n       return {elems[0], elems[1], elems[2], elems[3]};\n \n@@ -952,7 +939,6 @@ struct MMA16816ConversionHelper {\n   // Loading $a from smem to registers, returns a LLVM::Struct.\n   Value loadA(Value tensor, const SharedMemoryObject &smemObj) const {\n     auto aTensorTy = tensor.getType().cast<RankedTensorType>();\n-    auto layout = aTensorTy.getEncoding().cast<SharedEncodingAttr>();\n \n     SmallVector<int64_t> shape(aTensorTy.getShape().begin(),\n                                aTensorTy.getShape().end());\n@@ -973,12 +959,13 @@ struct MMA16816ConversionHelper {\n     if (aTensorTy.getEncoding().isa<SharedEncodingAttr>()) {\n       Value warpM = getWarpM(shape[0]);\n       // load from smem\n-      int wpt = std::min<int>(mmaLayout.getWarpsPerCTA()[0], shape[0] / matShapeM);\n-      loadFn = getLoadMatrixFn(\n-          tensor, smemObj, mmaLayout, wpt /*wpt*/,\n-          1 /*kOrder*/, {mmaInstrM, mmaInstrK} /*instrShape*/,\n-          {matShapeM, matShapeK} /*matShape*/, warpM /*warpId*/, ha /*vals*/,\n-          true /*isA*/);\n+      int wpt =\n+          std::min<int>(mmaLayout.getWarpsPerCTA()[0], shape[0] / matShapeM);\n+      loadFn =\n+          getLoadMatrixFn(tensor, smemObj, mmaLayout, wpt /*wpt*/, 1 /*kOrder*/,\n+                          {mmaInstrM, mmaInstrK} /*instrShape*/,\n+                          {matShapeM, matShapeK} /*matShape*/, warpM /*warpId*/,\n+                          ha /*vals*/, true /*isA*/);\n     } else if (aTensorTy.getEncoding().isa<BlockedEncodingAttr>()) {\n       // load from registers, used in gemm fuse\n       // TODO(Superjomn) Port the logic.\n@@ -1000,7 +987,6 @@ struct MMA16816ConversionHelper {\n   Value loadB(Value tensor, const SharedMemoryObject &smemObj) {\n     ValueTable hb;\n     auto tensorTy = tensor.getType().cast<RankedTensorType>();\n-    auto layout = tensorTy.getEncoding().cast<SharedEncodingAttr>();\n \n     SmallVector<int64_t> shape(tensorTy.getShape().begin(),\n                                tensorTy.getShape().end());\n@@ -1017,12 +1003,13 @@ struct MMA16816ConversionHelper {\n     int numRepN = getNumRepN(tensorTy, shape[1]);\n \n     Value warpN = getWarpN(shape[1]);\n-    int wpt = std::min<int>(mmaLayout.getWarpsPerCTA()[1], shape[1] / matShapeN);\n-    auto loadFn = getLoadMatrixFn(\n-        tensor, smemObj, mmaLayout,  wpt /*wpt*/,\n-        0 /*kOrder*/, {mmaInstrK, mmaInstrN} /*instrShape*/,\n-        {matShapeK, matShapeN} /*matShape*/, warpN /*warpId*/, hb /*vals*/,\n-        false /*isA*/);\n+    int wpt =\n+        std::min<int>(mmaLayout.getWarpsPerCTA()[1], shape[1] / matShapeN);\n+    auto loadFn =\n+        getLoadMatrixFn(tensor, smemObj, mmaLayout, wpt /*wpt*/, 0 /*kOrder*/,\n+                        {mmaInstrK, mmaInstrN} /*instrShape*/,\n+                        {matShapeK, matShapeN} /*matShape*/, warpN /*warpId*/,\n+                        hb /*vals*/, false /*isA*/);\n \n     for (int n = 0; n < std::max(numRepN / 2, 1); ++n) {\n       for (int k = 0; k < numRepK; ++k)\n@@ -1167,6 +1154,7 @@ struct MMA16816ConversionHelper {\n       SmallVector<Value> ptrs(numPtrs);\n \n       Value smemBase = smemObj.getBaseBeforeSwizzle(order[0], loc, rewriter);\n+\n       Type smemPtrTy = helper.getShemPtrTy();\n       for (int i = 0; i < numPtrs; ++i) {\n         ptrs[i] =\n@@ -1292,7 +1280,6 @@ struct DotOpFMAConversionHelper {\n     auto blockedLayout = dotOpLayout.getParent().cast<BlockedEncodingAttr>();\n     auto shapePerCTA = getShapePerCTA(blockedLayout);\n     auto sizePerThread = getSizePerThread(blockedLayout);\n-    auto order = blockedLayout.getOrder();\n \n     // TODO[Superjomn]: we assume the k aixs is fixed for $a and $b here, fix it\n     // if not.\n@@ -1342,17 +1329,15 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   SmallVector<unsigned> order(sharedLayout.getOrder().begin(),\n                               sharedLayout.getOrder().end());\n \n-  // TODO [Superjomn]: transA cannot be accessed in ConvertLayoutOp.\n-  bool transA = false;\n-  if (transA) {\n-    std::swap(shape[0], shape[1]);\n-    std::swap(order[0], order[1]);\n-  }\n-\n   Value cSwizzleOffset = smemObj.getCSwizzleOffset(order[0]);\n+  Value smemBase = smemObj.getBaseBeforeSwizzle(order[0], loc, rewriter);\n \n   bool isARow = order[0] != 0;\n   bool isAVec4 = !isARow && shape[order[0]] <= 16; // fp16*4 = 16bytes\n+  // TODO[Superjomn]: Support the case when isAVec4=false later\n+  // Currently, we only support ld.v2, for the mma layout varies with different\n+  // ld vector width.\n+  isAVec4 = true;\n   int packSize0 = (isARow || isAVec4) ? 1 : 2;\n \n   SmallVector<int> fpw({2, 2, 1});\n@@ -1362,6 +1347,16 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   SmallVector<int> rep({repM, 0, repK}); // pad N with 0\n   SmallVector<int> spw({spwM, 0, 1});    // pad N with 0\n \n+  auto [offsetAM, offsetAK, _0, _1] =\n+      computeOffsets(thread, isARow, false, fpw, spw, rep, rewriter, loc);\n+  // TODO [Superjomn]: transA cannot be accessed in ConvertLayoutOp.\n+  bool transA = false;\n+  if (transA) {\n+    std::swap(shape[0], shape[1]);\n+    std::swap(offsetAM, offsetAK);\n+    std::swap(order[0], order[1]);\n+  }\n+\n   int vecA = sharedLayout.getVec();\n \n   auto strides = smemObj.strides;\n@@ -1373,9 +1368,6 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   int strideRepM = wpt[0] * fpw[0] * 8;\n   int strideRepK = 1;\n \n-  auto [offsetAM, offsetAK, _0, _1] =\n-      computeOffsets(thread, isARow, false, fpw, spw, rep, rewriter, loc);\n-\n   // swizzling\n   int perPhaseA = sharedLayout.getPerPhase();\n   int maxPhaseA = sharedLayout.getMaxPhase();\n@@ -1398,19 +1390,14 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   }\n \n   Type f16x2Ty = vec_ty(f16_ty, 2);\n-  // One thread get 8 elements as result\n-  Type retTy =\n-      LLVM::LLVMStructType::getLiteral(ctx, SmallVector(8, type::f32Ty(ctx)));\n \n   // prepare arguments\n   SmallVector<Value> ptrA(numPtrA);\n \n   std::map<std::pair<int, int>, std::pair<Value, Value>> has;\n-  auto smem = smemObj.getBaseBeforeSwizzle(order[0], loc, rewriter);\n   for (int i = 0; i < numPtrA; i++)\n-    ptrA[i] = gep(ptr_ty(f16_ty), smem, offA[i]);\n+    ptrA[i] = gep(ptr_ty(f16_ty), smemBase, offA[i]);\n \n-  auto instrShape = getMmaInstrShape();\n   unsigned numM = std::max<int>(rep[0] * shape[0] / (spw[0] * wpt[0]), 1);\n \n   Type f16PtrTy = ptr_ty(f16_ty);\n@@ -1420,7 +1407,7 @@ Value DotOpMmaV1ConversionHelper::loadA(\n   };\n   auto loadA = [&](int m, int k) {\n     int offidx = (isARow ? k / 4 : m) % numPtrA;\n-    Value thePtrA = gep(f16PtrTy, smem, offA[offidx]);\n+    Value thePtrA = gep(f16PtrTy, smemBase, offA[offidx]);\n \n     int stepAM = isARow ? m : m / numPtrA * numPtrA;\n     int stepAK = isARow ? k / (numPtrA * vecA) * (numPtrA * vecA) : k;\n@@ -1446,12 +1433,10 @@ Value DotOpMmaV1ConversionHelper::loadA(\n \n   for (unsigned k = 0; k < NK; k += 4)\n     for (unsigned m = 0; m < numM / 2; ++m)\n-      if (!has.count({m, k}))\n-        loadA(m, k);\n+      loadA(m, k);\n \n   SmallVector<Value> elems;\n   elems.reserve(has.size() * 2);\n-  auto vecTy = vec_ty(f16_ty, 2);\n   for (auto item : has) { // has is a map, the key should be ordered.\n     elems.push_back(item.second.first);\n     elems.push_back(item.second.second);\n@@ -1466,7 +1451,6 @@ Value DotOpMmaV1ConversionHelper::loadB(\n     Value tensor, const SharedMemoryObject &smemObj, Value thread, Location loc,\n     ConversionPatternRewriter &rewriter) const {\n   // smem\n-  Value smem = smemObj.base;\n   auto strides = smemObj.strides;\n \n   auto *ctx = rewriter.getContext();\n@@ -1478,46 +1462,50 @@ Value DotOpMmaV1ConversionHelper::loadB(\n   SmallVector<unsigned> order(sharedLayout.getOrder().begin(),\n                               sharedLayout.getOrder().end());\n \n-  // TODO [Superjomn]: transB cannot be accessed in ConvertLayoutOp.\n-  bool transB = false;\n-\n-  if (transB) {\n-    std::swap(order[0], order[1]);\n-    std::swap(shape[0], shape[1]);\n-  }\n+  Value smem = smemObj.getBaseBeforeSwizzle(order[0], loc, rewriter);\n \n   bool isBRow = order[0] != 0;\n   bool isBVec4 = isBRow && shape[order[0]] <= 16;\n+  // TODO[Superjomn]: Support the case when isBVec4=false later\n+  // Currently, we only support ld.v2, for the mma layout varies with different\n+  // ld vector width.\n+  isBVec4 = true;\n   int packSize1 = (isBRow && !isBVec4) ? 2 : 1;\n   SmallVector<int> fpw({2, 2, 1});\n   SmallVector<int> rep({0, 2 * packSize1, 1});       // pad M with 0\n   SmallVector<int> spw({0, fpw[1] * 4 * rep[1], 1}); // pad M with 0\n   int vecB = sharedLayout.getVec();\n+\n   Value strideBN = isBRow ? i32_val(1) : strides[1];\n   Value strideBK = isBRow ? strides[0] : i32_val(1);\n   Value strideB0 = isBRow ? strideBN : strideBK;\n   Value strideB1 = isBRow ? strideBK : strideBN;\n   int strideRepN = wpt[1] * fpw[1] * 8;\n   int strideRepK = 1;\n \n+  // TODO [Superjomn]: transB cannot be accessed in ConvertLayoutOp.\n+  bool transB = false;\n+\n+  auto [_0, _1, offsetBN, offsetBK] =\n+      computeOffsets(thread, false, isBRow, fpw, spw, rep, rewriter, loc);\n+  if (transB) {\n+    std::swap(order[0], order[1]);\n+    std::swap(shape[0], shape[1]);\n+    std::swap(offsetBK, offsetBN);\n+  }\n+\n   // swizzling\n-  int perPhaseA = sharedLayout.getPerPhase();\n-  int maxPhaseA = sharedLayout.getMaxPhase();\n   int perPhaseB = sharedLayout.getPerPhase();\n   int maxPhaseB = sharedLayout.getMaxPhase();\n   int stepB0 = isBRow ? strideRepN : strideRepK;\n   int numPtrB = std::max(2 * perPhaseB * maxPhaseB / stepB0, 1);\n   int NK = shape[0];\n \n-  auto [_0, _1, offsetBN, offsetBK] =\n-      computeOffsets(thread, false, isBRow, fpw, spw, rep, rewriter, loc);\n-  if (transB)\n-    std::swap(offsetBK, offsetBN);\n-\n   Value offB0 = isBRow ? offsetBN : offsetBK;\n   Value offB1 = isBRow ? offsetBK : offsetBN;\n   Value phaseB = urem(udiv(offB1, i32_val(perPhaseB)), i32_val(maxPhaseB));\n   Value cSwizzleOffset = smemObj.getCSwizzleOffset(order[0]);\n+\n   offB0 = add(offB0, cSwizzleOffset);\n   SmallVector<Value> offB(numPtrB);\n   for (int i = 0; i < numPtrB; ++i) {\n@@ -1549,6 +1537,7 @@ Value DotOpMmaV1ConversionHelper::loadB(\n     Value offset = add(mul(i32_val(stepBN * strideRepN), strideBN),\n                        mul(i32_val(stepBK), strideBK));\n     Value pb = gep(f16PtrTy, thePtrB, offset);\n+\n     Value hb =\n         load(bitcast(pb, ptr_ty(vec_ty(i32_ty, std::max(vecB / 2, 1)), 3)));\n     // record lds that needs to be moved\n@@ -1651,9 +1640,12 @@ DotOpMmaV1ConversionHelper::extractLoadedOperand(\n   SmallVector<Value> elems =\n       getElementsFromStruct(llStruct.getLoc(), llStruct, rewriter);\n \n-  for (int k = 0, offset = 0, i = 0; k < NK && offset < elems.size();\n-       k += 4, i++, offset += 2) {\n-    rcds[{i, k}] = std::make_pair(elems[offset], elems[offset + 1]);\n+  int offset = 0;\n+  for (int i = 0; offset < elems.size(); ++i) {\n+    for (int k = 0; k < NK; k += 4) {\n+      rcds[{i, k}] = std::make_pair(elems[offset], elems[offset + 1]);\n+      offset += 2;\n+    }\n   }\n \n   return rcds;\n@@ -1675,9 +1667,7 @@ Value DotOpFMAConversionHelper::loadA(\n   int strideAK = isARow ? 1 : aShape[0];\n   int strideA0 = isARow ? strideAK : strideAM;\n   int strideA1 = isARow ? strideAM : strideAK;\n-  int lda = isARow ? strideAM : strideAK;\n   int aNumPtr = 8;\n-  int bNumPtr = 8;\n   int NK = aShape[1];\n \n   auto shapePerCTA = getShapePerCTA(dLayout);\n@@ -1686,13 +1676,11 @@ Value DotOpFMAConversionHelper::loadA(\n   Value _0 = i32_val(0);\n \n   Value mContig = i32_val(sizePerThread[order[1]]);\n-  Value nContig = i32_val(sizePerThread[order[0]]);\n \n   // threadId in blocked layout\n   auto threadIds = getThreadIds(thread, shapePerCTA, order, rewriter, loc);\n \n   Value threadIdM = threadIds[0];\n-  Value threadIdN = threadIds[1];\n \n   Value offA0 = isARow ? _0 : mul(threadIdM, mContig);\n   Value offA1 = isARow ? mul(threadIdM, mContig) : _0;\n@@ -1745,7 +1733,6 @@ Value DotOpFMAConversionHelper::loadB(\n   int strideBK = isBRow ? bShape[1] : 1;\n   int strideB0 = isBRow ? strideBN : strideBK;\n   int strideB1 = isBRow ? strideBK : strideBN;\n-  int ldb = isBRow ? strideBK : strideBN;\n   int bNumPtr = 8;\n   int NK = bShape[0];\n \n@@ -1754,7 +1741,6 @@ Value DotOpFMAConversionHelper::loadB(\n \n   Value _0 = i32_val(0);\n \n-  Value mContig = i32_val(sizePerThread[order[1]]);\n   Value nContig = i32_val(sizePerThread[order[0]]);\n \n   // threadId in blocked layout"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "file_content_changes": "@@ -62,12 +62,11 @@ namespace LLVM {\n static StringRef getStructAttrsAttrName() { return \"llvm.struct_attrs\"; }\n \n // A helper function for using printf in LLVM conversion.\n-void llPrintf(StringRef msg, ValueRange args,\n-              ConversionPatternRewriter &rewriter);\n+void vprintf(StringRef msg, ValueRange args,\n+             ConversionPatternRewriter &rewriter);\n \n-// Helper function\n-#define tid_val() getThreadId(rewriter, loc)\n-#define llprintf(fmt, ...) LLVM::llPrintf(fmt, {__VA_ARGS__}, rewriter)\n+void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n+                   std::string elem_repr, ConversionPatternRewriter &builder);\n \n } // namespace LLVM\n } // namespace mlir\n@@ -3035,7 +3034,6 @@ void ConvertLayoutOpConversion::processReplica(\n             currVal = zext(llvmElemTy, currVal);\n           else if (isPtr)\n             currVal = ptrtoint(llvmElemTy, currVal);\n-\n           valVec = insert_element(vecTy, valVec, currVal, idx_val(v));\n         }\n         store(valVec, ptr);\n@@ -3143,7 +3141,6 @@ LogicalResult ConvertLayoutOpConversion::lowerBlockedToShared(\n     triton::gpu::ConvertLayoutOp op, OpAdaptor adaptor,\n     ConversionPatternRewriter &rewriter) const {\n   auto loc = op.getLoc();\n-\n   Value src = op.src();\n   Value dst = op.result();\n   auto srcTy = src.getType().cast<RankedTensorType>();\n@@ -3539,8 +3536,8 @@ DotOpConversion::convertMMA884(triton::DotOp op, DotOpAdaptor adaptor,\n   SmallVector<Value> resVals(resSize);\n \n   auto callMMA = [&](unsigned m, unsigned n, unsigned k) {\n-    auto ha = has[{m, k}];\n-    auto hb = hbs[{n, k}];\n+    auto ha = has.at({m, k});\n+    auto hb = hbs.at({n, k});\n     std::vector<size_t> idx{{\n         (m * 2 + 0) + (n * 4 + 0) * numM, // row0\n         (m * 2 + 0) + (n * 4 + 1) * numM,\n@@ -3556,13 +3553,13 @@ DotOpConversion::convertMMA884(triton::DotOp op, DotOpAdaptor adaptor,\n \n     auto *resOprs = builder.newListOperand(8, \"=f\");\n     auto *AOprs = builder.newListOperand({\n-        {ha.first, \"f\"},\n-        {ha.second, \"f\"},\n+        {ha.first, \"r\"},\n+        {ha.second, \"r\"},\n     });\n \n     auto *BOprs = builder.newListOperand({\n-        {hb.first, \"f\"},\n-        {hb.second, \"f\"},\n+        {hb.first, \"r\"},\n+        {hb.second, \"r\"},\n     });\n     auto *COprs = builder.newListOperand();\n     for (int i = 0; i < 8; ++i)\n@@ -4808,11 +4805,23 @@ namespace mlir {\n \n namespace LLVM {\n \n-void llPrintf(StringRef msg, ValueRange args,\n-              ConversionPatternRewriter &rewriter) {\n+void vprintf(StringRef msg, ValueRange args,\n+             ConversionPatternRewriter &rewriter) {\n   PrintfOpConversion::llPrintf(msg, args, rewriter);\n }\n \n+void vprintf_array(Value thread, ArrayRef<Value> arr, std::string info,\n+                   std::string elem_repr, ConversionPatternRewriter &builder) {\n+  std::string fmt = info + \" t-%d \";\n+  std::vector<Value> new_arr({thread});\n+  for (int i = 0; i < arr.size(); ++i) {\n+    fmt += elem_repr + ((i == arr.size() - 1) ? \"\" : \", \");\n+    new_arr.push_back(arr[i]);\n+  }\n+\n+  vprintf(fmt, new_arr, builder);\n+}\n+\n } // namespace LLVM\n \n TritonLLVMConversionTarget::TritonLLVMConversionTarget("}, {"filename": "lib/Conversion/TritonGPUToLLVM/Utility.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -111,6 +111,8 @@\n   LLVM::createIndexConstant(rewriter, loc, this->getTypeConverter(),           \\\n                             __VA_ARGS__)\n \n+#define tid_val() getThreadId(rewriter, loc)\n+\n namespace mlir {\n namespace LLVM {\n using namespace mlir::triton;"}, {"filename": "lib/Dialect/TritonGPU/Transforms/Combine.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "file_content_changes": "@@ -756,6 +756,7 @@ class BlockedToMMA : public mlir::RewritePattern {\n     auto mod = op->getParentOfType<mlir::ModuleOp>();\n     int numWarps = triton::gpu::TritonGPUDialect::getNumWarps(mod);\n     int version = computeCapabilityToMMAVersion(computeCapability);\n+\n     auto newRetType = RankedTensorType::get(\n         retShape, oldRetType.getElementType(),\n         triton::gpu::MmaEncodingAttr::get("}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "file_content_changes": "@@ -1383,6 +1383,11 @@ void init_triton_translation(py::module &m) {\n         llvm::SMDiagnostic error;\n         std::unique_ptr<llvm::Module> module =\n             llvm::parseIR(buffer->getMemBufferRef(), error, context);\n+        if (!module)\n+          llvm::report_fatal_error(\n+              \"failed to parse IR: \" + error.getMessage() +\n+              \"lineno: \" + std::to_string(error.getLineNo()));\n+\n         // translate module to PTX\n         auto ptxCode =\n             triton::translateLLVMIRToPTX(*module, capability, version);"}, {"filename": "python/tests/libdevice_testutil.py", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "file_content_changes": "@@ -0,0 +1,18 @@\n+import os\n+from typing import Optional\n+\n+_SYSTEM_LIBDEVICE_SEARCH_PATHS = [\n+    '/usr/lib/cuda/nvvm/libdevice/libdevice.10.bc',\n+    '/usr/local/cuda/nvvm/libdevice/libdevice.10.bc',\n+]\n+\n+SYSTEM_LIBDEVICE_PATH: Optional[str] = None\n+for _p in _SYSTEM_LIBDEVICE_SEARCH_PATHS:\n+    if os.path.exists(_p):\n+        SYSTEM_LIBDEVICE_PATH = _p\n+\n+def system_libdevice_path() -> str:\n+    assert SYSTEM_LIBDEVICE_PATH is not None, \\\n+        \"Could not find libdevice.10.bc path\"\n+    return SYSTEM_LIBDEVICE_PATH\n+"}, {"filename": "python/tests/test_core.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -12,6 +12,7 @@\n import triton._C.libtriton.triton as _triton\n import triton.language as tl\n from triton.runtime.jit import JITFunction, TensorWrapper, reinterpret\n+from tests.libdevice_testutil import system_libdevice_path\n \n int_dtypes = ['int8', 'int16', 'int32', 'int64']\n uint_dtypes = ['uint8', 'uint16', 'uint32', 'uint64']\n@@ -1552,7 +1553,7 @@ def _kernel(dst):\n \n @pytest.mark.parametrize(\"dtype_str, expr, lib_path\",\n                          [('int32', 'libdevice.ffs', ''),\n-                          ('float32', 'libdevice.pow', '/usr/local/cuda/nvvm/libdevice/libdevice.10.bc'),\n+                          ('float32', 'libdevice.pow', system_libdevice_path()),\n                           ('float64', 'libdevice.norm4d', '')])\n def test_libdevice_tensor(dtype_str, expr, lib_path):\n "}, {"filename": "python/tests/test_elementwise.py", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "file_content_changes": "@@ -5,6 +5,7 @@\n import pytest\n import torch\n from torch.testing import assert_close\n+from tests.libdevice_testutil import system_libdevice_path\n \n import triton\n import triton.language as tl\n@@ -32,8 +33,6 @@\n     \"where\": \"where\",\n }\n \n-libdevice = '/usr/local/cuda/nvvm/libdevice/libdevice.10.bc'\n-\n \n def get_tensor(shape, data_type, b_positive=False):\n     x = None\n@@ -90,7 +89,11 @@ def kernel(X, Y, BLOCK: tl.constexpr):\n     x = get_tensor(shape, input0_type, expr == 'log' or expr == 'sqrt')\n     # triton result\n     y = torch.zeros(shape, dtype=torch_type[output_type], device=\"cuda\")\n-    kernel[(1,)](x, y, BLOCK=shape[0], extern_libs={\"libdevice\": libdevice})\n+    kernel[(1,)](\n+        x, y,\n+        BLOCK=shape[0],\n+        extern_libs={\"libdevice\": system_libdevice_path()},\n+    )\n     # reference result\n     y_ref = getattr(torch, torch_ops[expr])(x)\n     # compare\n@@ -134,7 +137,11 @@ def kernel(X0, X1, Y, BLOCK: tl.constexpr):\n \n     # triton result\n     y = torch.zeros(shape, dtype=torch_type[output_type], device=\"cuda\")\n-    kernel[(1,)](x0, x1, y, BLOCK=shape[0], extern_libs={\"libdevice\": libdevice})\n+    kernel[(1,)](\n+        x0, x1, y,\n+        BLOCK=shape[0],\n+        extern_libs={\"libdevice\": system_libdevice_path()},\n+    )\n     # reference result\n \n     if expr == \"cdiv\":\n@@ -182,7 +189,11 @@ def kernel(X0, X1, X2, Y, BLOCK: tl.constexpr):\n \n     # triton result\n     y = torch.zeros(shape, dtype=torch_type[output_type], device=\"cuda\")\n-    kernel[(1,)](x0, x1, x2, y, BLOCK=shape[0], extern_libs={\"libdevice\": libdevice})\n+    kernel[(1,)](\n+        x0, x1, x2, y,\n+        BLOCK=shape[0],\n+        extern_libs={\"libdevice\": system_libdevice_path()},\n+    )\n     # reference result\n \n     y_ref = getattr(torch, torch_ops[expr])(x0, x1, x2)"}, {"filename": "python/tests/test_ext_elemwise.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "file_content_changes": "@@ -5,6 +5,7 @@\n \n import triton\n import triton.language as tl\n+from tests.libdevice_testutil import system_libdevice_path\n \n \n @pytest.mark.parametrize('num_warps, block_size, iter_size', [\n@@ -125,7 +126,7 @@ def kernel(x_ptr,\n \n \n @pytest.mark.parametrize(\"dtype_str, expr, lib_path\",\n-                         [('int32', 'libdevice.ffs', '/usr/local/cuda/nvvm/libdevice/libdevice.10.bc'),\n+                         [('int32', 'libdevice.ffs', system_libdevice_path()),\n                           ('int32', 'libdevice.ffs', '')])\n def test_libdevice(dtype_str, expr, lib_path):\n     src = f\"\"\""}, {"filename": "python/tests/test_gemm.py", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "file_content_changes": "@@ -172,7 +172,7 @@ def get_proper_err(a, b, golden):\n     [128, 64, 128, 4, 128, 64, 128, False, False],\n     [16, 16, 16, 16, 16, 16, 16, False, False],  # wpt overflow issue\n     # K-Forloop\n-    #[16, 16, 64, 4, 8, 8, 8, False, False],  # Wrap threads\n+    # [16, 16, 64, 4, 8, 8, 8, False, False],  # Wrap threads\n     [32, 32, 64, 4, 32, 32, 32, False, False],  # Single shared encoding\n     [16, 16, 128, 4, 16, 16, 16, False, False],  # Single shared encoding and small k\n     [64, 32, 128, 4, 64, 32, 64, False, False],\n@@ -292,3 +292,21 @@ def matmul_kernel(\n         torch.testing.assert_close(c, golden, rtol=max(1e-2, 1.5 * golden_rel_err), atol=max(1e-2, 1.5 * golden_abs_err))\n     else:\n         torch.testing.assert_close(c, golden, rtol=max(1e-4, 1.5 * golden_rel_err), atol=max(1e-4, 1.5 * golden_abs_err))\n+\n+\n+# NOTE this is useful only on Volta GPU.\n+@pytest.mark.parametrize('SHAPE,NUM_WARPS,TRANS_A,TRANS_B', [\n+    (shape, num_warps, trans_a, trans_b)\n+    for shape in [\n+        [16, 16, 16],\n+        [16, 16, 32],\n+        [32, 16, 16],\n+        [32, 32, 32],\n+        [128, 16, 16],\n+    ]\n+    for num_warps in [1]\n+    for trans_a in [False]\n+    for trans_b in [False]\n+])\n+def test_gemm_no_scf_for_mmav1(SHAPE, NUM_WARPS, TRANS_A, TRANS_B):\n+    test_gemm_no_scf(SHAPE, NUM_WARPS, TRANS_A, TRANS_B)"}, {"filename": "python/triton/__init__.py", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "file_content_changes": "@@ -1,15 +1,52 @@\n \"\"\"isort:skip_file\"\"\"\n-# flake8: noqa: F401\n __version__ = '2.0.0'\n \n+# ---------------------------------------\n+# Note: import order is significant here.\n+\n # TODO: torch needs to be imported first\n # or pybind11 shows `munmap_chunk(): invalid pointer`\n-import torch\n+import torch  # noqa: F401\n+\n # submodules\n-from .utils import *\n-from .runtime import Config, autotune, heuristics, JITFunction, KernelInterface\n+from . import impl\n+from .utils import (\n+    cdiv,\n+    MockTensor,\n+    next_power_of_2,\n+    reinterpret,\n+    TensorWrapper,\n+)\n+from .runtime import (\n+    autotune,\n+    Config,\n+    heuristics,\n+    JITFunction,\n+    KernelInterface,\n+)\n from .runtime.jit import jit\n from .compiler import compile, CompilationError\n from . import language\n from . import testing\n from . import ops\n+\n+__all__ = [\n+    \"autotune\",\n+    \"cdiv\",\n+    \"CompilationError\",\n+    \"compile\",\n+    \"Config\",\n+    \"heuristics\",\n+    \"impl\",\n+    \"jit\",\n+    \"JITFunction\",\n+    \"KernelInterface\",\n+    \"language\",\n+    \"MockTensor\",\n+    \"next_power_of_2\",\n+    \"ops\",\n+    \"reinterpret\",\n+    \"runtime\",\n+    \"TensorWrapper\",\n+    \"testing\",\n+]"}, {"filename": "python/triton/compiler.py", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "file_content_changes": "@@ -25,6 +25,8 @@\n \n import triton\n import triton._C.libtriton.triton as _triton\n+\n+from . import impl\n from .tools.disasm import extract\n \n \n@@ -715,9 +717,8 @@ def visit_Call(self, node):\n                 for i in range(call_op.get_num_results()):\n                     results.append(triton.language.tensor(call_op.get_result(i), callee_ret_type[i]))\n                 return tuple(results)\n-        if hasattr(fn, '__self__') and self.is_triton_tensor(fn.__self__) or \\\n-                sys.modules[fn.__module__] is triton.language.core or \\\n-                isinstance(fn, triton.language.extern.ExternalFunction):\n+        if (hasattr(fn, '__self__') and self.is_triton_tensor(fn.__self__)) \\\n+                or impl.is_builtin(fn):\n             return fn(*args, _builder=self.builder, **kws)\n         if fn in self.builtins.values():\n             args = [arg.value if isinstance(arg, triton.language.constexpr) else arg"}, {"filename": "python/triton/impl/__init__.py", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "file_content_changes": "@@ -0,0 +1,22 @@\n+\"\"\"Triton internal implementation details.\n+\n+Client libraries should not import interfaces from the `triton.impl` module;\n+as the details are subject to change.\n+\n+APIs defined in the `triton.impl` module which are public will be re-exported\n+in other relevant `triton` module namespaces.\n+\"\"\"\n+\n+from triton._C.libtriton.triton import ir\n+from .base import (\n+    builtin,\n+    extern,\n+    is_builtin,\n+)\n+\n+__all__ = [\n+    \"builtin\",\n+    \"extern\",\n+    \"ir\",\n+    \"is_builtin\",\n+]"}, {"filename": "python/triton/impl/base.py", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "file_content_changes": "@@ -0,0 +1,36 @@\n+from __future__ import annotations\n+\n+from functools import wraps\n+from typing import TypeVar\n+\n+T = TypeVar(\"T\")\n+\n+TRITON_BUILTIN = \"__triton_builtin__\"\n+\n+\n+def builtin(fn: T) -> T:\n+    \"\"\"Mark a function as a builtin.\"\"\"\n+    assert callable(fn)\n+\n+    @wraps(fn)\n+    def wrapper(*args, **kwargs):\n+        if \"_builder\" not in kwargs or kwargs[\"_builder\"] is None:\n+            raise ValueError(\n+                \"Did you forget to add @triton.jit ? \"\n+                \"(`_builder` argument must be provided outside of JIT functions.)\"\n+            )\n+        return fn(*args, **kwargs)\n+\n+    setattr(wrapper, TRITON_BUILTIN, True)\n+\n+    return wrapper\n+\n+\n+def is_builtin(fn) -> bool:\n+    \"\"\"Is this a registered triton builtin function?\"\"\"\n+    return getattr(fn, TRITON_BUILTIN, False)\n+\n+\n+def extern(fn: T) -> T:\n+    \"\"\"A decorator for external functions.\"\"\"\n+    return builtin(fn)"}, {"filename": "python/triton/language/__init__.py", "status": "modified", "additions": 172, "deletions": 3, "changes": 175, "file_content_changes": "@@ -1,4 +1,173 @@\n-# flake8: noqa: F401\n+\"\"\"isort:skip_file\"\"\"\n+# Import order is significant here.\n+\n+from ..impl import (\n+    ir,\n+    builtin,\n+)\n from . import core, extern, libdevice, random\n-from .core import *\n-from .random import *\n+from .core import (\n+    abs,\n+    arange,\n+    argmin,\n+    argmax,\n+    atomic_add,\n+    atomic_and,\n+    atomic_cas,\n+    atomic_max,\n+    atomic_min,\n+    atomic_or,\n+    atomic_xchg,\n+    atomic_xor,\n+    bfloat16,\n+    block_type,\n+    builtin,\n+    cat,\n+    cdiv,\n+    constexpr,\n+    cos,\n+    debug_barrier,\n+    dot,\n+    dtype,\n+    exp,\n+    fdiv,\n+    float16,\n+    float32,\n+    float64,\n+    float8,\n+    function_type,\n+    int1,\n+    int16,\n+    int32,\n+    int64,\n+    int8,\n+    load,\n+    log,\n+    max,\n+    max_contiguous,\n+    maximum,\n+    min,\n+    minimum,\n+    multiple_of,\n+    num_programs,\n+    pi32_t,\n+    pointer_type,\n+    printf,\n+    program_id,\n+    ravel,\n+    sigmoid,\n+    sin,\n+    softmax,\n+    sqrt,\n+    store,\n+    sum,\n+    swizzle2d,\n+    tensor,\n+    trans,\n+    triton,\n+    uint16,\n+    uint32,\n+    uint64,\n+    uint8,\n+    umulhi,\n+    void,\n+    where,\n+    xor_sum,\n+    zeros,\n+    zeros_like,\n+)\n+from .random import (\n+    pair_uniform_to_normal,\n+    philox,\n+    philox_impl,\n+    rand,\n+    rand4x,\n+    randint,\n+    randint4x,\n+    randn,\n+    randn4x,\n+    uint32_to_uniform_float,\n+)\n+\n+\n+__all__ = [\n+    \"abs\",\n+    \"arange\",\n+    \"argmin\",\n+    \"argmax\",\n+    \"atomic_add\",\n+    \"atomic_and\",\n+    \"atomic_cas\",\n+    \"atomic_max\",\n+    \"atomic_min\",\n+    \"atomic_or\",\n+    \"atomic_xchg\",\n+    \"atomic_xor\",\n+    \"bfloat16\",\n+    \"block_type\",\n+    \"builtin\",\n+    \"cat\",\n+    \"cdiv\",\n+    \"constexpr\",\n+    \"cos\",\n+    \"debug_barrier\",\n+    \"dot\",\n+    \"dtype\",\n+    \"exp\",\n+    \"fdiv\",\n+    \"float16\",\n+    \"float32\",\n+    \"float64\",\n+    \"float8\",\n+    \"function_type\",\n+    \"int1\",\n+    \"int16\",\n+    \"int32\",\n+    \"int64\",\n+    \"int8\",\n+    \"ir\",\n+    \"load\",\n+    \"log\",\n+    \"max\",\n+    \"max_contiguous\",\n+    \"maximum\",\n+    \"min\",\n+    \"minimum\",\n+    \"multiple_of\",\n+    \"num_programs\",\n+    \"pair_uniform_to_normal\",\n+    \"philox\",\n+    \"philox_impl\",\n+    \"pi32_t\",\n+    \"pointer_type\",\n+    \"printf\",\n+    \"program_id\",\n+    \"rand\",\n+    \"rand4x\",\n+    \"randint\",\n+    \"randint4x\",\n+    \"randn\",\n+    \"randn4x\",\n+    \"ravel\",\n+    \"sigmoid\",\n+    \"sin\",\n+    \"softmax\",\n+    \"sqrt\",\n+    \"store\",\n+    \"sum\",\n+    \"swizzle2d\",\n+    \"tensor\",\n+    \"trans\",\n+    \"triton\",\n+    \"uint16\",\n+    \"uint32\",\n+    \"uint32_to_uniform_float\",\n+    \"uint64\",\n+    \"uint8\",\n+    \"umulhi\",\n+    \"void\",\n+    \"where\",\n+    \"xor_sum\",\n+    \"zeros\",\n+    \"zeros_like\",\n+]"}, {"filename": "python/triton/language/core.py", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "file_content_changes": "@@ -1,13 +1,13 @@\n from __future__ import annotations\n \n from enum import Enum\n-from functools import wraps\n-from typing import List\n+from typing import List, Callable, TypeVar\n \n import triton\n-from . import semantic\n+from . import builtin, semantic\n from triton._C.libtriton.triton import ir\n \n+T = TypeVar('T')\n \n def _to_tensor(x, builder):\n     if isinstance(x, bool):\n@@ -33,17 +33,6 @@ def _to_tensor(x, builder):\n     assert False, f'cannot convert {x} to tensor'\n \n \n-def builtin(fn):\n-    @wraps(fn)\n-    def wrapper(*args, **kwargs):\n-        if '_builder' not in kwargs or \\\n-           kwargs['_builder'] is None:\n-            raise ValueError(\"Did you forget to add @triton.jit ? (`_builder` argument must be provided outside of JIT functions.)\")\n-        return fn(*args, **kwargs)\n-\n-    return wrapper\n-\n-\n class dtype:\n     SINT_TYPES = ['int1', 'int8', 'int16', 'int32', 'int64']\n     UINT_TYPES = ['uint8', 'uint16', 'uint32', 'uint64']\n@@ -409,10 +398,10 @@ def __bool__(self):\n \n     def __neg__(self):\n         return constexpr(-self.value)\n-    \n+\n     def __pos__(self):\n         return constexpr(+self.value)\n-    \n+\n     def __invert__(self):\n         return constexpr(~self.value)\n \n@@ -851,9 +840,9 @@ def store(pointer, value, mask=None, _builder=None):\n # Atomic Memory Operations\n # -----------------------\n \n-def _add_atomic_docstr(name):\n+def _add_atomic_docstr(name: str) -> Callable[[T], T]:\n \n-    def _decorator(func):\n+    def _decorator(func: T) -> T:\n         docstr = \"\"\"\n     Performs an atomic {name} at the memory location specified by :code:`pointer`.\n \n@@ -974,9 +963,9 @@ def fdiv(x, y, ieee_rounding=False, _builder=None):\n     return semantic.fdiv(x, y, ieee_rounding, _builder)\n \n \n-def _add_math_1arg_docstr(name):\n+def _add_math_1arg_docstr(name: str) -> Callable[[T], T]:\n \n-    def _decorator(func):\n+    def _decorator(func: T) -> T:\n         docstr = \"\"\"\n     Computes the element-wise {name} of :code:`x`\n \n@@ -1023,9 +1012,9 @@ def sqrt(x, _builder=None):\n # Reductions\n # -----------------------\n \n-def _add_reduction_docstr(name):\n+def _add_reduction_docstr(name: str) -> Callable[[T], T]:\n \n-    def _decorator(func):\n+    def _decorator(func: T) -> T:\n         docstr = \"\"\"\n     Returns the {name} of all elements in the :code:`input` tensor along the provided :code:`axis`\n "}, {"filename": "python/triton/language/extern.py", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "file_content_changes": "@@ -86,25 +86,3 @@ def elementwise(lib_name: str, lib_path: str, args: list, arg_type_symbol_dict:\n             ret_shape = broadcast_arg.shape\n     func = getattr(_builder, \"create_external_elementwise\")\n     return dispatch(func, lib_name, lib_path, dispatch_args, arg_type_symbol_dict, ret_shape, _builder)\n-\n-\n-class ExternalFunction:\n-    '''\n-        A wrapper for external functions\n-    '''\n-\n-    def __init__(self, fn):\n-        self.fn = fn\n-\n-    def __call__(self, *args, **kwargs):\n-        if '_builder' not in kwargs or \\\n-           kwargs['_builder'] is None:\n-            raise ValueError(\"Did you forget to add @triton.jit ? (`_builder` argument must be provided outside of JIT functions.)\")\n-        return self.fn(*args, **kwargs)\n-\n-\n-def extern(fn):\n-    '''\n-        A decorator for external functions\n-    '''\n-    return ExternalFunction(fn)"}, {"filename": "python/triton/language/libdevice.py", "status": "modified", "additions": 200, "deletions": 199, "changes": 399, "file_content_changes": "@@ -1,35 +1,36 @@\n import os\n \n+from .. import impl\n from . import core, extern\n \n LIBDEVICE_PATH = os.path.dirname(\n     os.path.abspath(__file__)) + \"/libdevice.10.bc\"\n \n \n-@extern.extern\n+@impl.extern\n def clz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_clz\", core.dtype(\"int32\")),\n                                (core.dtype(\"int64\"),): (\"__nv_clzll\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def popc(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_popc\", core.dtype(\"int32\")),\n                                (core.dtype(\"int64\"),): (\"__nv_popcll\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def byte_perm(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_byte_perm\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def min(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_min\", core.dtype(\"int32\")),\n@@ -41,7 +42,7 @@ def min(arg0, arg1, _builder=None):\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def max(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_max\", core.dtype(\"int32\")),\n@@ -53,7 +54,7 @@ def max(arg0, arg1, _builder=None):\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def mulhi(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_mulhi\", core.dtype(\"int32\")),\n@@ -63,31 +64,31 @@ def mulhi(arg0, arg1, _builder=None):\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def mul24(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_mul24\", core.dtype(\"int32\")),\n                                (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_umul24\", core.dtype(\"uint32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def brev(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_brev\", core.dtype(\"int32\")),\n                                (core.dtype(\"int64\"),): (\"__nv_brevll\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sad(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"), core.dtype(\"uint32\"),): (\"__nv_sad\", core.dtype(\"int32\")),\n                                (core.dtype(\"uint32\"), core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_usad\", core.dtype(\"uint32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def abs(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_abs\", core.dtype(\"int32\")),\n@@ -97,1370 +98,1370 @@ def abs(arg0, _builder=None):\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def floor(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_floorf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_floor\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rcp64h(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_rcp64h\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rsqrt(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_rsqrtf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_rsqrt\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ceil(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_ceil\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"),): (\"__nv_ceilf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def trunc(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_trunc\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"),): (\"__nv_truncf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def exp2(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_exp2f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_exp2\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def saturatef(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_saturatef\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fma_rn(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fma_rz(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fma_rd(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fma_ru(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_dividef(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fast_fdividef\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def div_rn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def div_rz(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def div_rd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def div_ru(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdiv_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_ddiv_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rcp_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frcp_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_drcp_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rcp_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frcp_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_drcp_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rcp_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frcp_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_drcp_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rcp_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frcp_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_drcp_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sqrt_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_dsqrt_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sqrt_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_dsqrt_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sqrt_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_dsqrt_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sqrt_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fsqrt_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_dsqrt_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sqrt(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_sqrtf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_sqrt\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def add_rn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rn\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def add_rz(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rz\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def add_rd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_rd\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def add_ru(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dadd_ru\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fadd_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def mul_rn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rn\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def mul_rz(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rz\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def mul_rd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_rd\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def mul_ru(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dmul_ru\", core.dtype(\"fp64\")),\n                                (core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmul_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2int_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2int_rn\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2int_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2int_rz\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2int_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2int_rd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2int_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2int_ru\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2uint_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rn\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2uint_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rz\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2uint_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2uint_rd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2uint_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2uint_ru\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def int2double_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2double_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def uint2double_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2double_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2int_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2int_rn\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2int_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2int_rz\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2int_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2int_rd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2int_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2int_ru\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2uint_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rn\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2uint_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rz\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2uint_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2uint_rd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2uint_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2uint_ru\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def int2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def int2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def int2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def int2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def uint2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def uint2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def uint2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def uint2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def hiloint2double(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_hiloint2double\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2loint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2loint\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2hiint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2hiint\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2ll_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rn\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2ll_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rz\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2ll_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ll_rd\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2ll_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ll_ru\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2ull_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rn\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2ull_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rz\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2ull_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ull_rd\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float2ull_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float2ull_ru\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2ll_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rn\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2ll_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rz\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2ll_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ll_rd\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2ll_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ll_ru\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2ull_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rn\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2ull_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rz\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2ull_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ull_rd\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double2ull_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double2ull_ru\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ll2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ll2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ll2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ll2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ull2float_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2float_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ull2float_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2float_rz\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ull2float_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2float_rd\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ull2float_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2float_ru\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ll2double_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2double_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ll2double_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2double_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ll2double_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2double_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ll2double_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_ll2double_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ull2double_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2double_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ull2double_rz(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2double_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ull2double_rd(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2double_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ull2double_ru(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint64\"),): (\"__nv_ull2double_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def int_as_float(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_int_as_float\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float_as_int(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float_as_int\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def uint_as_float(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"uint32\"),): (\"__nv_uint_as_float\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def float_as_uint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_float_as_uint\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def longlong_as_double(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int64\"),): (\"__nv_longlong_as_double\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def double_as_longlong(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_double_as_longlong\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_sinf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_sinf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_cosf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_cosf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_log2f(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_log2f\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_logf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_logf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_expf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_expf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_tanf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_tanf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_exp10f(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_exp10f\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_log10f(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_fast_log10f\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fast_powf(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fast_powf\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def hadd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_hadd\", core.dtype(\"int32\")),\n                                (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_uhadd\", core.dtype(\"uint32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rhadd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"int32\"),): (\"__nv_rhadd\", core.dtype(\"int32\")),\n                                (core.dtype(\"uint32\"), core.dtype(\"uint32\"),): (\"__nv_urhadd\", core.dtype(\"uint32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sub_rn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rn\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sub_rz(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rz\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rz\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sub_rd(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_rd\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_rd\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sub_ru(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fsub_ru\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_dsub_ru\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rsqrt_rn(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_frsqrt_rn\", core.dtype(\"fp32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ffs(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"int32\"),): (\"__nv_ffs\", core.dtype(\"int32\")),\n                                (core.dtype(\"int64\"),): (\"__nv_ffsll\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_rintf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_rint\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def llrint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_llrintf\", core.dtype(\"int64\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_llrint\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def nearbyint(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_nearbyintf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_nearbyint\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def isnan(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_isnanf\", core.dtype(\"int32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_isnand\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def signbit(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_signbitf\", core.dtype(\"int32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_signbitd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def copysign(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_copysignf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_copysign\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def finitef(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_finitef\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def isinf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_isinff\", core.dtype(\"int32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_isinfd\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def nextafter(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_nextafterf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_nextafter\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sin(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_sinf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_sin\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def cos(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cosf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cos\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sinpi(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_sinpif\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_sinpi\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def cospi(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cospif\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cospi\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def tan(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_tanf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_tan\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def log2(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_log2f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_log2\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def exp(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_expf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_exp\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def exp10(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_exp10f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_exp10\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def cosh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_coshf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cosh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def sinh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_sinhf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_sinh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def tanh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_tanhf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_tanh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def atan2(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_atan2f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_atan2\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def atan(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_atanf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_atan\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def asin(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_asinf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_asin\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def acos(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_acosf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_acos\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def log(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_logf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_log\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def log10(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_log10f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_log10\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def log1p(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_log1pf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_log1p\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def acosh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_acoshf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_acosh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def asinh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_asinhf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_asinh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def atanh(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_atanhf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_atanh\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def expm1(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_expm1f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_expm1\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def hypot(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_hypotf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_hypot\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rhypot(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rhypotf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rhypot\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def norm3d(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_norm3df\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_norm3d\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rnorm3d(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rnorm3df\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rnorm3d\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def norm4d(arg0, arg1, arg2, arg3, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, arg3, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_norm4df\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_norm4d\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rnorm4d(arg0, arg1, arg2, arg3, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, arg3, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_rnorm4df\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_rnorm4d\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def cbrt(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cbrtf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cbrt\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def rcbrt(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_rcbrtf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_rcbrt\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def j0(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_j0f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_j0\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def j1(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_j1f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_j1\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def y0(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_y0f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_y0\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def y1(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_y1f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_y1\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def yn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"fp32\"),): (\"__nv_ynf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"int32\"), core.dtype(\"fp64\"),): (\"__nv_yn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def jn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"int32\"), core.dtype(\"fp32\"),): (\"__nv_jnf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"int32\"), core.dtype(\"fp64\"),): (\"__nv_jn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def cyl_bessel_i0(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cyl_bessel_i0f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cyl_bessel_i0\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def cyl_bessel_i1(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_cyl_bessel_i1f\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_cyl_bessel_i1\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def erf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erff\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erf\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def erfinv(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erfinvf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erfinv\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def erfc(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erfcf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erfc\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def erfcx(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erfcxf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erfcx\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def erfcinv(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_erfcinvf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_erfcinv\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def normcdfinv(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_normcdfinvf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_normcdfinv\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def normcdf(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_normcdff\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_normcdf\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def lgamma(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_lgammaf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_lgamma\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ldexp(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_ldexpf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"int32\"),): (\"__nv_ldexp\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def scalbn(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_scalbnf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"int32\"),): (\"__nv_scalbn\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fmod(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmodf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fmod\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def remainder(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_remainderf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_remainder\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fma(arg0, arg1, arg2, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, arg2, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fmaf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fma\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def pow(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"int32\"),): (\"__nv_powif\", core.dtype(\"fp32\")),\n@@ -1470,55 +1471,55 @@ def pow(arg0, arg1, _builder=None):\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def tgamma(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_tgammaf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_tgamma\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def round(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_roundf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_round\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def llround(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_llroundf\", core.dtype(\"int64\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_llround\", core.dtype(\"int64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def fdim(arg0, arg1, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, arg1, ],\n                               {(core.dtype(\"fp32\"), core.dtype(\"fp32\"),): (\"__nv_fdimf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"), core.dtype(\"fp64\"),): (\"__nv_fdim\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def ilogb(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_ilogbf\", core.dtype(\"int32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_ilogb\", core.dtype(\"int32\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def logb(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp32\"),): (\"__nv_logbf\", core.dtype(\"fp32\")),\n                                (core.dtype(\"fp64\"),): (\"__nv_logb\", core.dtype(\"fp64\")),\n                                }, _builder)\n \n \n-@extern.extern\n+@impl.extern\n def isfinited(arg0, _builder=None):\n     return extern.elementwise(\"libdevice\", LIBDEVICE_PATH, [arg0, ],\n                               {(core.dtype(\"fp64\"),): (\"__nv_isfinited\", core.dtype(\"int32\")),"}, {"filename": "python/triton/ops/__init__.py", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "file_content_changes": "@@ -1,5 +1,12 @@\n-# flake8: noqa: F401\n-#from .conv import _conv, conv\n+# from .conv import _conv, conv\n from . import blocksparse\n from .cross_entropy import _cross_entropy, cross_entropy\n from .matmul import _matmul, matmul\n+\n+__all__ = [\n+    \"blocksparse\",\n+    \"_cross_entropy\",\n+    \"cross_entropy\",\n+    \"_matmul\",\n+    \"matmul\",\n+]"}, {"filename": "python/triton/ops/blocksparse/__init__.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "file_content_changes": "@@ -1,3 +1,7 @@\n-# flake8: noqa: F401\n from .matmul import matmul\n from .softmax import softmax\n+\n+__all__ = [\n+    \"matmul\",\n+    \"softmax\",\n+]"}, {"filename": "python/triton/runtime/__init__.py", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "file_content_changes": "@@ -1,2 +1,12 @@\n-from .autotuner import Config, Heuristics, autotune, heuristics  # noqa: F401\n-from .jit import JITFunction, KernelInterface, version_key  # noqa: F401\n+from .autotuner import Config, Heuristics, autotune, heuristics\n+from .jit import JITFunction, KernelInterface, version_key\n+\n+__all__ = [\n+    \"Config\",\n+    \"Heuristics\",\n+    \"autotune\",\n+    \"heuristics\",\n+    \"JITFunction\",\n+    \"KernelInterface\",\n+    \"version_key\",\n+]"}, {"filename": "python/triton/runtime/jit.py", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "file_content_changes": "@@ -8,6 +8,7 @@\n import subprocess\n import textwrap\n from collections import namedtuple\n+from typing import TypeVar, Generic, cast, Callable, overload, Optional, Iterable, Union\n \n import torch\n \n@@ -19,6 +20,9 @@\n except ImportError:\n     get_cuda_stream = lambda dev_idx: torch.cuda.current_stream(dev_idx).cuda_stream\n \n+\n+T = TypeVar('T')\n+\n # -----------------------------------------------------------------------------\n # Dependencies Finder\n # -----------------------------------------------------------------------------\n@@ -94,20 +98,20 @@ def version_key():\n     return '-'.join(triton.__version__) + '-' + ptxas_version + '-' + '-'.join(contents)\n \n \n-class KernelInterface:\n+class KernelInterface(Generic[T]):\n+    run: T\n \n-    def __getitem__(self, grid):\n+    def __getitem__(self, grid) -> T:\n         \"\"\"\n         A JIT function is launched with: fn[grid](*args, **kwargs).\n         Hence JITFunction.__getitem__ returns a callable proxy that\n         memorizes the grid.\n         \"\"\"\n-        def launcher(*args, **kwargs):\n-            return self.run(*args, grid=grid, **kwargs)\n-        return launcher\n+        return cast(T, functools.partial(cast(Callable, self.run), grid=grid))\n \n \n-class JITFunction(KernelInterface):\n+\n+class JITFunction(KernelInterface[T]):\n \n     cache_hook = None\n     divisibility = 16\n@@ -367,25 +371,55 @@ def __repr__(self):\n # -----------------------------------------------------------------------------\n \n \n-def jit(*args, **kwargs):\n+@overload\n+def jit(fn: T) -> JITFunction[T]:\n+    ...\n+\n+\n+@overload\n+def jit(\n+    *,\n+    version=None,\n+    do_not_specialize: Optional[Iterable[int]] = None,\n+) -> Callable[[T], JITFunction[T]]:\n+    ...\n+\n+\n+def jit(\n+    fn: Optional[T] = None,\n+    *,\n+    version=None,\n+    do_not_specialize: Optional[Iterable[int]] = None,\n+) -> Union[JITFunction[T], Callable[[T], JITFunction[T]]]:\n     \"\"\"\n     Decorator for JIT-compiling a function using the Triton compiler.\n-    :note: When a jit'd function is called, :code:`torch.tensor` arguments are implicitly converted to pointers using the :code:`.data_ptr()` method.\n+\n+    :note: When a jit'd function is called, :code:`torch.tensor` arguments are\n+        implicitly converted to pointers using the :code:`.data_ptr()` method.\n+\n     :note: This function will be compiled and run on the GPU. It will only have access to:\n+\n            * python primitives,\n-           * objects within the triton.language package,\n+           * builtins within the triton package,\n            * arguments to this function,\n            * other jit'd functions\n+\n     :param fn: the function to be jit-compiled\n     :type fn: Callable\n     \"\"\"\n-    if args:\n-        assert len(args) == 1\n-        assert callable(args[0])\n-        return JITFunction(args[0], **kwargs)\n+\n+    def decorator(fn: T) -> JITFunction[T]:\n+        assert callable(fn)\n+        return JITFunction(\n+            fn,\n+            version=version,\n+            do_not_specialize=do_not_specialize,\n+        )\n+\n+    if fn is not None:\n+        return decorator(fn)\n+\n     else:\n-        def decorator(fn):\n-            return JITFunction(fn, **kwargs)\n         return decorator\n \n "}]