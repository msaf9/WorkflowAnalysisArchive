[{"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 62, "deletions": 28, "changes": 90, "file_content_changes": "@@ -2639,41 +2639,75 @@ def add_fn_static_cond(x, cond: tl.constexpr):\n         return x + 1\n \n \n-@pytest.mark.parametrize(\"call_type\", [\"attribute\", \"jit_function\", \"jit_function_return\",\n-                                       \"ifexp\", \"expr\", \"jit_function_static_cond\", \"jit_function_noinline\"])\n+@pytest.mark.parametrize(\"call_type\", [\"attribute\", \"attribute_chain\", \"attribute_nested\", \"attribute_jit\",\n+                                       \"jit\", \"jit_return\", \"jit_ifexp\", \"jit_expr\",\n+                                       \"jit_static_cond\", \"jit_noinline\", \"jit_extern\"])\n def test_if_call(call_type):\n     @triton.jit\n     def kernel(Out, call_type: tl.constexpr):\n         pid = tl.program_id(0)\n         o = tl.load(Out)\n-        if pid == 0:\n-            if call_type == \"attribute\":\n-                # call attribute\n-                a = o + 1\n-                a = a.to(tl.int32).to(tl.int32)\n+        if call_type == \"attribute\":\n+            # call attribute\n+            if pid == 0:\n+                a = o\n+                a = a.to(tl.int32).to(tl.int32) + 1\n                 o = a\n-            else:\n+        elif call_type == \"attribute_chain\":\n+            # t is an unknown name\n+            if pid == 0:\n+                t = Out\n+                a = tl.load(t + 1 - 1).to(tl.int32) + 1\n+                o = a\n+        elif call_type == \"attribute_nested\":\n+            if pid == 0:\n+                t = Out\n+                a = tl.load(t + tl.load(t)).to(tl.int32) + 1\n+                o = a\n+        elif call_type == \"attribute_jit\":\n+            if pid == 0:\n+                a = o\n+                a = tl.load(Out + add_fn(a) - 1).to(tl.int32) + 1\n+                o = a\n+        elif call_type == \"jit\":\n+            if pid == 0:\n+                # regular function call\n+                a = o\n+                a = add_fn(a)\n+                o = a\n+        elif call_type == \"jit_return\":\n+            # function without end_if block\n+            if pid == 0:\n                 a = o\n-                if call_type == \"jit_function\":\n-                    # regular function call\n-                    a = add_fn(a)\n-                elif call_type == \"jit_function_return\":\n-                    # function without end_if block\n-                    a = add_fn_return(a, pid)\n-                elif call_type == \"ifexp\":\n-                    # ifexp expression\n-                    a = add_fn(a) if pid == 0 else add_fn_return(a, pid)\n-                elif call_type == \"expr\":\n-                    if pid == 1:\n-                        return\n-                    a = add_fn(a)\n-                    if pid == 0:\n-                        # call without return\n-                        add_fn_expr(Out, a)\n-                elif call_type == \"jit_function_static_cond\":\n-                    a = add_fn_static_cond(a, call_type)\n-                elif call_type == \"jit_function_noinline\":\n-                    a = add_fn_noinline(a)\n+                a = add_fn_return(a, pid)\n+                o = a\n+        elif call_type == \"jit_ifexp\":\n+            # ifexp expression\n+            if pid == 0:\n+                a = o\n+                a = add_fn(a) if pid == 0 else add_fn_return(a, pid)\n+                o = a\n+        elif call_type == \"jit_expr\":\n+            a = o\n+            if pid == 1:\n+                return\n+            a = add_fn(a)\n+            if pid == 0:\n+                # call without return\n+                add_fn_expr(Out, a)\n+            o = a\n+        elif call_type == \"jit_static_cond\":\n+            if pid == 0:\n+                a = add_fn_static_cond(o, call_type)\n+                o = a\n+        elif call_type == \"jit_noinline\":\n+            if pid == 0:\n+                a = o\n+                a = add_fn_noinline(a)\n+                o = a\n+        elif call_type == \"jit_extern\":\n+            if pid == 0:\n+                a = tl.cdiv(o + 1, o + 1)\n                 o = a\n \n         tl.store(Out, o)"}, {"filename": "python/triton/compiler/code_generator.py", "status": "modified", "additions": 82, "deletions": 58, "changes": 140, "file_content_changes": "@@ -97,6 +97,87 @@ def __exit__(self, *args, **kwargs):\n         self.generator.local_defs = self.prev_defs\n \n \n+class ContainsReturnChecker(ast.NodeVisitor):\n+    def __init__(self, gscope):\n+        self.gscope = gscope\n+\n+    def _visit_stmts(self, body) -> bool:\n+        for s in body:\n+            if self.visit(s):\n+                return True\n+        return False\n+\n+    def _visit_function(self, fn) -> bool:\n+        # Currently we only support JITFunctions defined in the global scope\n+        if isinstance(fn, JITFunction) and not fn.noinline:\n+            fn_node = fn.parse()\n+            return ContainsReturnChecker(self.gscope).visit(fn_node)\n+\n+    def generic_visit(self, node) -> bool:\n+        ret = False\n+        for _, value in ast.iter_fields(node):\n+            if isinstance(value, list):\n+                for item in value:\n+                    if isinstance(item, ast.AST):\n+                        ret = ret or self.visit(item)\n+            elif isinstance(value, ast.AST):\n+                ret = ret or self.visit(value)\n+        return ret\n+\n+    def visit_Attribute(self, node: ast.Attribute) -> bool:\n+        if isinstance(node.value, ast.Name):\n+            if node.value.id in self.gscope:\n+                value = self.gscope[node.value.id]\n+                fn = getattr(value, node.attr)\n+                if self._visit_function(fn):\n+                    return True\n+        # If the left part is not a name, it must return a tensor or a constexpr\n+        # whose methods do not contain return statements\n+        # e.g., (tl.load(x)).to(y)\n+        # So we only check if the expressions within value have return or not\n+        return self.visit(node.value)\n+\n+    def visit_Name(self, node: ast.Name) -> bool:\n+        if type(node.ctx) == ast.Store:\n+            return False\n+        if node.id in self.gscope:\n+            fn = self.gscope[node.id]\n+            if self._visit_function(fn):\n+                return True\n+        return False\n+\n+    def visit_Return(self, node: ast.Return) -> bool:\n+        return True\n+\n+    def visit_Assign(self, node: ast.Assign) -> bool:\n+        return self.visit(node.value)\n+\n+    def visit_Module(self, node: ast.Module) -> bool:\n+        return self._visit_stmts(node.body)\n+\n+    def visit_FunctionDef(self, node: ast.FunctionDef) -> bool:\n+        return self._visit_stmts(node.body)\n+\n+    def visit_If(self, node: ast.If) -> bool:\n+        # TODO: optimize the following case in which we actually don't have\n+        # a return when static_cond is false:\n+        # if dynamic_cond\n+        #   if static_cond\n+        #     func_with_return\n+        #   else\n+        #     func_without_return\n+        ret = self._visit_stmts(node.body)\n+        if node.orelse:\n+            ret = ret or self._visit_stmts(node.orelse)\n+        return ret\n+\n+    def visit_IfExp(self, node: ast.IfExp) -> bool:\n+        return self.visit(node.body) or self.visit(node.orelse)\n+\n+    def visit_Call(self, node: ast.Call) -> bool:\n+        return self.visit(node.func)\n+\n+\n class CodeGenerator(ast.NodeVisitor):\n     def __init__(self, context, prototype, gscope, attributes, constants, function_name,\n                  module=None, is_kernel=False, function_types: Optional[Dict] = None,\n@@ -166,63 +247,6 @@ def visit_compound_statement(self, stmts):\n             if ret_type is not None and isinstance(stmt, ast.Return):\n                 self.last_ret_type = ret_type\n \n-    # TODO: should be its own AST visitor\n-    def contains_return_op(self, node):\n-        if isinstance(node, ast.Return):\n-            return True\n-        elif isinstance(node, ast.Assign):\n-            return self.contains_return_op(node.value)\n-        elif isinstance(node, ast.Module):\n-            pred = lambda s: self.contains_return_op(s)\n-            return any(pred(s) for s in node.body)\n-        elif isinstance(node, ast.FunctionDef):\n-            pred = lambda s: self.contains_return_op(s)\n-            return any(pred(s) for s in node.body)\n-        elif isinstance(node, ast.Call):\n-            def check_undefined_name(cur_node):\n-                # Check if name is an undefined local variable,\n-                # which can only be a tensor or a constexpr\n-                if isinstance(cur_node.func, ast.Attribute):\n-                    if isinstance(cur_node.func.value, ast.Name):\n-                        name = cur_node.func.value.id\n-                        if name not in self.lscope and name not in self.gscope:\n-                            return True\n-                        return False\n-                    # chain of calls\n-                    # e.g., tl.load(a).to(tl.float32)\n-                    return check_undefined_name(cur_node.func.value)\n-                return False\n-            if check_undefined_name(node):\n-                return False\n-            fn = self.visit(node.func)\n-            if isinstance(fn, JITFunction) and fn.noinline is not True:\n-                old_gscope = self.gscope\n-                self.gscope = sys.modules[fn.fn.__module__].__dict__\n-                ret = self.contains_return_op(fn.parse())\n-                self.gscope = old_gscope\n-                return ret\n-            return False\n-        elif isinstance(node, ast.If):\n-            pred = lambda s: self.contains_return_op(s)\n-            ret = any(pred(s) for s in node.body)\n-            if node.orelse:\n-                ret = ret or any(pred(s) for s in node.orelse)\n-            return ret\n-        elif isinstance(node, ast.IfExp):\n-            return self.contains_return_op(node.body) or self.contains_return_op(node.orelse)\n-        elif isinstance(node, ast.Expr):\n-            ret = False\n-            for _, value in ast.iter_fields(node):\n-                if isinstance(value, list):\n-                    for item in value:\n-                        if isinstance(item, ast.AST):\n-                            ret = ret or self.contains_return_op(item)\n-                elif isinstance(value, ast.AST):\n-                    ret = ret or self.contains_return_op(value)\n-            return ret\n-        else:\n-            return False\n-\n     def visit_Module(self, node):\n         ast.NodeVisitor.generic_visit(self, node)\n \n@@ -526,7 +550,7 @@ def visit_If(self, node):\n         cond = self.visit(node.test)\n         if _is_triton_tensor(cond):\n             cond = cond.to(language.int1, _builder=self.builder)\n-            if self.scf_stack or not self.contains_return_op(node):\n+            if self.scf_stack or not ContainsReturnChecker(self.gscope).visit(node):\n                 self.visit_if_scf(cond, node)\n             else:\n                 self.visit_if_top_level(cond, node)"}]