[{"filename": "lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "file_content_changes": "@@ -107,7 +107,9 @@ struct ConvertLayoutOpConversion\n       unsigned dim = sliceLayout.getDim();\n       auto parentEncoding = sliceLayout.getParent();\n       auto parentSizePerThread = getSizePerThread(parentEncoding);\n-      unsigned stride = parentSizePerThread[dim];\n+      unsigned stride = 1;\n+      if (getOrder(parentEncoding)[0] == dim)\n+        stride = parentSizePerThread[dim];\n       auto parentShape = sliceLayout.paddedShape(shape);\n       auto parentTy = RankedTensorType::get(parentShape, type.getElementType(),\n                                             parentEncoding);"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMBase.h", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "file_content_changes": "@@ -574,7 +574,7 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n       } else if (auto mma = layout.dyn_cast<MmaEncodingAttr>()) {\n         result = emitIndicesForDistributedLayout(loc, b, mma, type);\n       } else if (auto slice = layout.dyn_cast<SliceEncodingAttr>()) {\n-        result = emitIndicesForSliceLayout(loc, b, slice, type);\n+        result = emitIndicesForDistributedLayout(loc, b, slice, type);\n       } else {\n         llvm_unreachable(\n             \"emitIndices for layouts other than blocked & slice not \"\n@@ -913,34 +913,6 @@ class ConvertTritonGPUOpToLLVMPatternBase {\n     return resultOffsets;\n   }\n \n-  SmallVector<SmallVector<Value>>\n-  emitIndicesForSliceLayout(Location loc, ConversionPatternRewriter &rewriter,\n-                            const SliceEncodingAttr &sliceLayout,\n-                            RankedTensorType type) const {\n-    auto parentEncoding = sliceLayout.getParent();\n-    auto parentShape = sliceLayout.paddedShape(type.getShape());\n-    RankedTensorType parentTy = RankedTensorType::get(\n-        parentShape, type.getElementType(), parentEncoding);\n-\n-    unsigned dim = sliceLayout.getDim();\n-    // step 1, delinearize threadId to get the base index\n-    auto multiDimBase =\n-        emitBaseIndexForLayout(loc, rewriter, sliceLayout, type);\n-    // step 2, get offset of each element\n-    auto offset = emitOffsetForSliceLayout(sliceLayout, type);\n-    // step 3, add offset to base, and reorder the sequence of indices to\n-    // guarantee that elems in the same sizePerThread are adjacent in order\n-    auto shape = type.getShape();\n-    unsigned rank = shape.size();\n-    unsigned elemsPerThread = offset.size();\n-    SmallVector<SmallVector<Value>> multiDimIdx(elemsPerThread,\n-                                                SmallVector<Value>(rank));\n-    for (unsigned n = 0; n < elemsPerThread; ++n)\n-      for (unsigned k = 0; k < rank; ++k)\n-        multiDimIdx[n][k] = add(multiDimBase[k], i32_val(offset[n][k]));\n-    return multiDimIdx;\n-  }\n-\n protected:\n   TritonGPUToLLVMTypeConverter *converter;\n   const Allocation *allocation;"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "file_content_changes": "@@ -103,7 +103,6 @@ SmallVector<unsigned> getSizePerThread(Attribute layout) {\n     return SmallVector<unsigned>(blockedLayout.getSizePerThread().begin(),\n                                  blockedLayout.getSizePerThread().end());\n   } else if (auto sliceLayout = layout.dyn_cast<SliceEncodingAttr>()) {\n-    // TODO: maybe should not be supported\n     auto sizePerThread = getSizePerThread(sliceLayout.getParent());\n     sizePerThread.erase(sizePerThread.begin() + sliceLayout.getDim());\n     return sizePerThread;"}]