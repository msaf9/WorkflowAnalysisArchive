[{"filename": "python/triton/compiler.py", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "file_content_changes": "@@ -23,6 +23,8 @@\n import triton\n import triton._C.libtriton.triton as _triton\n \n+from .tools.disasm import extract\n+\n \n def str_to_ty(name):\n     if name[0] == \"*\":\n@@ -1209,14 +1211,20 @@ def compile(fn, signature: str, device: int = -1, constants=dict(), num_warps: i\n     ptx_name = f\"{name}.ptx\"\n     cubin_name = f\"{name}.cubin\"\n     data_name = f\"{name}.json\"\n+    ttir_name = f\"{name}.ttir\"\n+    llir_name = f\"{name}.llir\"\n     if not fn_cache_manager.has_file(cubin_name) or \\\n        not fn_cache_manager.has_file(data_name) or \\\n-       not fn_cache_manager.has_file(ptx_name):\n+       not fn_cache_manager.has_file(ptx_name) or \\\n+       not fn_cache_manager.has_file(ttir_name) or \\\n+       not fn_cache_manager.has_file(llir_name):\n         asm, shared, kernel_name = _compile(fn, signature, device, constants, configs[0], num_warps, num_stages,\n                                             extern_libs, \"cubin\", cc)\n         metadata = {\"name\": kernel_name, \"shared\": shared, \"num_warps\": num_warps, \"num_stages\": num_stages}\n         fn_cache_manager.put(asm[\"cubin\"], cubin_name)\n         fn_cache_manager.put(asm[\"ptx\"], ptx_name, binary=False)\n+        fn_cache_manager.put(asm[\"ttir\"], ttir_name, binary=False)\n+        fn_cache_manager.put(asm[\"llir\"], llir_name, binary=False)\n         fn_cache_manager.put(json.dumps(metadata), data_name, binary=False)\n \n     if warm_cache_only:\n@@ -1246,14 +1254,33 @@ def __init__(self, fn_name, so_path, cache_dir, device):\n             self.asm[\"cubin\"] = f.read()\n         with open(os.path.join(cache_dir, f\"{fn_name}.ptx\"), \"r\") as f:\n             self.asm[\"ptx\"] = f.read()\n+        with open(os.path.join(cache_dir, f\"{fn_name}.llir\"), \"r\") as f:\n+            self.asm[\"llir\"] = f.read()\n+        with open(os.path.join(cache_dir, f\"{fn_name}.ttir\"), \"r\") as f:\n+            self.asm[\"ttir\"] = f.read()\n \n         mod, func, n_regs, n_spills = _triton.code_gen.load_binary(metadata[\"name\"], self.asm[\"cubin\"], self.shared, device)\n         self.cu_module = mod\n         self.cu_function = func\n+        self.n_regs = n_regs\n+        self.n_spills = n_spills\n \n     def __getitem__(self, grid):\n         def runner(*args, stream=None):\n             if stream is None:\n                 stream = torch.cuda.current_stream().cuda_stream\n             self.c_wrapper(grid[0], grid[1], grid[2], self.num_warps, self.shared, stream, self.cu_function, *args)\n         return runner\n+\n+    def get_sass(self, fun=None):\n+        if 'sass' in self.asm:\n+            return self.asm['sass']\n+        fd, path = tempfile.mkstemp()\n+        try:\n+            with open(fd, 'wb') as cubin:\n+                cubin.write(self.asm['cubin'])\n+            self.sass = extract(path, fun)\n+        finally:\n+            os.remove(path)\n+        self.asm['sass'] = self.sass\n+        return self.sass"}]