[{"filename": "python/triton/language/random.py", "status": "removed", "additions": 0, "deletions": 173, "changes": 173, "file_content_changes": "@@ -1,173 +0,0 @@\n-import triton\n-from . import core as tl\n-\n-PHILOX_KEY_A: tl.constexpr = -1640531527  # 0x9E3779B9\n-PHILOX_KEY_B: tl.constexpr = -1150833019  # 0xBB67AE85\n-PHILOX_ROUND_A: tl.constexpr = -766435501  # 0xD2511F53\n-PHILOX_ROUND_B: tl.constexpr = -845247145  # 0xCD9E8D57\n-N_ROUNDS_DEFAULT = 10  # Default number of rounds for philox\n-\n-# -------------------\n-# randint\n-# -------------------\n-\n-\n-@triton.jit\n-def philox_impl(c0, c1, c2, c3, k0, k1, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n-    \"\"\"\n-    Run `n_rounds` rounds of Philox for state (c0, c1, c2, c3) and key (k0, k1).\n-    \"\"\"\n-    for _ in range(n_rounds):\n-        # update random state\n-        A = PHILOX_ROUND_A\n-        B = PHILOX_ROUND_B\n-        _c0, _c2 = c0, c2\n-        c0 = tl.umulhi(B, _c2) ^ c1 ^ k0\n-        c2 = tl.umulhi(A, _c0) ^ c3 ^ k1\n-        c1 = B * _c2\n-        c3 = A * _c0\n-        # raise key\n-        k0 = k0 + PHILOX_KEY_A\n-        k1 = k1 + PHILOX_KEY_B\n-    return c0, c1, c2, c3\n-\n-\n-@triton.jit\n-def philox(seed, c0, c1, c2, c3, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n-    seed = seed.to(tl.uint64)\n-    seed_hi = ((seed >> 32) & 0xffffffff).to(tl.uint32)\n-    seed_lo = (seed & 0xffffffff).to(tl.uint32)\n-    return philox_impl(c0, c1, c2, c3, seed_lo, seed_hi, n_rounds)\n-\n-\n-@triton.jit\n-def randint(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n-    \"\"\"\n-    Given a :code:`seed` scalar and an :code:`offset` block, returns a single\n-    block of random :code:`int32`.\n-\n-    If you need multiple streams of random numbers,\n-    using `randint4x` is likely to be faster than calling `randint` 4 times.\n-\n-    :param seed: The seed for generating random numbers.\n-    :param offsets: The offsets to generate random numbers for.\n-    \"\"\"\n-    ret, _, _, _ = randint4x(seed, offset, n_rounds)\n-    return ret\n-\n-\n-@triton.jit\n-def randint4x(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n-    \"\"\"\n-    Given a :code:`seed` scalar and an :code:`offset` block, returns four\n-    blocks of random :code:`int32`.\n-\n-    This is the maximally efficient entry point\n-    to Triton's Philox pseudo-random number generator.\n-\n-    :param seed: The seed for generating random numbers.\n-    :param offsets: The offsets to generate random numbers for.\n-    \"\"\"\n-    # _0 = tl.zeros(offset.shape, offset.dtype)\n-    _0 = offset * 0\n-    return philox(seed, offset, _0, _0, _0, n_rounds)\n-\n-\n-# -------------------\n-# rand\n-# -------------------\n-\n-# @triton.jit\n-# def uint32_to_uniform_float(x):\n-#     \"\"\"\n-#     Numerically stable function to convert a random uint32 into a random float uniformly sampled in [0, 1).\n-#     \"\"\"\n-#     two_to_the_minus_32: tl.constexpr = 2.328306e-10\n-#     return x * two_to_the_minus_32\n-\n-@triton.jit\n-def uint32_to_uniform_float(x):\n-    \"\"\"\n-    Numerically stable function to convert a random uint32 into a random float uniformly sampled in [0, 1).\n-    \"\"\"\n-    x = x.to(tl.int32, bitcast=True)\n-    # maximum value such that `MAX_INT * scale < 1.0` (with float rounding)\n-    scale = 4.6566127342e-10\n-    x = tl.where(x < 0, -x - 1, x)\n-    return x * scale\n-\n-\n-@triton.jit\n-def rand(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n-    \"\"\"\n-    Given a :code:`seed` scalar and an :code:`offset` block,\n-    returns a block of random :code:`float32` in :math:`U(0, 1)`\n-\n-    :param seed: The seed for generating random numbers.\n-    :param offsets: The offsets to generate random numbers for.\n-    \"\"\"\n-    offset = offset.to(tl.uint32, bitcast=True)\n-    source = randint(seed, offset, n_rounds)\n-    return uint32_to_uniform_float(source)\n-\n-\n-@triton.jit\n-def rand4x(seed, offsets, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n-    \"\"\"\n-    Given a :code:`seed` scalar and an :code:`offsets` block,\n-    returns a 4 blocks of random :code:`float32` in :math:`U(0, 1)`\n-\n-    :param seed: The seed for generating random numbers.\n-    :param offsets: The offsets to generate random numbers for.\n-    \"\"\"\n-    offsets = offsets.to(tl.uint32, bitcast=True)\n-    i1, i2, i3, i4 = randint4x(seed, offsets, n_rounds)\n-    u1 = uint32_to_uniform_float(i1)\n-    u2 = uint32_to_uniform_float(i2)\n-    u3 = uint32_to_uniform_float(i3)\n-    u4 = uint32_to_uniform_float(i4)\n-    return u1, u2, u3, u4\n-\n-# -------------------\n-# randn\n-# -------------------\n-\n-\n-@triton.jit\n-def pair_uniform_to_normal(u1, u2):\n-    \"\"\"Box-Muller transform\"\"\"\n-    u1 = tl.maximum(1.0e-7, u1)\n-    th = 6.283185307179586 * u2\n-    r = tl.sqrt(-2.0 * tl.log(u1))\n-    return r * tl.cos(th), r * tl.sin(th)\n-\n-\n-@triton.jit\n-def randn(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n-    \"\"\"\n-    Given a :code:`seed` scalar and an :code:`offset` block,\n-    returns a block of random :code:`float32` in :math:`\\\\mathcal{N}(0, 1)`\n-\n-    :param seed: The seed for generating random numbers.\n-    :param offsets: The offsets to generate random numbers for.\n-    \"\"\"\n-    i1, i2, _, _ = randint4x(seed, offset, n_rounds)\n-    u1 = uint32_to_uniform_float(i1)\n-    u2 = uint32_to_uniform_float(i2)\n-    n1, _ = pair_uniform_to_normal(u1, u2)\n-    return n1\n-\n-\n-@triton.jit\n-def randn4x(seed, offset, n_rounds: tl.constexpr = N_ROUNDS_DEFAULT):\n-    \"\"\"\n-    Given a :code:`seed` scalar and an :code:`offset` block,\n-    returns a 4 blocks of random :code:`float32` in :math:`\\\\mathcal{N}(0, 1)`\n-\n-    :param seed: The seed for generating random numbers.\n-    :param offsets: The offsets to generate random numbers for.\n-    \"\"\"\n-    u1, u2, u3, u4 = rand4x(seed, offset, n_rounds)\n-    n1, n2 = pair_uniform_to_normal(u1, u2)\n-    n3, n4 = pair_uniform_to_normal(u3, u4)\n-    return n1, n2, n3, n4"}, {"filename": "python/triton/unroll.py", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "file_content_changes": "@@ -21,7 +21,6 @@\n from enum import Enum\n from types import ModuleType\n from typing import Any, Dict, Set, Tuple, Union, List, Optional, Callable, Sequence\n-from typing import cast as typecast\n from collections import defaultdict, namedtuple\n \n \n@@ -840,6 +839,7 @@ def __init__(\n         #\n         self.builtins = {\n             \"range\": range,\n+            # this is the triton `minimum`\n             \"min\": minimum,\n             \"float\": float,\n             \"int\": int,\n@@ -1499,13 +1499,15 @@ def visit_Call(self, node):\n             fn, ExternalFunction\n         ):\n             ret = fn(*args, _builder=self.builder, **kws)\n-        if fn in self.value_constructor.builtins.values():\n+        elif fn in self.value_constructor.builtins.values():\n             args = [arg.value if isinstance(arg, constexpr) else arg for arg in args]\n             ret = fn(*args, **kws)\n             if isinstance(ret, (bool, int, float)):\n                 ret = constexpr(ret)\n             else:\n                 ret = _to_tensor(ret, self.builder)\n+        else:\n+            raise AssertionError(f\"Couldn't resolve function: {repr(fn)}\")\n         # special case: dynamic parallelism\n         # in this case the core primitive returns a proxy\n         # if isinstance(ret, triton.LaunchProxy):\n@@ -2292,7 +2294,7 @@ class SIGNEDNESS(Enum):\n     int_signedness: SIGNEDNESS\n     int_bitwidth: int\n     primitive_bitwidth: int\n-    fp_mantissa_width: Optional[int] = None\n+    fp_mantissa_width: int = 0\n \n     def __init__(self, name):\n         self.name = name\n@@ -2405,7 +2407,7 @@ def __hash__(self):\n         return hash((self.name,))\n \n     @property\n-    def scalar(self):\n+    def scalar(self) -> dtype:\n         return self\n \n     def to_ir(self, builder: ir.builder) -> ir.type:\n@@ -2481,7 +2483,7 @@ def __ne__(self, other: Any) -> bool:\n         return not self.__eq__(other)\n \n     @property\n-    def scalar(self):\n+    def scalar(self) -> pointer_type:\n         return self\n \n \n@@ -2531,7 +2533,7 @@ def __ne__(self, other: Any) -> bool:\n         return not self.__eq__(other)\n \n     @property\n-    def scalar(self):\n+    def scalar(self) -> dtype:\n         return self.element_ty\n \n \n@@ -5088,7 +5090,7 @@ def philox_impl(c0, c1, c2, c3, k0, k1, n_rounds: constexpr = N_ROUNDS_DEFAULT):\n     \"\"\"\n     Run `n_rounds` rounds of Philox for state (c0, c1, c2, c3) and key (k0, k1).\n     \"\"\"\n-    for _ in range(typecast(int, n_rounds)):\n+    for _ in range(n_rounds):  # type: ignore\n         # update random state\n         A = PHILOX_ROUND_A\n         B = PHILOX_ROUND_B"}]