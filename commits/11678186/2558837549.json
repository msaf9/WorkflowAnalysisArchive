[{"filename": "lib/codegen/selection/generator.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -2658,7 +2658,7 @@ void generator::visit_layout_convert(ir::value *out, ir::value *in){\n       in_layout->to_mma() ? out_layout->get_order() : in_layout->get_order();\n   auto out_ord =\n       out_layout->to_mma() ? in_layout->get_order() : out_layout->get_order();\n-  // out_ord[0] == 0 and in_order[0] == 0 means the first dimension is\n+  // out_ord[0] == 0 or in_order[0] == 0 means the first dimension is\n   // non-contiguous. in_vec can be greater than 0 only if both out_ord[0] and\n   // and in_ord[0] are contiguous.\n   int in_vec = out_ord[0] == 0  ? 1"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -815,8 +815,8 @@ def kernel(X, stride_xm, stride_xn,\n     z_tri_contiguous = to_triton(np.empty_like(x), device=device)\n     x_tri = to_triton(x, device=device)\n     pgm = kernel[(1, 1)](x_tri, x_tri.stride(0), x_tri.stride(1),\n-                             z_tri, z_tri.stride(1), z_tri.stride(0),\n-                             BLOCK_M=shape[0], BLOCK_N=shape[1])\n+                         z_tri, z_tri.stride(1), z_tri.stride(0),\n+                         BLOCK_M=shape[0], BLOCK_N=shape[1])\n     pgm_contiguous = kernel[(1, 1)](x_tri, x_tri.stride(1), x_tri.stride(0),\n                                     z_tri_contiguous, z_tri_contiguous.stride(0), z_tri_contiguous.stride(1),\n                                     BLOCK_M=shape[0], BLOCK_N=shape[1])"}]