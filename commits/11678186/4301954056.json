[{"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.cpp", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "file_content_changes": "@@ -7,6 +7,8 @@\n #include \"mlir/Conversion/LLVMCommon/VectorPattern.h\"\n #include \"mlir/Conversion/MathToLLVM/MathToLLVM.h\"\n #include \"mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h\"\n+#include \"mlir/Dialect/Index/IR/IndexDialect.h\"\n+#include \"mlir/Dialect/Index/IR/IndexOps.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"mlir/Dialect/LLVMIR/NVVMDialect.h\"\n #include \"mlir/Pass/Pass.h\"\n@@ -365,34 +367,54 @@ struct FuncOpConversion : public FuncOpConversionBase {\n   int numWarps{0};\n };\n \n+bool hasIndexResultOrOperand(Operation *op) {\n+  if (!op)\n+    return false;\n+  bool hasRetIndex = llvm::find_if(op->getResultTypes(), [](Type type) {\n+                       return type.isIndex();\n+                     }) != op->getResultTypes().end();\n+  bool hasArgIndex = llvm::find_if(op->getOperandTypes(), [](Type type) {\n+                       return type.isIndex();\n+                     }) != op->getOperandTypes().end();\n+  return !hasRetIndex && !hasArgIndex;\n+}\n+\n class TritonLLVMFunctionConversionTarget : public ConversionTarget {\n public:\n   explicit TritonLLVMFunctionConversionTarget(MLIRContext &ctx)\n       : ConversionTarget(ctx) {\n+    addLegalDialect<index::IndexDialect>();\n     addLegalDialect<LLVM::LLVMDialect>();\n     addLegalDialect<NVVM::NVVMDialect>();\n     addIllegalOp<mlir::func::FuncOp>();\n     addLegalOp<mlir::UnrealizedConversionCastOp>();\n+    addDynamicallyLegalDialect<arith::ArithDialect>(hasIndexResultOrOperand);\n   }\n };\n \n-// There are some patterns that NVPTX can't codegen. We\n-// make sure that arith doesn't generate them by providing a dummy pattern\n-// with a higher benefit.\n-template <class T> struct OverridePattern : public ConvertOpToLLVMPattern<T> {\n+#undef add\n \n-  using ConvertOpToLLVMPattern<T>::ConvertOpToLLVMPattern;\n-  using OpAdaptor = typename T::Adaptor;\n+template <class SrcOp, class DstOp>\n+LogicalResult replaceArithWithIndex(SrcOp op, PatternRewriter &rewriter) {\n+  // if (!hasIndexResultOrOperand(&*op))\n+  //   return failure();\n+  rewriter.replaceOpWithNewOp<DstOp>(op, op->getResultTypes(),\n+                                     op->getOperands(), op->getAttrs());\n+  return success();\n+}\n \n-  OverridePattern(LLVMTypeConverter &converter)\n-      : ConvertOpToLLVMPattern<T>(converter, 100) {}\n+LogicalResult replaceArithCmpWithIndexCmp(arith::CmpIOp op,\n+                                          PatternRewriter &rewriter) {\n+  // if (!hasIndexResultOrOperand(&*op))\n+  //   return failure();\n+  rewriter.replaceOpWithNewOp<index::CmpOp>(\n+      op, op.getResult().getType(), (index::IndexCmpPredicate)op.getPredicate(),\n+      op.getOperand(0), op.getOperand(1));\n+  return success();\n+}\n \n-  LogicalResult\n-  matchAndRewrite(arith::TruncFOp funcOp, OpAdaptor adaptor,\n-                  ConversionPatternRewriter &rewriter) const override {\n-    return success();\n-  }\n-};\n+// mlir::LogicalResult (*replaceIndexCast)(OpType, mlir::PatternRewriter &) =\n+//     &replaceArithWithIndex<arith::IndexCastOp, index::CastSOp>;\n \n class ConvertTritonFuncToLLVM\n     : public ConvertTritonFuncToLLVMBase<ConvertTritonFuncToLLVM> {\n@@ -410,18 +432,28 @@ class ConvertTritonFuncToLLVM\n       patterns.add<ReturnOpConversion>(typeConverter);\n       mlir::cf::populateControlFlowToLLVMConversionPatterns(typeConverter,\n                                                             patterns);\n-      if (failed(applyPartialConversion(mod, target, std::move(patterns))))\n-        return signalPassFailure();\n-    }\n-    {\n-      LLVMTypeConverter typeConverter(context, option);\n-      RewritePatternSet patterns(context);\n-      mlir::arith::populateArithToLLVMConversionPatterns(typeConverter,\n-                                                         patterns);\n-      patterns.add<OverridePattern<arith::TruncFOp>>(typeConverter);\n-      if (failed(applyPartialConversion(mod, target, std::move(patterns))))\n+      patterns.add(replaceArithWithIndex<arith::IndexCastOp, index::CastSOp>);\n+      patterns.add(replaceArithWithIndex<arith::ConstantOp, index::ConstantOp>);\n+      patterns.add(replaceArithWithIndex<arith::AddIOp, index::AddOp>);\n+      patterns.add(replaceArithCmpWithIndexCmp);\n+\n+      if (failed(applyPartialConversion(mod, target, std::move(patterns)))) {\n+        // llvm::outs() << mod << \"\\n\";\n         return signalPassFailure();\n+      }\n     }\n+    // {\n+    //   RewritePatternSet patterns(context);\n+    //   TritonGPUToLLVMTypeConverter typeConverter(context, option);\n+    //   // LLVMTypeConverter typeConverter(context, option);\n+    //   // RewritePatternSet patterns(context);\n+    //   // mlir::arith::populateArithToLLVMConversionPatterns(typeConverter,\n+    //   //                                                    patterns);\n+    //   // patterns.add<OverridePattern<arith::TruncFOp>>(typeConverter);\n+    //   if (failed(applyPartialConversion(mod, target, std::move(patterns)))) {\n+    //     return signalPassFailure();\n+    //   }\n+    // }\n   }\n };\n "}, {"filename": "lib/Target/LLVMIR/LLVMIRTranslation.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "file_content_changes": "@@ -296,7 +296,9 @@ translateTritonGPUToLLVMIR(llvm::LLVMContext *llvmContext,\n \n   pm.addPass(mlir::createConvertSCFToCFPass());\n   pm.addPass(mlir::triton::createConvertTritonFuncToLLVMPass());\n+  pm.addPass(mlir::createConvertIndexToLLVMPass());\n   pm.addPass(createConvertTritonGPUToLLVMPass(computeCapability));\n+  pm.addPass(mlir::createArithToLLVMConversionPass());\n   pm.addPass(mlir::createCanonicalizerPass());\n   // Simplify the IR\n   pm.addPass(mlir::createCSEPass());"}, {"filename": "python/src/triton.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "file_content_changes": "@@ -13,6 +13,8 @@\n \n #include \"mlir/Dialect/ControlFlow/IR/ControlFlow.h\"\n #include \"mlir/Dialect/ControlFlow/IR/ControlFlowOps.h\"\n+#include \"mlir/Dialect/Index/IR/IndexDialect.h\"\n+#include \"mlir/Dialect/Index/IR/IndexOps.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n #include \"triton/Analysis/Allocation.h\"\n #include \"triton/Conversion/TritonGPUToLLVM/TritonGPUToLLVMPass.h\"\n@@ -118,6 +120,7 @@ void init_triton_ir(py::module &&m) {\n       .def(py::init<>())\n       .def(\"load_triton\", [](mlir::MLIRContext &self) {\n         self.getOrLoadDialect<mlir::triton::TritonDialect>();\n+        self.getOrLoadDialect<mlir::index::IndexDialect>();\n         // we load LLVM because the frontend uses LLVM.undef for\n         // some placeholders\n         self.getOrLoadDialect<mlir::triton::TritonDialect>();\n@@ -392,8 +395,8 @@ void init_triton_ir(py::module &&m) {\n         registry.insert<mlir::triton::TritonDialect,\n                         mlir::triton::gpu::TritonGPUDialect,\n                         mlir::math::MathDialect, mlir::arith::ArithDialect,\n-                        mlir::func::FuncDialect, mlir::scf::SCFDialect,\n-                        mlir::cf::ControlFlowDialect>();\n+                        mlir::index::IndexDialect, mlir::func::FuncDialect,\n+                        mlir::scf::SCFDialect, mlir::cf::ControlFlowDialect>();\n         context.appendDialectRegistry(registry);\n         context.loadAllAvailableDialects();\n "}]