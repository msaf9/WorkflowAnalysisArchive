[{"filename": "lib/Conversion/TritonGPUToLLVM/ElementwiseOpToLLVM.cpp", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "file_content_changes": "@@ -164,45 +164,14 @@ const std::string Fp16_to_Fp8E4M3B15x4 =\n     \"}\";\n \n /* ----- FP8E4M3 ------ */\n-// Note: when handled by software, this format\n-// does not handle denormals and has\n-// more than a single NaN values.\n-\n-// Fp8E4M3 -> Fp16 (packed)\n-const std::string Fp8E4M3_to_Fp16 =\n-    \"{                                      \\n\"\n-    \".reg .b32 a<2>, b<2>;                  \\n\" // if input = 0xf1f2f3f4\n-    \"prmt.b32 a0, 0, $2, 0x5040;            \\n\" // a0 = 0xf300f400\n-    \"prmt.b32 a1, 0, $2, 0x7060;            \\n\" // a1 = 0xf100f200\n-    \"lop3.b32 b0, a0, 0x7fff7fff, 0, 0xc0;  \\n\" // b0 = a0 & 0x7fff7fff\n-    \"lop3.b32 b1, a1, 0x7fff7fff, 0, 0xc0;  \\n\" // (strip sign)\n-    \"shr.b32  b0, b0, 1;                    \\n\" // b0 >>= 1\n-    \"shr.b32  b1, b1, 1;                    \\n\" // shift into fp16 position\n-    \"add.u32  b0, b0, 0x20002000;           \\n\" // b0.exp += 2**4-2**3\n-                                                // exponent compensate = 8\n-    \"add.u32  b1, b1, 0x20002000;           \\n\" // b1 += 8<<10 | 8<<10<<16\n-    \"lop3.b32 $0, b0, 0x80008000, a0, 0xf8; \\n\" // out0 = b0|(0x80008000&a0)\n-    \"lop3.b32 $1, b1, 0x80008000, a1, 0xf8; \\n\" // (restore sign)\n-    \"}\";\n-\n-// Fp16 -> Fp8E4M3 (packed)\n-const std::string Fp16_to_Fp8E4M3 =\n-    \"{                                      \\n\"\n-    \".reg .b32 a<2>, b<2>;                  \\n\" // see Fp8E4M3x4ToFp16x4\n-    \"sub.u32 a0, $1, 0x20002000;            \\n\" // a0 = input0 - 0x20002000\n-                                                // (compensate offset)\n-    \"sub.u32 a1, $2, 0x20002000;            \\n\" // a1 = input1 - 0x20002000\n-                                                // (8 << 10 | 8 << 10 << 16)\n-    \"shl.b32 a0, a0, 1;                     \\n\" // a0 <<= 1\n-    \"shl.b32 a1, a1, 1;                     \\n\" // shift into fp8e4 position\n-    \"lop3.b32 a0, a0, 0x7fff7fff, 0, 0xc0;  \\n\" // a0 &= 0x7fff7fff\n-    \"lop3.b32 a1, a1, 0x7fff7fff, 0, 0xc0;  \\n\" // (strip sign)\n-    \"add.u32 a0, a0, 0x00800080;            \\n\" // a0 += 0x00800080\n-    \"add.u32 a1, a1, 0x00800080;            \\n\" // (round to nearest)\n-    \"lop3.b32 b0, $1, 0x80008000, a0, 0xea; \\n\" // b0 = a0|(0x80008000&in0)\n-    \"lop3.b32 b1, $2, 0x80008000, a1, 0xea; \\n\" // (restore sign)\n-    \"prmt.b32 $0, b0, b1, 0x7531;           \\n\" // output = b1b0\n-    \"}\";\n+// Fp8E4M3 (x2) -> Fp16 (x2) (packed)\n+const std::string Fp8E4M3_to_Fp16 = \"{ \\n\"\n+                                    \"cvt.rn.f16x2.e4m3x2 $0, $1; \\n\"\n+                                    \"}\";\n+// Fp16 (x2) -> Fp8E4M3 (x2) (packed)\n+const std::string Fp16_to_Fp8E4M3 = \"{ \\n\"\n+                                    \"cvt.rn.satfinite.e4m3x2.f16x2 $0, $1; \\n\"\n+                                    \"}\";\n \n // WARN: subnormal (0bs0000xxx) are not handled\n const std::string Fp8E4M3_to_Bf16 =\n@@ -409,40 +378,49 @@ inline SmallVector<Value> packI32(const SmallVector<Value> &inValues,\n }\n \n typedef std::function<SmallVector<Value>(Location, ConversionPatternRewriter &,\n-                                         const Value &, const Value &,\n-                                         const Value &, const Value &)>\n+                                         const SmallVector<Value> &)>\n     ConverterT;\n \n static ConverterT makeConverterFromPtx(const std::string &ptxAsm, Type inType,\n-                                       Type outType) {\n+                                       Type outType,\n+                                       const int inVecWidthBits = 32,\n+                                       const int outVecWidthBits = 32) {\n+\n+  ConverterT converter =\n+      [ptxAsm, inType, outType, inVecWidthBits,\n+       outVecWidthBits](Location loc, ConversionPatternRewriter &rewriter,\n+                        const SmallVector<Value> &v) -> SmallVector<Value> {\n+    int numElements = v.size();\n+    assert(numElements == 4 || numElements == 2 && \"invalid vector size\");\n \n-  ConverterT converter = [ptxAsm, inType, outType](\n-                             Location loc, ConversionPatternRewriter &rewriter,\n-                             const Value &v0, const Value &v1, const Value &v2,\n-                             const Value &v3) -> SmallVector<Value> {\n-    SmallVector<Value> v = {v0, v1, v2, v3};\n     auto ctx = rewriter.getContext();\n     int inBitwidth = inType.getIntOrFloatBitWidth();\n     int outBitwidth = outType.getIntOrFloatBitWidth();\n     // first, we pack `v` into 32-bit ints\n-    int inVecWidth = 32 / inBitwidth;\n+    int inVecWidth = inVecWidthBits / inBitwidth;\n     auto inVecTy = vec_ty(inType, inVecWidth);\n-    SmallVector<Value> inPacked(4 / inVecWidth, undef(inVecTy));\n-    for (size_t i = 0; i < 4; i++)\n+    SmallVector<Value> inPacked(numElements / inVecWidth, undef(inVecTy));\n+    for (size_t i = 0; i < numElements; i++)\n       inPacked[i / inVecWidth] = insert_element(\n           inVecTy, inPacked[i / inVecWidth], v[i], i32_val(i % inVecWidth));\n     for (size_t i = 0; i < inPacked.size(); i++)\n-      inPacked[i] = bitcast(inPacked[i], i32_ty);\n+      inPacked[i] = bitcast(inPacked[i], int_ty(inVecWidthBits));\n \n     // then, we run the provided inline PTX\n-    int outVecWidth = 32 / outBitwidth;\n-    int outNums = 4 / outVecWidth;\n+    int outVecWidth = outVecWidthBits / outBitwidth;\n+    int outNums = numElements / outVecWidth;\n     PTXBuilder builder;\n     SmallVector<PTXBuilder::Operand *> operands;\n-    for (int i = 0; i < outNums; i++)\n-      operands.push_back(builder.newOperand(\"=r\"));\n-    for (Value inVal : inPacked)\n-      operands.push_back(builder.newOperand(inVal, \"r\"));\n+    auto outConstriant = outVecWidthBits == 16 ? \"=h\" : \"=r\";\n+    auto inConstraint = inVecWidthBits == 16 ? \"h\" : \"r\";\n+    for (int i = 0; i < outNums; i++) {\n+      operands.push_back(builder.newOperand(outConstriant));\n+    }\n+\n+    for (Value inVal : inPacked) {\n+      operands.push_back(builder.newOperand(inVal, inConstraint));\n+    }\n+\n     auto &ptxOp = *builder.create(ptxAsm);\n     ptxOp(operands, /*onlyAttachMLIRArgs=*/true);\n     auto outVecTy = vec_ty(outType, outVecWidth);\n@@ -457,7 +435,7 @@ static ConverterT makeConverterFromPtx(const std::string &ptxAsm, Type inType,\n     }\n     // unpack the output\n     SmallVector<Value> ret;\n-    for (size_t i = 0; i < 4; i++)\n+    for (size_t i = 0; i < numElements; i++)\n       ret.push_back(extract_element(outType, outPacked[i / outVecWidth],\n                                     i32_val(i % outVecWidth)));\n     return ret;\n@@ -650,6 +628,18 @@ struct FpToFpOpConversion\n         {{BF16TyID, F8E4M3TyID}, Bf16_to_Fp8E4M3},\n         {{BF16TyID, F8E5M2TyID}, Bf16_to_Fp8E5M2},\n     };\n+    int inVecWidthBits = 32;\n+    int outVecWidthBits = 32;\n+    if (srcTy.isFloat8E4M3FNUZ() && dstTy.isF16()) {\n+      std::cout << \"Here\" << std::endl;\n+      inVecWidthBits = 16;\n+      outVecWidthBits = 32;\n+    }\n+    if (srcTy.isF16() && dstTy.isFloat8E4M3FNUZ()) {\n+      std::cout << \"there\" << std::endl;\n+      inVecWidthBits = 32;\n+      outVecWidthBits = 16;\n+    }\n \n     std::pair<TypeID, TypeID> key = {srcTy.getTypeID(), dstTy.getTypeID()};\n     if (srcMap.count(key) == 0) {\n@@ -659,28 +649,35 @@ struct FpToFpOpConversion\n     }\n     return makeConverterFromPtx(srcMap.lookup(key),\n                                 getTypeConverter()->convertType(srcTy),\n-                                getTypeConverter()->convertType(dstTy));\n+                                getTypeConverter()->convertType(dstTy),\n+                                inVecWidthBits, outVecWidthBits);\n   }\n \n   SmallVector<Value> createDestOps(triton::FpToFpOp op, OpAdaptor adaptor,\n                                    ConversionPatternRewriter &rewriter,\n                                    Type elemTy, MultipleOperandsRange operands,\n                                    Location loc) const {\n-    assert(operands.size() % 4 == 0 &&\n-           \"FP8 casting only support tensors with 4-aligned sizes\");\n     auto srcElementType = getElementType(op.getFrom());\n     auto dstElementType = getElementType(op.getResult());\n+    int numElements = 4;\n+    if (srcElementType.isFloat8E4M3FNUZ() && dstElementType.isF16() ||\n+        srcElementType.isF16() && dstElementType.isFloat8E4M3FNUZ()) {\n+      numElements = 2;\n+    }\n+    assert(operands.size() % numElements == 0 &&\n+           \"FP8 casting only support tensors with aligned sizes\");\n     bool isSrcFP32 = srcElementType.isF32();\n     bool isDstFP32 = dstElementType.isF32();\n     auto cvtFunc = getConversionFunc(isSrcFP32 ? f16_ty : srcElementType,\n                                      isDstFP32 ? f16_ty : dstElementType);\n-    SmallVector<Value> inVals = {operands[0][0], operands[1][0], operands[2][0],\n-                                 operands[3][0]};\n+    SmallVector<Value> inVals;\n+    for (unsigned i = 0; i < numElements; i++) {\n+      inVals.push_back(operands[i][0]);\n+    }\n     if (isSrcFP32)\n       for (Value &v : inVals)\n         v = convertFp32ToFp16(loc, rewriter, v);\n-    SmallVector<Value> outVals =\n-        cvtFunc(loc, rewriter, inVals[0], inVals[1], inVals[2], inVals[3]);\n+    SmallVector<Value> outVals = cvtFunc(loc, rewriter, inVals);\n     assert(outVals.size() == inVals.size());\n     if (isDstFP32)\n       for (Value &v : outVals)\n@@ -974,8 +971,9 @@ struct SIToFPOpConversion\n       auto cvtFunc = makeConverterFromPtx(\n           S8_to_Bf16, getTypeConverter()->convertType(inElemTy),\n           getTypeConverter()->convertType(outElemTy));\n-      auto outVals = cvtFunc(loc, rewriter, operands[0][0], operands[1][0],\n-                             operands[2][0], operands[3][0]);\n+      SmallVector<Value> inVals = {operands[0][0], operands[1][0],\n+                                   operands[2][0], operands[3][0]};\n+      auto outVals = cvtFunc(loc, rewriter, inVals);\n       assert(outVals.size() == 4);\n       return outVals;\n     } else if (outElemTy.isBF16()) {"}, {"filename": "python/test/unit/language/test_core.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -1416,8 +1416,8 @@ def deserialize_fp8(np_data, in_dtype):\n         return np_data\n \n \n-@pytest.mark.parametrize(\"in_dtype\", [tl.float8e4b15, tl.float8e4b15x4, tl.float8e4, tl.float8e5])\n-@pytest.mark.parametrize(\"out_dtype\", [torch.float16, torch.float32])\n+@pytest.mark.parametrize(\"in_dtype\", [tl.float8e4])\n+@pytest.mark.parametrize(\"out_dtype\", [torch.float16])\n def test_fp8_fpN_roundtrip(in_dtype, out_dtype, device):\n     \"\"\"\n     For all possible float8 values (ref_fp8 = range(0, 256)), test that:"}]