[{"filename": "python/triton/compiler/code_generator.py", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "file_content_changes": "@@ -5,6 +5,7 @@\n from typing import Any, Callable, Dict, Optional, Tuple, Type, Union\n \n from .. import language\n+from ..language import constexpr, tensor\n # ideally we wouldn't need any runtime component\n from ..runtime import JITFunction\n from .errors import (CompilationError, CompileTimeAssertionFailure,\n@@ -49,15 +50,15 @@ def mangle_fn(name, arg_tys, constants):\n \n \n def _is_triton_tensor(o: Any) -> bool:\n-    return isinstance(o, language.tensor)\n+    return isinstance(o, tensor)\n \n \n def _is_constexpr(o: Any) -> bool:\n-    return isinstance(o, language.constexpr)  # TODO: fetch language.constexpr to a global after circular imports untangled, saving getattr\n+    return isinstance(o, constexpr)\n \n \n def _unwrap_if_constexpr(o: Any):\n-    return o.value if isinstance(o, language.constexpr) else o\n+    return o.value if isinstance(o, constexpr) else o\n \n \n _condition_types = {bool, int, type(None)}  # Python types accepted for conditionals inside kernels\n@@ -100,24 +101,17 @@ def __init__(self, context, prototype, gscope, attributes, constants, function_n\n         self.scf_stack = []\n         # SSA-construction\n         # name => language.tensor\n-        self.local_defs: Dict[str, language.tensor] = {}\n-        self.global_uses: Dict[str, language.tensor] = {}\n+        self.local_defs: Dict[str, tensor] = {}\n+        self.global_uses: Dict[str, tensor] = {}\n         self.dereference_name: Callable[[str], Any] = self._define_name_lookup()\n \n     builtin_namespace: Dict[str, Any] = {_.__name__: _ for _ in (range, float, int, isinstance, getattr)}\n+    builtin_namespace.update((\n+        ('print', language.core.device_print),\n+        ('min', language.minimum),\n+    ))\n \n     def _define_name_lookup(self):\n-        # TODO: this needs to be moved to class scope when cyclic imports untangled and `language` can be imported at module level\n-        self.builtin_namespace.update((\n-            ('print', language.core.device_print),\n-            ('min', language.minimum),  # TODO: why `min`? if `min`, why not `max`? `sum`? `all`?\n-        ))\n-        # TODO: this needs to be moved to class scope when cyclic imports untangled and `language` can be imported at module level\n-        self.statically_implemented_functions.update((\n-            (language.core.static_assert, CodeGenerator.execute_static_assert),\n-            (language.core.static_print, CodeGenerator.execute_static_print),\n-        ))\n-\n         def local_lookup(name: str, absent):\n             value = self.lscope.get(name, absent)  # this needs to be re-fetched from `self` every time, because it gets switched occasionally\n             if value is not absent and name not in self.local_defs:\n@@ -127,9 +121,8 @@ def local_lookup(name: str, absent):\n         absent_marker = object()\n \n         def name_lookup(name: str) -> Any:\n-            lookup_order = local_lookup, self.gscope.get, self.builtin_namespace.get\n             absent = absent_marker\n-            for lookup_function in lookup_order:\n+            for lookup_function in local_lookup, self.gscope.get, self.builtin_namespace.get:\n                 value = lookup_function(name, absent)\n                 if value is not absent:\n                     return value\n@@ -138,7 +131,7 @@ def name_lookup(name: str) -> Any:\n         return name_lookup\n \n     def set_value(self, name: str,\n-                  value: Union[language.tensor, language.constexpr]) -> None:\n+                  value: Union[tensor, constexpr]) -> None:\n         ''' This function:\n           called by visit_Assign() & visit_FuncDef() to store left value (lvalue)\n         1. record local defined name (FIXME: should consider control flow)\n@@ -243,13 +236,13 @@ def visit_FunctionDef(self, node):\n             if i in self.constants:\n                 cst = self.constants[i]\n                 if not _is_constexpr(cst):\n-                    cst = language.constexpr(self.constants[i])\n+                    cst = constexpr(self.constants[i])\n                 arg_values.append(cst)\n                 continue\n             else:\n                 if i in self.attributes:\n                     fn.set_arg_attr(idx, \"tt.divisibility\", self.attributes[i][1])\n-                arg_values.append(language.tensor(fn.args(idx), self.prototype.param_types[idx]))\n+                arg_values.append(tensor(fn.args(idx), self.prototype.param_types[idx]))\n                 idx += 1\n \n         insert_pt = self.builder.get_insertion_block()\n@@ -289,12 +282,12 @@ def visit_AnnAssign(self, node):\n         target = self.visit(node.target)\n         value = self.visit(node.value)\n         # constexpr\n-        if annotation == language.constexpr:\n+        if annotation == constexpr:\n             if target in self.lscope:\n                 raise ValueError(f'{target} is already defined.'\n                                  f' constexpr cannot be reassigned.')\n             if not _is_constexpr(value):\n-                value = language.constexpr(value)\n+                value = constexpr(value)\n             self.lscope[target] = value\n             return self.lscope[target]\n         # default: call visit_Assign\n@@ -515,9 +508,9 @@ def visit_Compare(self, node):\n         lhs = _unwrap_if_constexpr(self.visit(node.left))\n         rhs = _unwrap_if_constexpr(self.visit(node.comparators[0]))\n         if type(node.ops[0]) == ast.Is:\n-            return language.constexpr(lhs is rhs)\n+            return constexpr(lhs is rhs)\n         if type(node.ops[0]) == ast.IsNot:\n-            return language.constexpr(lhs is not rhs)\n+            return constexpr(lhs is not rhs)\n         method_name = self._method_name_for_comp_op.get(type(node.ops[0]))\n         if method_name is None:\n             raise UnsupportedLanguageConstruct(None, node, \"AST comparison operator '{}' is not (currently) implemented.\".format(node.ops[0].__name__))\n@@ -631,7 +624,7 @@ def visit_For(self, node):\n                                  iterator.end.value,\n                                  iterator.step.value)\n             for i in static_range:\n-                self.lscope[node.target.id] = language.constexpr(i)\n+                self.lscope[node.target.id] = constexpr(i)\n                 self.visit_compound_statement(node.body)\n                 for stmt in node.orelse:\n                     ast.NodeVisitor.generic_visit(self, stmt)\n@@ -649,7 +642,7 @@ def visit_For(self, node):\n         # handle negative constant step (not supported by scf.for in MLIR)\n         negative_step = False\n         if _is_constexpr(step) and step.value < 0:\n-            step = language.constexpr(-step.value)\n+            step = constexpr(-step.value)\n             negative_step = True\n             lb, ub = ub, lb\n         lb = language.core._to_tensor(lb, self.builder)\n@@ -779,7 +772,7 @@ def visit_Call(self, node):\n             args = getcallargs(fn.fn, *args, **kws)\n             args = [args[name] for name in fn.arg_names]\n             args = [arg if _is_triton_tensor(arg)\n-                    else language.constexpr(arg) for arg in args]\n+                    else constexpr(arg) for arg in args]\n             # generate function def\n             attributes = dict()\n             constexprs = [i for i, arg in enumerate(args) if _is_constexpr(arg)]\n@@ -804,12 +797,12 @@ def visit_Call(self, node):\n             if call_op.get_num_results() == 0 or callee_ret_type is None:\n                 return None\n             elif call_op.get_num_results() == 1:\n-                return language.tensor(call_op.get_result(0), callee_ret_type)\n+                return tensor(call_op.get_result(0), callee_ret_type)\n             else:\n                 # should return a tuple of tl.tensor\n                 results = []\n                 for i in range(call_op.get_num_results()):\n-                    results.append(language.tensor(call_op.get_result(i), callee_ret_type[i]))\n+                    results.append(tensor(call_op.get_result(i), callee_ret_type[i]))\n                 return tuple(results)\n         if (hasattr(fn, '__self__') and _is_triton_tensor(fn.__self__)) or language.core.is_builtin(fn):\n             return fn(*args, _builder=self.builder, **kws)\n@@ -818,7 +811,7 @@ def visit_Call(self, node):\n         return fn(*args, **kws)\n \n     def visit_Constant(self, node):\n-        return language.constexpr(node.value)\n+        return constexpr(node.value)\n \n     def visit_BoolOp(self, node: ast.BoolOp):\n         if len(node.values) != 2:\n@@ -833,13 +826,13 @@ def visit_BoolOp(self, node: ast.BoolOp):\n \n     if sys.version_info < (3, 8):\n         def visit_NameConstant(self, node):\n-            return language.constexpr(node.value)\n+            return constexpr(node.value)\n \n         def visit_Num(self, node):\n-            return language.constexpr(node.n)\n+            return constexpr(node.n)\n \n         def visit_Str(self, node):\n-            return language.constexpr(ast.literal_eval(node))\n+            return constexpr(ast.literal_eval(node))\n \n     def visit_Attribute(self, node):\n         lhs = self.visit(node.value)\n@@ -883,9 +876,6 @@ def visit(self, node):\n     def generic_visit(self, node):\n         raise UnsupportedLanguageConstruct(None, node, \"unsupported AST node type: {}\".format(type(node).__name__))\n \n-    # TODO: populate this here (rather than inside `_define_name_lookup`) once cyclic imports resolved\n-    statically_implemented_functions: Dict[object, Callable[[ast.Call], Any]] = {}\n-\n     def execute_static_print(self, node: ast.Call) -> None:\n         # TODO: too simplistic? Perhaps do something else with non-constexpr\n \n@@ -913,6 +903,11 @@ def execute_static_assert(self, node: ast.Call) -> None:\n             raise CompileTimeAssertionFailure(None, node, _unwrap_if_constexpr(message))\n         return None\n \n+    statically_implemented_functions: Dict[object, Callable[[ast.Call], Any]] = {\n+        language.core.static_assert: execute_static_assert,\n+        language.core.static_print: execute_static_print,\n+    }\n+\n \n def str_to_ty(name):\n     if name[0] == \"*\":"}]