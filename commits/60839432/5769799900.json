[{"filename": "include/triton/Analysis/Alias.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -63,11 +63,11 @@ class AliasInfo {\n // Shared Memory Alias Analysis\n //===----------------------------------------------------------------------===//\n class SharedMemoryAliasAnalysis\n-    : public dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AliasInfo>> {\n+    : public dataflow::SparseForwardDataFlowAnalysis<dataflow::Lattice<AliasInfo>> {\n public:\n-  using dataflow::SparseDataFlowAnalysis<\n-      dataflow::Lattice<AliasInfo>>::SparseDataFlowAnalysis;\n-  using dataflow::SparseDataFlowAnalysis<\n+  using dataflow::SparseForwardDataFlowAnalysis<\n+      dataflow::Lattice<AliasInfo>>::SparseForwardDataFlowAnalysis;\n+  using dataflow::SparseForwardDataFlowAnalysis<\n       dataflow::Lattice<AliasInfo>>::getLatticeElement;\n \n   /// XXX(Keren): Compatible interface with MLIR AliasAnalysis for future use."}, {"filename": "include/triton/Analysis/AxisInfo.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -272,7 +272,7 @@ class AxisInfoVisitorList {\n };\n \n class AxisInfoAnalysis\n-    : public dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>> {\n+    : public dataflow::SparseForwardDataFlowAnalysis<dataflow::Lattice<AxisInfo>> {\n private:\n   AxisInfoVisitorList visitors;\n \n@@ -284,7 +284,7 @@ class AxisInfoAnalysis\n \n public:\n   AxisInfoAnalysis(DataFlowSolver &solver);\n-  using dataflow::SparseDataFlowAnalysis<\n+  using dataflow::SparseForwardDataFlowAnalysis<\n       dataflow::Lattice<AxisInfo>>::getLatticeElement;\n   using FuncAxisInfoMapT = DenseMap<FunctionOpInterface, AxisInfo>;\n "}, {"filename": "include/triton/Dialect/Triton/IR/TritonOps.td", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "file_content_changes": "@@ -633,6 +633,9 @@ def CallOp : TT_Op<\"call\", [CallOpInterface, /*MemRefsNormalizable, */DeclareOpI\n     operand_range getArgOperands() {\n       return {arg_operand_begin(), arg_operand_end()};\n     }\n+    MutableOperandRange getArgOperandsMutable() {\n+      return getOperandsMutable();\n+    }\n \n     operand_iterator arg_operand_begin() { return operand_begin(); }\n     operand_iterator arg_operand_end() { return operand_end(); }"}, {"filename": "lib/Analysis/AxisInfo.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -857,7 +857,7 @@ class MaxMinOpAxisInfoVisitor final : public AxisInfoVisitorImpl<OpTy> {\n //===----------------------------------------------------------------------===//\n \n AxisInfoAnalysis::AxisInfoAnalysis(DataFlowSolver &solver)\n-    : dataflow::SparseDataFlowAnalysis<dataflow::Lattice<AxisInfo>>(solver) {\n+    : dataflow::SparseForwardDataFlowAnalysis<dataflow::Lattice<AxisInfo>>(solver) {\n   // UnrealizedConversionCast:\n   // This is needed by TritonGPUToLLVM, to get AxisInfo when the graph is\n   // in the process of a PartialConversion, where UnrealizedConversionCast"}, {"filename": "lib/Conversion/TritonGPUToLLVM/TritonGPUToLLVM.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -533,7 +533,7 @@ struct ExtractSliceOpConversion\n     // newShape = rank_reduce(shape)\n     // Triton only supports static tensor sizes\n     SmallVector<Value, 4> strideVals;\n-    for (auto i = 0; i < op.static_sizes().size(); ++i) {\n+    for (auto i = 0; i < op.getStaticSizes().size(); ++i) {\n       if (op.getStaticSize(i) == 1) {\n         offsetVals.erase(offsetVals.begin() + i);\n       } else {"}, {"filename": "lib/Dialect/TritonGPU/IR/Dialect.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "file_content_changes": "@@ -1218,10 +1218,10 @@ LogicalResult ConvertLayoutOp::canonicalize(ConvertLayoutOp op,\n     auto newArg = rewriter.create<triton::gpu::ConvertLayoutOp>(\n         op->getLoc(), newType, extract_slice.getSource());\n     rewriter.replaceOpWithNewOp<triton::gpu::ExtractSliceOp>(\n-        op, resType, newArg.getResult(), extract_slice.offsets(),\n-        extract_slice.sizes(), extract_slice.strides(),\n-        extract_slice.static_offsets(), extract_slice.static_sizes(),\n-        extract_slice.static_strides());\n+        op, resType, newArg.getResult(), extract_slice.getOffsets(),\n+        extract_slice.getSizes(), extract_slice.getStrides(),\n+        extract_slice.getStaticOffsets(), extract_slice.getStaticSizes(),\n+        extract_slice.getStaticStrides());\n     return mlir::success();\n   }\n "}, {"filename": "llvm-hash.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "file_content_changes": "@@ -1 +1 @@\n-b126ee65fcbb49054e32fd11fdac07279d00f159\n+50665511c79f62d97c0d6602e1577b0abe1b982f"}, {"filename": "test/Analysis/test-alias.mlir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "file_content_changes": "@@ -192,10 +192,10 @@ tt.func @for_for_if(%lb : index, %ub : index, %step : index, %A : !tt.ptr<f16>,\n   // CHECK-NEXT: %arg9 -> %cst_1\n   // CHECK-NEXT: %0#0 -> %cst\n   // CHECK-NEXT: %0#1 -> %cst_0\n-  // CHECK-NEXT: %0#2 -> %cst_2,%cst_2\n+  // CHECK-NEXT: %0#2 -> %cst_1,%cst_2,%cst_2\n   %a_shared, %b_shared, %c_shared = scf.for %iv = %lb to %ub step %step iter_args(%a_shared = %a_shared_init, %b_shared = %b_shared_init, %c_shared = %c_shared_init) -> (tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>, tensor<128x32xf16, #A_SHARED>) {\n     // CHECK-NEXT: %arg11 -> %cst_1,%cst_2,%cst_2\n-    // CHECK-NEXT: %1 -> %cst_2,%cst_2\n+    // CHECK-NEXT: %1 -> %cst_1,%cst_2,%cst_2\n     %c_shared_next = scf.for %jv = %lb to %ub step %step iter_args(%c_shared_next = %c_shared) -> (tensor<128x32xf16, #A_SHARED>) {\n       // CHECK-NEXT: %2 -> %cst_2,%cst_2\n       %c_shared_next_next = scf.if %i1 -> tensor<128x32xf16, #A_SHARED> {"}]